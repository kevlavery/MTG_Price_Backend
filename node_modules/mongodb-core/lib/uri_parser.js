'use strict';
const URL = require('url');
const qs = require('querystring');
const dns = require('dns');
const MongoParseError = require('./error').MongoParseError;

/**
 * The following regular expression validates a connection string and breaks the
 * provide string into the following capture groups: [protocol, username, password, hosts]
 */
const HOSTS_RX = /(mongodb(?:\+srv|)):\/\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\/|)(.*)/;

/**
 * Determines whether a provided address matches the provided parent domain in order
 * to avoid certain attack vectors.
 *
 * @param ***REMOVED***String***REMOVED*** srvAddress The address to check against a domain
 * @param ***REMOVED***String***REMOVED*** parentDomain The domain to check the provided address against
 * @return ***REMOVED***Boolean***REMOVED*** Whether the provided address matches the parent domain
 */
function matchesParentDomain(srvAddress, parentDomain) ***REMOVED***
  const regex = /^.*?\./;
  const srv = `.$***REMOVED***srvAddress.replace(regex, '')***REMOVED***`;
  const parent = `.$***REMOVED***parentDomain.replace(regex, '')***REMOVED***`;
  return srv.endsWith(parent);
***REMOVED***

/**
 * Lookup an `mongodb+srv` connection string, combine the parts and reparse it as a normal
 * connection string.
 *
 * @param ***REMOVED***string***REMOVED*** uri The connection string to parse
 * @param ***REMOVED***object***REMOVED*** options Optional user provided connection string options
 * @param ***REMOVED***function***REMOVED*** callback
 */
function parseSrvConnectionString(uri, options, callback) ***REMOVED***
  const result = URL.parse(uri, true);

  if (result.hostname.split('.').length < 3) ***REMOVED***
    return callback(new MongoParseError('URI does not have hostname, domain name and tld'));
  ***REMOVED***

  result.domainLength = result.hostname.split('.').length;
  if (result.pathname && result.pathname.match(',')) ***REMOVED***
    return callback(new MongoParseError('Invalid URI, cannot contain multiple hostnames'));
  ***REMOVED***

  if (result.port) ***REMOVED***
    return callback(new MongoParseError(`Ports not accepted with '$***REMOVED***PROTOCOL_MONGODB_SRV***REMOVED***' URIs`));
  ***REMOVED***

  let srvAddress = `_mongodb._tcp.$***REMOVED***result.host***REMOVED***`;
  dns.resolveSrv(srvAddress, (err, addresses) => ***REMOVED***
    if (err) return callback(err);

    if (addresses.length === 0) ***REMOVED***
      return callback(new MongoParseError('No addresses found at host'));
    ***REMOVED***

    for (let i = 0; i < addresses.length; i++) ***REMOVED***
      if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) ***REMOVED***
        return callback(
          new MongoParseError('Server record does not share hostname with parent URI')
        );
      ***REMOVED***
    ***REMOVED***

    let base = result.auth ? `mongodb://$***REMOVED***result.auth***REMOVED***@` : `mongodb://`;
    let connectionStrings = addresses.map(
      (address, i) =>
        i === 0 ? `$***REMOVED***base***REMOVED***$***REMOVED***address.name***REMOVED***:$***REMOVED***address.port***REMOVED***` : `$***REMOVED***address.name***REMOVED***:$***REMOVED***address.port***REMOVED***`
    );

    let connectionString = `$***REMOVED***connectionStrings.join(',')***REMOVED***/`;
    let connectionStringOptions = [];

    // Add the default database if needed
    if (result.path) ***REMOVED***
      let defaultDb = result.path.slice(1);
      if (defaultDb.indexOf('?') !== -1) ***REMOVED***
        defaultDb = defaultDb.slice(0, defaultDb.indexOf('?'));
      ***REMOVED***

      connectionString += defaultDb;
    ***REMOVED***

    // Default to SSL true
    if (!options.ssl && (!result.search || result.query['ssl'] == null)) ***REMOVED***
      connectionStringOptions.push('ssl=true');
    ***REMOVED***

    // Keep original uri options
    if (result.search) ***REMOVED***
      connectionStringOptions.push(result.search.replace('?', ''));
    ***REMOVED***

    dns.resolveTxt(result.host, (err, record) => ***REMOVED***
      if (err) ***REMOVED***
        if (err.code !== 'ENODATA') ***REMOVED***
          return callback(err);
        ***REMOVED***
        record = null;
      ***REMOVED***

      if (record) ***REMOVED***
        if (record.length > 1) ***REMOVED***
          return callback(new MongoParseError('Multiple text records not allowed'));
        ***REMOVED***

        record = record[0];
        record = record.length > 1 ? record.join('') : record[0];
        if (!record.includes('authSource') && !record.includes('replicaSet')) ***REMOVED***
          return callback(
            new MongoParseError('Text record must only set `authSource` or `replicaSet`')
          );
        ***REMOVED***

        connectionStringOptions.push(record);
      ***REMOVED***

      // Add any options to the connection string
      if (connectionStringOptions.length) ***REMOVED***
        connectionString += `?$***REMOVED***connectionStringOptions.join('&')***REMOVED***`;
      ***REMOVED***

      parseConnectionString(connectionString, callback);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * Parses a query string item according to the connection string spec
 *
 * @param ***REMOVED***Array|String***REMOVED*** value The value to parse
 * @return ***REMOVED***Array|Object|String***REMOVED*** The parsed value
 */
function parseQueryStringItemValue(value) ***REMOVED***
  if (Array.isArray(value)) ***REMOVED***
    // deduplicate and simplify arrays
    value = value.filter((value, idx) => value.indexOf(value) === idx);
    if (value.length === 1) value = value[0];
  ***REMOVED*** else if (value.indexOf(':') > 0) ***REMOVED***
    value = value.split(',').reduce((result, pair) => ***REMOVED***
      const parts = pair.split(':');
      result[parts[0]] = parseQueryStringItemValue(parts[1]);
      return result;
    ***REMOVED***, ***REMOVED******REMOVED***);
  ***REMOVED*** else if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') ***REMOVED***
    value = value.toLowerCase() === 'true';
  ***REMOVED*** else if (!Number.isNaN(value)) ***REMOVED***
    const numericValue = parseFloat(value);
    if (!Number.isNaN(numericValue)) ***REMOVED***
      value = parseFloat(value);
    ***REMOVED***
  ***REMOVED***

  return value;
***REMOVED***

/**
 * Parses a query string according the connection string spec.
 *
 * @param ***REMOVED***String***REMOVED*** query The query string to parse
 * @return ***REMOVED***Object|Error***REMOVED*** The parsed query string as an object, or an error if one was encountered
 */
function parseQueryString(query) ***REMOVED***
  const result = ***REMOVED******REMOVED***;
  let parsedQueryString = qs.parse(query);

  for (const key in parsedQueryString) ***REMOVED***
    const value = parsedQueryString[key];
    if (value === '' || value == null) ***REMOVED***
      return new MongoParseError('Incomplete key value pair for option');
    ***REMOVED***

    result[key.toLowerCase()] = parseQueryStringItemValue(value);
  ***REMOVED***

  // special cases for known deprecated options
  if (result.wtimeout && result.wtimeoutms) ***REMOVED***
    delete result.wtimeout;
    console.warn('Unsupported option `wtimeout` specified');
  ***REMOVED***

  return Object.keys(result).length ? result : null;
***REMOVED***

const PROTOCOL_MONGODB = 'mongodb';
const PROTOCOL_MONGODB_SRV = 'mongodb+srv';
const SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];

/**
 * Parses a MongoDB connection string
 *
 * @param ***REMOVED*******REMOVED*** uri the MongoDB connection string to parse
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings.
 * @param ***REMOVED***parseCallback***REMOVED*** callback
 */
function parseConnectionString(uri, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Check for bad uris before we parse
  try ***REMOVED***
    URL.parse(uri);
  ***REMOVED*** catch (e) ***REMOVED***
    return callback(new MongoParseError('URI malformed, cannot be parsed'));
  ***REMOVED***

  const cap = uri.match(HOSTS_RX);
  if (!cap) ***REMOVED***
    return callback(new MongoParseError('Invalid connection string'));
  ***REMOVED***

  const protocol = cap[1];
  if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) ***REMOVED***
    return callback(new MongoParseError('Invalid protocol provided'));
  ***REMOVED***

  if (protocol === PROTOCOL_MONGODB_SRV) ***REMOVED***
    return parseSrvConnectionString(uri, options, callback);
  ***REMOVED***

  const dbAndQuery = cap[4].split('?');
  const db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;
  const query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;
  let parsedOptions = parseQueryString(query);
  if (parsedOptions instanceof MongoParseError) ***REMOVED***
    return callback(parsedOptions);
  ***REMOVED***

  parsedOptions = Object.assign(***REMOVED******REMOVED***, parsedOptions, options);
  const auth = ***REMOVED*** username: null, password: null, db: db && db !== '' ? qs.unescape(db) : null ***REMOVED***;
  if (cap[4].split('?')[0].indexOf('@') !== -1) ***REMOVED***
    return callback(new MongoParseError('Unescaped slash in userinfo section'));
  ***REMOVED***

  const authorityParts = cap[3].split('@');
  if (authorityParts.length > 2) ***REMOVED***
    return callback(new MongoParseError('Unescaped at-sign in authority section'));
  ***REMOVED***

  if (authorityParts.length > 1) ***REMOVED***
    const authParts = authorityParts.shift().split(':');
    if (authParts.length > 2) ***REMOVED***
      return callback(new MongoParseError('Unescaped colon in authority section'));
    ***REMOVED***

    auth.username = qs.unescape(authParts[0]);
    auth.password = authParts[1] ? qs.unescape(authParts[1]) : null;
  ***REMOVED***

  let hostParsingError = null;
  const hosts = authorityParts
    .shift()
    .split(',')
    .map(host => ***REMOVED***
      let parsedHost = URL.parse(`mongodb://$***REMOVED***host***REMOVED***`);
      if (parsedHost.path === '/:') ***REMOVED***
        hostParsingError = new MongoParseError('Double colon in host identifier');
        return null;
      ***REMOVED***

      // heuristically determine if we're working with a domain socket
      if (host.match(/\.sock/)) ***REMOVED***
        parsedHost.hostname = qs.unescape(host);
        parsedHost.port = null;
      ***REMOVED***

      if (Number.isNaN(parsedHost.port)) ***REMOVED***
        hostParsingError = new MongoParseError('Invalid port (non-numeric string)');
        return;
      ***REMOVED***

      const result = ***REMOVED***
        host: parsedHost.hostname,
        port: parsedHost.port ? parseInt(parsedHost.port) : null
      ***REMOVED***;

      if (result.port === 0) ***REMOVED***
        hostParsingError = new MongoParseError('Invalid port (zero) with hostname');
        return;
      ***REMOVED***

      if (result.port > 65535) ***REMOVED***
        hostParsingError = new MongoParseError('Invalid port (larger than 65535) with hostname');
        return;
      ***REMOVED***

      if (result.port < 0) ***REMOVED***
        hostParsingError = new MongoParseError('Invalid port (negative number)');
        return;
      ***REMOVED***

      return result;
    ***REMOVED***)
    .filter(host => !!host);

  if (hostParsingError) ***REMOVED***
    return callback(hostParsingError);
  ***REMOVED***

  if (hosts.length === 0 || hosts[0].host === '' || hosts[0].host === null) ***REMOVED***
    return callback(new MongoParseError('No hostname or hostnames provided in connection string'));
  ***REMOVED***

  callback(null, ***REMOVED***
    hosts: hosts,
    auth: auth.db || auth.username ? auth : null,
    options: Object.keys(parsedOptions).length ? parsedOptions : null
  ***REMOVED***);
***REMOVED***

module.exports = parseConnectionString;
