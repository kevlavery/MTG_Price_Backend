'use strict';

const Logger = require('./connection/logger');
const retrieveBSON = require('./connection/utils').retrieveBSON;
const MongoError = require('./error').MongoError;
const MongoNetworkError = require('./error').MongoNetworkError;
const mongoErrorContextSymbol = require('./error').mongoErrorContextSymbol;
const f = require('util').format;

var BSON = retrieveBSON(),
  Long = BSON.Long;

/**
 * This is a cursor results callback
 *
 * @callback resultCallback
 * @param ***REMOVED***error***REMOVED*** error An error object. Set to null if no error present
 * @param ***REMOVED***object***REMOVED*** document
 */

/**
 * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB
 * allowing for iteration over the results returned from the underlying query.
 *
 * **CURSORS Cannot directly be instantiated**
 * @example
 * var Server = require('mongodb-core').Server
 *   , ReadPreference = require('mongodb-core').ReadPreference
 *   , assert = require('assert');
 *
 * var server = new Server(***REMOVED***host: 'localhost', port: 27017***REMOVED***);
 * // Wait for the connection event
 * server.on('connect', function(server) ***REMOVED***
 *   assert.equal(null, err);
 *
 *   // Execute the write
 *   var cursor = _server.cursor('integration_tests.inserts_example4', ***REMOVED***
 *       find: 'integration_tests.example4'
 *     , query: ***REMOVED***a:1***REMOVED***
 *   ***REMOVED***, ***REMOVED***
 *     readPreference: new ReadPreference('secondary');
 *   ***REMOVED***);
 *
 *   // Get the first document
 *   cursor.next(function(err, doc) ***REMOVED***
 *     assert.equal(null, err);
 *     server.destroy();
 *   ***REMOVED***);
 * ***REMOVED***);
 *
 * // Start connecting
 * server.connect();
 */

/**
 * Creates a new Cursor, not to be used directly
 * @class
 * @param ***REMOVED***object***REMOVED*** bson An instance of the BSON parser
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED******REMOVED***object***REMOVED***|Long***REMOVED*** cmd The selector (can be a command or a cursorId)
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***object***REMOVED*** [options.batchSize=1000] Batchsize for the operation
 * @param ***REMOVED***array***REMOVED*** [options.documents=[]] Initial documents list for cursor
 * @param ***REMOVED***object***REMOVED*** [options.transforms=null] Transform methods for the cursor results
 * @param ***REMOVED***function***REMOVED*** [options.transforms.query] Transform the value returned from the initial query
 * @param ***REMOVED***function***REMOVED*** [options.transforms.doc] Transform each document returned from Cursor.prototype.next
 * @param ***REMOVED***object***REMOVED*** topology The server topology instance.
 * @param ***REMOVED***object***REMOVED*** topologyOptions The server topology options.
 * @return ***REMOVED***Cursor***REMOVED*** A cursor instance
 * @property ***REMOVED***number***REMOVED*** cursorBatchSize The current cursorBatchSize for the cursor
 * @property ***REMOVED***number***REMOVED*** cursorLimit The current cursorLimit for the cursor
 * @property ***REMOVED***number***REMOVED*** cursorSkip The current cursorSkip for the cursor
 */
var Cursor = function(bson, ns, cmd, options, topology, topologyOptions) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  // Cursor pool
  this.pool = null;
  // Cursor server
  this.server = null;

  // Do we have a not connected handler
  this.disconnectHandler = options.disconnectHandler;

  // Set local values
  this.bson = bson;
  this.ns = ns;
  this.cmd = cmd;
  this.options = options;
  this.topology = topology;

  // All internal state
  this.cursorState = ***REMOVED***
    cursorId: null,
    cmd: cmd,
    documents: options.documents || [],
    cursorIndex: 0,
    dead: false,
    killed: false,
    init: false,
    notified: false,
    limit: options.limit || cmd.limit || 0,
    skip: options.skip || cmd.skip || 0,
    batchSize: options.batchSize || cmd.batchSize || 1000,
    currentLimit: 0,
    // Result field name if not a cursor (contains the array of results)
    transforms: options.transforms
  ***REMOVED***;

  if (typeof options.session === 'object') ***REMOVED***
    this.cursorState.session = options.session;
  ***REMOVED***

  // Add promoteLong to cursor state
  if (typeof topologyOptions.promoteLongs === 'boolean') ***REMOVED***
    this.cursorState.promoteLongs = topologyOptions.promoteLongs;
  ***REMOVED*** else if (typeof options.promoteLongs === 'boolean') ***REMOVED***
    this.cursorState.promoteLongs = options.promoteLongs;
  ***REMOVED***

  // Add promoteValues to cursor state
  if (typeof topologyOptions.promoteValues === 'boolean') ***REMOVED***
    this.cursorState.promoteValues = topologyOptions.promoteValues;
  ***REMOVED*** else if (typeof options.promoteValues === 'boolean') ***REMOVED***
    this.cursorState.promoteValues = options.promoteValues;
  ***REMOVED***

  // Add promoteBuffers to cursor state
  if (typeof topologyOptions.promoteBuffers === 'boolean') ***REMOVED***
    this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
  ***REMOVED*** else if (typeof options.promoteBuffers === 'boolean') ***REMOVED***
    this.cursorState.promoteBuffers = options.promoteBuffers;
  ***REMOVED***

  if (topologyOptions.reconnect) ***REMOVED***
    this.cursorState.reconnect = topologyOptions.reconnect;
  ***REMOVED***

  // Logger
  this.logger = Logger('Cursor', topologyOptions);

  //
  // Did we pass in a cursor id
  if (typeof cmd === 'number') ***REMOVED***
    this.cursorState.cursorId = Long.fromNumber(cmd);
    this.cursorState.lastCursorId = this.cursorState.cursorId;
  ***REMOVED*** else if (cmd instanceof Long) ***REMOVED***
    this.cursorState.cursorId = cmd;
    this.cursorState.lastCursorId = cmd;
  ***REMOVED***
***REMOVED***;

Cursor.prototype.setCursorBatchSize = function(value) ***REMOVED***
  this.cursorState.batchSize = value;
***REMOVED***;

Cursor.prototype.cursorBatchSize = function() ***REMOVED***
  return this.cursorState.batchSize;
***REMOVED***;

Cursor.prototype.setCursorLimit = function(value) ***REMOVED***
  this.cursorState.limit = value;
***REMOVED***;

Cursor.prototype.cursorLimit = function() ***REMOVED***
  return this.cursorState.limit;
***REMOVED***;

Cursor.prototype.setCursorSkip = function(value) ***REMOVED***
  this.cursorState.skip = value;
***REMOVED***;

Cursor.prototype.cursorSkip = function() ***REMOVED***
  return this.cursorState.skip;
***REMOVED***;

Cursor.prototype._endSession = function(options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  const session = this.cursorState.session;

  if (session && (options.force || session.owner === this)) ***REMOVED***
    this.cursorState.session = undefined;
    session.endSession(callback);
    return true;
  ***REMOVED***

  if (callback) ***REMOVED***
    callback();
  ***REMOVED***
  return false;
***REMOVED***;

//
// Handle callback (including any exceptions thrown)
var handleCallback = function(callback, err, result) ***REMOVED***
  try ***REMOVED***
    callback(err, result);
  ***REMOVED*** catch (err) ***REMOVED***
    process.nextTick(function() ***REMOVED***
      throw err;
    ***REMOVED***);
  ***REMOVED***
***REMOVED***;

// Internal methods
Cursor.prototype._find = function(callback) ***REMOVED***
  var self = this;

  if (self.logger.isDebug()) ***REMOVED***
    self.logger.debug(
      f(
        'issue initial query [%s] with flags [%s]',
        JSON.stringify(self.cmd),
        JSON.stringify(self.query)
      )
    );
  ***REMOVED***

  var queryCallback = function(err, r) ***REMOVED***
    if (err) return callback(err);

    // Get the raw message
    var result = r.message;

    // Query failure bit set
    if (result.queryFailure) ***REMOVED***
      return callback(new MongoError(result.documents[0]), null);
    ***REMOVED***

    // Check if we have a command cursor
    if (
      Array.isArray(result.documents) &&
      result.documents.length === 1 &&
      (!self.cmd.find || (self.cmd.find && self.cmd.virtual === false)) &&
      (result.documents[0].cursor !== 'string' ||
        result.documents[0]['$err'] ||
        result.documents[0]['errmsg'] ||
        Array.isArray(result.documents[0].result))
    ) ***REMOVED***
      // We have a an error document return the error
      if (result.documents[0]['$err'] || result.documents[0]['errmsg']) ***REMOVED***
        return callback(new MongoError(result.documents[0]), null);
      ***REMOVED***

      // We have a cursor document
      if (result.documents[0].cursor != null && typeof result.documents[0].cursor !== 'string') ***REMOVED***
        var id = result.documents[0].cursor.id;
        // If we have a namespace change set the new namespace for getmores
        if (result.documents[0].cursor.ns) ***REMOVED***
          self.ns = result.documents[0].cursor.ns;
        ***REMOVED***
        // Promote id to long if needed
        self.cursorState.cursorId = typeof id === 'number' ? Long.fromNumber(id) : id;
        self.cursorState.lastCursorId = self.cursorState.cursorId;
        self.cursorState.operationTime = result.documents[0].operationTime;
        // If we have a firstBatch set it
        if (Array.isArray(result.documents[0].cursor.firstBatch)) ***REMOVED***
          self.cursorState.documents = result.documents[0].cursor.firstBatch; //.reverse();
        ***REMOVED***

        // Return after processing command cursor
        return callback(null, result);
      ***REMOVED***

      if (Array.isArray(result.documents[0].result)) ***REMOVED***
        self.cursorState.documents = result.documents[0].result;
        self.cursorState.cursorId = Long.ZERO;
        return callback(null, result);
      ***REMOVED***
    ***REMOVED***

    // Otherwise fall back to regular find path
    self.cursorState.cursorId = result.cursorId;
    self.cursorState.documents = result.documents;
    self.cursorState.lastCursorId = result.cursorId;

    // Transform the results with passed in transformation method if provided
    if (self.cursorState.transforms && typeof self.cursorState.transforms.query === 'function') ***REMOVED***
      self.cursorState.documents = self.cursorState.transforms.query(result);
    ***REMOVED***

    // Return callback
    callback(null, result);
  ***REMOVED***;

  // Options passed to the pool
  var queryOptions = ***REMOVED******REMOVED***;

  // If we have a raw query decorate the function
  if (self.options.raw || self.cmd.raw) ***REMOVED***
    // queryCallback.raw = self.options.raw || self.cmd.raw;
    queryOptions.raw = self.options.raw || self.cmd.raw;
  ***REMOVED***

  // Do we have documentsReturnedIn set on the query
  if (typeof self.query.documentsReturnedIn === 'string') ***REMOVED***
    // queryCallback.documentsReturnedIn = self.query.documentsReturnedIn;
    queryOptions.documentsReturnedIn = self.query.documentsReturnedIn;
  ***REMOVED***

  // Add promote Long value if defined
  if (typeof self.cursorState.promoteLongs === 'boolean') ***REMOVED***
    queryOptions.promoteLongs = self.cursorState.promoteLongs;
  ***REMOVED***

  // Add promote values if defined
  if (typeof self.cursorState.promoteValues === 'boolean') ***REMOVED***
    queryOptions.promoteValues = self.cursorState.promoteValues;
  ***REMOVED***

  // Add promote values if defined
  if (typeof self.cursorState.promoteBuffers === 'boolean') ***REMOVED***
    queryOptions.promoteBuffers = self.cursorState.promoteBuffers;
  ***REMOVED***

  if (typeof self.cursorState.session === 'object') ***REMOVED***
    queryOptions.session = self.cursorState.session;
  ***REMOVED***

  // Write the initial command out
  self.server.s.pool.write(self.query, queryOptions, queryCallback);
***REMOVED***;

Cursor.prototype._getmore = function(callback) ***REMOVED***
  if (this.logger.isDebug())
    this.logger.debug(f('schedule getMore call for query [%s]', JSON.stringify(this.query)));
  // Determine if it's a raw query
  var raw = this.options.raw || this.cmd.raw;

  // Set the current batchSize
  var batchSize = this.cursorState.batchSize;
  if (
    this.cursorState.limit > 0 &&
    this.cursorState.currentLimit + batchSize > this.cursorState.limit
  ) ***REMOVED***
    batchSize = this.cursorState.limit - this.cursorState.currentLimit;
  ***REMOVED***

  // Default pool
  var pool = this.server.s.pool;

  // We have a wire protocol handler
  this.server.wireProtocolHandler.getMore(
    this.bson,
    this.ns,
    this.cursorState,
    batchSize,
    raw,
    pool,
    this.options,
    callback
  );
***REMOVED***;

/**
 * Clone the cursor
 * @method
 * @return ***REMOVED***Cursor***REMOVED***
 */
Cursor.prototype.clone = function() ***REMOVED***
  return this.topology.cursor(this.ns, this.cmd, this.options);
***REMOVED***;

/**
 * Checks if the cursor is dead
 * @method
 * @return ***REMOVED***boolean***REMOVED*** A boolean signifying if the cursor is dead or not
 */
Cursor.prototype.isDead = function() ***REMOVED***
  return this.cursorState.dead === true;
***REMOVED***;

/**
 * Checks if the cursor was killed by the application
 * @method
 * @return ***REMOVED***boolean***REMOVED*** A boolean signifying if the cursor was killed by the application
 */
Cursor.prototype.isKilled = function() ***REMOVED***
  return this.cursorState.killed === true;
***REMOVED***;

/**
 * Checks if the cursor notified it's caller about it's death
 * @method
 * @return ***REMOVED***boolean***REMOVED*** A boolean signifying if the cursor notified the callback
 */
Cursor.prototype.isNotified = function() ***REMOVED***
  return this.cursorState.notified === true;
***REMOVED***;

/**
 * Returns current buffered documents length
 * @method
 * @return ***REMOVED***number***REMOVED*** The number of items in the buffered documents
 */
Cursor.prototype.bufferedCount = function() ***REMOVED***
  return this.cursorState.documents.length - this.cursorState.cursorIndex;
***REMOVED***;

/**
 * Returns current buffered documents
 * @method
 * @return ***REMOVED***Array***REMOVED*** An array of buffered documents
 */
Cursor.prototype.readBufferedDocuments = function(number) ***REMOVED***
  var unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
  var length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
  var elements = this.cursorState.documents.slice(
    this.cursorState.cursorIndex,
    this.cursorState.cursorIndex + length
  );

  // Transform the doc with passed in transformation method if provided
  if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === 'function') ***REMOVED***
    // Transform all the elements
    for (var i = 0; i < elements.length; i++) ***REMOVED***
      elements[i] = this.cursorState.transforms.doc(elements[i]);
    ***REMOVED***
  ***REMOVED***

  // Ensure we do not return any more documents than the limit imposed
  // Just return the number of elements up to the limit
  if (
    this.cursorState.limit > 0 &&
    this.cursorState.currentLimit + elements.length > this.cursorState.limit
  ) ***REMOVED***
    elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
    this.kill();
  ***REMOVED***

  // Adjust current limit
  this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
  this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;

  // Return elements
  return elements;
***REMOVED***;

/**
 * Kill the cursor
 * @method
 * @param ***REMOVED***resultCallback***REMOVED*** callback A callback function
 */
Cursor.prototype.kill = function(callback) ***REMOVED***
  // Set cursor to dead
  this.cursorState.dead = true;
  this.cursorState.killed = true;
  // Remove documents
  this.cursorState.documents = [];

  // If no cursor id just return
  if (
    this.cursorState.cursorId == null ||
    this.cursorState.cursorId.isZero() ||
    this.cursorState.init === false
  ) ***REMOVED***
    if (callback) callback(null, null);
    return;
  ***REMOVED***

  // Default pool
  var pool = this.server.s.pool;
  // Execute command
  this.server.wireProtocolHandler.killCursor(this.bson, this.ns, this.cursorState, pool, callback);
***REMOVED***;

/**
 * Resets the cursor
 * @method
 * @return ***REMOVED***null***REMOVED***
 */
Cursor.prototype.rewind = function() ***REMOVED***
  if (this.cursorState.init) ***REMOVED***
    if (!this.cursorState.dead) ***REMOVED***
      this.kill();
    ***REMOVED***

    this.cursorState.currentLimit = 0;
    this.cursorState.init = false;
    this.cursorState.dead = false;
    this.cursorState.killed = false;
    this.cursorState.notified = false;
    this.cursorState.documents = [];
    this.cursorState.cursorId = null;
    this.cursorState.cursorIndex = 0;
  ***REMOVED***
***REMOVED***;

/**
 * Validate if the pool is dead and return error
 */
var isConnectionDead = function(self, callback) ***REMOVED***
  if (self.pool && self.pool.isDestroyed()) ***REMOVED***
    self.cursorState.killed = true;
    const err = new MongoNetworkError(
      f('connection to host %s:%s was destroyed', self.pool.host, self.pool.port)
    );
    _setCursorNotifiedImpl(self, () => callback(err));
    return true;
  ***REMOVED***

  return false;
***REMOVED***;

/**
 * Validate if the cursor is dead but was not explicitly killed by user
 */
var isCursorDeadButNotkilled = function(self, callback) ***REMOVED***
  // Cursor is dead but not marked killed, return null
  if (self.cursorState.dead && !self.cursorState.killed) ***REMOVED***
    self.cursorState.killed = true;
    setCursorNotified(self, callback);
    return true;
  ***REMOVED***

  return false;
***REMOVED***;

/**
 * Validate if the cursor is dead and was killed by user
 */
var isCursorDeadAndKilled = function(self, callback) ***REMOVED***
  if (self.cursorState.dead && self.cursorState.killed) ***REMOVED***
    handleCallback(callback, new MongoError('cursor is dead'));
    return true;
  ***REMOVED***

  return false;
***REMOVED***;

/**
 * Validate if the cursor was killed by the user
 */
var isCursorKilled = function(self, callback) ***REMOVED***
  if (self.cursorState.killed) ***REMOVED***
    setCursorNotified(self, callback);
    return true;
  ***REMOVED***

  return false;
***REMOVED***;

/**
 * Mark cursor as being dead and notified
 */
var setCursorDeadAndNotified = function(self, callback) ***REMOVED***
  self.cursorState.dead = true;
  setCursorNotified(self, callback);
***REMOVED***;

/**
 * Mark cursor as being notified
 */
var setCursorNotified = function(self, callback) ***REMOVED***
  _setCursorNotifiedImpl(self, () => handleCallback(callback, null, null));
***REMOVED***;

var _setCursorNotifiedImpl = function(self, callback) ***REMOVED***
  self.cursorState.notified = true;
  self.cursorState.documents = [];
  self.cursorState.cursorIndex = 0;
  if (self._endSession) ***REMOVED***
    return self._endSession(undefined, () => callback());
  ***REMOVED***
  return callback();
***REMOVED***;

var nextFunction = function(self, callback) ***REMOVED***
  // We have notified about it
  if (self.cursorState.notified) ***REMOVED***
    return callback(new Error('cursor is exhausted'));
  ***REMOVED***

  // Cursor is killed return null
  if (isCursorKilled(self, callback)) return;

  // Cursor is dead but not marked killed, return null
  if (isCursorDeadButNotkilled(self, callback)) return;

  // We have a dead and killed cursor, attempting to call next should error
  if (isCursorDeadAndKilled(self, callback)) return;

  // We have just started the cursor
  if (!self.cursorState.init) ***REMOVED***
    // Topology is not connected, save the call in the provided store to be
    // Executed at some point when the handler deems it's reconnected
    if (!self.topology.isConnected(self.options)) ***REMOVED***
      // Only need this for single server, because repl sets and mongos
      // will always continue trying to reconnect
      if (self.topology._type === 'server' && !self.topology.s.options.reconnect) ***REMOVED***
        // Reconnect is disabled, so we'll never reconnect
        return callback(new MongoError('no connection available'));
      ***REMOVED***

      if (self.disconnectHandler != null) ***REMOVED***
        if (self.topology.isDestroyed()) ***REMOVED***
          // Topology was destroyed, so don't try to wait for it to reconnect
          return callback(new MongoError('Topology was destroyed'));
        ***REMOVED***

        return self.disconnectHandler.addObjectAndMethod(
          'cursor',
          self,
          'next',
          [callback],
          callback
        );
      ***REMOVED***
    ***REMOVED***

    try ***REMOVED***
      self.server = self.topology.getServer(self.options);
    ***REMOVED*** catch (err) ***REMOVED***
      // Handle the error and add object to next method call
      if (self.disconnectHandler != null) ***REMOVED***
        return self.disconnectHandler.addObjectAndMethod(
          'cursor',
          self,
          'next',
          [callback],
          callback
        );
      ***REMOVED***

      // Otherwise return the error
      return callback(err);
    ***REMOVED***

    // Set as init
    self.cursorState.init = true;

    // Server does not support server
    if (self.cmd && self.cmd.collation && self.server.ismaster.maxWireVersion < 5) ***REMOVED***
      return callback(new MongoError(f('server %s does not support collation', self.server.name)));
    ***REMOVED***

    try ***REMOVED***
      self.query = self.server.wireProtocolHandler.command(
        self.bson,
        self.ns,
        self.cmd,
        self.cursorState,
        self.topology,
        self.options
      );

      if (self.query instanceof MongoError) ***REMOVED***
        return callback(self.query);
      ***REMOVED***
    ***REMOVED*** catch (err) ***REMOVED***
      return callback(err);
    ***REMOVED***
  ***REMOVED***

  // If we don't have a cursorId execute the first query
  if (self.cursorState.cursorId == null) ***REMOVED***
    // Check if pool is dead and return if not possible to
    // execute the query against the db
    if (isConnectionDead(self, callback)) return;

    // Check if topology is destroyed
    if (self.topology.isDestroyed())
      return callback(
        new MongoNetworkError('connection destroyed, not possible to instantiate cursor')
      );

    // query, cmd, options, cursorState, callback
    self._find(function(err) ***REMOVED***
      if (err) return handleCallback(callback, err, null);

      if (self.cursorState.cursorId && self.cursorState.cursorId.isZero() && self._endSession) ***REMOVED***
        self._endSession();
      ***REMOVED***

      if (
        self.cursorState.documents.length === 0 &&
        self.cursorState.cursorId &&
        self.cursorState.cursorId.isZero() &&
        !self.cmd.tailable &&
        !self.cmd.awaitData
      ) ***REMOVED***
        return setCursorNotified(self, callback);
      ***REMOVED***

      nextFunction(self, callback);
    ***REMOVED***);
  ***REMOVED*** else if (
    self.cursorState.limit > 0 &&
    self.cursorState.currentLimit >= self.cursorState.limit
  ) ***REMOVED***
    // Ensure we kill the cursor on the server
    self.kill();
    // Set cursor in dead and notified state
    return setCursorDeadAndNotified(self, callback);
  ***REMOVED*** else if (
    self.cursorState.cursorIndex === self.cursorState.documents.length &&
    !Long.ZERO.equals(self.cursorState.cursorId)
  ) ***REMOVED***
    // Ensure an empty cursor state
    self.cursorState.documents = [];
    self.cursorState.cursorIndex = 0;

    // Check if topology is destroyed
    if (self.topology.isDestroyed())
      return callback(
        new MongoNetworkError('connection destroyed, not possible to instantiate cursor')
      );

    // Check if connection is dead and return if not possible to
    // execute a getmore on this connection
    if (isConnectionDead(self, callback)) return;

    // Execute the next get more
    self._getmore(function(err, doc, connection) ***REMOVED***
      if (err) ***REMOVED***
        if (err instanceof MongoError) ***REMOVED***
          err[mongoErrorContextSymbol].isGetMore = true;
        ***REMOVED***

        return handleCallback(callback, err);
      ***REMOVED***

      if (self.cursorState.cursorId && self.cursorState.cursorId.isZero() && self._endSession) ***REMOVED***
        self._endSession();
      ***REMOVED***

      // Save the returned connection to ensure all getMore's fire over the same connection
      self.connection = connection;

      // Tailable cursor getMore result, notify owner about it
      // No attempt is made here to retry, this is left to the user of the
      // core module to handle to keep core simple
      if (
        self.cursorState.documents.length === 0 &&
        self.cmd.tailable &&
        Long.ZERO.equals(self.cursorState.cursorId)
      ) ***REMOVED***
        // No more documents in the tailed cursor
        return handleCallback(
          callback,
          new MongoError(***REMOVED***
            message: 'No more documents in tailed cursor',
            tailable: self.cmd.tailable,
            awaitData: self.cmd.awaitData
          ***REMOVED***)
        );
      ***REMOVED*** else if (
        self.cursorState.documents.length === 0 &&
        self.cmd.tailable &&
        !Long.ZERO.equals(self.cursorState.cursorId)
      ) ***REMOVED***
        return nextFunction(self, callback);
      ***REMOVED***

      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) ***REMOVED***
        return setCursorDeadAndNotified(self, callback);
      ***REMOVED***

      nextFunction(self, callback);
    ***REMOVED***);
  ***REMOVED*** else if (
    self.cursorState.documents.length === self.cursorState.cursorIndex &&
    self.cmd.tailable &&
    Long.ZERO.equals(self.cursorState.cursorId)
  ) ***REMOVED***
    return handleCallback(
      callback,
      new MongoError(***REMOVED***
        message: 'No more documents in tailed cursor',
        tailable: self.cmd.tailable,
        awaitData: self.cmd.awaitData
      ***REMOVED***)
    );
  ***REMOVED*** else if (
    self.cursorState.documents.length === self.cursorState.cursorIndex &&
    Long.ZERO.equals(self.cursorState.cursorId)
  ) ***REMOVED***
    setCursorDeadAndNotified(self, callback);
  ***REMOVED*** else ***REMOVED***
    if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) ***REMOVED***
      // Ensure we kill the cursor on the server
      self.kill();
      // Set cursor in dead and notified state
      return setCursorDeadAndNotified(self, callback);
    ***REMOVED***

    // Increment the current cursor limit
    self.cursorState.currentLimit += 1;

    // Get the document
    var doc = self.cursorState.documents[self.cursorState.cursorIndex++];

    // Doc overflow
    if (!doc || doc.$err) ***REMOVED***
      // Ensure we kill the cursor on the server
      self.kill();
      // Set cursor in dead and notified state
      return setCursorDeadAndNotified(self, function() ***REMOVED***
        handleCallback(callback, new MongoError(doc ? doc.$err : undefined));
      ***REMOVED***);
    ***REMOVED***

    // Transform the doc with passed in transformation method if provided
    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc === 'function') ***REMOVED***
      doc = self.cursorState.transforms.doc(doc);
    ***REMOVED***

    // Return the document
    handleCallback(callback, null, doc);
  ***REMOVED***
***REMOVED***;

/**
 * Retrieve the next document from the cursor
 * @method
 * @param ***REMOVED***resultCallback***REMOVED*** callback A callback function
 */
Cursor.prototype.next = function(callback) ***REMOVED***
  nextFunction(this, callback);
***REMOVED***;

module.exports = Cursor;
