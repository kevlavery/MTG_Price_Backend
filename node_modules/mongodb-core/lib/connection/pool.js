'use strict';

const inherits = require('util').inherits;
const EventEmitter = require('events').EventEmitter;
const Connection = require('./connection');
const MongoError = require('../error').MongoError;
const MongoNetworkError = require('../error').MongoNetworkError;
const MongoWriteConcernError = require('../error').MongoWriteConcernError;
const Logger = require('./logger');
const f = require('util').format;
const Query = require('./commands').Query;
const CommandResult = require('./command_result');
const MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;
const opcodes = require('../wireprotocol/shared').opcodes;
const compress = require('../wireprotocol/compression').compress;
const compressorIDs = require('../wireprotocol/compression').compressorIDs;
const uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;
const resolveClusterTime = require('../topologies/shared').resolveClusterTime;
const apm = require('./apm');
const defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;

var DISCONNECTED = 'disconnected';
var CONNECTING = 'connecting';
var CONNECTED = 'connected';
var DESTROYING = 'destroying';
var DESTROYED = 'destroyed';

var _id = 0;

function hasSessionSupport(topology) ***REMOVED***
  if (topology == null) return false;
  return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;
***REMOVED***

/**
 * Creates a new Pool instance
 * @class
 * @param ***REMOVED***string***REMOVED*** options.host The server host
 * @param ***REMOVED***number***REMOVED*** options.port The server port
 * @param ***REMOVED***number***REMOVED*** [options.size=5] Max server connection pool size
 * @param ***REMOVED***number***REMOVED*** [options.minSize=0] Minimum server connection pool size
 * @param ***REMOVED***boolean***REMOVED*** [options.reconnect=true] Server will attempt to reconnect on loss of connection
 * @param ***REMOVED***number***REMOVED*** [options.reconnectTries=30] Server attempt to reconnect #times
 * @param ***REMOVED***number***REMOVED*** [options.reconnectInterval=1000] Server will wait # milliseconds between retries
 * @param ***REMOVED***boolean***REMOVED*** [options.keepAlive=true] TCP Connection keep alive enabled
 * @param ***REMOVED***number***REMOVED*** [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled
 * @param ***REMOVED***boolean***REMOVED*** [options.noDelay=true] TCP Connection no delay
 * @param ***REMOVED***number***REMOVED*** [options.connectionTimeout=30000] TCP Connection timeout setting
 * @param ***REMOVED***number***REMOVED*** [options.socketTimeout=360000] TCP Socket timeout setting
 * @param ***REMOVED***number***REMOVED*** [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket
 * @param ***REMOVED***boolean***REMOVED*** [options.ssl=false] Use SSL for connection
 * @param ***REMOVED***boolean|function***REMOVED*** [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
 * @param ***REMOVED***Buffer***REMOVED*** [options.ca] SSL Certificate store binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.crl] SSL Certificate revocation store binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.cert] SSL Certificate binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.key] SSL Key file binary buffer
 * @param ***REMOVED***string***REMOVED*** [options.passPhrase] SSL Certificate pass phrase
 * @param ***REMOVED***boolean***REMOVED*** [options.rejectUnauthorized=false] Reject unauthorized server certificates
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
 * @fires Pool#connect
 * @fires Pool#close
 * @fires Pool#error
 * @fires Pool#timeout
 * @fires Pool#parseError
 * @return ***REMOVED***Pool***REMOVED*** A cursor instance
 */
var Pool = function(topology, options) ***REMOVED***
  // Add event listener
  EventEmitter.call(this);

  // Store topology for later use
  this.topology = topology;

  // Add the options
  this.options = Object.assign(
    ***REMOVED***
      // Host and port settings
      host: 'localhost',
      port: 27017,
      // Pool default max size
      size: 5,
      // Pool default min size
      minSize: 0,
      // socket settings
      connectionTimeout: 30000,
      socketTimeout: 360000,
      keepAlive: true,
      keepAliveInitialDelay: 300000,
      noDelay: true,
      // SSL Settings
      ssl: false,
      checkServerIdentity: true,
      ca: null,
      crl: null,
      cert: null,
      key: null,
      passPhrase: null,
      rejectUnauthorized: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      // Reconnection options
      reconnect: true,
      reconnectInterval: 1000,
      reconnectTries: 30,
      // Enable domains
      domainsEnabled: false
    ***REMOVED***,
    options
  );

  // Identification information
  this.id = _id++;
  // Current reconnect retries
  this.retriesLeft = this.options.reconnectTries;
  this.reconnectId = null;
  // No bson parser passed in
  if (
    !options.bson ||
    (options.bson &&
      (typeof options.bson.serialize !== 'function' ||
        typeof options.bson.deserialize !== 'function'))
  ) ***REMOVED***
    throw new Error('must pass in valid bson parser');
  ***REMOVED***

  // Logger instance
  this.logger = Logger('Pool', options);
  // Pool state
  this.state = DISCONNECTED;
  // Connections
  this.availableConnections = [];
  this.inUseConnections = [];
  this.connectingConnections = [];
  // Currently executing
  this.executing = false;
  // Operation work queue
  this.queue = [];

  // All the authProviders
  this.authProviders = options.authProviders || defaultAuthProviders(options.bson);

  // Contains the reconnect connection
  this.reconnectConnection = null;

  // Are we currently authenticating
  this.authenticating = false;
  this.loggingout = false;
  this.nonAuthenticatedConnections = [];
  this.authenticatingTimestamp = null;
  // Number of consecutive timeouts caught
  this.numberOfConsecutiveTimeouts = 0;
  // Current pool Index
  this.connectionIndex = 0;
***REMOVED***;

inherits(Pool, EventEmitter);

Object.defineProperty(Pool.prototype, 'size', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.options.size;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Pool.prototype, 'minSize', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.options.minSize;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Pool.prototype, 'connectionTimeout', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.options.connectionTimeout;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Pool.prototype, 'socketTimeout', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.options.socketTimeout;
  ***REMOVED***
***REMOVED***);

function stateTransition(self, newState) ***REMOVED***
  var legalTransitions = ***REMOVED***
    disconnected: [CONNECTING, DESTROYING, DISCONNECTED],
    connecting: [CONNECTING, DESTROYING, CONNECTED, DISCONNECTED],
    connected: [CONNECTED, DISCONNECTED, DESTROYING],
    destroying: [DESTROYING, DESTROYED],
    destroyed: [DESTROYED]
  ***REMOVED***;

  // Get current state
  var legalStates = legalTransitions[self.state];
  if (legalStates && legalStates.indexOf(newState) !== -1) ***REMOVED***
    self.emit('stateChanged', self.state, newState);
    self.state = newState;
  ***REMOVED*** else ***REMOVED***
    self.logger.error(
      f(
        'Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]',
        self.id,
        self.state,
        newState,
        legalStates
      )
    );
  ***REMOVED***
***REMOVED***

function authenticate(pool, auth, connection, cb) ***REMOVED***
  if (auth[0] === undefined) return cb(null);
  // We need to authenticate the server
  var mechanism = auth[0];
  var db = auth[1];
  // Validate if the mechanism exists
  if (!pool.authProviders[mechanism]) ***REMOVED***
    throw new MongoError(f('authMechanism %s not supported', mechanism));
  ***REMOVED***

  // Get the provider
  var provider = pool.authProviders[mechanism];

  // Authenticate using the provided mechanism
  provider.auth.apply(provider, [write(pool), [connection], db].concat(auth.slice(2)).concat([cb]));
***REMOVED***

// The write function used by the authentication mechanism (bypasses external)
function write(self) ***REMOVED***
  return function(connection, command, callback) ***REMOVED***
    // Get the raw buffer
    // Ensure we stop auth if pool was destroyed
    if (self.state === DESTROYED || self.state === DESTROYING) ***REMOVED***
      return callback(new MongoError('pool destroyed'));
    ***REMOVED***

    // Set the connection workItem callback
    connection.workItems.push(***REMOVED***
      cb: callback,
      command: true,
      requestId: command.requestId
    ***REMOVED***);

    // Write the buffer out to the connection
    connection.write(command.toBin());
  ***REMOVED***;
***REMOVED***

function reauthenticate(pool, connection, cb) ***REMOVED***
  // Authenticate
  function authenticateAgainstProvider(pool, connection, providers, cb) ***REMOVED***
    // Finished re-authenticating against providers
    if (providers.length === 0) return cb();
    // Get the provider name
    var provider = pool.authProviders[providers.pop()];

    // Auth provider
    provider.reauthenticate(write(pool), [connection], function(err) ***REMOVED***
      // We got an error return immediately
      if (err) return cb(err);
      // Continue authenticating the connection
      authenticateAgainstProvider(pool, connection, providers, cb);
    ***REMOVED***);
  ***REMOVED***

  // Start re-authenticating process
  authenticateAgainstProvider(pool, connection, Object.keys(pool.authProviders), cb);
***REMOVED***

function connectionFailureHandler(self, event) ***REMOVED***
  return function(err) ***REMOVED***
    if (this._connectionFailHandled) return;
    this._connectionFailHandled = true;
    // Destroy the connection
    this.destroy();

    // Remove the connection
    removeConnection(self, this);

    // Flush all work Items on this connection
    while (this.workItems.length > 0) ***REMOVED***
      var workItem = this.workItems.shift();
      if (workItem.cb) workItem.cb(err);
    ***REMOVED***

    // Did we catch a timeout, increment the numberOfConsecutiveTimeouts
    if (event === 'timeout') ***REMOVED***
      self.numberOfConsecutiveTimeouts = self.numberOfConsecutiveTimeouts + 1;

      // Have we timed out more than reconnectTries in a row ?
      // Force close the pool as we are trying to connect to tcp sink hole
      if (self.numberOfConsecutiveTimeouts > self.options.reconnectTries) ***REMOVED***
        self.numberOfConsecutiveTimeouts = 0;
        // Destroy all connections and pool
        self.destroy(true);
        // Emit close event
        return self.emit('close', self);
      ***REMOVED***
    ***REMOVED***

    // No more socket available propegate the event
    if (self.socketCount() === 0) ***REMOVED***
      if (self.state !== DESTROYED && self.state !== DESTROYING) ***REMOVED***
        stateTransition(self, DISCONNECTED);
      ***REMOVED***

      // Do not emit error events, they are always close events
      // do not trigger the low level error handler in node
      event = event === 'error' ? 'close' : event;
      self.emit(event, err);
    ***REMOVED***

    // Start reconnection attempts
    if (!self.reconnectId && self.options.reconnect) ***REMOVED***
      self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
    ***REMOVED***

    // Do we need to do anything to maintain the minimum pool size
    const totalConnections =
      self.availableConnections.length +
      self.connectingConnections.length +
      self.inUseConnections.length;

    if (totalConnections < self.minSize) ***REMOVED***
      _createConnection(self);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

function attemptReconnect(self) ***REMOVED***
  return function() ***REMOVED***
    self.emit('attemptReconnect', self);
    if (self.state === DESTROYED || self.state === DESTROYING) return;

    // We are connected do not try again
    if (self.isConnected()) ***REMOVED***
      self.reconnectId = null;
      return;
    ***REMOVED***

    // If we have failure schedule a retry
    function _connectionFailureHandler(self) ***REMOVED***
      return function() ***REMOVED***
        if (this._connectionFailHandled) return;
        this._connectionFailHandled = true;
        // Destroy the connection
        this.destroy();
        // Count down the number of reconnects
        self.retriesLeft = self.retriesLeft - 1;
        // How many retries are left
        if (self.retriesLeft <= 0) ***REMOVED***
          // Destroy the instance
          self.destroy();
          // Emit close event
          self.emit(
            'reconnectFailed',
            new MongoNetworkError(
              f(
                'failed to reconnect after %s attempts with interval %s ms',
                self.options.reconnectTries,
                self.options.reconnectInterval
              )
            )
          );
        ***REMOVED*** else ***REMOVED***
          self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***

    // Got a connect handler
    function _connectHandler(self) ***REMOVED***
      return function() ***REMOVED***
        // Assign
        var connection = this;

        // Pool destroyed stop the connection
        if (self.state === DESTROYED || self.state === DESTROYING) ***REMOVED***
          return connection.destroy();
        ***REMOVED***

        // Clear out all handlers
        handlers.forEach(function(event) ***REMOVED***
          connection.removeAllListeners(event);
        ***REMOVED***);

        // Reset reconnect id
        self.reconnectId = null;

        // Apply pool connection handlers
        connection.on('error', connectionFailureHandler(self, 'error'));
        connection.on('close', connectionFailureHandler(self, 'close'));
        connection.on('timeout', connectionFailureHandler(self, 'timeout'));
        connection.on('parseError', connectionFailureHandler(self, 'parseError'));

        // Apply any auth to the connection
        reauthenticate(self, this, function() ***REMOVED***
          // Reset retries
          self.retriesLeft = self.options.reconnectTries;
          // Push to available connections
          self.availableConnections.push(connection);
          // Set the reconnectConnection to null
          self.reconnectConnection = null;
          // Emit reconnect event
          self.emit('reconnect', self);
          // Trigger execute to start everything up again
          _execute(self)();
        ***REMOVED***);
      ***REMOVED***;
    ***REMOVED***

    // Create a connection
    self.reconnectConnection = new Connection(messageHandler(self), self.options);
    // Add handlers
    self.reconnectConnection.on('close', _connectionFailureHandler(self, 'close'));
    self.reconnectConnection.on('error', _connectionFailureHandler(self, 'error'));
    self.reconnectConnection.on('timeout', _connectionFailureHandler(self, 'timeout'));
    self.reconnectConnection.on('parseError', _connectionFailureHandler(self, 'parseError'));
    // On connection
    self.reconnectConnection.on('connect', _connectHandler(self));
    // Attempt connection
    self.reconnectConnection.connect();
  ***REMOVED***;
***REMOVED***

function moveConnectionBetween(connection, from, to) ***REMOVED***
  var index = from.indexOf(connection);
  // Move the connection from connecting to available
  if (index !== -1) ***REMOVED***
    from.splice(index, 1);
    to.push(connection);
  ***REMOVED***
***REMOVED***

function messageHandler(self) ***REMOVED***
  return function(message, connection) ***REMOVED***
    // workItem to execute
    var workItem = null;

    // Locate the workItem
    for (var i = 0; i < connection.workItems.length; i++) ***REMOVED***
      if (connection.workItems[i].requestId === message.responseTo) ***REMOVED***
        // Get the callback
        workItem = connection.workItems[i];
        // Remove from list of workItems
        connection.workItems.splice(i, 1);
      ***REMOVED***
    ***REMOVED***

    // Reset timeout counter
    self.numberOfConsecutiveTimeouts = 0;

    // Reset the connection timeout if we modified it for
    // this operation
    if (workItem && workItem.socketTimeout) ***REMOVED***
      connection.resetSocketTimeout();
    ***REMOVED***

    // Log if debug enabled
    if (self.logger.isDebug()) ***REMOVED***
      self.logger.debug(
        f(
          'message [%s] received from %s:%s',
          message.raw.toString('hex'),
          self.options.host,
          self.options.port
        )
      );
    ***REMOVED***

    // Authenticate any straggler connections
    function authenticateStragglers(self, connection, callback) ***REMOVED***
      // Get any non authenticated connections
      var connections = self.nonAuthenticatedConnections.slice(0);
      var nonAuthenticatedConnections = self.nonAuthenticatedConnections;
      self.nonAuthenticatedConnections = [];

      // Establish if the connection need to be authenticated
      // Add to authentication list if
      // 1. we were in an authentication process when the operation was executed
      // 2. our current authentication timestamp is from the workItem one, meaning an auth has happened
      if (
        connection.workItems.length === 1 &&
        (connection.workItems[0].authenticating === true ||
          (typeof connection.workItems[0].authenticatingTimestamp === 'number' &&
            connection.workItems[0].authenticatingTimestamp !== self.authenticatingTimestamp))
      ) ***REMOVED***
        // Add connection to the list
        connections.push(connection);
      ***REMOVED***

      // No connections need to be re-authenticated
      if (connections.length === 0) ***REMOVED***
        // Release the connection back to the pool
        moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);
        // Finish
        return callback();
      ***REMOVED***

      // Apply re-authentication to all connections before releasing back to pool
      var connectionCount = connections.length;
      // Authenticate all connections
      for (var i = 0; i < connectionCount; i++) ***REMOVED***
        reauthenticate(self, connections[i], function() ***REMOVED***
          connectionCount = connectionCount - 1;

          if (connectionCount === 0) ***REMOVED***
            // Put non authenticated connections in available connections
            self.availableConnections = self.availableConnections.concat(
              nonAuthenticatedConnections
            );
            // Release the connection back to the pool
            moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);
            // Return
            callback();
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    function handleOperationCallback(self, cb, err, result) ***REMOVED***
      // No domain enabled
      if (!self.options.domainsEnabled) ***REMOVED***
        return process.nextTick(function() ***REMOVED***
          return cb(err, result);
        ***REMOVED***);
      ***REMOVED***

      // Domain enabled just call the callback
      cb(err, result);
    ***REMOVED***

    authenticateStragglers(self, connection, function() ***REMOVED***
      // Keep executing, ensure current message handler does not stop execution
      if (!self.executing) ***REMOVED***
        process.nextTick(function() ***REMOVED***
          _execute(self)();
        ***REMOVED***);
      ***REMOVED***

      // Time to dispatch the message if we have a callback
      if (workItem && !workItem.immediateRelease) ***REMOVED***
        try ***REMOVED***
          // Parse the message according to the provided options
          message.parse(workItem);
        ***REMOVED*** catch (err) ***REMOVED***
          return handleOperationCallback(self, workItem.cb, new MongoError(err));
        ***REMOVED***

        // Look for clusterTime, and operationTime and update them if necessary
        if (message.documents[0]) ***REMOVED***
          if (message.documents[0].$clusterTime) ***REMOVED***
            const $clusterTime = message.documents[0].$clusterTime;
            self.topology.clusterTime = $clusterTime;

            if (workItem.session != null) ***REMOVED***
              resolveClusterTime(workItem.session, $clusterTime);
            ***REMOVED***
          ***REMOVED***

          if (
            message.documents[0].operationTime &&
            workItem.session &&
            workItem.session.supports.causalConsistency
          ) ***REMOVED***
            workItem.session.advanceOperationTime(message.documents[0].operationTime);
          ***REMOVED***
        ***REMOVED***

        // Establish if we have an error
        if (workItem.command && message.documents[0]) ***REMOVED***
          const responseDoc = message.documents[0];
          if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) ***REMOVED***
            return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));
          ***REMOVED***

          if (responseDoc.writeConcernError) ***REMOVED***
            const err =
              responseDoc.ok === 1
                ? new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc)
                : new MongoWriteConcernError(responseDoc.writeConcernError);
            return handleOperationCallback(self, workItem.cb, err);
          ***REMOVED***
        ***REMOVED***

        // Add the connection details
        message.hashedName = connection.hashedName;

        // Return the documents
        handleOperationCallback(
          self,
          workItem.cb,
          null,
          new CommandResult(
            workItem.fullResult ? message : message.documents[0],
            connection,
            message
          )
        );
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***;
***REMOVED***

/**
 * Return the total socket count in the pool.
 * @method
 * @return ***REMOVED***Number***REMOVED*** The number of socket available.
 */
Pool.prototype.socketCount = function() ***REMOVED***
  return this.availableConnections.length + this.inUseConnections.length;
  // + this.connectingConnections.length;
***REMOVED***;

/**
 * Return all pool connections
 * @method
 * @return ***REMOVED***Connection[]***REMOVED*** The pool connections
 */
Pool.prototype.allConnections = function() ***REMOVED***
  return this.availableConnections.concat(this.inUseConnections).concat(this.connectingConnections);
***REMOVED***;

/**
 * Get a pool connection (round-robin)
 * @method
 * @return ***REMOVED***Connection***REMOVED***
 */
Pool.prototype.get = function() ***REMOVED***
  return this.allConnections()[0];
***REMOVED***;

/**
 * Is the pool connected
 * @method
 * @return ***REMOVED***boolean***REMOVED***
 */
Pool.prototype.isConnected = function() ***REMOVED***
  // We are in a destroyed state
  if (this.state === DESTROYED || this.state === DESTROYING) ***REMOVED***
    return false;
  ***REMOVED***

  // Get connections
  var connections = this.availableConnections.concat(this.inUseConnections);

  // Check if we have any connected connections
  for (var i = 0; i < connections.length; i++) ***REMOVED***
    if (connections[i].isConnected()) return true;
  ***REMOVED***

  // Might be authenticating, but we are still connected
  if (connections.length === 0 && this.authenticating) ***REMOVED***
    return true;
  ***REMOVED***

  // Not connected
  return false;
***REMOVED***;

/**
 * Was the pool destroyed
 * @method
 * @return ***REMOVED***boolean***REMOVED***
 */
Pool.prototype.isDestroyed = function() ***REMOVED***
  return this.state === DESTROYED || this.state === DESTROYING;
***REMOVED***;

/**
 * Is the pool in a disconnected state
 * @method
 * @return ***REMOVED***boolean***REMOVED***
 */
Pool.prototype.isDisconnected = function() ***REMOVED***
  return this.state === DISCONNECTED;
***REMOVED***;

/**
 * Connect pool
 * @method
 */
Pool.prototype.connect = function() ***REMOVED***
  if (this.state !== DISCONNECTED) ***REMOVED***
    throw new MongoError('connection in unlawful state ' + this.state);
  ***REMOVED***

  var self = this;
  // Transition to connecting state
  stateTransition(this, CONNECTING);
  // Create an array of the arguments
  var args = Array.prototype.slice.call(arguments, 0);
  // Create a connection
  var connection = new Connection(messageHandler(self), this.options);
  // Add to list of connections
  this.connectingConnections.push(connection);
  // Add listeners to the connection
  connection.once('connect', function(connection) ***REMOVED***
    if (self.state === DESTROYED || self.state === DESTROYING) return self.destroy();

    // If we are in a topology, delegate the auth to it
    // This is to avoid issues where we would auth against an
    // arbiter
    if (self.options.inTopology) ***REMOVED***
      // Set connected mode
      stateTransition(self, CONNECTED);

      // Move the active connection
      moveConnectionBetween(connection, self.connectingConnections, self.availableConnections);

      // Emit the connect event
      return self.emit('connect', self);
    ***REMOVED***

    // Apply any store credentials
    reauthenticate(self, connection, function(err) ***REMOVED***
      if (self.state === DESTROYED || self.state === DESTROYING) return self.destroy();

      // We have an error emit it
      if (err) ***REMOVED***
        // Destroy the pool
        self.destroy();
        // Emit the error
        return self.emit('error', err);
      ***REMOVED***

      // Authenticate
      authenticate(self, args, connection, function(err) ***REMOVED***
        if (self.state === DESTROYED || self.state === DESTROYING) return self.destroy();

        // We have an error emit it
        if (err) ***REMOVED***
          // Destroy the pool
          self.destroy();
          // Emit the error
          return self.emit('error', err);
        ***REMOVED***
        // Set connected mode
        stateTransition(self, CONNECTED);

        // Move the active connection
        moveConnectionBetween(connection, self.connectingConnections, self.availableConnections);

        // if we have a minPoolSize, create a connection
        if (self.minSize) ***REMOVED***
          for (let i = 0; i < self.minSize; i++) _createConnection(self);
        ***REMOVED***

        // Emit the connect event
        self.emit('connect', self);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);

  // Add error handlers
  connection.once('error', connectionFailureHandler(this, 'error'));
  connection.once('close', connectionFailureHandler(this, 'close'));
  connection.once('timeout', connectionFailureHandler(this, 'timeout'));
  connection.once('parseError', connectionFailureHandler(this, 'parseError'));

  try ***REMOVED***
    connection.connect();
  ***REMOVED*** catch (err) ***REMOVED***
    // SSL or something threw on connect
    process.nextTick(function() ***REMOVED***
      self.emit('error', err);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***;

/**
 * Authenticate using a specified mechanism
 * @method
 * @param ***REMOVED***string***REMOVED*** mechanism The Auth mechanism we are invoking
 * @param ***REMOVED***string***REMOVED*** db The db we are invoking the mechanism against
 * @param ***REMOVED***...object***REMOVED*** param Parameters for the specific mechanism
 * @param ***REMOVED***authResultCallback***REMOVED*** callback A callback function
 */
Pool.prototype.auth = function(mechanism) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  var callback = args.pop();

  // If we don't have the mechanism fail
  if (self.authProviders[mechanism] == null && mechanism !== 'default') ***REMOVED***
    throw new MongoError(f('auth provider %s does not exist', mechanism));
  ***REMOVED***

  // Signal that we are authenticating a new set of credentials
  this.authenticating = true;
  this.authenticatingTimestamp = new Date().getTime();

  // Authenticate all live connections
  function authenticateLiveConnections(self, args, cb) ***REMOVED***
    // Get the current viable connections
    var connections = self.allConnections();
    // Allow nothing else to use the connections while we authenticate them
    self.availableConnections = [];
    self.inUseConnections = [];
    self.connectingConnections = [];

    var connectionsCount = connections.length;
    var error = null;
    // No connections available, return
    if (connectionsCount === 0) ***REMOVED***
      self.authenticating = false;
      return callback(null);
    ***REMOVED***

    // Authenticate the connections
    for (var i = 0; i < connections.length; i++) ***REMOVED***
      authenticate(self, args, connections[i], function(err, result) ***REMOVED***
        connectionsCount = connectionsCount - 1;

        // Store the error
        if (err) error = err;

        // Processed all connections
        if (connectionsCount === 0) ***REMOVED***
          // Auth finished
          self.authenticating = false;
          // Add the connections back to available connections
          self.availableConnections = self.availableConnections.concat(connections);
          // We had an error, return it
          if (error) ***REMOVED***
            // Log the error
            if (self.logger.isError()) ***REMOVED***
              self.logger.error(
                f(
                  '[%s] failed to authenticate against server %s:%s',
                  self.id,
                  self.options.host,
                  self.options.port
                )
              );
            ***REMOVED***

            return cb(error, result);
          ***REMOVED***
          cb(null, result);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  // Wait for a logout in process to happen
  function waitForLogout(self, cb) ***REMOVED***
    if (!self.loggingout) return cb();
    setTimeout(function() ***REMOVED***
      waitForLogout(self, cb);
    ***REMOVED***, 1);
  ***REMOVED***

  // Wait for loggout to finish
  waitForLogout(self, function() ***REMOVED***
    // Authenticate all live connections
    authenticateLiveConnections(self, args, function(err, result) ***REMOVED***
      // Credentials correctly stored in auth provider if successful
      // Any new connections will now reauthenticate correctly
      self.authenticating = false;
      // Return after authentication connections
      callback(err, result);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Logout all users against a database
 * @method
 * @param ***REMOVED***string***REMOVED*** dbName The database name
 * @param ***REMOVED***authResultCallback***REMOVED*** callback A callback function
 */
Pool.prototype.logout = function(dbName, callback) ***REMOVED***
  var self = this;
  if (typeof dbName !== 'string') ***REMOVED***
    throw new MongoError('logout method requires a db name as first argument');
  ***REMOVED***

  if (typeof callback !== 'function') ***REMOVED***
    throw new MongoError('logout method requires a callback');
  ***REMOVED***

  // Indicate logout in process
  this.loggingout = true;

  // Get all relevant connections
  var connections = self.availableConnections.concat(self.inUseConnections);
  var count = connections.length;
  // Store any error
  var error = null;

  // Send logout command over all the connections
  for (var i = 0; i < connections.length; i++) ***REMOVED***
    write(self)(
      connections[i],
      new Query(
        this.options.bson,
        f('%s.$cmd', dbName),
        ***REMOVED*** logout: 1 ***REMOVED***,
        ***REMOVED*** numberToSkip: 0, numberToReturn: 1 ***REMOVED***
      ),
      function(err) ***REMOVED***
        count = count - 1;
        if (err) error = err;

        if (count === 0) ***REMOVED***
          self.loggingout = false;
          callback(error);
        ***REMOVED***
      ***REMOVED***
    );
  ***REMOVED***
***REMOVED***;

/**
 * Unref the pool
 * @method
 */
Pool.prototype.unref = function() ***REMOVED***
  // Get all the known connections
  var connections = this.availableConnections
    .concat(this.inUseConnections)
    .concat(this.connectingConnections);
  connections.forEach(function(c) ***REMOVED***
    c.unref();
  ***REMOVED***);
***REMOVED***;

// Events
var events = ['error', 'close', 'timeout', 'parseError', 'connect'];

// Destroy the connections
function destroy(self, connections) ***REMOVED***
  // Destroy all connections
  connections.forEach(function(c) ***REMOVED***
    // Remove all listeners
    for (var i = 0; i < events.length; i++) ***REMOVED***
      c.removeAllListeners(events[i]);
    ***REMOVED***
    // Destroy connection
    c.destroy();
  ***REMOVED***);

  // Zero out all connections
  self.inUseConnections = [];
  self.availableConnections = [];
  self.nonAuthenticatedConnections = [];
  self.connectingConnections = [];

  // Set state to destroyed
  stateTransition(self, DESTROYED);
***REMOVED***

/**
 * Destroy pool
 * @method
 */
Pool.prototype.destroy = function(force) ***REMOVED***
  var self = this;
  // Do not try again if the pool is already dead
  if (this.state === DESTROYED || self.state === DESTROYING) return;
  // Set state to destroyed
  stateTransition(this, DESTROYING);

  // Are we force closing
  if (force) ***REMOVED***
    // Get all the known connections
    var connections = self.availableConnections
      .concat(self.inUseConnections)
      .concat(self.nonAuthenticatedConnections)
      .concat(self.connectingConnections);

    // Flush any remaining work items with
    // an error
    while (self.queue.length > 0) ***REMOVED***
      var workItem = self.queue.shift();
      if (typeof workItem.cb === 'function') ***REMOVED***
        workItem.cb(new MongoError('Pool was force destroyed'));
      ***REMOVED***
    ***REMOVED***

    // Destroy the topology
    return destroy(self, connections);
  ***REMOVED***

  // Clear out the reconnect if set
  if (this.reconnectId) ***REMOVED***
    clearTimeout(this.reconnectId);
  ***REMOVED***

  // If we have a reconnect connection running, close
  // immediately
  if (this.reconnectConnection) ***REMOVED***
    this.reconnectConnection.destroy();
  ***REMOVED***

  // Wait for the operations to drain before we close the pool
  function checkStatus() ***REMOVED***
    flushMonitoringOperations(self.queue);

    if (self.queue.length === 0) ***REMOVED***
      // Get all the known connections
      var connections = self.availableConnections
        .concat(self.inUseConnections)
        .concat(self.nonAuthenticatedConnections)
        .concat(self.connectingConnections);

      // Check if we have any in flight operations
      for (var i = 0; i < connections.length; i++) ***REMOVED***
        // There is an operation still in flight, reschedule a
        // check waiting for it to drain
        if (connections[i].workItems.length > 0) ***REMOVED***
          return setTimeout(checkStatus, 1);
        ***REMOVED***
      ***REMOVED***

      destroy(self, connections);
      // ***REMOVED*** else if (self.queue.length > 0 && !this.reconnectId) ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      // Ensure we empty the queue
      _execute(self)();
      // Set timeout
      setTimeout(checkStatus, 1);
    ***REMOVED***
  ***REMOVED***

  // Initiate drain of operations
  checkStatus();
***REMOVED***;

// Prepare the buffer that Pool.prototype.write() uses to send to the server
var serializeCommands = function(self, commands, result, callback) ***REMOVED***
  // Base case when there are no more commands to serialize
  if (commands.length === 0) return callback(null, result);

  // Pop off the zeroth command and serialize it
  var thisCommand = commands.shift();
  var originalCommandBuffer = thisCommand.toBin();

  // Check whether we and the server have agreed to use a compressor
  if (self.options.agreedCompressor && !hasUncompressibleCommands(thisCommand)) ***REMOVED***
    // Transform originalCommandBuffer into OP_COMPRESSED
    var concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);
    var messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);

    // Extract information needed for OP_COMPRESSED from the uncompressed message
    var originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);

    // Compress the message body
    compress(self, messageToBeCompressed, function(err, compressedMessage) ***REMOVED***
      if (err) return callback(err, null);

      // Create the msgHeader of OP_COMPRESSED
      var msgHeader = new Buffer(MESSAGE_HEADER_SIZE);
      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + 9 + compressedMessage.length, 0); // messageLength
      msgHeader.writeInt32LE(thisCommand.requestId, 4); // requestID
      msgHeader.writeInt32LE(0, 8); // responseTo (zero)
      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode

      // Create the compression details of OP_COMPRESSED
      var compressionDetails = new Buffer(9);
      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode
      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader
      compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); // compressorID

      // Push the concatenation of the OP_COMPRESSED message onto results
      result.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));

      // Continue recursing through the commands array
      serializeCommands(self, commands, result, callback);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    // Push the serialization of the command onto results
    result.push(originalCommandBuffer);

    // Continue recursing through the commands array
    serializeCommands(self, commands, result, callback);
  ***REMOVED***
***REMOVED***;

/**
 * Write a message to MongoDB
 * @method
 * @return ***REMOVED***Connection***REMOVED***
 */
Pool.prototype.write = function(commands, options, cb) ***REMOVED***
  var self = this;
  // Ensure we have a callback
  if (typeof options === 'function') ***REMOVED***
    cb = options;
  ***REMOVED***

  // Always have options
  options = options || ***REMOVED******REMOVED***;

  // We need to have a callback function unless the message returns no response
  if (!(typeof cb === 'function') && !options.noResponse) ***REMOVED***
    throw new MongoError('write method must provide a callback');
  ***REMOVED***

  // Pool was destroyed error out
  if (this.state === DESTROYED || this.state === DESTROYING) ***REMOVED***
    // Callback with an error
    if (cb) ***REMOVED***
      try ***REMOVED***
        cb(new MongoError('pool destroyed'));
      ***REMOVED*** catch (err) ***REMOVED***
        process.nextTick(function() ***REMOVED***
          throw err;
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    return;
  ***REMOVED***

  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') ***REMOVED***
    // if we have a domain bind to it
    var oldCb = cb;
    cb = process.domain.bind(function() ***REMOVED***
      // v8 - argumentsToArray one-liner
      var args = new Array(arguments.length);
      for (var i = 0; i < arguments.length; i++) ***REMOVED***
        args[i] = arguments[i];
      ***REMOVED***
      // bounce off event loop so domain switch takes place
      process.nextTick(function() ***REMOVED***
        oldCb.apply(null, args);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  // Do we have an operation
  var operation = ***REMOVED***
    cb: cb,
    raw: false,
    promoteLongs: true,
    promoteValues: true,
    promoteBuffers: false,
    fullResult: false
  ***REMOVED***;

  // Set the options for the parsing
  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;
  operation.promoteValues =
    typeof options.promoteValues === 'boolean' ? options.promoteValues : true;
  operation.promoteBuffers =
    typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;
  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;
  operation.immediateRelease =
    typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;
  operation.documentsReturnedIn = options.documentsReturnedIn;
  operation.command = typeof options.command === 'boolean' ? options.command : false;
  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;
  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;
  operation.session = options.session || null;

  // Optional per operation socketTimeout
  operation.socketTimeout = options.socketTimeout;
  operation.monitoring = options.monitoring;
  // Custom socket Timeout
  if (options.socketTimeout) ***REMOVED***
    operation.socketTimeout = options.socketTimeout;
  ***REMOVED***

  // Ensure commands is an array
  if (!Array.isArray(commands)) ***REMOVED***
    commands = [commands];
  ***REMOVED***

  // Get the requestId
  operation.requestId = commands[commands.length - 1].requestId;

  if (hasSessionSupport(this.topology)) ***REMOVED***
    let sessionOptions = ***REMOVED******REMOVED***;
    if (this.topology.clusterTime) ***REMOVED***
      sessionOptions = ***REMOVED*** $clusterTime: this.topology.clusterTime ***REMOVED***;
    ***REMOVED***

    if (operation.session) ***REMOVED***
      // TODO: reenable when sessions development is complete
      // if (operation.session.topology !== this.topology) ***REMOVED***
      //   return cb(
      //     new MongoError('Sessions may only be used with the client they were created from')
      //   );
      // ***REMOVED***

      if (operation.session.hasEnded) ***REMOVED***
        return cb(new MongoError('Use of expired sessions is not permitted'));
      ***REMOVED***

      if (
        operation.session.clusterTime &&
        operation.session.clusterTime.clusterTime.greaterThan(
          sessionOptions.$clusterTime.clusterTime
        )
      ) ***REMOVED***
        sessionOptions.$clusterTime = operation.session.clusterTime;
      ***REMOVED***

      sessionOptions.lsid = operation.session.id;

      // update the `lastUse` of the acquired ServerSession
      operation.session.serverSession.lastUse = Date.now();
    ***REMOVED***

    // decorate the commands with session-specific details
    commands.forEach(command => ***REMOVED***
      if (command instanceof Query) ***REMOVED***
        if (command.query.$query) ***REMOVED***
          Object.assign(command.query.$query, sessionOptions);
        ***REMOVED*** else ***REMOVED***
          Object.assign(command.query, sessionOptions);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        Object.assign(command, sessionOptions);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  // If command monitoring is enabled we need to modify the callback here
  if (self.options.monitorCommands) ***REMOVED***
    // NOTE: there is only ever a single command, for some legacy reason I am unaware of we
    //       treat this as a potential array of commands
    const command = commands[0];
    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));

    operation.started = process.hrtime();
    operation.cb = (err, reply) => ***REMOVED***
      if (err) ***REMOVED***
        self.emit(
          'commandFailed',
          new apm.CommandFailedEvent(this, command, err, operation.started)
        );
      ***REMOVED*** else ***REMOVED***
        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) ***REMOVED***
          self.emit(
            'commandFailed',
            new apm.CommandFailedEvent(this, command, reply.result, operation.started)
          );
        ***REMOVED*** else ***REMOVED***
          self.emit(
            'commandSucceeded',
            new apm.CommandSucceededEvent(this, command, reply, operation.started)
          );
        ***REMOVED***
      ***REMOVED***

      if (typeof cb === 'function') cb(err, reply);
    ***REMOVED***;
  ***REMOVED***

  // Prepare the operation buffer
  serializeCommands(self, commands, [], function(err, serializedCommands) ***REMOVED***
    if (err) throw err;

    // Set the operation's buffer to the serialization of the commands
    operation.buffer = serializedCommands;

    // If we have a monitoring operation schedule as the very first operation
    // Otherwise add to back of queue
    if (options.monitoring) ***REMOVED***
      self.queue.unshift(operation);
    ***REMOVED*** else ***REMOVED***
      self.queue.push(operation);
    ***REMOVED***

    // Attempt to execute the operation
    if (!self.executing) ***REMOVED***
      process.nextTick(function() ***REMOVED***
        _execute(self)();
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

// Return whether a command contains an uncompressible command term
// Will return true if command contains no uncompressible command terms
var hasUncompressibleCommands = function(command) ***REMOVED***
  return uncompressibleCommands.some(function(cmd) ***REMOVED***
    return command.query.hasOwnProperty(cmd);
  ***REMOVED***);
***REMOVED***;

// Remove connection method
function remove(connection, connections) ***REMOVED***
  for (var i = 0; i < connections.length; i++) ***REMOVED***
    if (connections[i] === connection) ***REMOVED***
      connections.splice(i, 1);
      return true;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function removeConnection(self, connection) ***REMOVED***
  if (remove(connection, self.availableConnections)) return;
  if (remove(connection, self.inUseConnections)) return;
  if (remove(connection, self.connectingConnections)) return;
  if (remove(connection, self.nonAuthenticatedConnections)) return;
***REMOVED***

// All event handlers
var handlers = ['close', 'message', 'error', 'timeout', 'parseError', 'connect'];

function _createConnection(self) ***REMOVED***
  if (self.state === DESTROYED || self.state === DESTROYING) ***REMOVED***
    return;
  ***REMOVED***
  var connection = new Connection(messageHandler(self), self.options);

  // Push the connection
  self.connectingConnections.push(connection);

  // Handle any errors
  var tempErrorHandler = function(_connection) ***REMOVED***
    return function() ***REMOVED***
      // Destroy the connection
      _connection.destroy();
      // Remove the connection from the connectingConnections list
      removeConnection(self, _connection);
      // Start reconnection attempts
      if (!self.reconnectId && self.options.reconnect) ***REMOVED***
        self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***;

  // Handle successful connection
  var tempConnectHandler = function(_connection) ***REMOVED***
    return function() ***REMOVED***
      // Destroyed state return
      if (self.state === DESTROYED || self.state === DESTROYING) ***REMOVED***
        // Remove the connection from the list
        removeConnection(self, _connection);
        return _connection.destroy();
      ***REMOVED***

      // Destroy all event emitters
      handlers.forEach(function(e) ***REMOVED***
        _connection.removeAllListeners(e);
      ***REMOVED***);

      // Add the final handlers
      _connection.once('close', connectionFailureHandler(self, 'close'));
      _connection.once('error', connectionFailureHandler(self, 'error'));
      _connection.once('timeout', connectionFailureHandler(self, 'timeout'));
      _connection.once('parseError', connectionFailureHandler(self, 'parseError'));

      // Signal
      reauthenticate(self, _connection, function(err) ***REMOVED***
        if (self.state === DESTROYED || self.state === DESTROYING) ***REMOVED***
          return _connection.destroy();
        ***REMOVED***
        // Remove the connection from the connectingConnections list
        removeConnection(self, _connection);

        // Handle error
        if (err) ***REMOVED***
          return _connection.destroy();
        ***REMOVED***

        // If we are c at the moment
        // Do not automatially put in available connections
        // As we need to apply the credentials first
        if (self.authenticating) ***REMOVED***
          self.nonAuthenticatedConnections.push(_connection);
        ***REMOVED*** else ***REMOVED***
          // Push to available
          self.availableConnections.push(_connection);
          // Execute any work waiting
          _execute(self)();
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***;
  ***REMOVED***;

  // Add all handlers
  connection.once('close', tempErrorHandler(connection));
  connection.once('error', tempErrorHandler(connection));
  connection.once('timeout', tempErrorHandler(connection));
  connection.once('parseError', tempErrorHandler(connection));
  connection.once('connect', tempConnectHandler(connection));

  // Start connection
  connection.connect();
***REMOVED***

function flushMonitoringOperations(queue) ***REMOVED***
  for (var i = 0; i < queue.length; i++) ***REMOVED***
    if (queue[i].monitoring) ***REMOVED***
      var workItem = queue[i];
      queue.splice(i, 1);
      workItem.cb(
        new MongoError(***REMOVED*** message: 'no connection available for monitoring', driver: true ***REMOVED***)
      );
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function _execute(self) ***REMOVED***
  return function() ***REMOVED***
    if (self.state === DESTROYED) return;
    // Already executing, skip
    if (self.executing) return;
    // Set pool as executing
    self.executing = true;

    // Wait for auth to clear before continuing
    function waitForAuth(cb) ***REMOVED***
      if (!self.authenticating) return cb();
      // Wait for a milisecond and try again
      setTimeout(function() ***REMOVED***
        waitForAuth(cb);
      ***REMOVED***, 1);
    ***REMOVED***

    // Block on any auth in process
    waitForAuth(function() ***REMOVED***
      // New pool connections are in progress, wait them to finish
      // before executing any more operation to ensure distribution of
      // operations
      if (self.connectingConnections.length > 0) ***REMOVED***
        return;
      ***REMOVED***

      // As long as we have available connections
      // eslint-disable-next-line
      while (true) ***REMOVED***
        // Total availble connections
        var totalConnections =
          self.availableConnections.length +
          self.connectingConnections.length +
          self.inUseConnections.length;

        // No available connections available, flush any monitoring ops
        if (self.availableConnections.length === 0) ***REMOVED***
          // Flush any monitoring operations
          flushMonitoringOperations(self.queue);
          break;
        ***REMOVED***

        // No queue break
        if (self.queue.length === 0) ***REMOVED***
          break;
        ***REMOVED***

        // Get a connection
        var connection = null;

        // Locate all connections that have no work
        var connections = [];
        // Get a list of all connections
        for (var i = 0; i < self.availableConnections.length; i++) ***REMOVED***
          if (self.availableConnections[i].workItems.length === 0) ***REMOVED***
            connections.push(self.availableConnections[i]);
          ***REMOVED***
        ***REMOVED***

        // No connection found that has no work on it, just pick one for pipelining
        if (connections.length === 0) ***REMOVED***
          connection =
            self.availableConnections[self.connectionIndex++ % self.availableConnections.length];
        ***REMOVED*** else ***REMOVED***
          connection = connections[self.connectionIndex++ % connections.length];
        ***REMOVED***

        // Is the connection connected
        if (connection.isConnected()) ***REMOVED***
          // Get the next work item
          var workItem = self.queue.shift();

          // If we are monitoring we need to use a connection that is not
          // running another operation to avoid socket timeout changes
          // affecting an existing operation
          if (workItem.monitoring) ***REMOVED***
            var foundValidConnection = false;

            for (i = 0; i < self.availableConnections.length; i++) ***REMOVED***
              // If the connection is connected
              // And there are no pending workItems on it
              // Then we can safely use it for monitoring.
              if (
                self.availableConnections[i].isConnected() &&
                self.availableConnections[i].workItems.length === 0
              ) ***REMOVED***
                foundValidConnection = true;
                connection = self.availableConnections[i];
                break;
              ***REMOVED***
            ***REMOVED***

            // No safe connection found, attempt to grow the connections
            // if possible and break from the loop
            if (!foundValidConnection) ***REMOVED***
              // Put workItem back on the queue
              self.queue.unshift(workItem);

              // Attempt to grow the pool if it's not yet maxsize
              if (totalConnections < self.options.size && self.queue.length > 0) ***REMOVED***
                // Create a new connection
                _createConnection(self);
              ***REMOVED***

              // Re-execute the operation
              setTimeout(function() ***REMOVED***
                _execute(self)();
              ***REMOVED***, 10);

              break;
            ***REMOVED***
          ***REMOVED***

          // Don't execute operation until we have a full pool
          if (totalConnections < self.options.size) ***REMOVED***
            // Connection has work items, then put it back on the queue
            // and create a new connection
            if (connection.workItems.length > 0) ***REMOVED***
              // Lets put the workItem back on the list
              self.queue.unshift(workItem);
              // Create a new connection
              _createConnection(self);
              // Break from the loop
              break;
            ***REMOVED***
          ***REMOVED***

          // Get actual binary commands
          var buffer = workItem.buffer;

          // Set current status of authentication process
          workItem.authenticating = self.authenticating;
          workItem.authenticatingTimestamp = self.authenticatingTimestamp;

          // If we are monitoring take the connection of the availableConnections
          if (workItem.monitoring) ***REMOVED***
            moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);
          ***REMOVED***

          // Track the executing commands on the mongo server
          // as long as there is an expected response
          if (!workItem.noResponse) ***REMOVED***
            connection.workItems.push(workItem);
          ***REMOVED***

          // We have a custom socketTimeout
          if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') ***REMOVED***
            connection.setSocketTimeout(workItem.socketTimeout);
          ***REMOVED***

          // Capture if write was successful
          var writeSuccessful = true;

          // Put operation on the wire
          if (Array.isArray(buffer)) ***REMOVED***
            for (i = 0; i < buffer.length; i++) ***REMOVED***
              writeSuccessful = connection.write(buffer[i]);
            ***REMOVED***
          ***REMOVED*** else ***REMOVED***
            writeSuccessful = connection.write(buffer);
          ***REMOVED***

          // if the command is designated noResponse, call the callback immeditely
          if (workItem.noResponse && typeof workItem.cb === 'function') ***REMOVED***
            workItem.cb(null, null);
          ***REMOVED***

          if (writeSuccessful && workItem.immediateRelease && self.authenticating) ***REMOVED***
            removeConnection(self, connection);
            self.nonAuthenticatedConnections.push(connection);
          ***REMOVED*** else if (writeSuccessful === false) ***REMOVED***
            // If write not successful put back on queue
            self.queue.unshift(workItem);
            // Remove the disconnected connection
            removeConnection(self, connection);
            // Flush any monitoring operations in the queue, failing fast
            flushMonitoringOperations(self.queue);
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          // Remove the disconnected connection
          removeConnection(self, connection);
          // Flush any monitoring operations in the queue, failing fast
          flushMonitoringOperations(self.queue);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***);

    self.executing = false;
  ***REMOVED***;
***REMOVED***

// Make execution loop available for testing
Pool._execute = _execute;

/**
 * A server connect event, used to verify that the connection is up and running
 *
 * @event Pool#connect
 * @type ***REMOVED***Pool***REMOVED***
 */

/**
 * A server reconnect event, used to verify that pool reconnected.
 *
 * @event Pool#reconnect
 * @type ***REMOVED***Pool***REMOVED***
 */

/**
 * The server connection closed, all pool connections closed
 *
 * @event Pool#close
 * @type ***REMOVED***Pool***REMOVED***
 */

/**
 * The server connection caused an error, all pool connections closed
 *
 * @event Pool#error
 * @type ***REMOVED***Pool***REMOVED***
 */

/**
 * The server connection timed out, all pool connections closed
 *
 * @event Pool#timeout
 * @type ***REMOVED***Pool***REMOVED***
 */

/**
 * The driver experienced an invalid message, all pool connections closed
 *
 * @event Pool#parseError
 * @type ***REMOVED***Pool***REMOVED***
 */

/**
 * The driver attempted to reconnect
 *
 * @event Pool#attemptReconnect
 * @type ***REMOVED***Pool***REMOVED***
 */

/**
 * The driver exhausted all reconnect attempts
 *
 * @event Pool#reconnectFailed
 * @type ***REMOVED***Pool***REMOVED***
 */

module.exports = Pool;
