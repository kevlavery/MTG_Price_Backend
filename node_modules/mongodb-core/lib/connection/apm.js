'use strict';
const KillCursor = require('../connection/commands').KillCursor;
const GetMore = require('../connection/commands').GetMore;
const process = require('process');

/** Commands that we want to redact because of the sensitive nature of their contents */
const SENSITIVE_COMMANDS = new Set([
  'authenticate',
  'saslStart',
  'saslContinue',
  'getnonce',
  'createUser',
  'updateUser',
  'copydbgetnonce',
  'copydbsaslstart',
  'copydb'
]);

// helper methods
const extractCommandName = command => Object.keys(command)[0];
const calculateDurationInMs = started => ***REMOVED***
  const hrtime = process.hrtime(started);
  return (hrtime[0] * 1e9 + hrtime[1]) / 1e6;
***REMOVED***;

const namespace = command => command.ns;
const databaseName = command => command.ns.split('.')[0];
const collectionName = command => command.ns.split('.')[1];
const generateConnectionId = pool => `$***REMOVED***pool.options.host***REMOVED***:$***REMOVED***pool.options.port***REMOVED***`;
const maybeRedact = (commandName, result) => (SENSITIVE_COMMANDS.has(commandName) ? ***REMOVED******REMOVED*** : result);

const LEGACY_FIND_QUERY_MAP = ***REMOVED***
  $query: 'filter',
  $orderby: 'sort',
  $hint: 'hint',
  $comment: 'comment',
  $maxScan: 'maxScan',
  $max: 'max',
  $min: 'min',
  $returnKey: 'returnKey',
  $showDiskLoc: 'showRecordId',
  $maxTimeMS: 'maxTimeMS',
  $snapshot: 'snapshot'
***REMOVED***;

const LEGACY_FIND_OPTIONS_MAP = ***REMOVED***
  numberToSkip: 'skip',
  numberToReturn: 'batchSize',
  returnFieldsSelector: 'projection'
***REMOVED***;

const OP_QUERY_KEYS = [
  'tailable',
  'oplogReplay',
  'noCursorTimeout',
  'awaitData',
  'partial',
  'exhaust'
];

/**
 * Extract the actual command from the query, possibly upconverting if it's a legacy
 * format
 *
 * @param ***REMOVED***Object***REMOVED*** command the command
 */
const extractCommand = command => ***REMOVED***
  if (command instanceof GetMore) ***REMOVED***
    return ***REMOVED***
      getMore: command.cursorId,
      collection: collectionName(command),
      batchSize: command.numberToReturn
    ***REMOVED***;
  ***REMOVED***

  if (command instanceof KillCursor) ***REMOVED***
    return ***REMOVED***
      killCursors: collectionName(command),
      cursors: command.cursorIds
    ***REMOVED***;
  ***REMOVED***

  if (command.query && command.query.$query) ***REMOVED***
    // upconvert legacy find command
    const result = ***REMOVED*** find: collectionName(command) ***REMOVED***;
    Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => ***REMOVED***
      if (typeof command.query[key] !== 'undefined')
        result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];
    ***REMOVED***);

    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => ***REMOVED***
      if (typeof command.options[key] !== 'undefined')
        result[LEGACY_FIND_OPTIONS_MAP[key]] = command.options[key];
    ***REMOVED***);

    OP_QUERY_KEYS.forEach(key => ***REMOVED***
      if (command[key]) result[key] = command[key];
    ***REMOVED***);

    if (typeof command.pre32Limit !== 'undefined') ***REMOVED***
      result.limit = command.pre32Limit;
    ***REMOVED***

    if (command.query.$explain) ***REMOVED***
      return ***REMOVED*** explain: result ***REMOVED***;
    ***REMOVED***

    return result;
  ***REMOVED***

  return command.query ? command.query : command;
***REMOVED***;

const extractReply = (command, reply) => ***REMOVED***
  if (command instanceof GetMore) ***REMOVED***
    return ***REMOVED***
      ok: 1,
      cursor: ***REMOVED***
        id: reply.message.cursorId,
        ns: namespace(command),
        nextBatch: reply.message.documents
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***

  if (command instanceof KillCursor) ***REMOVED***
    return ***REMOVED***
      ok: 1,
      cursorsUnknown: command.cursorIds
    ***REMOVED***;
  ***REMOVED***

  // is this a legacy find command?
  if (command.query && typeof command.query.$query !== 'undefined') ***REMOVED***
    return ***REMOVED***
      ok: 1,
      cursor: ***REMOVED***
        id: reply.message.cursorId,
        ns: namespace(command),
        firstBatch: reply.message.documents
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***

  return reply.result;
***REMOVED***;

/** An event indicating the start of a given command */
class CommandStartedEvent ***REMOVED***
  /**
   * Create a started event
   *
   * @param ***REMOVED***Pool***REMOVED*** pool the pool that originated the command
   * @param ***REMOVED***Object***REMOVED*** command the command
   */
  constructor(pool, command) ***REMOVED***
    const cmd = extractCommand(command);
    const commandName = extractCommandName(cmd);

    // NOTE: remove in major revision, this is not spec behavior
    if (SENSITIVE_COMMANDS.has(commandName)) ***REMOVED***
      this.commandObj = ***REMOVED******REMOVED***;
      this.commandObj[commandName] = true;
    ***REMOVED***

    Object.assign(this, ***REMOVED***
      command: cmd,
      databaseName: databaseName(command),
      commandName,
      requestId: command.requestId,
      connectionId: generateConnectionId(pool)
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/** An event indicating the success of a given command */
class CommandSucceededEvent ***REMOVED***
  /**
   * Create a succeeded event
   *
   * @param ***REMOVED***Pool***REMOVED*** pool the pool that originated the command
   * @param ***REMOVED***Object***REMOVED*** command the command
   * @param ***REMOVED***Object***REMOVED*** reply the reply for this command from the server
   * @param ***REMOVED***Array***REMOVED*** started a high resolution tuple timestamp of when the command was first sent, to calculate duration
   */
  constructor(pool, command, reply, started) ***REMOVED***
    const cmd = extractCommand(command);
    const commandName = extractCommandName(cmd);

    Object.assign(this, ***REMOVED***
      duration: calculateDurationInMs(started),
      commandName,
      reply: maybeRedact(commandName, extractReply(command, reply)),
      requestId: command.requestId,
      connectionId: generateConnectionId(pool)
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/** An event indicating the failure of a given command */
class CommandFailedEvent ***REMOVED***
  /**
   * Create a failure event
   *
   * @param ***REMOVED***Pool***REMOVED*** pool the pool that originated the command
   * @param ***REMOVED***Object***REMOVED*** command the command
   * @param ***REMOVED***MongoError|Object***REMOVED*** error the generated error or a server error response
   * @param ***REMOVED***Array***REMOVED*** started a high resolution tuple timestamp of when the command was first sent, to calculate duration
   */
  constructor(pool, command, error, started) ***REMOVED***
    const cmd = extractCommand(command);
    const commandName = extractCommandName(cmd);

    Object.assign(this, ***REMOVED***
      duration: calculateDurationInMs(started),
      commandName,
      failure: maybeRedact(commandName, error),
      requestId: command.requestId,
      connectionId: generateConnectionId(pool)
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

module.exports = ***REMOVED***
  CommandStartedEvent,
  CommandSucceededEvent,
  CommandFailedEvent
***REMOVED***;
