'use strict';

var f = require('util').format,
  crypto = require('crypto'),
  retrieveBSON = require('../connection/utils').retrieveBSON,
  Query = require('../connection/commands').Query,
  MongoError = require('../error').MongoError;

var BSON = retrieveBSON(),
  Binary = BSON.Binary;

var AuthSession = function(db, username, password) ***REMOVED***
  this.db = db;
  this.username = username;
  this.password = password;
***REMOVED***;

AuthSession.prototype.equal = function(session) ***REMOVED***
  return (
    session.db === this.db &&
    session.username === this.username &&
    session.password === this.password
  );
***REMOVED***;

var id = 0;

/**
 * Creates a new ScramSHA1 authentication mechanism
 * @class
 * @return ***REMOVED***ScramSHA1***REMOVED*** A cursor instance
 */
var ScramSHA1 = function(bson) ***REMOVED***
  this.bson = bson;
  this.authStore = [];
  this.id = id++;
***REMOVED***;

var parsePayload = function(payload) ***REMOVED***
  var dict = ***REMOVED******REMOVED***;
  var parts = payload.split(',');

  for (var i = 0; i < parts.length; i++) ***REMOVED***
    var valueParts = parts[i].split('=');
    dict[valueParts[0]] = valueParts[1];
  ***REMOVED***

  return dict;
***REMOVED***;

var passwordDigest = function(username, password) ***REMOVED***
  if (typeof username !== 'string') throw new MongoError('username must be a string');
  if (typeof password !== 'string') throw new MongoError('password must be a string');
  if (password.length === 0) throw new MongoError('password cannot be empty');
  // Use node md5 generator
  var md5 = crypto.createHash('md5');
  // Generate keys used for authentication
  md5.update(username + ':mongo:' + password, 'utf8');
  return md5.digest('hex');
***REMOVED***;

// XOR two buffers
var xor = function(a, b) ***REMOVED***
  if (!Buffer.isBuffer(a)) a = new Buffer(a);
  if (!Buffer.isBuffer(b)) b = new Buffer(b);
  var res = [];
  if (a.length > b.length) ***REMOVED***
    for (var i = 0; i < b.length; i++) ***REMOVED***
      res.push(a[i] ^ b[i]);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    for (i = 0; i < a.length; i++) ***REMOVED***
      res.push(a[i] ^ b[i]);
    ***REMOVED***
  ***REMOVED***
  return new Buffer(res);
***REMOVED***;

var _hiCache = ***REMOVED******REMOVED***;
var _hiCacheCount = 0;
var _hiCachePurge = function() ***REMOVED***
  _hiCache = ***REMOVED******REMOVED***;
  _hiCacheCount = 0;
***REMOVED***;

var hi = function(data, salt, iterations) ***REMOVED***
  // omit the work if already generated
  var key = [data, salt.toString('base64'), iterations].join('_');
  if (_hiCache[key] !== undefined) ***REMOVED***
    return _hiCache[key];
  ***REMOVED***

  // generate the salt
  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, 20, 'sha1');

  // cache a copy to speed up the next lookup, but prevent unbounded cache growth
  if (_hiCacheCount >= 200) ***REMOVED***
    _hiCachePurge();
  ***REMOVED***

  _hiCache[key] = saltedData;
  _hiCacheCount += 1;
  return saltedData;
***REMOVED***;

/**
 * Authenticate
 * @method
 * @param ***REMOVED******REMOVED***Server***REMOVED***|***REMOVED***ReplSet***REMOVED***|***REMOVED***Mongos***REMOVED******REMOVED*** server Topology the authentication method is being called on
 * @param ***REMOVED***[]Connections***REMOVED*** connections Connections to authenticate using this authenticator
 * @param ***REMOVED***string***REMOVED*** db Name of the database
 * @param ***REMOVED***string***REMOVED*** username Username
 * @param ***REMOVED***string***REMOVED*** password Password
 * @param ***REMOVED***authResultCallback***REMOVED*** callback The callback to return the result from the authentication
 * @return ***REMOVED***object***REMOVED***
 */
ScramSHA1.prototype.auth = function(server, connections, db, username, password, callback) ***REMOVED***
  var self = this;
  // Total connections
  var count = connections.length;
  if (count === 0) return callback(null, null);

  // Valid connections
  var numberOfValidConnections = 0;
  var errorObject = null;

  // Execute MongoCR
  var executeScram = function(connection) ***REMOVED***
    // Clean up the user
    username = username.replace('=', '=3D').replace(',', '=2C');

    // Create a random nonce
    var nonce = crypto.randomBytes(24).toString('base64');
    // var nonce = 'MsQUY9iw0T9fx2MUEz6LZPwGuhVvWAhc'
    var firstBare = f('n=%s,r=%s', username, nonce);

    // Build command structure
    var cmd = ***REMOVED***
      saslStart: 1,
      mechanism: 'SCRAM-SHA-1',
      payload: new Binary(f('n,,%s', firstBare)),
      autoAuthorize: 1
    ***REMOVED***;

    // Handle the error
    var handleError = function(err, r) ***REMOVED***
      if (err) ***REMOVED***
        numberOfValidConnections = numberOfValidConnections - 1;
        errorObject = err;
        return false;
      ***REMOVED*** else if (r.result['$err']) ***REMOVED***
        errorObject = r.result;
        return false;
      ***REMOVED*** else if (r.result['errmsg']) ***REMOVED***
        errorObject = r.result;
        return false;
      ***REMOVED*** else ***REMOVED***
        numberOfValidConnections = numberOfValidConnections + 1;
      ***REMOVED***

      return true;
    ***REMOVED***;

    // Finish up
    var finish = function(_count, _numberOfValidConnections) ***REMOVED***
      if (_count === 0 && _numberOfValidConnections > 0) ***REMOVED***
        // Store the auth details
        addAuthSession(self.authStore, new AuthSession(db, username, password));
        // Return correct authentication
        return callback(null, true);
      ***REMOVED*** else if (_count === 0) ***REMOVED***
        if (errorObject == null)
          errorObject = new MongoError(f('failed to authenticate using scram'));
        return callback(errorObject, false);
      ***REMOVED***
    ***REMOVED***;

    var handleEnd = function(_err, _r) ***REMOVED***
      // Handle any error
      handleError(_err, _r);
      // Adjust the number of connections
      count = count - 1;
      // Execute the finish
      finish(count, numberOfValidConnections);
    ***REMOVED***;

    // Write the commmand on the connection
    server(
      connection,
      new Query(self.bson, f('%s.$cmd', db), cmd, ***REMOVED***
        numberToSkip: 0,
        numberToReturn: 1
      ***REMOVED***),
      function(err, r) ***REMOVED***
        // Do we have an error, handle it
        if (handleError(err, r) === false) ***REMOVED***
          count = count - 1;

          if (count === 0 && numberOfValidConnections > 0) ***REMOVED***
            // Store the auth details
            addAuthSession(self.authStore, new AuthSession(db, username, password));
            // Return correct authentication
            return callback(null, true);
          ***REMOVED*** else if (count === 0) ***REMOVED***
            if (errorObject == null)
              errorObject = new MongoError(f('failed to authenticate using scram'));
            return callback(errorObject, false);
          ***REMOVED***

          return;
        ***REMOVED***

        // Get the dictionary
        var dict = parsePayload(r.result.payload.value());

        // Unpack dictionary
        var iterations = parseInt(dict.i, 10);
        var salt = dict.s;
        var rnonce = dict.r;

        // Set up start of proof
        var withoutProof = f('c=biws,r=%s', rnonce);
        var passwordDig = passwordDigest(username, password);
        var saltedPassword = hi(passwordDig, new Buffer(salt, 'base64'), iterations);

        // Create the client key
        var hmac = crypto.createHmac('sha1', saltedPassword);
        hmac.update(new Buffer('Client Key'));
        var clientKey = new Buffer(hmac.digest('base64'), 'base64');

        // Create the stored key
        var hash = crypto.createHash('sha1');
        hash.update(clientKey);
        var storedKey = new Buffer(hash.digest('base64'), 'base64');

        // Create the authentication message
        var authMsg = [firstBare, r.result.payload.value().toString('base64'), withoutProof].join(
          ','
        );

        // Create client signature
        hmac = crypto.createHmac('sha1', storedKey);
        hmac.update(new Buffer(authMsg));
        var clientSig = new Buffer(hmac.digest('base64'), 'base64');

        // Create client proof
        var clientProof = f('p=%s', new Buffer(xor(clientKey, clientSig)).toString('base64'));

        // Create client final
        var clientFinal = [withoutProof, clientProof].join(',');

        //
        // Create continue message
        var cmd = ***REMOVED***
          saslContinue: 1,
          conversationId: r.result.conversationId,
          payload: new Binary(new Buffer(clientFinal))
        ***REMOVED***;

        //
        // Execute sasl continue
        // Write the commmand on the connection
        server(
          connection,
          new Query(self.bson, f('%s.$cmd', db), cmd, ***REMOVED***
            numberToSkip: 0,
            numberToReturn: 1
          ***REMOVED***),
          function(err, r) ***REMOVED***
            if (r && r.result.done === false) ***REMOVED***
              var cmd = ***REMOVED***
                saslContinue: 1,
                conversationId: r.result.conversationId,
                payload: new Buffer(0)
              ***REMOVED***;

              // Write the commmand on the connection
              server(
                connection,
                new Query(self.bson, f('%s.$cmd', db), cmd, ***REMOVED***
                  numberToSkip: 0,
                  numberToReturn: 1
                ***REMOVED***),
                function(err, r) ***REMOVED***
                  handleEnd(err, r);
                ***REMOVED***
              );
            ***REMOVED*** else ***REMOVED***
              handleEnd(err, r);
            ***REMOVED***
          ***REMOVED***
        );
      ***REMOVED***
    );
  ***REMOVED***;

  var _execute = function(_connection) ***REMOVED***
    process.nextTick(function() ***REMOVED***
      executeScram(_connection);
    ***REMOVED***);
  ***REMOVED***;

  // For each connection we need to authenticate
  while (connections.length > 0) ***REMOVED***
    _execute(connections.shift());
  ***REMOVED***
***REMOVED***;

// Add to store only if it does not exist
var addAuthSession = function(authStore, session) ***REMOVED***
  var found = false;

  for (var i = 0; i < authStore.length; i++) ***REMOVED***
    if (authStore[i].equal(session)) ***REMOVED***
      found = true;
      break;
    ***REMOVED***
  ***REMOVED***

  if (!found) authStore.push(session);
***REMOVED***;

/**
 * Remove authStore credentials
 * @method
 * @param ***REMOVED***string***REMOVED*** db Name of database we are removing authStore details about
 * @return ***REMOVED***object***REMOVED***
 */
ScramSHA1.prototype.logout = function(dbName) ***REMOVED***
  this.authStore = this.authStore.filter(function(x) ***REMOVED***
    return x.db !== dbName;
  ***REMOVED***);
***REMOVED***;

/**
 * Re authenticate pool
 * @method
 * @param ***REMOVED******REMOVED***Server***REMOVED***|***REMOVED***ReplSet***REMOVED***|***REMOVED***Mongos***REMOVED******REMOVED*** server Topology the authentication method is being called on
 * @param ***REMOVED***[]Connections***REMOVED*** connections Connections to authenticate using this authenticator
 * @param ***REMOVED***authResultCallback***REMOVED*** callback The callback to return the result from the authentication
 * @return ***REMOVED***object***REMOVED***
 */
ScramSHA1.prototype.reauthenticate = function(server, connections, callback) ***REMOVED***
  var authStore = this.authStore.slice(0);
  var count = authStore.length;
  // No connections
  if (count === 0) return callback(null, null);
  // Iterate over all the auth details stored
  for (var i = 0; i < authStore.length; i++) ***REMOVED***
    this.auth(
      server,
      connections,
      authStore[i].db,
      authStore[i].username,
      authStore[i].password,
      function(err) ***REMOVED***
        count = count - 1;
        // Done re-authenticating
        if (count === 0) ***REMOVED***
          callback(err, null);
        ***REMOVED***
      ***REMOVED***
    );
  ***REMOVED***
***REMOVED***;

module.exports = ScramSHA1;
