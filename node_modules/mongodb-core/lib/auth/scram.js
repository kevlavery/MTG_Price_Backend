'use strict';

var f = require('util').format,
  crypto = require('crypto'),
  retrieveBSON = require('../connection/utils').retrieveBSON,
  Query = require('../connection/commands').Query,
  MongoError = require('../error').MongoError;

let saslprep;

try ***REMOVED***
  saslprep = require('saslprep');
***REMOVED*** catch (e) ***REMOVED***
  // don't do anything;
***REMOVED***

var BSON = retrieveBSON(),
  Binary = BSON.Binary;

var AuthSession = function(db, username, password) ***REMOVED***
  this.db = db;
  this.username = username;
  this.password = password;
***REMOVED***;

AuthSession.prototype.equal = function(session) ***REMOVED***
  return (
    session.db === this.db &&
    session.username === this.username &&
    session.password === this.password
  );
***REMOVED***;

var id = 0;

/**
 * Creates a new ScramSHA authentication mechanism
 * @class
 * @return ***REMOVED***ScramSHA***REMOVED*** A cursor instance
 */
var ScramSHA = function(bson, cryptoMethod) ***REMOVED***
  this.bson = bson;
  this.authStore = [];
  this.id = id++;
  this.cryptoMethod = cryptoMethod || 'sha1';
***REMOVED***;

var parsePayload = function(payload) ***REMOVED***
  var dict = ***REMOVED******REMOVED***;
  var parts = payload.split(',');

  for (var i = 0; i < parts.length; i++) ***REMOVED***
    var valueParts = parts[i].split('=');
    dict[valueParts[0]] = valueParts[1];
  ***REMOVED***

  return dict;
***REMOVED***;

var passwordDigest = function(username, password) ***REMOVED***
  if (typeof username !== 'string') throw new MongoError('username must be a string');
  if (typeof password !== 'string') throw new MongoError('password must be a string');
  if (password.length === 0) throw new MongoError('password cannot be empty');
  // Use node md5 generator
  var md5 = crypto.createHash('md5');
  // Generate keys used for authentication
  md5.update(username + ':mongo:' + password, 'utf8');
  return md5.digest('hex');
***REMOVED***;

// XOR two buffers
function xor(a, b) ***REMOVED***
  if (!Buffer.isBuffer(a)) a = new Buffer(a);
  if (!Buffer.isBuffer(b)) b = new Buffer(b);
  const length = Math.max(a.length, b.length);
  const res = [];

  for (let i = 0; i < length; i += 1) ***REMOVED***
    res.push(a[i] ^ b[i]);
  ***REMOVED***

  return new Buffer(res).toString('base64');
***REMOVED***

function H(method, text) ***REMOVED***
  return crypto
    .createHash(method)
    .update(text)
    .digest();
***REMOVED***

function HMAC(method, key, text) ***REMOVED***
  return crypto
    .createHmac(method, key)
    .update(text)
    .digest();
***REMOVED***

var _hiCache = ***REMOVED******REMOVED***;
var _hiCacheCount = 0;
var _hiCachePurge = function() ***REMOVED***
  _hiCache = ***REMOVED******REMOVED***;
  _hiCacheCount = 0;
***REMOVED***;

const hiLengthMap = ***REMOVED***
  sha256: 32,
  sha1: 20
***REMOVED***;

function HI(data, salt, iterations, cryptoMethod) ***REMOVED***
  // omit the work if already generated
  const key = [data, salt.toString('base64'), iterations].join('_');
  if (_hiCache[key] !== undefined) ***REMOVED***
    return _hiCache[key];
  ***REMOVED***

  // generate the salt
  const saltedData = crypto.pbkdf2Sync(
    data,
    salt,
    iterations,
    hiLengthMap[cryptoMethod],
    cryptoMethod
  );

  // cache a copy to speed up the next lookup, but prevent unbounded cache growth
  if (_hiCacheCount >= 200) ***REMOVED***
    _hiCachePurge();
  ***REMOVED***

  _hiCache[key] = saltedData;
  _hiCacheCount += 1;
  return saltedData;
***REMOVED***

/**
 * Authenticate
 * @method
 * @param ***REMOVED******REMOVED***Server***REMOVED***|***REMOVED***ReplSet***REMOVED***|***REMOVED***Mongos***REMOVED******REMOVED*** server Topology the authentication method is being called on
 * @param ***REMOVED***[]Connections***REMOVED*** connections Connections to authenticate using this authenticator
 * @param ***REMOVED***string***REMOVED*** db Name of the database
 * @param ***REMOVED***string***REMOVED*** username Username
 * @param ***REMOVED***string***REMOVED*** password Password
 * @param ***REMOVED***authResultCallback***REMOVED*** callback The callback to return the result from the authentication
 * @return ***REMOVED***object***REMOVED***
 */
ScramSHA.prototype.auth = function(server, connections, db, username, password, callback) ***REMOVED***
  var self = this;
  // Total connections
  var count = connections.length;
  if (count === 0) return callback(null, null);

  // Valid connections
  var numberOfValidConnections = 0;
  var errorObject = null;

  const cryptoMethod = this.cryptoMethod;
  let mechanism = 'SCRAM-SHA-1';
  let processedPassword;

  if (cryptoMethod === 'sha256') ***REMOVED***
    mechanism = 'SCRAM-SHA-256';

    let saslprepFn = (server.s && server.s.saslprep) || saslprep;

    if (saslprepFn) ***REMOVED***
      processedPassword = saslprepFn(password);
    ***REMOVED*** else ***REMOVED***
      console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');
      processedPassword = password;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    processedPassword = passwordDigest(username, password);
  ***REMOVED***

  // Execute MongoCR
  var executeScram = function(connection) ***REMOVED***
    // Clean up the user
    username = username.replace('=', '=3D').replace(',', '=2C');

    // Create a random nonce
    var nonce = crypto.randomBytes(24).toString('base64');
    // var nonce = 'MsQUY9iw0T9fx2MUEz6LZPwGuhVvWAhc'

    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
    // Since the username is not sasl-prep-d, we need to do this here.
    const firstBare = Buffer.concat([
      Buffer.from('n=', 'utf8'),
      Buffer.from(username, 'utf8'),
      Buffer.from(',r=', 'utf8'),
      Buffer.from(nonce, 'utf8')
    ]);

    // Build command structure
    var cmd = ***REMOVED***
      saslStart: 1,
      mechanism: mechanism,
      payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), firstBare])),
      autoAuthorize: 1
    ***REMOVED***;

    // Handle the error
    var handleError = function(err, r) ***REMOVED***
      if (err) ***REMOVED***
        numberOfValidConnections = numberOfValidConnections - 1;
        errorObject = err;
        return false;
      ***REMOVED*** else if (r.result['$err']) ***REMOVED***
        errorObject = r.result;
        return false;
      ***REMOVED*** else if (r.result['errmsg']) ***REMOVED***
        errorObject = r.result;
        return false;
      ***REMOVED*** else ***REMOVED***
        numberOfValidConnections = numberOfValidConnections + 1;
      ***REMOVED***

      return true;
    ***REMOVED***;

    // Finish up
    var finish = function(_count, _numberOfValidConnections) ***REMOVED***
      if (_count === 0 && _numberOfValidConnections > 0) ***REMOVED***
        // Store the auth details
        addAuthSession(self.authStore, new AuthSession(db, username, password));
        // Return correct authentication
        return callback(null, true);
      ***REMOVED*** else if (_count === 0) ***REMOVED***
        if (errorObject == null)
          errorObject = new MongoError(f('failed to authenticate using scram'));
        return callback(errorObject, false);
      ***REMOVED***
    ***REMOVED***;

    var handleEnd = function(_err, _r) ***REMOVED***
      // Handle any error
      handleError(_err, _r);
      // Adjust the number of connections
      count = count - 1;
      // Execute the finish
      finish(count, numberOfValidConnections);
    ***REMOVED***;

    // Write the commmand on the connection
    server(
      connection,
      new Query(self.bson, f('%s.$cmd', db), cmd, ***REMOVED***
        numberToSkip: 0,
        numberToReturn: 1
      ***REMOVED***),
      function(err, r) ***REMOVED***
        // Do we have an error, handle it
        if (handleError(err, r) === false) ***REMOVED***
          count = count - 1;

          if (count === 0 && numberOfValidConnections > 0) ***REMOVED***
            // Store the auth details
            addAuthSession(self.authStore, new AuthSession(db, username, password));
            // Return correct authentication
            return callback(null, true);
          ***REMOVED*** else if (count === 0) ***REMOVED***
            if (errorObject == null)
              errorObject = new MongoError(f('failed to authenticate using scram'));
            return callback(errorObject, false);
          ***REMOVED***

          return;
        ***REMOVED***

        // Get the dictionary
        var dict = parsePayload(r.result.payload.value());

        // Unpack dictionary
        var iterations = parseInt(dict.i, 10);
        var salt = dict.s;
        var rnonce = dict.r;

        // Set up start of proof
        var withoutProof = f('c=biws,r=%s', rnonce);
        var saltedPassword = HI(
          processedPassword,
          new Buffer(salt, 'base64'),
          iterations,
          cryptoMethod
        );

        if (iterations && iterations < 4096) ***REMOVED***
          const error = new MongoError(`Server returned an invalid iteration count $***REMOVED***iterations***REMOVED***`);
          return callback(error, false);
        ***REMOVED***

        // Create the client key
        const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');

        // Create the stored key
        const storedKey = H(cryptoMethod, clientKey);

        // Create the authentication message
        const authMessage = [
          firstBare,
          r.result.payload.value().toString('base64'),
          withoutProof
        ].join(',');

        // Create client signature
        const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);

        // Create client proof
        const clientProof = f('p=%s', xor(clientKey, clientSignature));

        // Create client final
        const clientFinal = [withoutProof, clientProof].join(',');

        // Create continue message
        const cmd = ***REMOVED***
          saslContinue: 1,
          conversationId: r.result.conversationId,
          payload: new Binary(new Buffer(clientFinal))
        ***REMOVED***;

        //
        // Execute sasl continue
        // Write the commmand on the connection
        server(
          connection,
          new Query(self.bson, f('%s.$cmd', db), cmd, ***REMOVED***
            numberToSkip: 0,
            numberToReturn: 1
          ***REMOVED***),
          function(err, r) ***REMOVED***
            if (r && r.result.done === false) ***REMOVED***
              var cmd = ***REMOVED***
                saslContinue: 1,
                conversationId: r.result.conversationId,
                payload: new Buffer(0)
              ***REMOVED***;

              // Write the commmand on the connection
              server(
                connection,
                new Query(self.bson, f('%s.$cmd', db), cmd, ***REMOVED***
                  numberToSkip: 0,
                  numberToReturn: 1
                ***REMOVED***),
                function(err, r) ***REMOVED***
                  handleEnd(err, r);
                ***REMOVED***
              );
            ***REMOVED*** else ***REMOVED***
              handleEnd(err, r);
            ***REMOVED***
          ***REMOVED***
        );
      ***REMOVED***
    );
  ***REMOVED***;

  var _execute = function(_connection) ***REMOVED***
    process.nextTick(function() ***REMOVED***
      executeScram(_connection);
    ***REMOVED***);
  ***REMOVED***;

  // For each connection we need to authenticate
  while (connections.length > 0) ***REMOVED***
    _execute(connections.shift());
  ***REMOVED***
***REMOVED***;

// Add to store only if it does not exist
var addAuthSession = function(authStore, session) ***REMOVED***
  var found = false;

  for (var i = 0; i < authStore.length; i++) ***REMOVED***
    if (authStore[i].equal(session)) ***REMOVED***
      found = true;
      break;
    ***REMOVED***
  ***REMOVED***

  if (!found) authStore.push(session);
***REMOVED***;

/**
 * Remove authStore credentials
 * @method
 * @param ***REMOVED***string***REMOVED*** db Name of database we are removing authStore details about
 * @return ***REMOVED***object***REMOVED***
 */
ScramSHA.prototype.logout = function(dbName) ***REMOVED***
  this.authStore = this.authStore.filter(function(x) ***REMOVED***
    return x.db !== dbName;
  ***REMOVED***);
***REMOVED***;

/**
 * Re authenticate pool
 * @method
 * @param ***REMOVED******REMOVED***Server***REMOVED***|***REMOVED***ReplSet***REMOVED***|***REMOVED***Mongos***REMOVED******REMOVED*** server Topology the authentication method is being called on
 * @param ***REMOVED***[]Connections***REMOVED*** connections Connections to authenticate using this authenticator
 * @param ***REMOVED***authResultCallback***REMOVED*** callback The callback to return the result from the authentication
 * @return ***REMOVED***object***REMOVED***
 */
ScramSHA.prototype.reauthenticate = function(server, connections, callback) ***REMOVED***
  var authStore = this.authStore.slice(0);
  var count = authStore.length;
  // No connections
  if (count === 0) return callback(null, null);
  // Iterate over all the auth details stored
  for (var i = 0; i < authStore.length; i++) ***REMOVED***
    this.auth(
      server,
      connections,
      authStore[i].db,
      authStore[i].username,
      authStore[i].password,
      function(err) ***REMOVED***
        count = count - 1;
        // Done re-authenticating
        if (count === 0) ***REMOVED***
          callback(err, null);
        ***REMOVED***
      ***REMOVED***
    );
  ***REMOVED***
***REMOVED***;

class ScramSHA1 extends ScramSHA ***REMOVED***
  constructor(bson) ***REMOVED***
    super(bson, 'sha1');
  ***REMOVED***
***REMOVED***

class ScramSHA256 extends ScramSHA ***REMOVED***
  constructor(bson) ***REMOVED***
    super(bson, 'sha256');
  ***REMOVED***
***REMOVED***

module.exports = ***REMOVED*** ScramSHA1, ScramSHA256 ***REMOVED***;
