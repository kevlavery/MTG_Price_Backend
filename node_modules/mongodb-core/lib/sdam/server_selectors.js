'use strict';
const ServerType = require('./server_description').ServerType;
const TopologyType = require('./topology_description').TopologyType;
const ReadPreference = require('../topologies/read_preference');
const MongoError = require('../error').MongoError;

// max staleness constants
const IDLE_WRITE_PERIOD = 10000;
const SMALLEST_MAX_STALENESS_SECONDS = 90;

function writableServerSelector() ***REMOVED***
  return function(topologyDescription, servers) ***REMOVED***
    if (topologyDescription === TopologyType.ReplicaSetNoPrimary) return [];
    if (
      topologyDescription.type === TopologyType.Sharded ||
      topologyDescription.type === TopologyType.Single
    ) ***REMOVED***
      return latencyWindowReducer(topologyDescription, servers);
    ***REMOVED***

    return latencyWindowReducer(topologyDescription, servers.filter(s => s.isWritable));
  ***REMOVED***;
***REMOVED***

// reducers
function maxStalenessReducer(readPreference, topologyDescription, servers) ***REMOVED***
  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) ***REMOVED***
    return servers;
  ***REMOVED***

  const maxStaleness = readPreference.maxStalenessSeconds;
  const maxStalenessVariance =
    (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;
  if (maxStaleness < maxStalenessVariance) ***REMOVED***
    throw MongoError(`maxStalenessSeconds must be at least $***REMOVED***maxStalenessVariance***REMOVED*** seconds`);
  ***REMOVED***

  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) ***REMOVED***
    throw new MongoError(
      `maxStalenessSeconds must be at least $***REMOVED***SMALLEST_MAX_STALENESS_SECONDS***REMOVED*** seconds`
    );
  ***REMOVED***

  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) ***REMOVED***
    const primary = servers.filter(primaryFilter)[0];
    return servers.reduce((result, server) => ***REMOVED***
      const stalenessMS =
        server.lastUpdateTime -
        server.lastWriteDate -
        (primary.lastUpdateTime - primary.lastWriteDate) +
        topologyDescription.heartbeatFrequencyMS;

      const staleness = stalenessMS / 1000;
      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);
      return result;
    ***REMOVED***, []);
  ***REMOVED*** else if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) ***REMOVED***
    const sMax = servers.reduce((max, s) => (s.lastWriteDate > max.lastWriteDate ? s : max));
    return servers.reduce((result, server) => ***REMOVED***
      const stalenessMS =
        sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;

      const staleness = stalenessMS / 1000;
      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);
      return result;
    ***REMOVED***, []);
  ***REMOVED***

  return servers;
***REMOVED***

function tagSetMatch(tagSet, serverTags) ***REMOVED***
  const keys = Object.keys(tagSet);
  const serverTagKeys = Object.keys(serverTags);
  for (let i = 0; i < keys.length; ++i) ***REMOVED***
    const key = keys[i];
    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***

function tagSetReducer(readPreference, servers) ***REMOVED***
  if (
    readPreference.tags == null ||
    (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)
  ) ***REMOVED***
    return servers;
  ***REMOVED***

  for (let i = 0; i < readPreference.tags.length; ++i) ***REMOVED***
    const tagSet = readPreference.tags[i];
    const serversMatchingTagset = servers.reduce((matched, server) => ***REMOVED***
      if (tagSetMatch(tagSet, server.tags)) matched.push(server);
      return matched;
    ***REMOVED***, []);

    if (serversMatchingTagset.length) ***REMOVED***
      return serversMatchingTagset;
    ***REMOVED***
  ***REMOVED***

  return [];
***REMOVED***

function latencyWindowReducer(topologyDescription, servers) ***REMOVED***
  const low = servers.reduce(
    (min, server) => (min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min)),
    -1
  );

  const high = low + topologyDescription.localThresholdMS;

  return servers.reduce((result, server) => ***REMOVED***
    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);
    return result;
  ***REMOVED***, []);
***REMOVED***

// filters
function primaryFilter(server) ***REMOVED***
  return server.type === ServerType.RSPrimary;
***REMOVED***

function secondaryFilter(server) ***REMOVED***
  return server.type === ServerType.RSSecondary;
***REMOVED***

function nearestFilter(server) ***REMOVED***
  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;
***REMOVED***

function knownFilter(server) ***REMOVED***
  return server.type !== ServerType.Unknown;
***REMOVED***

function readPreferenceServerSelector(readPreference) ***REMOVED***
  if (!readPreference.isValid()) ***REMOVED***
    throw new TypeError('Invalid read preference specified');
  ***REMOVED***

  return function(topologyDescription, servers) ***REMOVED***
    const commonWireVersion = topologyDescription.commonWireVersion;
    if (
      commonWireVersion &&
      (readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion)
    ) ***REMOVED***
      throw new MongoError(
        `Minimum wire version '$***REMOVED***
          readPreference.minWireVersion
        ***REMOVED***' required, but found '$***REMOVED***commonWireVersion***REMOVED***'`
      );
    ***REMOVED***

    if (
      topologyDescription.type === TopologyType.Single ||
      topologyDescription.type === TopologyType.Sharded
    ) ***REMOVED***
      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
    ***REMOVED***

    if (readPreference.mode === ReadPreference.PRIMARY) ***REMOVED***
      return servers.filter(primaryFilter);
    ***REMOVED***

    if (readPreference.mode === ReadPreference.SECONDARY) ***REMOVED***
      return latencyWindowReducer(
        topologyDescription,
        tagSetReducer(
          readPreference,
          maxStalenessReducer(readPreference, topologyDescription, servers)
        )
      ).filter(secondaryFilter);
    ***REMOVED*** else if (readPreference.mode === ReadPreference.NEAREST) ***REMOVED***
      return latencyWindowReducer(
        topologyDescription,
        tagSetReducer(
          readPreference,
          maxStalenessReducer(readPreference, topologyDescription, servers)
        )
      ).filter(nearestFilter);
    ***REMOVED*** else if (readPreference.mode === ReadPreference.SECONDARY_PREFERRED) ***REMOVED***
      const result = latencyWindowReducer(
        topologyDescription,
        tagSetReducer(
          readPreference,
          maxStalenessReducer(readPreference, topologyDescription, servers)
        )
      ).filter(secondaryFilter);

      return result.length === 0 ? servers.filter(primaryFilter) : result;
    ***REMOVED*** else if (readPreference.mode === ReadPreference.PRIMARY_PREFERRED) ***REMOVED***
      const result = servers.filter(primaryFilter);
      if (result.length) ***REMOVED***
        return result;
      ***REMOVED***

      return latencyWindowReducer(
        topologyDescription,
        tagSetReducer(
          readPreference,
          maxStalenessReducer(readPreference, topologyDescription, servers)
        )
      ).filter(secondaryFilter);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

module.exports = ***REMOVED***
  writableServerSelector,
  readPreferenceServerSelector
***REMOVED***;
