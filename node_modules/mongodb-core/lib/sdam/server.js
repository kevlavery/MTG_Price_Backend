'use strict';
const EventEmitter = require('events');
const MongoError = require('../error').MongoError;
const Pool = require('../connection/pool');
const relayEvents = require('../utils').relayEvents;
const calculateDurationInMs = require('../utils').calculateDurationInMs;
const Query = require('../connection/commands').Query;
const TwoSixWireProtocolSupport = require('../wireprotocol/2_6_support');
const ThreeTwoWireProtocolSupport = require('../wireprotocol/3_2_support');
const BSON = require('../connection/utils').retrieveBSON();
const createClientInfo = require('../topologies/shared').createClientInfo;
const Logger = require('../connection/logger');
const ServerDescription = require('./server_description').ServerDescription;
const ReadPreference = require('../topologies/read_preference');

/**
 *
 * @fires Server#serverHeartbeatStarted
 * @fires Server#serverHeartbeatSucceeded
 * @fires Server#serverHeartbeatFailed
 */
class Server extends EventEmitter ***REMOVED***
  /**
   * Create a server
   *
   * @param ***REMOVED***ServerDescription***REMOVED*** description
   * @param ***REMOVED***Object***REMOVED*** options
   */
  constructor(description, options) ***REMOVED***
    super();

    this.s = ***REMOVED***
      // the server description
      description,
      // a saved copy of the incoming options
      options,
      // the server logger
      logger: Logger('Server', options),
      // the bson parser
      bson:
        options.bson ||
        new BSON([
          BSON.Binary,
          BSON.Code,
          BSON.DBRef,
          BSON.Decimal128,
          BSON.Double,
          BSON.Int32,
          BSON.Long,
          BSON.Map,
          BSON.MaxKey,
          BSON.MinKey,
          BSON.ObjectId,
          BSON.BSONRegExp,
          BSON.Symbol,
          BSON.Timestamp
        ]),
      // client metadata for the initial handshake
      clientInfo: createClientInfo(options)
    ***REMOVED***;
  ***REMOVED***

  get description() ***REMOVED***
    return this.s.description;
  ***REMOVED***

  get name() ***REMOVED***
    return this.s.description.address;
  ***REMOVED***

  /**
   * Initiate server connect
   *
   * @param ***REMOVED***Array***REMOVED*** [options.auth] Array of auth options to apply on connect
   */
  connect(options) ***REMOVED***
    options = options || ***REMOVED******REMOVED***;

    // do not allow connect to be called on anything that's not disconnected
    if (this.s.pool && !this.s.pool.isDisconnected() && !this.s.pool.isDestroyed()) ***REMOVED***
      throw new MongoError(`Server instance in invalid state $***REMOVED***this.s.pool.state***REMOVED***`);
    ***REMOVED***

    // create a pool
    this.s.pool = new Pool(this, Object.assign(this.s.options, options, ***REMOVED*** bson: this.s.bson ***REMOVED***));

    // Set up listeners
    this.s.pool.on('connect', connectEventHandler(this));
    this.s.pool.on('close', closeEventHandler(this));

    // this.s.pool.on('error', errorEventHandler(this));
    // this.s.pool.on('timeout', timeoutEventHandler(this));
    // this.s.pool.on('parseError', errorEventHandler(this));
    // this.s.pool.on('reconnect', reconnectEventHandler(this));
    // this.s.pool.on('reconnectFailed', errorEventHandler(this));

    // relay all command monitoring events
    relayEvents(this.s.pool, this, ['commandStarted', 'commandSucceeded', 'commandFailed']);

    // If auth settings have been provided, use them
    if (options.auth) ***REMOVED***
      this.s.pool.connect.apply(this.s.pool, options.auth);
      return;
    ***REMOVED***

    this.s.pool.connect();
  ***REMOVED***

  /**
   * Destroy the server connection
   *
   * @param ***REMOVED***Boolean***REMOVED*** [options.emitClose=false] Emit close event on destroy
   * @param ***REMOVED***Boolean***REMOVED*** [options.emitDestroy=false] Emit destroy event on destroy
   * @param ***REMOVED***Boolean***REMOVED*** [options.force=false] Force destroy the pool
   */
  destroy(callback) ***REMOVED***
    if (typeof callback === 'function') ***REMOVED***
      callback(null, null);
    ***REMOVED***
  ***REMOVED***

  /**
   * Execute a command
   *
   * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
   * @param ***REMOVED***object***REMOVED*** cmd The command hash
   * @param ***REMOVED***ReadPreference***REMOVED*** [options.readPreference] Specify read preference if command supports it
   * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
   * @param ***REMOVED***Boolean***REMOVED*** [options.checkKeys=false] Specify if the bson parser should validate keys.
   * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
   * @param ***REMOVED***Boolean***REMOVED*** [options.fullResult=false] Return the full envelope instead of just the result document.
   * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
   * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
   */
  command(ns, cmd, options, callback) ***REMOVED***
    if (typeof options === 'function') ***REMOVED***
      (callback = options), (options = ***REMOVED******REMOVED***), (options = options || ***REMOVED******REMOVED***);
    ***REMOVED***

    const error = basicReadValidations(this, options);
    if (error) ***REMOVED***
      return callback(error, null);
    ***REMOVED***

    // Clone the options
    options = Object.assign(***REMOVED******REMOVED***, options, ***REMOVED*** wireProtocolCommand: false ***REMOVED***);

    // Debug log
    if (this.s.logger.isDebug()) ***REMOVED***
      this.s.logger.debug(
        `executing command [$***REMOVED***JSON.stringify(***REMOVED*** ns, cmd, options ***REMOVED***)***REMOVED***] against $***REMOVED***this.name***REMOVED***`
      );
    ***REMOVED***

    // Check if we have collation support
    if (this.description.maxWireVersion < 5 && cmd.collation) ***REMOVED***
      callback(new MongoError(`server $***REMOVED***this.name***REMOVED*** does not support collation`));
      return;
    ***REMOVED***

    // Are we executing against a specific topology
    const topology = options.topology || ***REMOVED******REMOVED***;
    // Create the query object
    const query = this.s.wireProtocolHandler.command(this.s.bson, ns, cmd, ***REMOVED******REMOVED***, topology, options);
    // Set slave OK of the query
    query.slaveOk = options.readPreference ? options.readPreference.slaveOk() : false;

    // write options
    const writeOptions = ***REMOVED***
      raw: typeof options.raw === 'boolean' ? options.raw : false,
      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,
      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,
      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,
      command: true,
      monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : false,
      fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,
      requestId: query.requestId,
      socketTimeout: typeof options.socketTimeout === 'number' ? options.socketTimeout : null,
      session: options.session || null
    ***REMOVED***;

    // write the operation to the pool
    this.s.pool.write(query, writeOptions, callback);
  ***REMOVED***

  /**
   * Insert one or more documents
   * @method
   * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
   * @param ***REMOVED***array***REMOVED*** ops An array of documents to insert
   * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
   * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
   * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
   * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
   * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
   * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
   */
  insert(ns, ops, options, callback) ***REMOVED***
    executeWriteOperation(***REMOVED*** server: this, op: 'insert', ns, ops ***REMOVED***, options, callback);
  ***REMOVED***

  /**
   * Perform one or more update operations
   * @method
   * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
   * @param ***REMOVED***array***REMOVED*** ops An array of updates
   * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
   * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
   * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
   * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
   * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
   * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
   */
  update(ns, ops, options, callback) ***REMOVED***
    executeWriteOperation(***REMOVED*** server: this, op: 'update', ns, ops ***REMOVED***, options, callback);
  ***REMOVED***

  /**
   * Perform one or more remove operations
   * @method
   * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
   * @param ***REMOVED***array***REMOVED*** ops An array of removes
   * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
   * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
   * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
   * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
   * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
   * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
   */
  remove(ns, ops, options, callback) ***REMOVED***
    executeWriteOperation(***REMOVED*** server: this, op: 'remove', ns, ops ***REMOVED***, options, callback);
  ***REMOVED***
***REMOVED***

function basicWriteValidations(server) ***REMOVED***
  if (!server.s.pool) ***REMOVED***
    return new MongoError('server instance is not connected');
  ***REMOVED***

  if (server.s.pool.isDestroyed()) ***REMOVED***
    return new MongoError('server instance pool was destroyed');
  ***REMOVED***

  return null;
***REMOVED***

function basicReadValidations(server, options) ***REMOVED***
  const error = basicWriteValidations(server, options);
  if (error) ***REMOVED***
    return error;
  ***REMOVED***

  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) ***REMOVED***
    return new MongoError('readPreference must be an instance of ReadPreference');
  ***REMOVED***
***REMOVED***

function executeWriteOperation(args, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // TODO: once we drop Node 4, use destructuring either here or in arguments.
  const server = args.server;
  const op = args.op;
  const ns = args.ns;
  const ops = Array.isArray(args.ops) ? args.ops : [args.ops];

  const error = basicWriteValidations(server, options);
  if (error) ***REMOVED***
    callback(error, null);
    return;
  ***REMOVED***

  // Check if we have collation support
  if (server.description.maxWireVersion < 5 && options.collation) ***REMOVED***
    callback(new MongoError(`server $***REMOVED***this.name***REMOVED*** does not support collation`));
    return;
  ***REMOVED***

  // Execute write
  return this.s.wireProtocolHandler[op](server.s.pool, ns, server.s.bson, ops, options, callback);
***REMOVED***

function saslSupportedMechs(options) ***REMOVED***
  if (!options) ***REMOVED***
    return ***REMOVED******REMOVED***;
  ***REMOVED***

  const authArray = options.auth || [];
  const authMechanism = authArray[0] || options.authMechanism;
  const authSource = authArray[1] || options.authSource || options.dbName || 'admin';
  const user = authArray[2] || options.user;

  if (typeof authMechanism === 'string' && authMechanism.toUpperCase() !== 'DEFAULT') ***REMOVED***
    return ***REMOVED******REMOVED***;
  ***REMOVED***

  if (!user) ***REMOVED***
    return ***REMOVED******REMOVED***;
  ***REMOVED***

  return ***REMOVED*** saslSupportedMechs: `$***REMOVED***authSource***REMOVED***.$***REMOVED***user***REMOVED***` ***REMOVED***;
***REMOVED***

function extractIsMasterError(err, result) ***REMOVED***
  if (err) return err;
  if (result && result.result && result.result.ok === 0) ***REMOVED***
    return new MongoError(result.result);
  ***REMOVED***
***REMOVED***

function executeServerHandshake(server, callback) ***REMOVED***
  // construct an `ismaster` query
  const compressors =
    server.s.options.compression && server.s.options.compression.compressors
      ? server.s.options.compression.compressors
      : [];

  const queryOptions = ***REMOVED*** numberToSkip: 0, numberToReturn: -1, checkKeys: false, slaveOk: true ***REMOVED***;
  const query = new Query(
    server.s.bson,
    'admin.$cmd',
    Object.assign(
      ***REMOVED*** ismaster: true, client: server.s.clientInfo, compression: compressors ***REMOVED***,
      saslSupportedMechs(server.s.options)
    ),
    queryOptions
  );

  // execute the query
  server.s.pool.write(
    query,
    ***REMOVED*** socketTimeout: server.s.options.connectionTimeout || 2000 ***REMOVED***,
    callback
  );
***REMOVED***

function configureWireProtocolHandler(ismaster) ***REMOVED***
  // 3.2 wire protocol handler
  if (ismaster.maxWireVersion >= 4) ***REMOVED***
    return new ThreeTwoWireProtocolSupport();
  ***REMOVED***

  // default to 2.6 wire protocol handler
  return new TwoSixWireProtocolSupport();
***REMOVED***

function connectEventHandler(server) ***REMOVED***
  return function() ***REMOVED***
    // log information of received information if in info mode
    // if (server.s.logger.isInfo()) ***REMOVED***
    //   var object = err instanceof MongoError ? JSON.stringify(err) : ***REMOVED******REMOVED***;
    //   server.s.logger.info(`server $***REMOVED***server.name***REMOVED*** fired event $***REMOVED***event***REMOVED*** out with message $***REMOVED***object***REMOVED***`);
    // ***REMOVED***

    // begin initial server handshake
    const start = process.hrtime();
    executeServerHandshake(server, (err, response) => ***REMOVED***
      // Set initial lastIsMasterMS - is this needed?
      server.s.lastIsMasterMS = calculateDurationInMs(start);

      const serverError = extractIsMasterError(err, response);
      if (serverError) ***REMOVED***
        server.emit('error', serverError);
        return;
      ***REMOVED***

      // extract the ismaster from the server response
      const isMaster = response.result;

      // compression negotation
      if (isMaster && isMaster.compression) ***REMOVED***
        const localCompressionInfo = server.s.options.compression;
        const localCompressors = localCompressionInfo.compressors;
        for (var i = 0; i < localCompressors.length; i++) ***REMOVED***
          if (isMaster.compression.indexOf(localCompressors[i]) > -1) ***REMOVED***
            server.s.pool.options.agreedCompressor = localCompressors[i];
            break;
          ***REMOVED***
        ***REMOVED***

        if (localCompressionInfo.zlibCompressionLevel) ***REMOVED***
          server.s.pool.options.zlibCompressionLevel = localCompressionInfo.zlibCompressionLevel;
        ***REMOVED***
      ***REMOVED***

      // configure the wire protocol handler
      server.s.wireProtocolHandler = configureWireProtocolHandler(isMaster);

      // log the connection event if requested
      if (server.s.logger.isInfo()) ***REMOVED***
        server.s.logger.info(
          `server $***REMOVED***server.name***REMOVED*** connected with ismaster [$***REMOVED***JSON.stringify(isMaster)***REMOVED***]`
        );
      ***REMOVED***

      // emit an event indicating that our description has changed
      server.emit(
        'descriptionReceived',
        new ServerDescription(server.description.address, isMaster)
      );

      // emit a connect event
      server.emit('connect', isMaster);
    ***REMOVED***);
  ***REMOVED***;
***REMOVED***

function closeEventHandler(server) ***REMOVED***
  return function() ***REMOVED***
    server.emit('close');
  ***REMOVED***;
***REMOVED***

module.exports = Server;
