'use strict';

// An enumeration of server types we know about
const ServerType = ***REMOVED***
  Standalone: 'Standalone',
  Mongos: 'Mongos',
  PossiblePrimary: 'PossiblePrimary',
  RSPrimary: 'RSPrimary',
  RSSecondary: 'RSSecondary',
  RSArbiter: 'RSArbiter',
  RSOther: 'RSOther',
  RSGhost: 'RSGhost',
  Unknown: 'Unknown'
***REMOVED***;

const WRITABLE_SERVER_TYPES = new Set([
  ServerType.RSPrimary,
  ServerType.Standalone,
  ServerType.Mongos
]);

const ISMASTER_FIELDS = [
  'minWireVersion',
  'maxWireVersion',
  'me',
  'hosts',
  'passives',
  'arbiters',
  'tags',
  'setName',
  'setVersion',
  'electionId',
  'primary',
  'logicalSessionTimeoutMinutes'
];

/**
 * The client's view of a single server, based on the most recent ismaster outcome.
 *
 * Internal type, not meant to be directly instantiated
 */
class ServerDescription ***REMOVED***
  /**
   * Create a ServerDescription
   * @param ***REMOVED***String***REMOVED*** address The address of the server
   * @param ***REMOVED***Object***REMOVED*** [ismaster] An optional ismaster response for this server
   * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
   * @param ***REMOVED***Number***REMOVED*** [options.roundTripTime] The round trip time to ping this server (in ms)
   */
  constructor(address, ismaster, options) ***REMOVED***
    options = options || ***REMOVED******REMOVED***;
    ismaster = Object.assign(
      ***REMOVED***
        minWireVersion: 0,
        maxWireVersion: 0,
        hosts: [],
        passives: [],
        arbiters: [],
        tags: []
      ***REMOVED***,
      ismaster
    );

    this.address = address;
    this.error = null;
    this.roundTripTime = options.roundTripTime || 0;
    this.lastUpdateTime = Date.now();
    this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;
    this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;
    this.type = parseServerType(ismaster);

    // direct mappings
    ISMASTER_FIELDS.forEach(field => ***REMOVED***
      if (typeof ismaster[field] !== 'undefined') this[field] = ismaster[field];
    ***REMOVED***);

    // normalize case for hosts
    this.hosts = this.hosts.map(host => host.toLowerCase());
    this.passives = this.passives.map(host => host.toLowerCase());
    this.arbiters = this.arbiters.map(host => host.toLowerCase());
  ***REMOVED***

  get allHosts() ***REMOVED***
    return this.hosts.concat(this.arbiters).concat(this.passives);
  ***REMOVED***

  /**
   * @return ***REMOVED***Boolean***REMOVED*** Is this server available for reads
   */
  get isReadable() ***REMOVED***
    return this.type === ServerType.RSSecondary || this.isWritable;
  ***REMOVED***

  /**
   * @return ***REMOVED***Boolean***REMOVED*** Is this server available for writes
   */
  get isWritable() ***REMOVED***
    return WRITABLE_SERVER_TYPES.has(this.type);
  ***REMOVED***
***REMOVED***

/**
 * Parses an `ismaster` message and determines the server type
 *
 * @param ***REMOVED***Object***REMOVED*** ismaster The `ismaster` message to parse
 * @return ***REMOVED***ServerType***REMOVED***
 */
function parseServerType(ismaster) ***REMOVED***
  if (!ismaster || !ismaster.ok) ***REMOVED***
    return ServerType.Unknown;
  ***REMOVED***

  if (ismaster.isreplicaset) ***REMOVED***
    return ServerType.RSGhost;
  ***REMOVED***

  if (ismaster.msg && ismaster.msg === 'isdbgrid') ***REMOVED***
    return ServerType.Mongos;
  ***REMOVED***

  if (ismaster.setName) ***REMOVED***
    if (ismaster.hidden) ***REMOVED***
      return ServerType.RSOther;
    ***REMOVED*** else if (ismaster.ismaster) ***REMOVED***
      return ServerType.RSPrimary;
    ***REMOVED*** else if (ismaster.secondary) ***REMOVED***
      return ServerType.RSSecondary;
    ***REMOVED*** else if (ismaster.arbiterOnly) ***REMOVED***
      return ServerType.RSArbiter;
    ***REMOVED*** else ***REMOVED***
      return ServerType.RSOther;
    ***REMOVED***
  ***REMOVED***

  return ServerType.Standalone;
***REMOVED***

module.exports = ***REMOVED***
  ServerDescription,
  ServerType
***REMOVED***;
