'use strict';

const inherits = require('util').inherits,
  f = require('util').format,
  EventEmitter = require('events').EventEmitter,
  BasicCursor = require('../cursor'),
  Logger = require('../connection/logger'),
  retrieveBSON = require('../connection/utils').retrieveBSON,
  MongoError = require('../error').MongoError,
  errors = require('../error'),
  Server = require('./server'),
  clone = require('./shared').clone,
  diff = require('./shared').diff,
  cloneOptions = require('./shared').cloneOptions,
  createClientInfo = require('./shared').createClientInfo,
  SessionMixins = require('./shared').SessionMixins,
  isRetryableWritesSupported = require('./shared').isRetryableWritesSupported,
  getNextTransactionNumber = require('./shared').getNextTransactionNumber,
  relayEvents = require('./shared').relayEvents;

const BSON = retrieveBSON();

/**
 * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is
 * used to construct connections.
 *
 * @example
 * var Mongos = require('mongodb-core').Mongos
 *   , ReadPreference = require('mongodb-core').ReadPreference
 *   , assert = require('assert');
 *
 * var server = new Mongos([***REMOVED***host: 'localhost', port: 30000***REMOVED***]);
 * // Wait for the connection event
 * server.on('connect', function(server) ***REMOVED***
 *   server.destroy();
 * ***REMOVED***);
 *
 * // Start connecting
 * server.connect();
 */

var MongoCR = require('../auth/mongocr'),
  X509 = require('../auth/x509'),
  Plain = require('../auth/plain'),
  GSSAPI = require('../auth/gssapi'),
  SSPI = require('../auth/sspi'),
  ScramSHA1 = require('../auth/scram');

//
// States
var DISCONNECTED = 'disconnected';
var CONNECTING = 'connecting';
var CONNECTED = 'connected';
var UNREFERENCED = 'unreferenced';
var DESTROYED = 'destroyed';

function stateTransition(self, newState) ***REMOVED***
  var legalTransitions = ***REMOVED***
    disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
    connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
    connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
    unreferenced: [UNREFERENCED, DESTROYED],
    destroyed: [DESTROYED]
  ***REMOVED***;

  // Get current state
  var legalStates = legalTransitions[self.state];
  if (legalStates && legalStates.indexOf(newState) !== -1) ***REMOVED***
    self.state = newState;
  ***REMOVED*** else ***REMOVED***
    self.logger.error(
      f(
        'Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]',
        self.id,
        self.state,
        newState,
        legalStates
      )
    );
  ***REMOVED***
***REMOVED***

//
// ReplSet instance id
var id = 1;
var handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];

/**
 * Creates a new Mongos instance
 * @class
 * @param ***REMOVED***array***REMOVED*** seedlist A list of seeds for the replicaset
 * @param ***REMOVED***number***REMOVED*** [options.haInterval=5000] The High availability period for replicaset inquiry
 * @param ***REMOVED***Cursor***REMOVED*** [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
 * @param ***REMOVED***number***REMOVED*** [options.size=5] Server connection pool size
 * @param ***REMOVED***boolean***REMOVED*** [options.keepAlive=true] TCP Connection keep alive enabled
 * @param ***REMOVED***number***REMOVED*** [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
 * @param ***REMOVED***number***REMOVED*** [options.localThresholdMS=15] Cutoff latency point in MS for MongoS proxy selection
 * @param ***REMOVED***boolean***REMOVED*** [options.noDelay=true] TCP Connection no delay
 * @param ***REMOVED***number***REMOVED*** [options.connectionTimeout=1000] TCP Connection timeout setting
 * @param ***REMOVED***number***REMOVED*** [options.socketTimeout=0] TCP Socket timeout setting
 * @param ***REMOVED***boolean***REMOVED*** [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
 * @param ***REMOVED***boolean***REMOVED*** [options.ssl=false] Use SSL for connection
 * @param ***REMOVED***boolean|function***REMOVED*** [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
 * @param ***REMOVED***Buffer***REMOVED*** [options.ca] SSL Certificate store binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.crl] SSL Certificate revocation store binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.cert] SSL Certificate binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.key] SSL Key file binary buffer
 * @param ***REMOVED***string***REMOVED*** [options.passphrase] SSL Certificate pass phrase
 * @param ***REMOVED***string***REMOVED*** [options.servername=null] String containing the server name requested via TLS SNI.
 * @param ***REMOVED***boolean***REMOVED*** [options.rejectUnauthorized=true] Reject unauthorized server certificates
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
 * @param ***REMOVED***boolean***REMOVED*** [options.monitorCommands=false] Enable command monitoring for this topology
 * @return ***REMOVED***Mongos***REMOVED*** A cursor instance
 * @fires Mongos#connect
 * @fires Mongos#reconnect
 * @fires Mongos#joined
 * @fires Mongos#left
 * @fires Mongos#failed
 * @fires Mongos#fullsetup
 * @fires Mongos#all
 * @fires Mongos#serverHeartbeatStarted
 * @fires Mongos#serverHeartbeatSucceeded
 * @fires Mongos#serverHeartbeatFailed
 * @fires Mongos#topologyOpening
 * @fires Mongos#topologyClosed
 * @fires Mongos#topologyDescriptionChanged
 * @property ***REMOVED***string***REMOVED*** type the topology type.
 * @property ***REMOVED***string***REMOVED*** parserType the parser type used (c++ or js).
 */
var Mongos = function(seedlist, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  // Get replSet Id
  this.id = id++;

  // Internal state
  this.s = ***REMOVED***
    options: Object.assign(***REMOVED******REMOVED***, options),
    // BSON instance
    bson:
      options.bson ||
      new BSON([
        BSON.Binary,
        BSON.Code,
        BSON.DBRef,
        BSON.Decimal128,
        BSON.Double,
        BSON.Int32,
        BSON.Long,
        BSON.Map,
        BSON.MaxKey,
        BSON.MinKey,
        BSON.ObjectId,
        BSON.BSONRegExp,
        BSON.Symbol,
        BSON.Timestamp
      ]),
    // Factory overrides
    Cursor: options.cursorFactory || BasicCursor,
    // Logger instance
    logger: Logger('Mongos', options),
    // Seedlist
    seedlist: seedlist,
    // Ha interval
    haInterval: options.haInterval ? options.haInterval : 10000,
    // Disconnect handler
    disconnectHandler: options.disconnectHandler,
    // Server selection index
    index: 0,
    // Connect function options passed in
    connectOptions: ***REMOVED******REMOVED***,
    // Are we running in debug mode
    debug: typeof options.debug === 'boolean' ? options.debug : false,
    // localThresholdMS
    localThresholdMS: options.localThresholdMS || 15,
    // Client info
    clientInfo: createClientInfo(options),
    // Authentication context
    authenticationContexts: []
  ***REMOVED***;

  // Set the client info
  this.s.options.clientInfo = createClientInfo(options);

  // Log info warning if the socketTimeout < haInterval as it will cause
  // a lot of recycled connections to happen.
  if (
    this.s.logger.isWarn() &&
    this.s.options.socketTimeout !== 0 &&
    this.s.options.socketTimeout < this.s.haInterval
  ) ***REMOVED***
    this.s.logger.warn(
      f(
        'warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts',
        this.s.options.socketTimeout,
        this.s.haInterval
      )
    );
  ***REMOVED***

  // All the authProviders
  this.authProviders = options.authProviders || ***REMOVED***
    mongocr: new MongoCR(this.s.bson),
    x509: new X509(this.s.bson),
    plain: new Plain(this.s.bson),
    gssapi: new GSSAPI(this.s.bson),
    sspi: new SSPI(this.s.bson),
    'scram-sha-1': new ScramSHA1(this.s.bson)
  ***REMOVED***;

  // Disconnected state
  this.state = DISCONNECTED;

  // Current proxies we are connecting to
  this.connectingProxies = [];
  // Currently connected proxies
  this.connectedProxies = [];
  // Disconnected proxies
  this.disconnectedProxies = [];
  // Are we authenticating
  this.authenticating = false;
  // Index of proxy to run operations against
  this.index = 0;
  // High availability timeout id
  this.haTimeoutId = null;
  // Last ismaster
  this.ismaster = null;

  // Description of the Replicaset
  this.topologyDescription = ***REMOVED***
    topologyType: 'Unknown',
    servers: []
  ***REMOVED***;

  // Highest clusterTime seen in responses from the current deployment
  this.clusterTime = null;

  // Add event listener
  EventEmitter.call(this);
***REMOVED***;

inherits(Mongos, EventEmitter);
Object.assign(Mongos.prototype, SessionMixins);

Object.defineProperty(Mongos.prototype, 'type', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return 'mongos';
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Mongos.prototype, 'parserType', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return BSON.native ? 'c++' : 'js';
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Mongos.prototype, 'logicalSessionTimeoutMinutes', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    if (!this.ismaster) return null;
    return this.ismaster.logicalSessionTimeoutMinutes || null;
  ***REMOVED***
***REMOVED***);

/**
 * Emit event if it exists
 * @method
 */
function emitSDAMEvent(self, event, description) ***REMOVED***
  if (self.listeners(event).length > 0) ***REMOVED***
    self.emit(event, description);
  ***REMOVED***
***REMOVED***

/**
 * Initiate server connect
 * @method
 * @param ***REMOVED***array***REMOVED*** [options.auth=null] Array of auth options to apply on connect
 */
Mongos.prototype.connect = function(options) ***REMOVED***
  var self = this;
  // Add any connect level options to the internal state
  this.s.connectOptions = options || ***REMOVED******REMOVED***;
  // Set connecting state
  stateTransition(this, CONNECTING);
  // Create server instances
  var servers = this.s.seedlist.map(function(x) ***REMOVED***
    return new Server(
      Object.assign(***REMOVED******REMOVED***, self.s.options, x, ***REMOVED***
        authProviders: self.authProviders,
        reconnect: false,
        monitoring: false,
        parent: self,
        clientInfo: clone(self.s.clientInfo)
      ***REMOVED***)
    );
  ***REMOVED***);

  const serverDescriptionChangedCallback = event => ***REMOVED***
    self.emit('serverDescriptionChanged', event);
  ***REMOVED***;

  servers.forEach(function(server) ***REMOVED***
    server.on('serverDescriptionChanged', serverDescriptionChangedCallback);
    server.on('destroy', () =>
      server.removeListener('serverDescriptionChanged', serverDescriptionChangedCallback)
    );
  ***REMOVED***);

  // Emit the topology opening event
  emitSDAMEvent(this, 'topologyOpening', ***REMOVED*** topologyId: this.id ***REMOVED***);

  // Start all server connections
  connectProxies(self, servers);
***REMOVED***;

function handleEvent(self) ***REMOVED***
  return function() ***REMOVED***
    if (self.state === DESTROYED) return;
    // Move to list of disconnectedProxies
    moveServerFrom(self.connectedProxies, self.disconnectedProxies, this);
    // Emit the initial topology
    emitTopologyDescriptionChanged(self);
    // Emit the left signal
    self.emit('left', 'mongos', this);
    // Emit the sdam event
    self.emit('serverClosed', ***REMOVED***
      topologyId: self.id,
      address: this.name
    ***REMOVED***);
  ***REMOVED***;
***REMOVED***

function handleInitialConnectEvent(self, event) ***REMOVED***
  return function() ***REMOVED***
    var _this = this;

    // Destroy the instance
    if (self.state === DESTROYED) ***REMOVED***
      // Emit the initial topology
      emitTopologyDescriptionChanged(self);
      // Move from connectingProxies
      moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
      return this.destroy();
    ***REMOVED***

    // Check the type of server
    if (event === 'connect') ***REMOVED***
      // Do we have authentication contexts that need to be applied
      applyAuthenticationContexts(self, _this, function() ***REMOVED***
        // Get last known ismaster
        self.ismaster = _this.lastIsMaster();

        // Is this not a proxy, remove t
        if (self.ismaster.msg === 'isdbgrid') ***REMOVED***
          // Add to the connectd list
          for (var i = 0; i < self.connectedProxies.length; i++) ***REMOVED***
            if (self.connectedProxies[i].name === _this.name) ***REMOVED***
              // Move from connectingProxies
              moveServerFrom(self.connectingProxies, self.disconnectedProxies, _this);
              // Emit the initial topology
              emitTopologyDescriptionChanged(self);
              _this.destroy();
              return self.emit('failed', _this);
            ***REMOVED***
          ***REMOVED***

          // Remove the handlers
          for (i = 0; i < handlers.length; i++) ***REMOVED***
            _this.removeAllListeners(handlers[i]);
          ***REMOVED***

          // Add stable state handlers
          _this.on('error', handleEvent(self, 'error'));
          _this.on('close', handleEvent(self, 'close'));
          _this.on('timeout', handleEvent(self, 'timeout'));
          _this.on('parseError', handleEvent(self, 'parseError'));

          // Move from connecting proxies connected
          moveServerFrom(self.connectingProxies, self.connectedProxies, _this);
          // Emit the joined event
          self.emit('joined', 'mongos', _this);
        ***REMOVED*** else ***REMOVED***
          // Print warning if we did not find a mongos proxy
          if (self.s.logger.isWarn()) ***REMOVED***
            var message = 'expected mongos proxy, but found replicaset member mongod for server %s';
            // We have a standalone server
            if (!self.ismaster.hosts) ***REMOVED***
              message = 'expected mongos proxy, but found standalone mongod for server %s';
            ***REMOVED***

            self.s.logger.warn(f(message, _this.name));
          ***REMOVED***

          // This is not a mongos proxy, remove it completely
          removeProxyFrom(self.connectingProxies, _this);
          // Emit the left event
          self.emit('left', 'server', _this);
          // Emit failed event
          self.emit('failed', _this);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
      // Emit the left event
      self.emit('left', 'mongos', this);
      // Emit failed event
      self.emit('failed', this);
    ***REMOVED***

    // Emit the initial topology
    emitTopologyDescriptionChanged(self);

    // Trigger topologyMonitor
    if (self.connectingProxies.length === 0) ***REMOVED***
      // Emit connected if we are connected
      if (self.connectedProxies.length > 0 && self.state === CONNECTING) ***REMOVED***
        // Set the state to connected
        stateTransition(self, CONNECTED);
        // Emit the connect event
        self.emit('connect', self);
        self.emit('fullsetup', self);
        self.emit('all', self);
      ***REMOVED*** else if (self.disconnectedProxies.length === 0) ***REMOVED***
        // Print warning if we did not find a mongos proxy
        if (self.s.logger.isWarn()) ***REMOVED***
          self.s.logger.warn(
            f('no mongos proxies found in seed list, did you mean to connect to a replicaset')
          );
        ***REMOVED***

        // Emit the error that no proxies were found
        return self.emit('error', new MongoError('no mongos proxies found in seed list'));
      ***REMOVED***

      // Topology monitor
      topologyMonitor(self, ***REMOVED*** firstConnect: true ***REMOVED***);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

function connectProxies(self, servers) ***REMOVED***
  // Update connectingProxies
  self.connectingProxies = self.connectingProxies.concat(servers);

  // Index used to interleaf the server connects, avoiding
  // runtime issues on io constrained vm's
  var timeoutInterval = 0;

  function connect(server, timeoutInterval) ***REMOVED***
    setTimeout(function() ***REMOVED***
      // Emit opening server event
      self.emit('serverOpening', ***REMOVED***
        topologyId: self.id,
        address: server.name
      ***REMOVED***);

      // Emit the initial topology
      emitTopologyDescriptionChanged(self);

      // Add event handlers
      server.once('close', handleInitialConnectEvent(self, 'close'));
      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));
      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));
      server.once('error', handleInitialConnectEvent(self, 'error'));
      server.once('connect', handleInitialConnectEvent(self, 'connect'));

      // Command Monitoring events
      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);

      // Start connection
      server.connect(self.s.connectOptions);
    ***REMOVED***, timeoutInterval);
  ***REMOVED***
  // Start all the servers
  while (servers.length > 0) ***REMOVED***
    connect(servers.shift(), timeoutInterval++);
  ***REMOVED***
***REMOVED***

function pickProxy(self) ***REMOVED***
  // Get the currently connected Proxies
  var connectedProxies = self.connectedProxies.slice(0);

  // Set lower bound
  var lowerBoundLatency = Number.MAX_VALUE;

  // Determine the lower bound for the Proxies
  for (var i = 0; i < connectedProxies.length; i++) ***REMOVED***
    if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) ***REMOVED***
      lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
    ***REMOVED***
  ***REMOVED***

  // Filter out the possible servers
  connectedProxies = connectedProxies.filter(function(server) ***REMOVED***
    if (
      server.lastIsMasterMS <= lowerBoundLatency + self.s.localThresholdMS &&
      server.isConnected()
    ) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***);

  // We have no connectedProxies pick first of the connected ones
  if (connectedProxies.length === 0) ***REMOVED***
    return self.connectedProxies[0];
  ***REMOVED***

  // Get proxy
  var proxy = connectedProxies[self.index % connectedProxies.length];
  // Update the index
  self.index = (self.index + 1) % connectedProxies.length;
  // Return the proxy
  return proxy;
***REMOVED***

function moveServerFrom(from, to, proxy) ***REMOVED***
  for (var i = 0; i < from.length; i++) ***REMOVED***
    if (from[i].name === proxy.name) ***REMOVED***
      from.splice(i, 1);
    ***REMOVED***
  ***REMOVED***

  for (i = 0; i < to.length; i++) ***REMOVED***
    if (to[i].name === proxy.name) ***REMOVED***
      to.splice(i, 1);
    ***REMOVED***
  ***REMOVED***

  to.push(proxy);
***REMOVED***

function removeProxyFrom(from, proxy) ***REMOVED***
  for (var i = 0; i < from.length; i++) ***REMOVED***
    if (from[i].name === proxy.name) ***REMOVED***
      from.splice(i, 1);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function reconnectProxies(self, proxies, callback) ***REMOVED***
  // Count lefts
  var count = proxies.length;

  // Handle events
  var _handleEvent = function(self, event) ***REMOVED***
    return function() ***REMOVED***
      var _self = this;
      count = count - 1;

      // Destroyed
      if (self.state === DESTROYED || self.state === UNREFERENCED) ***REMOVED***
        moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
        // Return destroy
        return this.destroy();
      ***REMOVED***

      if (event === 'connect' && !self.authenticating) ***REMOVED***
        // Do we have authentication contexts that need to be applied
        applyAuthenticationContexts(self, _self, function() ***REMOVED***
          // Destroyed
          if (self.state === DESTROYED || self.state === UNREFERENCED) ***REMOVED***
            moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
            return _self.destroy();
          ***REMOVED***

          // Remove the handlers
          for (var i = 0; i < handlers.length; i++) ***REMOVED***
            _self.removeAllListeners(handlers[i]);
          ***REMOVED***

          // Add stable state handlers
          _self.on('error', handleEvent(self, 'error'));
          _self.on('close', handleEvent(self, 'close'));
          _self.on('timeout', handleEvent(self, 'timeout'));
          _self.on('parseError', handleEvent(self, 'parseError'));

          // Move to the connected servers
          moveServerFrom(self.disconnectedProxies, self.connectedProxies, _self);
          // Emit topology Change
          emitTopologyDescriptionChanged(self);
          // Emit joined event
          self.emit('joined', 'mongos', _self);
        ***REMOVED***);
      ***REMOVED*** else if (event === 'connect' && self.authenticating) ***REMOVED***
        // Move from connectingProxies
        moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
        this.destroy();
      ***REMOVED***

      // Are we done finish up callback
      if (count === 0) ***REMOVED***
        callback();
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***;

  // No new servers
  if (count === 0) ***REMOVED***
    return callback();
  ***REMOVED***

  // Execute method
  function execute(_server, i) ***REMOVED***
    setTimeout(function() ***REMOVED***
      // Destroyed
      if (self.state === DESTROYED || self.state === UNREFERENCED) ***REMOVED***
        return;
      ***REMOVED***

      // Create a new server instance
      var server = new Server(
        Object.assign(***REMOVED******REMOVED***, self.s.options, ***REMOVED***
          host: _server.name.split(':')[0],
          port: parseInt(_server.name.split(':')[1], 10),
          authProviders: self.authProviders,
          reconnect: false,
          monitoring: false,
          parent: self,
          clientInfo: clone(self.s.clientInfo)
        ***REMOVED***)
      );

      // Relay the server description change
      server.on('serverDescriptionChanged', function(event) ***REMOVED***
        self.emit('serverDescriptionChanged', event);
      ***REMOVED***);

      // Emit opening server event
      self.emit('serverOpening', ***REMOVED***
        topologyId: server.s.topologyId !== -1 ? server.s.topologyId : self.id,
        address: server.name
      ***REMOVED***);

      // Add temp handlers
      server.once('connect', _handleEvent(self, 'connect'));
      server.once('close', _handleEvent(self, 'close'));
      server.once('timeout', _handleEvent(self, 'timeout'));
      server.once('error', _handleEvent(self, 'error'));
      server.once('parseError', _handleEvent(self, 'parseError'));

      // Command Monitoring events
      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);

      // Connect to proxy
      server.connect(self.s.connectOptions);
    ***REMOVED***, i);
  ***REMOVED***

  // Create new instances
  for (var i = 0; i < proxies.length; i++) ***REMOVED***
    execute(proxies[i], i);
  ***REMOVED***
***REMOVED***

function applyAuthenticationContexts(self, server, callback) ***REMOVED***
  if (self.s.authenticationContexts.length === 0) ***REMOVED***
    return callback();
  ***REMOVED***

  // Copy contexts to ensure no modificiation in the middle of
  // auth process.
  var authContexts = self.s.authenticationContexts.slice(0);

  // Apply one of the contexts
  function applyAuth(authContexts, server, callback) ***REMOVED***
    if (authContexts.length === 0) return callback();
    // Get the first auth context
    var authContext = authContexts.shift();
    // Copy the params
    var customAuthContext = authContext.slice(0);
    // Push our callback handler
    customAuthContext.push(function(/* err */) ***REMOVED***
      applyAuth(authContexts, server, callback);
    ***REMOVED***);

    // Attempt authentication
    server.auth.apply(server, customAuthContext);
  ***REMOVED***

  // Apply all auth contexts
  applyAuth(authContexts, server, callback);
***REMOVED***

function topologyMonitor(self, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  // Set momitoring timeout
  self.haTimeoutId = setTimeout(function() ***REMOVED***
    if (self.state === DESTROYED || self.state === UNREFERENCED) return;
    // If we have a primary and a disconnect handler, execute
    // buffered operations
    if (self.isConnected() && self.s.disconnectHandler) ***REMOVED***
      self.s.disconnectHandler.execute();
    ***REMOVED***

    // Get the connectingServers
    var proxies = self.connectedProxies.slice(0);
    // Get the count
    var count = proxies.length;

    // If the count is zero schedule a new fast
    function pingServer(_self, _server, cb) ***REMOVED***
      // Measure running time
      var start = new Date().getTime();

      // Emit the server heartbeat start
      emitSDAMEvent(self, 'serverHeartbeatStarted', ***REMOVED*** connectionId: _server.name ***REMOVED***);

      // Execute ismaster
      _server.command(
        'admin.$cmd',
        ***REMOVED***
          ismaster: true
        ***REMOVED***,
        ***REMOVED***
          monitoring: true,
          socketTimeout: self.s.options.connectionTimeout || 2000
        ***REMOVED***,
        function(err, r) ***REMOVED***
          if (self.state === DESTROYED || self.state === UNREFERENCED) ***REMOVED***
            // Move from connectingProxies
            moveServerFrom(self.connectedProxies, self.disconnectedProxies, _server);
            _server.destroy();
            return cb(err, r);
          ***REMOVED***

          // Calculate latency
          var latencyMS = new Date().getTime() - start;

          // We had an error, remove it from the state
          if (err) ***REMOVED***
            // Emit the server heartbeat failure
            emitSDAMEvent(self, 'serverHeartbeatFailed', ***REMOVED***
              durationMS: latencyMS,
              failure: err,
              connectionId: _server.name
            ***REMOVED***);
            // Move from connected proxies to disconnected proxies
            moveServerFrom(self.connectedProxies, self.disconnectedProxies, _server);
          ***REMOVED*** else ***REMOVED***
            // Update the server ismaster
            _server.ismaster = r.result;
            _server.lastIsMasterMS = latencyMS;

            // Server heart beat event
            emitSDAMEvent(self, 'serverHeartbeatSucceeded', ***REMOVED***
              durationMS: latencyMS,
              reply: r.result,
              connectionId: _server.name
            ***REMOVED***);
          ***REMOVED***

          cb(err, r);
        ***REMOVED***
      );
    ***REMOVED***

    // No proxies initiate monitor again
    if (proxies.length === 0) ***REMOVED***
      // Emit close event if any listeners registered
      if (self.listeners('close').length > 0 && self.state === CONNECTING) ***REMOVED***
        self.emit('error', new MongoError('no mongos proxy available'));
      ***REMOVED*** else ***REMOVED***
        self.emit('close', self);
      ***REMOVED***

      // Attempt to connect to any unknown servers
      return reconnectProxies(self, self.disconnectedProxies, function() ***REMOVED***
        if (self.state === DESTROYED || self.state === UNREFERENCED) return;

        // Are we connected ? emit connect event
        if (self.state === CONNECTING && options.firstConnect) ***REMOVED***
          self.emit('connect', self);
          self.emit('fullsetup', self);
          self.emit('all', self);
        ***REMOVED*** else if (self.isConnected()) ***REMOVED***
          self.emit('reconnect', self);
        ***REMOVED*** else if (!self.isConnected() && self.listeners('close').length > 0) ***REMOVED***
          self.emit('close', self);
        ***REMOVED***

        // Perform topology monitor
        topologyMonitor(self);
      ***REMOVED***);
    ***REMOVED***

    // Ping all servers
    for (var i = 0; i < proxies.length; i++) ***REMOVED***
      pingServer(self, proxies[i], function() ***REMOVED***
        count = count - 1;

        if (count === 0) ***REMOVED***
          if (self.state === DESTROYED || self.state === UNREFERENCED) return;

          // Attempt to connect to any unknown servers
          reconnectProxies(self, self.disconnectedProxies, function() ***REMOVED***
            if (self.state === DESTROYED || self.state === UNREFERENCED) return;
            // Perform topology monitor
            topologyMonitor(self);
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***, self.s.haInterval);
***REMOVED***

/**
 * Returns the last known ismaster document for this server
 * @method
 * @return ***REMOVED***object***REMOVED***
 */
Mongos.prototype.lastIsMaster = function() ***REMOVED***
  return this.ismaster;
***REMOVED***;

/**
 * Unref all connections belong to this server
 * @method
 */
Mongos.prototype.unref = function() ***REMOVED***
  // Transition state
  stateTransition(this, UNREFERENCED);
  // Get all proxies
  var proxies = this.connectedProxies.concat(this.connectingProxies);
  proxies.forEach(function(x) ***REMOVED***
    x.unref();
  ***REMOVED***);

  clearTimeout(this.haTimeoutId);
***REMOVED***;

/**
 * Destroy the server connection
 * @param ***REMOVED***boolean***REMOVED*** [options.force=false] Force destroy the pool
 * @method
 */
Mongos.prototype.destroy = function(options) ***REMOVED***
  var self = this;
  // Transition state
  stateTransition(this, DESTROYED);
  // Get all proxies
  var proxies = this.connectedProxies.concat(this.connectingProxies);
  // Clear out any monitoring process
  if (this.haTimeoutId) clearTimeout(this.haTimeoutId);
  // Clear out authentication contexts
  this.s.authenticationContexts = [];

  // Destroy all connecting servers
  proxies.forEach(function(x) ***REMOVED***
    // Emit the sdam event
    self.emit('serverClosed', ***REMOVED***
      topologyId: self.id,
      address: x.name
    ***REMOVED***);

    // Destroy the server
    x.destroy(options);
    // Move to list of disconnectedProxies
    moveServerFrom(self.connectedProxies, self.disconnectedProxies, x);
  ***REMOVED***);
  // Emit the final topology change
  emitTopologyDescriptionChanged(self);
  // Emit toplogy closing event
  emitSDAMEvent(this, 'topologyClosed', ***REMOVED*** topologyId: this.id ***REMOVED***);
***REMOVED***;

/**
 * Figure out if the server is connected
 * @method
 * @return ***REMOVED***boolean***REMOVED***
 */
Mongos.prototype.isConnected = function() ***REMOVED***
  return this.connectedProxies.length > 0;
***REMOVED***;

/**
 * Figure out if the server instance was destroyed by calling destroy
 * @method
 * @return ***REMOVED***boolean***REMOVED***
 */
Mongos.prototype.isDestroyed = function() ***REMOVED***
  return this.state === DESTROYED;
***REMOVED***;

//
// Operations
//

// Execute write operation
var executeWriteOperation = function(self, op, ns, ops, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Pick a server
  let server = pickProxy(self);
  // No server found error out
  if (!server) return callback(new MongoError('no mongos proxy available'));

  if (!options.retryWrites || !options.session || !isRetryableWritesSupported(self)) ***REMOVED***
    // Execute the command
    return server[op](ns, ops, options, callback);
  ***REMOVED***

  // increment and assign txnNumber
  options.txnNumber = getNextTransactionNumber(options.session);

  server[op](ns, ops, options, (err, result) => ***REMOVED***
    if (!err) return callback(null, result);
    if (!(err instanceof errors.MongoNetworkError) && !err.message.match(/not master/)) ***REMOVED***
      return callback(err);
    ***REMOVED***

    // Pick another server
    server = pickProxy(self);

    // No server found error out with original error
    if (!server || !isRetryableWritesSupported(server)) ***REMOVED***
      return callback(err);
    ***REMOVED***

    // rerun the operation
    server[op](ns, ops, options, callback);
  ***REMOVED***);
***REMOVED***;

/**
 * Insert one or more documents
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***array***REMOVED*** ops An array of documents to insert
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
 * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
 * @param ***REMOVED***boolean***REMOVED*** [options.retryWrites] Enable retryable writes for this operation
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Mongos.prototype.insert = function(ns, ops, options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    (callback = options), (options = ***REMOVED******REMOVED***), (options = options || ***REMOVED******REMOVED***);
  ***REMOVED***

  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));

  // Not connected but we have a disconnecthandler
  if (!this.isConnected() && this.s.disconnectHandler != null) ***REMOVED***
    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);
  ***REMOVED***

  // No mongos proxy available
  if (!this.isConnected()) ***REMOVED***
    return callback(new MongoError('no mongos proxy available'));
  ***REMOVED***

  // Execute write operation
  executeWriteOperation(this, 'insert', ns, ops, options, callback);
***REMOVED***;

/**
 * Perform one or more update operations
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***array***REMOVED*** ops An array of updates
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
 * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
 * @param ***REMOVED***boolean***REMOVED*** [options.retryWrites] Enable retryable writes for this operation
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Mongos.prototype.update = function(ns, ops, options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    (callback = options), (options = ***REMOVED******REMOVED***), (options = options || ***REMOVED******REMOVED***);
  ***REMOVED***

  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));

  // Not connected but we have a disconnecthandler
  if (!this.isConnected() && this.s.disconnectHandler != null) ***REMOVED***
    return this.s.disconnectHandler.add('update', ns, ops, options, callback);
  ***REMOVED***

  // No mongos proxy available
  if (!this.isConnected()) ***REMOVED***
    return callback(new MongoError('no mongos proxy available'));
  ***REMOVED***

  // Execute write operation
  executeWriteOperation(this, 'update', ns, ops, options, callback);
***REMOVED***;

/**
 * Perform one or more remove operations
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***array***REMOVED*** ops An array of removes
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
 * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
 * @param ***REMOVED***boolean***REMOVED*** [options.retryWrites] Enable retryable writes for this operation
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Mongos.prototype.remove = function(ns, ops, options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    (callback = options), (options = ***REMOVED******REMOVED***), (options = options || ***REMOVED******REMOVED***);
  ***REMOVED***

  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));

  // Not connected but we have a disconnecthandler
  if (!this.isConnected() && this.s.disconnectHandler != null) ***REMOVED***
    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);
  ***REMOVED***

  // No mongos proxy available
  if (!this.isConnected()) ***REMOVED***
    return callback(new MongoError('no mongos proxy available'));
  ***REMOVED***

  // Execute write operation
  executeWriteOperation(this, 'remove', ns, ops, options, callback);
***REMOVED***;

/**
 * Execute a command
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***object***REMOVED*** cmd The command hash
 * @param ***REMOVED***ReadPreference***REMOVED*** [options.readPreference] Specify read preference if command supports it
 * @param ***REMOVED***Connection***REMOVED*** [options.connection] Specify connection object to execute command against
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Mongos.prototype.command = function(ns, cmd, options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    (callback = options), (options = ***REMOVED******REMOVED***), (options = options || ***REMOVED******REMOVED***);
  ***REMOVED***

  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));
  var self = this;

  // Pick a proxy
  var server = pickProxy(self);

  // Topology is not connected, save the call in the provided store to be
  // Executed at some point when the handler deems it's reconnected
  if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) ***REMOVED***
    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
  ***REMOVED***

  // No server returned we had an error
  if (server == null) ***REMOVED***
    return callback(new MongoError('no mongos proxy available'));
  ***REMOVED***

  // Cloned options
  var clonedOptions = cloneOptions(options);
  clonedOptions.topology = self;

  // Execute the command
  server.command(ns, cmd, clonedOptions, callback);
***REMOVED***;

/**
 * Get a new cursor
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***object|Long***REMOVED*** cmd Can be either a command returning a cursor or a cursorId
 * @param ***REMOVED***object***REMOVED*** [options] Options for the cursor
 * @param ***REMOVED***object***REMOVED*** [options.batchSize=0] Batchsize for the operation
 * @param ***REMOVED***array***REMOVED*** [options.documents=[]] Initial documents list for cursor
 * @param ***REMOVED***ReadPreference***REMOVED*** [options.readPreference] Specify read preference if command supports it
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
 * @param ***REMOVED***object***REMOVED*** [options.topology] The internal topology of the created cursor
 * @returns ***REMOVED***Cursor***REMOVED***
 */
Mongos.prototype.cursor = function(ns, cmd, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  const topology = options.topology || this;

  // Set up final cursor type
  var FinalCursor = options.cursorFactory || this.s.Cursor;

  // Return the cursor
  return new FinalCursor(this.s.bson, ns, cmd, options, topology, this.s.options);
***REMOVED***;

/**
 * Authenticate using a specified mechanism
 * @method
 * @param ***REMOVED***string***REMOVED*** mechanism The Auth mechanism we are invoking
 * @param ***REMOVED***string***REMOVED*** db The db we are invoking the mechanism against
 * @param ***REMOVED***...object***REMOVED*** param Parameters for the specific mechanism
 * @param ***REMOVED***authResultCallback***REMOVED*** callback A callback function
 */
Mongos.prototype.auth = function(mechanism, db) ***REMOVED***
  var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);
  var self = this;
  var args = Array.prototype.slice.call(arguments, 2);
  var callback = args.pop();
  var currentContextIndex = 0;

  // If we don't have the mechanism fail
  if (this.authProviders[mechanism] == null && mechanism !== 'default') ***REMOVED***
    return callback(new MongoError(f('auth provider %s does not exist', mechanism)));
  ***REMOVED***

  // Are we already authenticating, throw
  if (this.authenticating) ***REMOVED***
    return callback(new MongoError('authentication or logout allready in process'));
  ***REMOVED***

  // Topology is not connected, save the call in the provided store to be
  // Executed at some point when the handler deems it's reconnected
  if (!self.isConnected() && self.s.disconnectHandler != null) ***REMOVED***
    return self.s.disconnectHandler.add('auth', db, allArgs, ***REMOVED******REMOVED***, callback);
  ***REMOVED***

  // Set to authenticating
  this.authenticating = true;
  // All errors
  var errors = [];

  // Get all the servers
  var servers = this.connectedProxies.slice(0);
  // No servers return
  if (servers.length === 0) ***REMOVED***
    this.authenticating = false;
    callback(null, true);
  ***REMOVED***

  // Authenticate
  function auth(server) ***REMOVED***
    // Arguments without a callback
    var argsWithoutCallback = [mechanism, db].concat(args.slice(0));
    // Create arguments
    var finalArguments = argsWithoutCallback.concat([
      function(err) ***REMOVED***
        count = count - 1;
        // Save all the errors
        if (err) errors.push(***REMOVED*** name: server.name, err: err ***REMOVED***);
        // We are done
        if (count === 0) ***REMOVED***
          // Auth is done
          self.authenticating = false;

          // Return the auth error
          if (errors.length) ***REMOVED***
            // Remove the entry from the stored authentication contexts
            self.s.authenticationContexts.splice(currentContextIndex, 0);
            // Return error
            return callback(
              new MongoError(***REMOVED***
                message: 'authentication fail',
                errors: errors
              ***REMOVED***),
              false
            );
          ***REMOVED***

          // Successfully authenticated session
          callback(null, self);
        ***REMOVED***
      ***REMOVED***
    ]);

    // Execute the auth only against non arbiter servers
    if (!server.lastIsMaster().arbiterOnly) ***REMOVED***
      server.auth.apply(server, finalArguments);
    ***REMOVED***
  ***REMOVED***

  // Save current context index
  currentContextIndex = this.s.authenticationContexts.length;
  // Store the auth context and return the last index
  this.s.authenticationContexts.push([mechanism, db].concat(args.slice(0)));

  // Get total count
  var count = servers.length;
  // Authenticate against all servers
  while (servers.length > 0) ***REMOVED***
    auth(servers.shift());
  ***REMOVED***
***REMOVED***;

/**
 * Logout from a database
 * @method
 * @param ***REMOVED***string***REMOVED*** db The db we are logging out from
 * @param ***REMOVED***authResultCallback***REMOVED*** callback A callback function
 */
Mongos.prototype.logout = function(dbName, callback) ***REMOVED***
  var self = this;
  // Are we authenticating or logging out, throw
  if (this.authenticating) ***REMOVED***
    throw new MongoError('authentication or logout allready in process');
  ***REMOVED***

  // Ensure no new members are processed while logging out
  this.authenticating = true;

  // Remove from all auth providers (avoid any reaplication of the auth details)
  var providers = Object.keys(this.authProviders);
  for (var i = 0; i < providers.length; i++) ***REMOVED***
    this.authProviders[providers[i]].logout(dbName);
  ***REMOVED***

  // Now logout all the servers
  var servers = this.connectedProxies.slice(0);
  var count = servers.length;
  if (count === 0) return callback();
  var errors = [];

  function logoutServer(_server, cb) ***REMOVED***
    _server.logout(dbName, function(err) ***REMOVED***
      if (err) errors.push(***REMOVED*** name: _server.name, err: err ***REMOVED***);
      cb();
    ***REMOVED***);
  ***REMOVED***

  // Execute logout on all server instances
  for (i = 0; i < servers.length; i++) ***REMOVED***
    logoutServer(servers[i], function() ***REMOVED***
      count = count - 1;

      if (count === 0) ***REMOVED***
        // Do not block new operations
        self.authenticating = false;
        // If we have one or more errors
        if (errors.length)
          return callback(
            new MongoError(***REMOVED***
              message: f('logout failed against db %s', dbName),
              errors: errors
            ***REMOVED***),
            false
          );

        // No errors
        callback();
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
***REMOVED***;

/**
 * Get server
 * @method
 * @return ***REMOVED***Server***REMOVED***
 */
Mongos.prototype.getServer = function() ***REMOVED***
  var server = pickProxy(this);
  if (this.s.debug) this.emit('pickedServer', null, server);
  return server;
***REMOVED***;

/**
 * Get a direct connection
 * @method
 * @return ***REMOVED***Connection***REMOVED***
 */
Mongos.prototype.getConnection = function() ***REMOVED***
  var server = this.getServer();
  if (server) return server.getConnection();
***REMOVED***;

/**
 * All raw connections
 * @method
 * @return ***REMOVED***Connection[]***REMOVED***
 */
Mongos.prototype.connections = function() ***REMOVED***
  var connections = [];

  for (var i = 0; i < this.connectedProxies.length; i++) ***REMOVED***
    connections = connections.concat(this.connectedProxies[i].connections());
  ***REMOVED***

  return connections;
***REMOVED***;

function emitTopologyDescriptionChanged(self) ***REMOVED***
  if (self.listeners('topologyDescriptionChanged').length > 0) ***REMOVED***
    var topology = 'Unknown';
    if (self.connectedProxies.length > 0) ***REMOVED***
      topology = 'Sharded';
    ***REMOVED***

    // Generate description
    var description = ***REMOVED***
      topologyType: topology,
      servers: []
    ***REMOVED***;

    // All proxies
    var proxies = self.disconnectedProxies.concat(self.connectingProxies);

    // Add all the disconnected proxies
    description.servers = description.servers.concat(
      proxies.map(function(x) ***REMOVED***
        var description = x.getDescription();
        description.type = 'Unknown';
        return description;
      ***REMOVED***)
    );

    // Add all the connected proxies
    description.servers = description.servers.concat(
      self.connectedProxies.map(function(x) ***REMOVED***
        var description = x.getDescription();
        description.type = 'Mongos';
        return description;
      ***REMOVED***)
    );

    // Get the diff
    var diffResult = diff(self.topologyDescription, description);

    // Create the result
    var result = ***REMOVED***
      topologyId: self.id,
      previousDescription: self.topologyDescription,
      newDescription: description,
      diff: diffResult
    ***REMOVED***;

    // Emit the topologyDescription change
    if (diffResult.servers.length > 0) ***REMOVED***
      self.emit('topologyDescriptionChanged', result);
    ***REMOVED***

    // Set the new description
    self.topologyDescription = description;
  ***REMOVED***
***REMOVED***

/**
 * A mongos connect event, used to verify that the connection is up and running
 *
 * @event Mongos#connect
 * @type ***REMOVED***Mongos***REMOVED***
 */

/**
 * A mongos reconnect event, used to verify that the mongos topology has reconnected
 *
 * @event Mongos#reconnect
 * @type ***REMOVED***Mongos***REMOVED***
 */

/**
 * A mongos fullsetup event, used to signal that all topology members have been contacted.
 *
 * @event Mongos#fullsetup
 * @type ***REMOVED***Mongos***REMOVED***
 */

/**
 * A mongos all event, used to signal that all topology members have been contacted.
 *
 * @event Mongos#all
 * @type ***REMOVED***Mongos***REMOVED***
 */

/**
 * A server member left the mongos list
 *
 * @event Mongos#left
 * @type ***REMOVED***Mongos***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The type of member that left (mongos)
 * @param ***REMOVED***Server***REMOVED*** server The server object that left
 */

/**
 * A server member joined the mongos list
 *
 * @event Mongos#joined
 * @type ***REMOVED***Mongos***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The type of member that left (mongos)
 * @param ***REMOVED***Server***REMOVED*** server The server object that joined
 */

/**
 * A server opening SDAM monitoring event
 *
 * @event Mongos#serverOpening
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A server closed SDAM monitoring event
 *
 * @event Mongos#serverClosed
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A server description SDAM change monitoring event
 *
 * @event Mongos#serverDescriptionChanged
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology open SDAM event
 *
 * @event Mongos#topologyOpening
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology closed SDAM event
 *
 * @event Mongos#topologyClosed
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology structure SDAM change event
 *
 * @event Mongos#topologyDescriptionChanged
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology serverHeartbeatStarted SDAM event
 *
 * @event Mongos#serverHeartbeatStarted
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology serverHeartbeatFailed SDAM event
 *
 * @event Mongos#serverHeartbeatFailed
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology serverHeartbeatSucceeded SDAM change event
 *
 * @event Mongos#serverHeartbeatSucceeded
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * An event emitted indicating a command was started, if command monitoring is enabled
 *
 * @event Mongos#commandStarted
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * An event emitted indicating a command succeeded, if command monitoring is enabled
 *
 * @event Mongos#commandSucceeded
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * An event emitted indicating a command failed, if command monitoring is enabled
 *
 * @event Mongos#commandFailed
 * @type ***REMOVED***object***REMOVED***
 */

module.exports = Mongos;
