'use strict';

var inherits = require('util').inherits,
  f = require('util').format,
  EventEmitter = require('events').EventEmitter,
  ReadPreference = require('./read_preference'),
  Logger = require('../connection/logger'),
  debugOptions = require('../connection/utils').debugOptions,
  retrieveBSON = require('../connection/utils').retrieveBSON,
  Pool = require('../connection/pool'),
  Query = require('../connection/commands').Query,
  MongoError = require('../error').MongoError,
  MongoNetworkError = require('../error').MongoNetworkError,
  TwoSixWireProtocolSupport = require('../wireprotocol/2_6_support'),
  ThreeTwoWireProtocolSupport = require('../wireprotocol/3_2_support'),
  BasicCursor = require('../cursor'),
  sdam = require('./shared'),
  createClientInfo = require('./shared').createClientInfo,
  createCompressionInfo = require('./shared').createCompressionInfo,
  resolveClusterTime = require('./shared').resolveClusterTime,
  SessionMixins = require('./shared').SessionMixins,
  relayEvents = require('../utils').relayEvents;

function getSaslSupportedMechs(options) ***REMOVED***
  if (!options) ***REMOVED***
    return ***REMOVED******REMOVED***;
  ***REMOVED***

  const authArray = options.auth || [];
  const authMechanism = authArray[0] || options.authMechanism;
  const authSource = authArray[1] || options.authSource || options.dbName || 'admin';
  const user = authArray[2] || options.user;

  if (typeof authMechanism === 'string' && authMechanism.toUpperCase() !== 'DEFAULT') ***REMOVED***
    return ***REMOVED******REMOVED***;
  ***REMOVED***

  if (!user) ***REMOVED***
    return ***REMOVED******REMOVED***;
  ***REMOVED***

  return ***REMOVED*** saslSupportedMechs: `$***REMOVED***authSource***REMOVED***.$***REMOVED***user***REMOVED***` ***REMOVED***;
***REMOVED***

function getDefaultAuthMechanism(ismaster) ***REMOVED***
  if (ismaster) ***REMOVED***
    // If ismaster contains saslSupportedMechs, use scram-sha-256
    // if it is available, else scram-sha-1
    if (Array.isArray(ismaster.saslSupportedMechs)) ***REMOVED***
      return ismaster.saslSupportedMechs.indexOf('SCRAM-SHA-256') >= 0
        ? 'scram-sha-256'
        : 'scram-sha-1';
    ***REMOVED***

    // Fallback to legacy selection method. If wire version >= 3, use scram-sha-1
    if (ismaster.maxWireVersion >= 3) ***REMOVED***
      return 'scram-sha-1';
    ***REMOVED***
  ***REMOVED***

  // Default for wireprotocol < 3
  return 'mongocr';
***REMOVED***

function extractIsMasterError(err, result) ***REMOVED***
  if (err) ***REMOVED***
    return err;
  ***REMOVED***

  if (result && result.result && result.result.ok === 0) ***REMOVED***
    return new MongoError(result.result);
  ***REMOVED***
***REMOVED***

// Used for filtering out fields for loggin
var debugFields = [
  'reconnect',
  'reconnectTries',
  'reconnectInterval',
  'emitError',
  'cursorFactory',
  'host',
  'port',
  'size',
  'keepAlive',
  'keepAliveInitialDelay',
  'noDelay',
  'connectionTimeout',
  'checkServerIdentity',
  'socketTimeout',
  'singleBufferSerializtion',
  'ssl',
  'ca',
  'crl',
  'cert',
  'key',
  'rejectUnauthorized',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'servername'
];

// Server instance id
var id = 0;
var serverAccounting = false;
var servers = ***REMOVED******REMOVED***;
var BSON = retrieveBSON();

/**
 * Creates a new Server instance
 * @class
 * @param ***REMOVED***boolean***REMOVED*** [options.reconnect=true] Server will attempt to reconnect on loss of connection
 * @param ***REMOVED***number***REMOVED*** [options.reconnectTries=30] Server attempt to reconnect #times
 * @param ***REMOVED***number***REMOVED*** [options.reconnectInterval=1000] Server will wait # milliseconds between retries
 * @param ***REMOVED***number***REMOVED*** [options.monitoring=true] Enable the server state monitoring (calling ismaster at monitoringInterval)
 * @param ***REMOVED***number***REMOVED*** [options.monitoringInterval=5000] The interval of calling ismaster when monitoring is enabled.
 * @param ***REMOVED***Cursor***REMOVED*** [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
 * @param ***REMOVED***string***REMOVED*** options.host The server host
 * @param ***REMOVED***number***REMOVED*** options.port The server port
 * @param ***REMOVED***number***REMOVED*** [options.size=5] Server connection pool size
 * @param ***REMOVED***boolean***REMOVED*** [options.keepAlive=true] TCP Connection keep alive enabled
 * @param ***REMOVED***number***REMOVED*** [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled
 * @param ***REMOVED***boolean***REMOVED*** [options.noDelay=true] TCP Connection no delay
 * @param ***REMOVED***number***REMOVED*** [options.connectionTimeout=30000] TCP Connection timeout setting
 * @param ***REMOVED***number***REMOVED*** [options.socketTimeout=360000] TCP Socket timeout setting
 * @param ***REMOVED***boolean***REMOVED*** [options.ssl=false] Use SSL for connection
 * @param ***REMOVED***boolean|function***REMOVED*** [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
 * @param ***REMOVED***Buffer***REMOVED*** [options.ca] SSL Certificate store binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.crl] SSL Certificate revocation store binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.cert] SSL Certificate binary buffer
 * @param ***REMOVED***Buffer***REMOVED*** [options.key] SSL Key file binary buffer
 * @param ***REMOVED***string***REMOVED*** [options.passphrase] SSL Certificate pass phrase
 * @param ***REMOVED***boolean***REMOVED*** [options.rejectUnauthorized=true] Reject unauthorized server certificates
 * @param ***REMOVED***string***REMOVED*** [options.servername=null] String containing the server name requested via TLS SNI.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***string***REMOVED*** [options.appname=null] Application name, passed in on ismaster call and logged in mongod server logs. Maximum size 128 bytes.
 * @param ***REMOVED***boolean***REMOVED*** [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
 * @param ***REMOVED***boolean***REMOVED*** [options.monitorCommands=false] Enable command monitoring for this topology
 * @return ***REMOVED***Server***REMOVED*** A cursor instance
 * @fires Server#connect
 * @fires Server#close
 * @fires Server#error
 * @fires Server#timeout
 * @fires Server#parseError
 * @fires Server#reconnect
 * @fires Server#reconnectFailed
 * @fires Server#serverHeartbeatStarted
 * @fires Server#serverHeartbeatSucceeded
 * @fires Server#serverHeartbeatFailed
 * @fires Server#topologyOpening
 * @fires Server#topologyClosed
 * @fires Server#topologyDescriptionChanged
 * @property ***REMOVED***string***REMOVED*** type the topology type.
 * @property ***REMOVED***string***REMOVED*** parserType the parser type used (c++ or js).
 */
var Server = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  // Add event listener
  EventEmitter.call(this);

  // Server instance id
  this.id = id++;

  // Internal state
  this.s = ***REMOVED***
    // Options
    options: options,
    // Logger
    logger: Logger('Server', options),
    // Factory overrides
    Cursor: options.cursorFactory || BasicCursor,
    // BSON instance
    bson:
      options.bson ||
      new BSON([
        BSON.Binary,
        BSON.Code,
        BSON.DBRef,
        BSON.Decimal128,
        BSON.Double,
        BSON.Int32,
        BSON.Long,
        BSON.Map,
        BSON.MaxKey,
        BSON.MinKey,
        BSON.ObjectId,
        BSON.BSONRegExp,
        BSON.Symbol,
        BSON.Timestamp
      ]),
    // Pool
    pool: null,
    // Disconnect handler
    disconnectHandler: options.disconnectHandler,
    // Monitor thread (keeps the connection alive)
    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : true,
    // Is the server in a topology
    inTopology: !!options.parent,
    // Monitoring timeout
    monitoringInterval:
      typeof options.monitoringInterval === 'number' ? options.monitoringInterval : 5000,
    // Topology id
    topologyId: -1,
    compression: ***REMOVED*** compressors: createCompressionInfo(options) ***REMOVED***,
    // Optional parent topology
    parent: options.parent
  ***REMOVED***;

  // If this is a single deployment we need to track the clusterTime here
  if (!this.s.parent) ***REMOVED***
    this.s.clusterTime = null;
  ***REMOVED***

  // Curent ismaster
  this.ismaster = null;
  // Current ping time
  this.lastIsMasterMS = -1;
  // The monitoringProcessId
  this.monitoringProcessId = null;
  // Initial connection
  this.initialConnect = true;
  // Wire protocol handler, default to oldest known protocol handler
  // this gets changed when the first ismaster is called.
  this.wireProtocolHandler = new TwoSixWireProtocolSupport();
  // Default type
  this._type = 'server';
  // Set the client info
  this.clientInfo = createClientInfo(options);

  // Max Stalleness values
  // last time we updated the ismaster state
  this.lastUpdateTime = 0;
  // Last write time
  this.lastWriteDate = 0;
  // Stalleness
  this.staleness = 0;
***REMOVED***;

inherits(Server, EventEmitter);
Object.assign(Server.prototype, SessionMixins);

Object.defineProperty(Server.prototype, 'type', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this._type;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Server.prototype, 'parserType', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return BSON.native ? 'c++' : 'js';
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Server.prototype, 'logicalSessionTimeoutMinutes', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    if (!this.ismaster) return null;
    return this.ismaster.logicalSessionTimeoutMinutes || null;
  ***REMOVED***
***REMOVED***);

// In single server deployments we track the clusterTime directly on the topology, however
// in Mongos and ReplSet deployments we instead need to delegate the clusterTime up to the
// tracking objects so we can ensure we are gossiping the maximum time received from the
// server.
Object.defineProperty(Server.prototype, 'clusterTime', ***REMOVED***
  enumerable: true,
  set: function(clusterTime) ***REMOVED***
    const settings = this.s.parent ? this.s.parent : this.s;
    resolveClusterTime(settings, clusterTime);
  ***REMOVED***,
  get: function() ***REMOVED***
    const settings = this.s.parent ? this.s.parent : this.s;
    return settings.clusterTime || null;
  ***REMOVED***
***REMOVED***);

Server.enableServerAccounting = function() ***REMOVED***
  serverAccounting = true;
  servers = ***REMOVED******REMOVED***;
***REMOVED***;

Server.disableServerAccounting = function() ***REMOVED***
  serverAccounting = false;
***REMOVED***;

Server.servers = function() ***REMOVED***
  return servers;
***REMOVED***;

Object.defineProperty(Server.prototype, 'name', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.options.host + ':' + this.s.options.port;
  ***REMOVED***
***REMOVED***);

function isSupportedServer(response) ***REMOVED***
  return response && typeof response.maxWireVersion === 'number' && response.maxWireVersion >= 2;
***REMOVED***

function configureWireProtocolHandler(self, ismaster) ***REMOVED***
  // 3.2 wire protocol handler
  if (ismaster.maxWireVersion >= 4) ***REMOVED***
    return new ThreeTwoWireProtocolSupport();
  ***REMOVED***

  // default to 2.6 wire protocol handler
  return new TwoSixWireProtocolSupport();
***REMOVED***

function disconnectHandler(self, type, ns, cmd, options, callback) ***REMOVED***
  // Topology is not connected, save the call in the provided store to be
  // Executed at some point when the handler deems it's reconnected
  if (
    !self.s.pool.isConnected() &&
    self.s.options.reconnect &&
    self.s.disconnectHandler != null &&
    !options.monitoring
  ) ***REMOVED***
    self.s.disconnectHandler.add(type, ns, cmd, options, callback);
    return true;
  ***REMOVED***

  // If we have no connection error
  if (!self.s.pool.isConnected()) ***REMOVED***
    callback(new MongoError(f('no connection available to server %s', self.name)));
    return true;
  ***REMOVED***
***REMOVED***

function monitoringProcess(self) ***REMOVED***
  return function() ***REMOVED***
    // Pool was destroyed do not continue process
    if (self.s.pool.isDestroyed()) return;
    // Emit monitoring Process event
    self.emit('monitoring', self);
    // Perform ismaster call
    // Query options
    var queryOptions = ***REMOVED*** numberToSkip: 0, numberToReturn: -1, checkKeys: false, slaveOk: true ***REMOVED***;
    // Create a query instance
    var query = new Query(self.s.bson, 'admin.$cmd', ***REMOVED*** ismaster: true ***REMOVED***, queryOptions);
    // Get start time
    var start = new Date().getTime();

    // Execute the ismaster query
    self.s.pool.write(
      query,
      ***REMOVED***
        socketTimeout:
          typeof self.s.options.connectionTimeout !== 'number'
            ? 2000
            : self.s.options.connectionTimeout,
        monitoring: true
      ***REMOVED***,
      function(err, result) ***REMOVED***
        // Set initial lastIsMasterMS
        self.lastIsMasterMS = new Date().getTime() - start;
        if (self.s.pool.isDestroyed()) return;
        // Update the ismaster view if we have a result
        if (result) ***REMOVED***
          self.ismaster = result.result;
        ***REMOVED***
        // Re-schedule the monitoring process
        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
      ***REMOVED***
    );
  ***REMOVED***;
***REMOVED***

var eventHandler = function(self, event) ***REMOVED***
  return function(err) ***REMOVED***
    // Log information of received information if in info mode
    if (self.s.logger.isInfo()) ***REMOVED***
      var object = err instanceof MongoError ? JSON.stringify(err) : ***REMOVED******REMOVED***;
      self.s.logger.info(
        f('server %s fired event %s out with message %s', self.name, event, object)
      );
    ***REMOVED***

    // Handle connect event
    if (event === 'connect') ***REMOVED***
      // Issue an ismaster command at connect
      // Query options
      var queryOptions = ***REMOVED*** numberToSkip: 0, numberToReturn: -1, checkKeys: false, slaveOk: true ***REMOVED***;
      // Create a query instance
      var compressors =
        self.s.compression && self.s.compression.compressors ? self.s.compression.compressors : [];
      var query = new Query(
        self.s.bson,
        'admin.$cmd',
        Object.assign(
          ***REMOVED*** ismaster: true, client: self.clientInfo, compression: compressors ***REMOVED***,
          getSaslSupportedMechs(self.s.options)
        ),
        queryOptions
      );
      // Get start time
      var start = new Date().getTime();
      // Execute the ismaster query
      self.s.pool.write(
        query,
        ***REMOVED***
          socketTimeout: self.s.options.connectionTimeout || 2000
        ***REMOVED***,
        function(err, result) ***REMOVED***
          // Set initial lastIsMasterMS
          self.lastIsMasterMS = new Date().getTime() - start;

          const serverError = extractIsMasterError(err, result);

          if (serverError) ***REMOVED***
            self.destroy();
            return self.emit('error', serverError);
          ***REMOVED***

          if (!isSupportedServer(result.result)) ***REMOVED***
            self.destroy();
            const latestSupportedVersion = '2.6';
            const message =
              'Server at ' +
              self.s.options.host +
              ':' +
              self.s.options.port +
              ' reports wire version ' +
              (result.result.maxWireVersion || 0) +
              ', but this version of Node.js Driver requires at least 2 (MongoDB' +
              latestSupportedVersion +
              ').';
            return self.emit('error', new MongoError(message), self);
          ***REMOVED***

          // Determine whether the server is instructing us to use a compressor
          if (result.result && result.result.compression) ***REMOVED***
            for (var i = 0; i < self.s.compression.compressors.length; i++) ***REMOVED***
              if (result.result.compression.indexOf(self.s.compression.compressors[i]) > -1) ***REMOVED***
                self.s.pool.options.agreedCompressor = self.s.compression.compressors[i];
                break;
              ***REMOVED***
            ***REMOVED***

            if (self.s.compression.zlibCompressionLevel) ***REMOVED***
              self.s.pool.options.zlibCompressionLevel = self.s.compression.zlibCompressionLevel;
            ***REMOVED***
          ***REMOVED***

          // Ensure no error emitted after initial connect when reconnecting
          self.initialConnect = false;
          // Save the ismaster
          self.ismaster = result.result;

          // It's a proxy change the type so
          // the wireprotocol will send $readPreference
          if (self.ismaster.msg === 'isdbgrid') ***REMOVED***
            self._type = 'mongos';
          ***REMOVED***
          // Add the correct wire protocol handler
          self.wireProtocolHandler = configureWireProtocolHandler(self, self.ismaster);
          // Have we defined self monitoring
          if (self.s.monitoring) ***REMOVED***
            self.monitoringProcessId = setTimeout(
              monitoringProcess(self),
              self.s.monitoringInterval
            );
          ***REMOVED***

          // Emit server description changed if something listening
          sdam.emitServerDescriptionChanged(self, ***REMOVED***
            address: self.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: sdam.getTopologyType(self)
          ***REMOVED***);

          if (!self.s.inTopology) ***REMOVED***
            // Emit topology description changed if something listening
            sdam.emitTopologyDescriptionChanged(self, ***REMOVED***
              topologyType: 'Single',
              servers: [
                ***REMOVED***
                  address: self.name,
                  arbiters: [],
                  hosts: [],
                  passives: [],
                  type: sdam.getTopologyType(self)
                ***REMOVED***
              ]
            ***REMOVED***);
          ***REMOVED***

          // Log the ismaster if available
          if (self.s.logger.isInfo()) ***REMOVED***
            self.s.logger.info(
              f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster))
            );
          ***REMOVED***

          // Emit connect
          self.emit('connect', self);
        ***REMOVED***
      );
    ***REMOVED*** else if (
      event === 'error' ||
      event === 'parseError' ||
      event === 'close' ||
      event === 'timeout' ||
      event === 'reconnect' ||
      event === 'attemptReconnect' ||
      'reconnectFailed'
    ) ***REMOVED***
      // Remove server instance from accounting
      if (
        serverAccounting &&
        ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) !== -1
      ) ***REMOVED***
        // Emit toplogy opening event if not in topology
        if (!self.s.inTopology) ***REMOVED***
          self.emit('topologyOpening', ***REMOVED*** topologyId: self.id ***REMOVED***);
        ***REMOVED***

        delete servers[self.id];
      ***REMOVED***

      if (event === 'close') ***REMOVED***
        // Closing emits a server description changed event going to unknown.
        sdam.emitServerDescriptionChanged(self, ***REMOVED***
          address: self.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: 'Unknown'
        ***REMOVED***);
      ***REMOVED***

      // Reconnect failed return error
      if (event === 'reconnectFailed') ***REMOVED***
        self.emit('reconnectFailed', err);
        // Emit error if any listeners
        if (self.listeners('error').length > 0) ***REMOVED***
          self.emit('error', err);
        ***REMOVED***
        // Terminate
        return;
      ***REMOVED***

      // On first connect fail
      if (
        self.s.pool.state === 'disconnected' &&
        self.initialConnect &&
        ['close', 'timeout', 'error', 'parseError'].indexOf(event) !== -1
      ) ***REMOVED***
        self.initialConnect = false;
        return self.emit(
          'error',
          new MongoNetworkError(
            f('failed to connect to server [%s] on first connect [%s]', self.name, err)
          )
        );
      ***REMOVED***

      // Reconnect event, emit the server
      if (event === 'reconnect') ***REMOVED***
        // Reconnecting emits a server description changed event going from unknown to the
        // current server type.
        sdam.emitServerDescriptionChanged(self, ***REMOVED***
          address: self.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: sdam.getTopologyType(self)
        ***REMOVED***);
        return self.emit(event, self);
      ***REMOVED***

      // Emit the event
      self.emit(event, err);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***;

/**
 * Initiate server connect
 * @method
 * @param ***REMOVED***array***REMOVED*** [options.auth=null] Array of auth options to apply on connect
 */
Server.prototype.connect = function(options) ***REMOVED***
  var self = this;
  options = options || ***REMOVED******REMOVED***;

  // Set the connections
  if (serverAccounting) servers[this.id] = this;

  // Do not allow connect to be called on anything that's not disconnected
  if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) ***REMOVED***
    throw new MongoError(f('server instance in invalid state %s', self.s.pool.state));
  ***REMOVED***

  // Create a pool
  self.s.pool = new Pool(this, Object.assign(self.s.options, options, ***REMOVED*** bson: this.s.bson ***REMOVED***));

  // Set up listeners
  self.s.pool.on('close', eventHandler(self, 'close'));
  self.s.pool.on('error', eventHandler(self, 'error'));
  self.s.pool.on('timeout', eventHandler(self, 'timeout'));
  self.s.pool.on('parseError', eventHandler(self, 'parseError'));
  self.s.pool.on('connect', eventHandler(self, 'connect'));
  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));
  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed'));

  // Set up listeners for command monitoring
  relayEvents(self.s.pool, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);

  // Emit toplogy opening event if not in topology
  if (!self.s.inTopology) ***REMOVED***
    this.emit('topologyOpening', ***REMOVED*** topologyId: self.id ***REMOVED***);
  ***REMOVED***

  // Emit opening server event
  self.emit('serverOpening', ***REMOVED***
    topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,
    address: self.name
  ***REMOVED***);

  // Connect with optional auth settings
  if (options.auth) ***REMOVED***
    self.s.pool.connect.apply(self.s.pool, options.auth);
  ***REMOVED*** else ***REMOVED***
    self.s.pool.connect();
  ***REMOVED***
***REMOVED***;

/**
 * Get the server description
 * @method
 * @return ***REMOVED***object***REMOVED***
 */
Server.prototype.getDescription = function() ***REMOVED***
  var ismaster = this.ismaster || ***REMOVED******REMOVED***;
  var description = ***REMOVED***
    type: sdam.getTopologyType(this),
    address: this.name
  ***REMOVED***;

  // Add fields if available
  if (ismaster.hosts) description.hosts = ismaster.hosts;
  if (ismaster.arbiters) description.arbiters = ismaster.arbiters;
  if (ismaster.passives) description.passives = ismaster.passives;
  if (ismaster.setName) description.setName = ismaster.setName;
  return description;
***REMOVED***;

/**
 * Returns the last known ismaster document for this server
 * @method
 * @return ***REMOVED***object***REMOVED***
 */
Server.prototype.lastIsMaster = function() ***REMOVED***
  return this.ismaster;
***REMOVED***;

/**
 * Unref all connections belong to this server
 * @method
 */
Server.prototype.unref = function() ***REMOVED***
  this.s.pool.unref();
***REMOVED***;

/**
 * Figure out if the server is connected
 * @method
 * @return ***REMOVED***boolean***REMOVED***
 */
Server.prototype.isConnected = function() ***REMOVED***
  if (!this.s.pool) return false;
  return this.s.pool.isConnected();
***REMOVED***;

/**
 * Figure out if the server instance was destroyed by calling destroy
 * @method
 * @return ***REMOVED***boolean***REMOVED***
 */
Server.prototype.isDestroyed = function() ***REMOVED***
  if (!this.s.pool) return false;
  return this.s.pool.isDestroyed();
***REMOVED***;

function basicWriteValidations(self) ***REMOVED***
  if (!self.s.pool) return new MongoError('server instance is not connected');
  if (self.s.pool.isDestroyed()) return new MongoError('server instance pool was destroyed');
***REMOVED***

function basicReadValidations(self, options) ***REMOVED***
  basicWriteValidations(self, options);

  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) ***REMOVED***
    throw new Error('readPreference must be an instance of ReadPreference');
  ***REMOVED***
***REMOVED***

/**
 * Execute a command
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***object***REMOVED*** cmd The command hash
 * @param ***REMOVED***ReadPreference***REMOVED*** [options.readPreference] Specify read preference if command supports it
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.checkKeys=false] Specify if the bson parser should validate keys.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***Boolean***REMOVED*** [options.fullResult=false] Return the full envelope instead of just the result document.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.command = function(ns, cmd, options, callback) ***REMOVED***
  var self = this;
  if (typeof options === 'function') ***REMOVED***
    (callback = options), (options = ***REMOVED******REMOVED***), (options = options || ***REMOVED******REMOVED***);
  ***REMOVED***

  var result = basicReadValidations(self, options);
  if (result) return callback(result);

  // Clone the options
  options = Object.assign(***REMOVED******REMOVED***, options, ***REMOVED*** wireProtocolCommand: false ***REMOVED***);

  // Debug log
  if (self.s.logger.isDebug())
    self.s.logger.debug(
      f(
        'executing command [%s] against %s',
        JSON.stringify(***REMOVED***
          ns: ns,
          cmd: cmd,
          options: debugOptions(debugFields, options)
        ***REMOVED***),
        self.name
      )
    );

  // If we are not connected or have a disconnectHandler specified
  if (disconnectHandler(self, 'command', ns, cmd, options, callback)) return;

  // Check if we have collation support
  if (this.ismaster && this.ismaster.maxWireVersion < 5 && cmd.collation) ***REMOVED***
    return callback(new MongoError(f('server %s does not support collation', this.name)));
  ***REMOVED***

  // Are we executing against a specific topology
  var topology = options.topology || ***REMOVED******REMOVED***;
  // Create the query object
  var query = self.wireProtocolHandler.command(self.s.bson, ns, cmd, ***REMOVED******REMOVED***, topology, options);
  if (query instanceof MongoError) ***REMOVED***
    return callback(query, null);
  ***REMOVED***

  // Set slave OK of the query
  query.slaveOk = options.readPreference ? options.readPreference.slaveOk() : false;

  // Write options
  var writeOptions = ***REMOVED***
    raw: typeof options.raw === 'boolean' ? options.raw : false,
    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,
    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,
    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,
    command: true,
    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : false,
    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,
    requestId: query.requestId,
    socketTimeout: typeof options.socketTimeout === 'number' ? options.socketTimeout : null,
    session: options.session || null
  ***REMOVED***;

  // Write the operation to the pool
  self.s.pool.write(query, writeOptions, callback);
***REMOVED***;

/**
 * Insert one or more documents
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***array***REMOVED*** ops An array of documents to insert
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
 * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.insert = function(ns, ops, options, callback) ***REMOVED***
  var self = this;
  if (typeof options === 'function') ***REMOVED***
    (callback = options), (options = ***REMOVED******REMOVED***), (options = options || ***REMOVED******REMOVED***);
  ***REMOVED***

  var result = basicWriteValidations(self, options);
  if (result) return callback(result);

  // If we are not connected or have a disconnectHandler specified
  if (disconnectHandler(self, 'insert', ns, ops, options, callback)) return;

  // Setup the docs as an array
  ops = Array.isArray(ops) ? ops : [ops];

  // Execute write
  return self.wireProtocolHandler.insert(self.s.pool, ns, self.s.bson, ops, options, callback);
***REMOVED***;

/**
 * Perform one or more update operations
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***array***REMOVED*** ops An array of updates
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
 * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.update = function(ns, ops, options, callback) ***REMOVED***
  var self = this;
  if (typeof options === 'function') ***REMOVED***
    (callback = options), (options = ***REMOVED******REMOVED***), (options = options || ***REMOVED******REMOVED***);
  ***REMOVED***

  var result = basicWriteValidations(self, options);
  if (result) return callback(result);

  // If we are not connected or have a disconnectHandler specified
  if (disconnectHandler(self, 'update', ns, ops, options, callback)) return;

  // Check if we have collation support
  if (this.ismaster && this.ismaster.maxWireVersion < 5 && options.collation) ***REMOVED***
    return callback(new MongoError(f('server %s does not support collation', this.name)));
  ***REMOVED***

  // Setup the docs as an array
  ops = Array.isArray(ops) ? ops : [ops];
  // Execute write
  return self.wireProtocolHandler.update(self.s.pool, ns, self.s.bson, ops, options, callback);
***REMOVED***;

/**
 * Perform one or more remove operations
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***array***REMOVED*** ops An array of removes
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute in order or out of order
 * @param ***REMOVED***object***REMOVED*** [options.writeConcern=***REMOVED******REMOVED***] Write concern for the operation
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
 * @param ***REMOVED***opResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.remove = function(ns, ops, options, callback) ***REMOVED***
  var self = this;
  if (typeof options === 'function') ***REMOVED***
    (callback = options), (options = ***REMOVED******REMOVED***), (options = options || ***REMOVED******REMOVED***);
  ***REMOVED***

  var result = basicWriteValidations(self, options);
  if (result) return callback(result);

  // If we are not connected or have a disconnectHandler specified
  if (disconnectHandler(self, 'remove', ns, ops, options, callback)) return;

  // Check if we have collation support
  if (this.ismaster && this.ismaster.maxWireVersion < 5 && options.collation) ***REMOVED***
    return callback(new MongoError(f('server %s does not support collation', this.name)));
  ***REMOVED***

  // Setup the docs as an array
  ops = Array.isArray(ops) ? ops : [ops];
  // Execute write
  return self.wireProtocolHandler.remove(self.s.pool, ns, self.s.bson, ops, options, callback);
***REMOVED***;

/**
 * Get a new cursor
 * @method
 * @param ***REMOVED***string***REMOVED*** ns The MongoDB fully qualified namespace (ex: db1.collection1)
 * @param ***REMOVED***object|Long***REMOVED*** cmd Can be either a command returning a cursor or a cursorId
 * @param ***REMOVED***object***REMOVED*** [options] Options for the cursor
 * @param ***REMOVED***object***REMOVED*** [options.batchSize=0] Batchsize for the operation
 * @param ***REMOVED***array***REMOVED*** [options.documents=[]] Initial documents list for cursor
 * @param ***REMOVED***ReadPreference***REMOVED*** [options.readPreference] Specify read preference if command supports it
 * @param ***REMOVED***Boolean***REMOVED*** [options.serializeFunctions=false] Specify if functions on an object should be serialized.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session=null] Session to use for the operation
 * @param ***REMOVED***object***REMOVED*** [options.topology] The internal topology of the created cursor
 * @returns ***REMOVED***Cursor***REMOVED***
 */
Server.prototype.cursor = function(ns, cmd, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  const topology = options.topology || this;

  // Set up final cursor type
  var FinalCursor = options.cursorFactory || this.s.Cursor;

  // Return the cursor
  return new FinalCursor(this.s.bson, ns, cmd, options, topology, this.s.options);
***REMOVED***;

/**
 * Logout from a database
 * @method
 * @param ***REMOVED***string***REMOVED*** db The db we are logging out from
 * @param ***REMOVED***authResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.logout = function(dbName, callback) ***REMOVED***
  this.s.pool.logout(dbName, callback);
***REMOVED***;

/**
 * Authenticate using a specified mechanism
 * @method
 * @param ***REMOVED***string***REMOVED*** mechanism The Auth mechanism we are invoking
 * @param ***REMOVED***string***REMOVED*** db The db we are invoking the mechanism against
 * @param ***REMOVED***...object***REMOVED*** param Parameters for the specific mechanism
 * @param ***REMOVED***authResultCallback***REMOVED*** callback A callback function
 */
Server.prototype.auth = function(mechanism, db) ***REMOVED***
  var self = this;

  if (mechanism === 'default') ***REMOVED***
    mechanism = getDefaultAuthMechanism(self.ismaster);
  ***REMOVED***

  // Slice all the arguments off
  var args = Array.prototype.slice.call(arguments, 0);
  // Set the mechanism
  args[0] = mechanism;
  // Get the callback
  var callback = args[args.length - 1];

  // If we are not connected or have a disconnectHandler specified
  if (disconnectHandler(self, 'auth', db, args, ***REMOVED******REMOVED***, callback)) ***REMOVED***
    return;
  ***REMOVED***

  // Do not authenticate if we are an arbiter
  if (this.lastIsMaster() && this.lastIsMaster().arbiterOnly) ***REMOVED***
    return callback(null, true);
  ***REMOVED***

  // Apply the arguments to the pool
  self.s.pool.auth.apply(self.s.pool, args);
***REMOVED***;

/**
 * Compare two server instances
 * @method
 * @param ***REMOVED***Server***REMOVED*** server Server to compare equality against
 * @return ***REMOVED***boolean***REMOVED***
 */
Server.prototype.equals = function(server) ***REMOVED***
  if (typeof server === 'string') return this.name.toLowerCase() === server.toLowerCase();
  if (server.name) return this.name.toLowerCase() === server.name.toLowerCase();
  return false;
***REMOVED***;

/**
 * All raw connections
 * @method
 * @return ***REMOVED***Connection[]***REMOVED***
 */
Server.prototype.connections = function() ***REMOVED***
  return this.s.pool.allConnections();
***REMOVED***;

/**
 * Get server
 * @method
 * @return ***REMOVED***Server***REMOVED***
 */
Server.prototype.getServer = function() ***REMOVED***
  return this;
***REMOVED***;

/**
 * Get connection
 * @method
 * @return ***REMOVED***Connection***REMOVED***
 */
Server.prototype.getConnection = function() ***REMOVED***
  return this.s.pool.get();
***REMOVED***;

var listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];

/**
 * Destroy the server connection
 * @method
 * @param ***REMOVED***boolean***REMOVED*** [options.emitClose=false] Emit close event on destroy
 * @param ***REMOVED***boolean***REMOVED*** [options.emitDestroy=false] Emit destroy event on destroy
 * @param ***REMOVED***boolean***REMOVED*** [options.force=false] Force destroy the pool
 */
Server.prototype.destroy = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  var self = this;

  // Set the connections
  if (serverAccounting) delete servers[this.id];

  // Destroy the monitoring process if any
  if (this.monitoringProcessId) ***REMOVED***
    clearTimeout(this.monitoringProcessId);
  ***REMOVED***

  // No pool, return
  if (!self.s.pool) return;

  // Emit close event
  if (options.emitClose) ***REMOVED***
    self.emit('close', self);
  ***REMOVED***

  // Emit destroy event
  if (options.emitDestroy) ***REMOVED***
    self.emit('destroy', self);
  ***REMOVED***

  // Remove all listeners
  listeners.forEach(function(event) ***REMOVED***
    self.s.pool.removeAllListeners(event);
  ***REMOVED***);

  // Emit opening server event
  if (self.listeners('serverClosed').length > 0)
    self.emit('serverClosed', ***REMOVED***
      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,
      address: self.name
    ***REMOVED***);

  // Emit toplogy opening event if not in topology
  if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) ***REMOVED***
    self.emit('topologyClosed', ***REMOVED*** topologyId: self.id ***REMOVED***);
  ***REMOVED***

  if (self.s.logger.isDebug()) ***REMOVED***
    self.s.logger.debug(f('destroy called on server %s', self.name));
  ***REMOVED***

  // Destroy the pool
  this.s.pool.destroy(options.force);
***REMOVED***;

/**
 * A server connect event, used to verify that the connection is up and running
 *
 * @event Server#connect
 * @type ***REMOVED***Server***REMOVED***
 */

/**
 * A server reconnect event, used to verify that the server topology has reconnected
 *
 * @event Server#reconnect
 * @type ***REMOVED***Server***REMOVED***
 */

/**
 * A server opening SDAM monitoring event
 *
 * @event Server#serverOpening
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A server closed SDAM monitoring event
 *
 * @event Server#serverClosed
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A server description SDAM change monitoring event
 *
 * @event Server#serverDescriptionChanged
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology open SDAM event
 *
 * @event Server#topologyOpening
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology closed SDAM event
 *
 * @event Server#topologyClosed
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * A topology structure SDAM change event
 *
 * @event Server#topologyDescriptionChanged
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Server reconnect failed
 *
 * @event Server#reconnectFailed
 * @type ***REMOVED***Error***REMOVED***
 */

/**
 * Server connection pool closed
 *
 * @event Server#close
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Server connection pool caused an error
 *
 * @event Server#error
 * @type ***REMOVED***Error***REMOVED***
 */

/**
 * Server destroyed was called
 *
 * @event Server#destroy
 * @type ***REMOVED***Server***REMOVED***
 */

module.exports = Server;
