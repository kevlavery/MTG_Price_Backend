'use strict';

const retrieveBSON = require('./connection/utils').retrieveBSON,
  EventEmitter = require('events'),
  BSON = retrieveBSON(),
  Binary = BSON.Binary,
  uuidV4 = require('./utils').uuidV4;

/**
 *
 */
class ClientSession extends EventEmitter ***REMOVED***
  constructor(topology, sessionPool, options) ***REMOVED***
    super();

    if (topology == null) ***REMOVED***
      throw new Error('ClientSession requires a topology');
    ***REMOVED***

    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) ***REMOVED***
      throw new Error('ClientSession requires a ServerSessionPool');
    ***REMOVED***

    options = options || ***REMOVED******REMOVED***;
    this.topology = topology;
    this.sessionPool = sessionPool;
    this.hasEnded = false;
    this.serverSession = sessionPool.acquire();

    this.supports = ***REMOVED***
      causalConsistency: !!options.causalConsistency
    ***REMOVED***;

    options = options || ***REMOVED******REMOVED***;
    if (typeof options.initialClusterTime !== 'undefined') ***REMOVED***
      this.clusterTime = options.initialClusterTime;
    ***REMOVED*** else ***REMOVED***
      this.clusterTime = null;
    ***REMOVED***

    this.operationTime = null;

    this.explicit = !!options.explicit;
    this.owner = options.owner;
  ***REMOVED***

  /**
   *
   */
  endSession(options, callback) ***REMOVED***
    if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
    options = options || ***REMOVED******REMOVED***;

    if (this.hasEnded) ***REMOVED***
      if (typeof callback === 'function') callback(null, null);
      return;
    ***REMOVED***

    if (!options.skipCommand) ***REMOVED***
      // send the `endSessions` command
      this.topology.endSessions(this.id);
    ***REMOVED***

    // mark the session as ended, and emit a signal
    this.hasEnded = true;
    this.emit('ended', this);

    // release the server session back to the pool
    this.sessionPool.release(this.serverSession);

    // spec indicates that we should ignore all errors for `endSessions`
    if (typeof callback === 'function') callback(null, null);
  ***REMOVED***

  /**
   * Advances the operationTime for a ClientSession.
   *
   * @param ***REMOVED***object***REMOVED*** operationTime the `BSON.Timestamp` of the operation type it is desired to advance to
   */
  advanceOperationTime(operationTime) ***REMOVED***
    if (this.operationTime == null) ***REMOVED***
      this.operationTime = operationTime;
      return;
    ***REMOVED***

    if (operationTime.greaterThan(this.operationTime)) ***REMOVED***
      this.operationTime = operationTime;
    ***REMOVED***
  ***REMOVED***

  /**
   * Used to determine if this session equals another
   */
  equals(session) ***REMOVED***
    if (!(session instanceof ClientSession)) ***REMOVED***
      return false;
    ***REMOVED***

    return this.id.id.buffer.equals(session.id.id.buffer);
  ***REMOVED***
***REMOVED***

Object.defineProperty(ClientSession.prototype, 'id', ***REMOVED***
  get: function() ***REMOVED***
    return this.serverSession.id;
  ***REMOVED***
***REMOVED***);

/**
 *
 */
class ServerSession ***REMOVED***
  constructor() ***REMOVED***
    this.id = ***REMOVED*** id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) ***REMOVED***;
    this.lastUse = Date.now();
    this.txnNumber = 0;
  ***REMOVED***

  /**
   *
   * @param ***REMOVED*******REMOVED*** sessionTimeoutMinutes
   */
  hasTimedOut(sessionTimeoutMinutes) ***REMOVED***
    // Take the difference of the lastUse timestamp and now, which will result in a value in
    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`
    const idleTimeMinutes = Math.round(
      (((Date.now() - this.lastUse) % 86400000) % 3600000) / 60000
    );

    return idleTimeMinutes > sessionTimeoutMinutes - 1;
  ***REMOVED***
***REMOVED***

/**
 *
 */
class ServerSessionPool ***REMOVED***
  constructor(topology) ***REMOVED***
    if (topology == null) ***REMOVED***
      throw new Error('ServerSessionPool requires a topology');
    ***REMOVED***

    this.topology = topology;
    this.sessions = [];
  ***REMOVED***

  endAllPooledSessions() ***REMOVED***
    if (this.sessions.length) ***REMOVED***
      this.topology.endSessions(this.sessions.map(session => session.id));
      this.sessions = [];
    ***REMOVED***
  ***REMOVED***

  /**
   * @returns ***REMOVED***ServerSession***REMOVED***
   */
  acquire() ***REMOVED***
    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
    while (this.sessions.length) ***REMOVED***
      const session = this.sessions.shift();
      if (!session.hasTimedOut(sessionTimeoutMinutes)) ***REMOVED***
        return session;
      ***REMOVED***
    ***REMOVED***

    return new ServerSession();
  ***REMOVED***

  /**
   *
   * @param ***REMOVED*******REMOVED*** session
   */
  release(session) ***REMOVED***
    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
    while (this.sessions.length) ***REMOVED***
      const session = this.sessions[this.sessions.length - 1];
      if (session.hasTimedOut(sessionTimeoutMinutes)) ***REMOVED***
        this.sessions.pop();
      ***REMOVED*** else ***REMOVED***
        break;
      ***REMOVED***
    ***REMOVED***

    if (!session.hasTimedOut(sessionTimeoutMinutes)) ***REMOVED***
      this.sessions.unshift(session);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

module.exports = ***REMOVED***
  ClientSession: ClientSession,
  ServerSession: ServerSession,
  ServerSessionPool: ServerSessionPool
***REMOVED***;
