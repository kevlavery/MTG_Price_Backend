'use strict';

const retrieveBSON = require('./connection/utils').retrieveBSON;
const EventEmitter = require('events');
const BSON = retrieveBSON();
const Binary = BSON.Binary;
const uuidV4 = require('./utils').uuidV4;
const MongoError = require('./error').MongoError;
const isRetryableError = require('././error').isRetryableError;
const MongoNetworkError = require('./error').MongoNetworkError;
const MongoWriteConcernError = require('./error').MongoWriteConcernError;
const Transaction = require('./transactions').Transaction;
const TxnState = require('./transactions').TxnState;

function assertAlive(session, callback) ***REMOVED***
  if (session.serverSession == null) ***REMOVED***
    const error = new MongoError('Cannot use a session that has ended');
    if (typeof callback === 'function') ***REMOVED***
      callback(error, null);
      return false;
    ***REMOVED***

    throw error;
  ***REMOVED***

  return true;
***REMOVED***

/** A class representing a client session on the server */
class ClientSession extends EventEmitter ***REMOVED***
  /**
   * Create a client session.
   * WARNING: not meant to be instantiated directly
   *
   * @param ***REMOVED***Topology***REMOVED*** topology The current client's topology
   * @param ***REMOVED***ServerSessionPool***REMOVED*** sessionPool The server session pool
   * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
   * @param ***REMOVED***Boolean***REMOVED*** [options.causalConsistency] Whether causal consistency should be enabled on this session
   * @param ***REMOVED***Boolean***REMOVED*** [options.autoStartTransaction=false] When enabled this session automatically starts a transaction with the provided defaultTransactionOptions.
   * @param ***REMOVED***Object***REMOVED*** [options.defaultTransactionOptions] The default TransactionOptions to use for transactions started on this session.
   * @param ***REMOVED***Object***REMOVED*** [clientOptions] Optional settings provided when creating a client in the porcelain driver
   */
  constructor(topology, sessionPool, options, clientOptions) ***REMOVED***
    super();

    if (topology == null) ***REMOVED***
      throw new Error('ClientSession requires a topology');
    ***REMOVED***

    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) ***REMOVED***
      throw new Error('ClientSession requires a ServerSessionPool');
    ***REMOVED***

    options = options || ***REMOVED******REMOVED***;
    this.topology = topology;
    this.sessionPool = sessionPool;
    this.hasEnded = false;
    this.serverSession = sessionPool.acquire();
    this.clientOptions = clientOptions;

    this.supports = ***REMOVED***
      causalConsistency:
        typeof options.causalConsistency !== 'undefined' ? options.causalConsistency : true
    ***REMOVED***;

    options = options || ***REMOVED******REMOVED***;
    if (typeof options.initialClusterTime !== 'undefined') ***REMOVED***
      this.clusterTime = options.initialClusterTime;
    ***REMOVED*** else ***REMOVED***
      this.clusterTime = null;
    ***REMOVED***

    this.operationTime = null;
    this.explicit = !!options.explicit;
    this.owner = options.owner;
    this.defaultTransactionOptions = Object.assign(***REMOVED******REMOVED***, options.defaultTransactionOptions);
    this.transaction = new Transaction();
  ***REMOVED***

  /**
   * Return the server id associated with this session
   */
  get id() ***REMOVED***
    return this.serverSession.id;
  ***REMOVED***

  /**
   * Ends this session on the server
   *
   * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
   * @param ***REMOVED***Function***REMOVED*** [callback] Optional callback for completion of this operation
   */
  endSession(options, callback) ***REMOVED***
    if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
    options = options || ***REMOVED******REMOVED***;

    if (this.hasEnded) ***REMOVED***
      if (typeof callback === 'function') callback(null, null);
      return;
    ***REMOVED***

    if (this.serverSession && this.inTransaction()) ***REMOVED***
      this.abortTransaction(); // pass in callback?
    ***REMOVED***

    // mark the session as ended, and emit a signal
    this.hasEnded = true;
    this.emit('ended', this);

    // release the server session back to the pool
    this.sessionPool.release(this.serverSession);

    // spec indicates that we should ignore all errors for `endSessions`
    if (typeof callback === 'function') callback(null, null);
  ***REMOVED***

  /**
   * Advances the operationTime for a ClientSession.
   *
   * @param ***REMOVED***object***REMOVED*** operationTime the `BSON.Timestamp` of the operation type it is desired to advance to
   */
  advanceOperationTime(operationTime) ***REMOVED***
    if (this.operationTime == null) ***REMOVED***
      this.operationTime = operationTime;
      return;
    ***REMOVED***

    if (operationTime.greaterThan(this.operationTime)) ***REMOVED***
      this.operationTime = operationTime;
    ***REMOVED***
  ***REMOVED***

  /**
   * Used to determine if this session equals another
   */
  equals(session) ***REMOVED***
    if (!(session instanceof ClientSession)) ***REMOVED***
      return false;
    ***REMOVED***

    return this.id.id.buffer.equals(session.id.id.buffer);
  ***REMOVED***

  /**
   * Increment the transaction number on the internal ServerSession
   */
  incrementTransactionNumber() ***REMOVED***
    this.serverSession.txnNumber++;
  ***REMOVED***

  /**
   * @returns whether this session is current in a transaction or not
   */
  inTransaction() ***REMOVED***
    return this.transaction.isActive;
  ***REMOVED***

  /**
   * Starts a new transaction with the given options.
   *
   * @param ***REMOVED***Object***REMOVED*** options Optional settings
   * @param ***REMOVED***ReadConcern***REMOVED*** [options.readConcern] The readConcern to use for this transaction
   * @param ***REMOVED***WriteConcern***REMOVED*** [options.writeConcern] The writeConcern to use for this transaction
   */
  startTransaction(options) ***REMOVED***
    assertAlive(this);
    if (this.inTransaction()) ***REMOVED***
      throw new MongoError('Transaction already in progress');
    ***REMOVED***

    // increment txnNumber
    this.incrementTransactionNumber();

    // create transaction state
    this.transaction = new Transaction(
      Object.assign(***REMOVED******REMOVED***, this.clientOptions, options || this.defaultTransactionOptions)
    );

    this.transaction.transition(TxnState.STARTING_TRANSACTION);
  ***REMOVED***

  /**
   * Commits the currently active transaction in this session.
   *
   * @param ***REMOVED***Function***REMOVED*** [callback] optional callback for completion of this operation
   * @return ***REMOVED***Promise***REMOVED*** A promise is returned if no callback is provided
   */
  commitTransaction(callback) ***REMOVED***
    if (typeof callback === 'function') ***REMOVED***
      endTransaction(this, 'commitTransaction', callback);
      return;
    ***REMOVED***

    return new Promise((resolve, reject) => ***REMOVED***
      endTransaction(
        this,
        'commitTransaction',
        (err, reply) => (err ? reject(err) : resolve(reply))
      );
    ***REMOVED***);
  ***REMOVED***

  /**
   * Aborts the currently active transaction in this session.
   *
   * @param ***REMOVED***Function***REMOVED*** [callback] optional callback for completion of this operation
   * @return ***REMOVED***Promise***REMOVED*** A promise is returned if no callback is provided
   */
  abortTransaction(callback) ***REMOVED***
    if (typeof callback === 'function') ***REMOVED***
      endTransaction(this, 'abortTransaction', callback);
      return;
    ***REMOVED***

    return new Promise((resolve, reject) => ***REMOVED***
      endTransaction(
        this,
        'abortTransaction',
        (err, reply) => (err ? reject(err) : resolve(reply))
      );
    ***REMOVED***);
  ***REMOVED***

  toBSON() ***REMOVED***
    throw new Error('ClientSession cannot be serialized to BSON.');
  ***REMOVED***
***REMOVED***

function endTransaction(session, commandName, callback) ***REMOVED***
  if (!assertAlive(session, callback)) ***REMOVED***
    // checking result in case callback was called
    return;
  ***REMOVED***

  // handle any initial problematic cases
  let txnState = session.transaction.state;

  if (txnState === TxnState.NO_TRANSACTION) ***REMOVED***
    callback(new MongoError('No transaction started'));
    return;
  ***REMOVED***

  if (commandName === 'commitTransaction') ***REMOVED***
    if (
      txnState === TxnState.STARTING_TRANSACTION ||
      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY
    ) ***REMOVED***
      // the transaction was never started, we can safely exit here
      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);
      callback(null, null);
      return;
    ***REMOVED***

    if (txnState === TxnState.TRANSACTION_ABORTED) ***REMOVED***
      callback(new MongoError('Cannot call commitTransaction after calling abortTransaction'));
      return;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    if (txnState === TxnState.STARTING_TRANSACTION) ***REMOVED***
      // the transaction was never started, we can safely exit here
      session.transaction.transition(TxnState.TRANSACTION_ABORTED);
      callback(null, null);
      return;
    ***REMOVED***

    if (txnState === TxnState.TRANSACTION_ABORTED) ***REMOVED***
      callback(new MongoError('Cannot call abortTransaction twice'));
      return;
    ***REMOVED***

    if (
      txnState === TxnState.TRANSACTION_COMMITTED ||
      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY
    ) ***REMOVED***
      callback(new MongoError('Cannot call abortTransaction after calling commitTransaction'));
      return;
    ***REMOVED***
  ***REMOVED***

  // construct and send the command
  const command = ***REMOVED*** [commandName]: 1 ***REMOVED***;

  // apply a writeConcern if specified
  if (session.transaction.options.writeConcern) ***REMOVED***
    Object.assign(command, ***REMOVED*** writeConcern: session.transaction.options.writeConcern ***REMOVED***);
  ***REMOVED*** else if (session.clientOptions && session.clientOptions.w) ***REMOVED***
    Object.assign(command, ***REMOVED*** writeConcern: ***REMOVED*** w: session.clientOptions.w ***REMOVED*** ***REMOVED***);
  ***REMOVED***

  function commandHandler(e, r) ***REMOVED***
    if (commandName === 'commitTransaction') ***REMOVED***
      session.transaction.transition(TxnState.TRANSACTION_COMMITTED);

      if (
        e &&
        (e instanceof MongoNetworkError ||
          e instanceof MongoWriteConcernError ||
          isRetryableError(e))
      ) ***REMOVED***
        if (e.errorLabels) ***REMOVED***
          const idx = e.errorLabels.indexOf('TransientTransactionError');
          if (idx !== -1) ***REMOVED***
            e.errorLabels.splice(idx, 1);
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          e.errorLabels = [];
        ***REMOVED***

        e.errorLabels.push('UnknownTransactionCommitResult');
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      session.transaction.transition(TxnState.TRANSACTION_ABORTED);
    ***REMOVED***

    callback(e, r);
  ***REMOVED***

  // The spec indicates that we should ignore all errors on `abortTransaction`
  function transactionError(err) ***REMOVED***
    return commandName === 'commitTransaction' ? err : null;
  ***REMOVED***

  // send the command
  session.topology.command('admin.$cmd', command, ***REMOVED*** session ***REMOVED***, (err, reply) => ***REMOVED***
    if (err && isRetryableError(err)) ***REMOVED***
      return session.topology.command('admin.$cmd', command, ***REMOVED*** session ***REMOVED***, (_err, _reply) =>
        commandHandler(transactionError(_err), _reply)
      );
    ***REMOVED***

    commandHandler(transactionError(err), reply);
  ***REMOVED***);
***REMOVED***

/**
 *
 */
class ServerSession ***REMOVED***
  constructor() ***REMOVED***
    this.id = ***REMOVED*** id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) ***REMOVED***;
    this.lastUse = Date.now();
    this.txnNumber = 0;
  ***REMOVED***

  /**
   *
   * @param ***REMOVED*******REMOVED*** sessionTimeoutMinutes
   */
  hasTimedOut(sessionTimeoutMinutes) ***REMOVED***
    // Take the difference of the lastUse timestamp and now, which will result in a value in
    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`
    const idleTimeMinutes = Math.round(
      (((Date.now() - this.lastUse) % 86400000) % 3600000) / 60000
    );

    return idleTimeMinutes > sessionTimeoutMinutes - 1;
  ***REMOVED***
***REMOVED***

/**
 *
 */
class ServerSessionPool ***REMOVED***
  constructor(topology) ***REMOVED***
    if (topology == null) ***REMOVED***
      throw new Error('ServerSessionPool requires a topology');
    ***REMOVED***

    this.topology = topology;
    this.sessions = [];
  ***REMOVED***

  endAllPooledSessions() ***REMOVED***
    if (this.sessions.length) ***REMOVED***
      this.topology.endSessions(this.sessions.map(session => session.id));
      this.sessions = [];
    ***REMOVED***
  ***REMOVED***

  /**
   * @returns ***REMOVED***ServerSession***REMOVED***
   */
  acquire() ***REMOVED***
    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
    while (this.sessions.length) ***REMOVED***
      const session = this.sessions.shift();
      if (!session.hasTimedOut(sessionTimeoutMinutes)) ***REMOVED***
        return session;
      ***REMOVED***
    ***REMOVED***

    return new ServerSession();
  ***REMOVED***

  /**
   *
   * @param ***REMOVED*******REMOVED*** session
   */
  release(session) ***REMOVED***
    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
    while (this.sessions.length) ***REMOVED***
      const session = this.sessions[this.sessions.length - 1];
      if (session.hasTimedOut(sessionTimeoutMinutes)) ***REMOVED***
        this.sessions.pop();
      ***REMOVED*** else ***REMOVED***
        break;
      ***REMOVED***
    ***REMOVED***

    if (!session.hasTimedOut(sessionTimeoutMinutes)) ***REMOVED***
      this.sessions.unshift(session);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

module.exports = ***REMOVED***
  ClientSession,
  ServerSession,
  ServerSessionPool,
  TxnState
***REMOVED***;
