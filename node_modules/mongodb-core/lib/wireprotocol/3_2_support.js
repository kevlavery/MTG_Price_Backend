'use strict';

var Query = require('../connection/commands').Query,
  retrieveBSON = require('../connection/utils').retrieveBSON,
  f = require('util').format,
  MongoError = require('../error').MongoError,
  MongoNetworkError = require('../error').MongoNetworkError,
  getReadPreference = require('./shared').getReadPreference;

var BSON = retrieveBSON(),
  Long = BSON.Long;

var WireProtocol = function(legacyWireProtocol) ***REMOVED***
  this.legacyWireProtocol = legacyWireProtocol;
***REMOVED***;

//
// Execute a write operation
var executeWrite = function(pool, bson, type, opsField, ns, ops, options, callback) ***REMOVED***
  if (ops.length === 0) throw new MongoError('insert must contain at least one document');
  if (typeof options === 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
    options = options || ***REMOVED******REMOVED***;
  ***REMOVED***

  // Split the ns up to get db and collection
  var p = ns.split('.');
  var d = p.shift();
  // Options
  var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
  var writeConcern = options.writeConcern;

  // return skeleton
  var writeCommand = ***REMOVED******REMOVED***;
  writeCommand[type] = p.join('.');
  writeCommand[opsField] = ops;
  writeCommand.ordered = ordered;

  // Did we specify a write concern
  if (writeConcern && Object.keys(writeConcern).length > 0) ***REMOVED***
    writeCommand.writeConcern = writeConcern;
  ***REMOVED***

  // If we have collation passed in
  if (options.collation) ***REMOVED***
    for (var i = 0; i < writeCommand[opsField].length; i++) ***REMOVED***
      if (!writeCommand[opsField][i].collation) ***REMOVED***
        writeCommand[opsField][i].collation = options.collation;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Do we have bypassDocumentValidation set, then enable it on the write command
  if (typeof options.bypassDocumentValidation === 'boolean') ***REMOVED***
    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;
  ***REMOVED***

  // optionally add a `txnNumber` if retryable writes are being attempted
  if (typeof options.txnNumber !== 'undefined') ***REMOVED***
    writeCommand.txnNumber = options.txnNumber;
  ***REMOVED***

  // Options object
  var opts = ***REMOVED*** command: true ***REMOVED***;
  if (typeof options.session !== 'undefined') opts.session = options.session;
  var queryOptions = ***REMOVED*** checkKeys: false, numberToSkip: 0, numberToReturn: 1 ***REMOVED***;
  if (type === 'insert') queryOptions.checkKeys = false;
  if (typeof options.checkKeys === 'boolean') queryOptions.checkKeys = options.checkKeys;

  // Ensure we support serialization of functions
  if (options.serializeFunctions) queryOptions.serializeFunctions = options.serializeFunctions;
  // Do not serialize the undefined fields
  if (options.ignoreUndefined) queryOptions.ignoreUndefined = options.ignoreUndefined;

  try ***REMOVED***
    // Create write command
    var cmd = new Query(bson, f('%s.$cmd', d), writeCommand, queryOptions);
    // Execute command
    pool.write(cmd, opts, callback);
  ***REMOVED*** catch (err) ***REMOVED***
    callback(err);
  ***REMOVED***
***REMOVED***;

//
// Needs to support legacy mass insert as well as ordered/unordered legacy
// emulation
//
WireProtocol.prototype.insert = function(pool, ismaster, ns, bson, ops, options, callback) ***REMOVED***
  executeWrite(pool, bson, 'insert', 'documents', ns, ops, options, callback);
***REMOVED***;

WireProtocol.prototype.update = function(pool, ismaster, ns, bson, ops, options, callback) ***REMOVED***
  executeWrite(pool, bson, 'update', 'updates', ns, ops, options, callback);
***REMOVED***;

WireProtocol.prototype.remove = function(pool, ismaster, ns, bson, ops, options, callback) ***REMOVED***
  executeWrite(pool, bson, 'delete', 'deletes', ns, ops, options, callback);
***REMOVED***;

WireProtocol.prototype.killCursor = function(bson, ns, cursorState, pool, callback) ***REMOVED***
  // Build command namespace
  var parts = ns.split(/\./);
  // Command namespace
  var commandns = f('%s.$cmd', parts.shift());
  const cursorId = cursorState.cursorId;
  // Create killCursor command
  var killcursorCmd = ***REMOVED***
    killCursors: parts.join('.'),
    cursors: [cursorId]
  ***REMOVED***;

  // Build Query object
  var query = new Query(bson, commandns, killcursorCmd, ***REMOVED***
    numberToSkip: 0,
    numberToReturn: -1,
    checkKeys: false,
    returnFieldSelector: null
  ***REMOVED***);

  // Set query flags
  query.slaveOk = true;

  // Kill cursor callback
  var killCursorCallback = function(err, result) ***REMOVED***
    if (err) ***REMOVED***
      if (typeof callback !== 'function') return;
      return callback(err);
    ***REMOVED***

    // Result
    var r = result.message;
    // If we have a timed out query or a cursor that was killed
    if ((r.responseFlags & (1 << 0)) !== 0) ***REMOVED***
      if (typeof callback !== 'function') return;
      return callback(new MongoNetworkError('cursor killed or timed out'), null);
    ***REMOVED***

    if (!Array.isArray(r.documents) || r.documents.length === 0) ***REMOVED***
      if (typeof callback !== 'function') return;
      return callback(
        new MongoError(f('invalid killCursors result returned for cursor id %s', cursorId))
      );
    ***REMOVED***

    // Return the result
    if (typeof callback === 'function') ***REMOVED***
      callback(null, r.documents[0]);
    ***REMOVED***
  ***REMOVED***;

  const options = ***REMOVED*** command: true ***REMOVED***;
  if (typeof cursorState.session === 'object') ***REMOVED***
    options.session = cursorState.session;
  ***REMOVED***

  // Execute the kill cursor command
  if (pool && pool.isConnected()) ***REMOVED***
    try ***REMOVED***
      pool.write(query, options, killCursorCallback);
    ***REMOVED*** catch (err) ***REMOVED***
      killCursorCallback(err, null);
    ***REMOVED***

    return;
  ***REMOVED***

  // Callback
  if (typeof callback === 'function') callback(null, null);
***REMOVED***;

WireProtocol.prototype.getMore = function(
  bson,
  ns,
  cursorState,
  batchSize,
  raw,
  connection,
  options,
  callback
) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Build command namespace
  var parts = ns.split(/\./);
  // Command namespace
  var commandns = f('%s.$cmd', parts.shift());

  // Create getMore command
  var getMoreCmd = ***REMOVED***
    getMore: cursorState.cursorId,
    collection: parts.join('.'),
    batchSize: Math.abs(batchSize)
  ***REMOVED***;

  if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === 'number') ***REMOVED***
    getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
  ***REMOVED***

  // Build Query object
  var query = new Query(bson, commandns, getMoreCmd, ***REMOVED***
    numberToSkip: 0,
    numberToReturn: -1,
    checkKeys: false,
    returnFieldSelector: null
  ***REMOVED***);

  // Set query flags
  query.slaveOk = true;

  // Query callback
  var queryCallback = function(err, result) ***REMOVED***
    if (err) return callback(err);
    // Get the raw message
    var r = result.message;

    // If we have a timed out query or a cursor that was killed
    if ((r.responseFlags & (1 << 0)) !== 0) ***REMOVED***
      return callback(new MongoNetworkError('cursor killed or timed out'), null);
    ***REMOVED***

    // Raw, return all the extracted documents
    if (raw) ***REMOVED***
      cursorState.documents = r.documents;
      cursorState.cursorId = r.cursorId;
      return callback(null, r.documents);
    ***REMOVED***

    // We have an error detected
    if (r.documents[0].ok === 0) ***REMOVED***
      return callback(new MongoError(r.documents[0]));
    ***REMOVED***

    // Ensure we have a Long valid cursor id
    var cursorId =
      typeof r.documents[0].cursor.id === 'number'
        ? Long.fromNumber(r.documents[0].cursor.id)
        : r.documents[0].cursor.id;

    // Set all the values
    cursorState.documents = r.documents[0].cursor.nextBatch;
    cursorState.cursorId = cursorId;

    // Return the result
    callback(null, r.documents[0], r.connection);
  ***REMOVED***;

  // Query options
  var queryOptions = ***REMOVED*** command: true ***REMOVED***;

  // If we have a raw query decorate the function
  if (raw) ***REMOVED***
    queryOptions.raw = raw;
  ***REMOVED***

  // Add the result field needed
  queryOptions.documentsReturnedIn = 'nextBatch';

  // Check if we need to promote longs
  if (typeof cursorState.promoteLongs === 'boolean') ***REMOVED***
    queryOptions.promoteLongs = cursorState.promoteLongs;
  ***REMOVED***

  if (typeof cursorState.promoteValues === 'boolean') ***REMOVED***
    queryOptions.promoteValues = cursorState.promoteValues;
  ***REMOVED***

  if (typeof cursorState.promoteBuffers === 'boolean') ***REMOVED***
    queryOptions.promoteBuffers = cursorState.promoteBuffers;
  ***REMOVED***

  if (typeof cursorState.session === 'object') ***REMOVED***
    queryOptions.session = cursorState.session;
  ***REMOVED***

  // Write out the getMore command
  connection.write(query, queryOptions, queryCallback);
***REMOVED***;

WireProtocol.prototype.command = function(bson, ns, cmd, cursorState, topology, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Check if this is a wire protocol command or not
  var wireProtocolCommand =
    typeof options.wireProtocolCommand === 'boolean' ? options.wireProtocolCommand : true;

  // Establish type of command
  if (cmd.find && wireProtocolCommand) ***REMOVED***
    // Create the find command
    var query = executeFindCommand(bson, ns, cmd, cursorState, topology, options);
    // Mark the cmd as virtual
    cmd.virtual = false;
    // Signal the documents are in the firstBatch value
    query.documentsReturnedIn = 'firstBatch';
    // Return the query
    return query;
  ***REMOVED*** else if (cursorState.cursorId != null) ***REMOVED***
    return;
  ***REMOVED*** else if (cmd) ***REMOVED***
    return setupCommand(bson, ns, cmd, cursorState, topology, options);
  ***REMOVED*** else ***REMOVED***
    throw new MongoError(f('command %s does not return a cursor', JSON.stringify(cmd)));
  ***REMOVED***
***REMOVED***;

// // Command
// ***REMOVED***
//     find: ns
//   , query: <object>
//   , limit: <n>
//   , fields: <object>
//   , skip: <n>
//   , hint: <string>
//   , explain: <boolean>
//   , snapshot: <boolean>
//   , batchSize: <n>
//   , returnKey: <boolean>
//   , maxScan: <n>
//   , min: <n>
//   , max: <n>
//   , showDiskLoc: <boolean>
//   , comment: <string>
//   , maxTimeMS: <n>
//   , raw: <boolean>
//   , readPreference: <ReadPreference>
//   , tailable: <boolean>
//   , oplogReplay: <boolean>
//   , noCursorTimeout: <boolean>
//   , awaitdata: <boolean>
//   , exhaust: <boolean>
//   , partial: <boolean>
// ***REMOVED***

// FIND/GETMORE SPEC
// ***REMOVED***
//     “find”: <string>,
//     “filter”: ***REMOVED*** ... ***REMOVED***,
//     “sort”: ***REMOVED*** ... ***REMOVED***,
//     “projection”: ***REMOVED*** ... ***REMOVED***,
//     “hint”: ***REMOVED*** ... ***REMOVED***,
//     “skip”: <int>,
//     “limit”: <int>,
//     “batchSize”: <int>,
//     “singleBatch”: <bool>,
//     “comment”: <string>,
//     “maxScan”: <int>,
//     “maxTimeMS”: <int>,
//     “max”: ***REMOVED*** ... ***REMOVED***,
//     “min”: ***REMOVED*** ... ***REMOVED***,
//     “returnKey”: <bool>,
//     “showRecordId”: <bool>,
//     “snapshot”: <bool>,
//     “tailable”: <bool>,
//     “oplogReplay”: <bool>,
//     “noCursorTimeout”: <bool>,
//     “awaitData”: <bool>,
//     “partial”: <bool>,
//     “$readPreference”: ***REMOVED*** ... ***REMOVED***
// ***REMOVED***

//
// Execute a find command
var executeFindCommand = function(bson, ns, cmd, cursorState, topology, options) ***REMOVED***
  // Ensure we have at least some options
  options = options || ***REMOVED******REMOVED***;
  // Get the readPreference
  var readPreference = getReadPreference(cmd, options);
  // Set the optional batchSize
  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;

  // Build command namespace
  var parts = ns.split(/\./);
  // Command namespace
  var commandns = f('%s.$cmd', parts.shift());

  // Build actual find command
  var findCmd = ***REMOVED***
    find: parts.join('.')
  ***REMOVED***;

  // I we provided a filter
  if (cmd.query) ***REMOVED***
    // Check if the user is passing in the $query parameter
    if (cmd.query['$query']) ***REMOVED***
      findCmd.filter = cmd.query['$query'];
    ***REMOVED*** else ***REMOVED***
      findCmd.filter = cmd.query;
    ***REMOVED***
  ***REMOVED***

  // Sort value
  var sortValue = cmd.sort;

  // Handle issue of sort being an Array
  if (Array.isArray(sortValue)) ***REMOVED***
    var sortObject = ***REMOVED******REMOVED***;

    if (sortValue.length > 0 && !Array.isArray(sortValue[0])) ***REMOVED***
      var sortDirection = sortValue[1];
      // Translate the sort order text
      if (sortDirection === 'asc') ***REMOVED***
        sortDirection = 1;
      ***REMOVED*** else if (sortDirection === 'desc') ***REMOVED***
        sortDirection = -1;
      ***REMOVED***

      // Set the sort order
      sortObject[sortValue[0]] = sortDirection;
    ***REMOVED*** else ***REMOVED***
      for (var i = 0; i < sortValue.length; i++) ***REMOVED***
        sortDirection = sortValue[i][1];
        // Translate the sort order text
        if (sortDirection === 'asc') ***REMOVED***
          sortDirection = 1;
        ***REMOVED*** else if (sortDirection === 'desc') ***REMOVED***
          sortDirection = -1;
        ***REMOVED***

        // Set the sort order
        sortObject[sortValue[i][0]] = sortDirection;
      ***REMOVED***
    ***REMOVED***

    sortValue = sortObject;
  ***REMOVED***

  // Add sort to command
  if (cmd.sort) findCmd.sort = sortValue;
  // Add a projection to the command
  if (cmd.fields) findCmd.projection = cmd.fields;
  // Add a hint to the command
  if (cmd.hint) findCmd.hint = cmd.hint;
  // Add a skip
  if (cmd.skip) findCmd.skip = cmd.skip;
  // Add a limit
  if (cmd.limit) findCmd.limit = cmd.limit;

  // Check if we wish to have a singleBatch
  if (cmd.limit < 0) ***REMOVED***
    findCmd.limit = Math.abs(cmd.limit);
    findCmd.singleBatch = true;
  ***REMOVED***

  // Add a batchSize
  if (typeof cmd.batchSize === 'number') ***REMOVED***
    if (cmd.batchSize < 0) ***REMOVED***
      if (cmd.limit !== 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) ***REMOVED***
        findCmd.limit = Math.abs(cmd.batchSize);
      ***REMOVED***

      findCmd.singleBatch = true;
    ***REMOVED***

    findCmd.batchSize = Math.abs(cmd.batchSize);
  ***REMOVED***

  // If we have comment set
  if (cmd.comment) findCmd.comment = cmd.comment;

  // If we have maxScan
  if (cmd.maxScan) findCmd.maxScan = cmd.maxScan;

  // If we have maxTimeMS set
  if (cmd.maxTimeMS) findCmd.maxTimeMS = cmd.maxTimeMS;

  // If we have min
  if (cmd.min) findCmd.min = cmd.min;

  // If we have max
  if (cmd.max) findCmd.max = cmd.max;

  // If we have returnKey set
  findCmd.returnKey = cmd.returnKey ? cmd.returnKey : false;

  // If we have showDiskLoc set
  findCmd.showRecordId = cmd.showDiskLoc ? cmd.showDiskLoc : false;

  // If we have snapshot set
  if (cmd.snapshot) findCmd.snapshot = cmd.snapshot;

  // If we have tailable set
  if (cmd.tailable) findCmd.tailable = cmd.tailable;

  // If we have oplogReplay set
  if (cmd.oplogReplay) findCmd.oplogReplay = cmd.oplogReplay;

  // If we have noCursorTimeout set
  if (cmd.noCursorTimeout) findCmd.noCursorTimeout = cmd.noCursorTimeout;

  // If we have awaitData set
  if (cmd.awaitData) findCmd.awaitData = cmd.awaitData;
  if (cmd.awaitdata) findCmd.awaitData = cmd.awaitdata;

  // If we have partial set
  if (cmd.partial) findCmd.partial = cmd.partial;

  // If we have collation passed in
  if (cmd.collation) findCmd.collation = cmd.collation;

  // If we have explain, we need to rewrite the find command
  // to wrap it in the explain command
  if (cmd.explain) ***REMOVED***
    findCmd = ***REMOVED***
      explain: findCmd
    ***REMOVED***;
  ***REMOVED***

  // Did we provide a readConcern
  if (cmd.readConcern) findCmd.readConcern = cmd.readConcern;

  // Set up the serialize and ignoreUndefined fields
  var serializeFunctions =
    typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
  var ignoreUndefined =
    typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;

  // We have a Mongos topology, check if we need to add a readPreference
  if (topology.type === 'mongos' && readPreference && readPreference.preference !== 'primary') ***REMOVED***
    findCmd = ***REMOVED***
      $query: findCmd,
      $readPreference: readPreference.toJSON()
    ***REMOVED***;
  ***REMOVED***

  // Build Query object
  var query = new Query(bson, commandns, findCmd, ***REMOVED***
    numberToSkip: 0,
    numberToReturn: 1,
    checkKeys: false,
    returnFieldSelector: null,
    serializeFunctions: serializeFunctions,
    ignoreUndefined: ignoreUndefined
  ***REMOVED***);

  // Set query flags
  query.slaveOk = readPreference.slaveOk();

  // Return the query
  return query;
***REMOVED***;

//
// Set up a command cursor
var setupCommand = function(bson, ns, cmd, cursorState, topology, options) ***REMOVED***
  // Set empty options object
  options = options || ***REMOVED******REMOVED***;
  // Get the readPreference
  var readPreference = getReadPreference(cmd, options);

  // Final query
  var finalCmd = ***REMOVED******REMOVED***;
  for (var name in cmd) ***REMOVED***
    finalCmd[name] = cmd[name];
  ***REMOVED***

  // Build command namespace
  var parts = ns.split(/\./);

  // Serialize functions
  var serializeFunctions =
    typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;

  // Set up the serialize and ignoreUndefined fields
  var ignoreUndefined =
    typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;

  // We have a Mongos topology, check if we need to add a readPreference
  if (topology.type === 'mongos' && readPreference && readPreference.preference !== 'primary') ***REMOVED***
    finalCmd = ***REMOVED***
      $query: finalCmd,
      $readPreference: readPreference.toJSON()
    ***REMOVED***;
  ***REMOVED***

  // Build Query object
  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, ***REMOVED***
    numberToSkip: 0,
    numberToReturn: -1,
    checkKeys: false,
    serializeFunctions: serializeFunctions,
    ignoreUndefined: ignoreUndefined
  ***REMOVED***);

  // Set query flags
  query.slaveOk = readPreference.slaveOk();

  // Return the query
  return query;
***REMOVED***;

module.exports = WireProtocol;
