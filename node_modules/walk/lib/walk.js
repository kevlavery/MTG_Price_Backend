// Adapted from work by jorge@jorgechamorro.com on 2010-11-25
(function () ***REMOVED***
  "use strict";

  function noop() ***REMOVED******REMOVED***

  var fs = require('fs')
    , forEachAsync = require('foreachasync').forEachAsync
    , EventEmitter = require('events').EventEmitter
    , TypeEmitter = require('./node-type-emitter')
    , util = require('util')
    , path = require('path')
    ;

  function appendToDirs(stat) ***REMOVED***
    /*jshint validthis:true*/
    this.push(stat.name);
  ***REMOVED***

  function wFilesHandlerWrapper(items) ***REMOVED***
    /*jshint validthis:true*/
    this._wFilesHandler(noop, items);
  ***REMOVED***

  function Walker(pathname, options, sync) ***REMOVED***
    EventEmitter.call(this);

    var me = this
      ;

    options = options || ***REMOVED******REMOVED***;
    me._wStat = options.followLinks && 'stat' || 'lstat';
    me._wStatSync = me._wStat + 'Sync';
    me._wsync = sync;
    me._wq = [];
    me._wqueue = [me._wq];
    me._wcurpath = undefined;
    me._wfilters = options.filters || [];
    me._wfirstrun = true;
    me._wcurpath = pathname;

    if (me._wsync) ***REMOVED***
      //console.log('_walkSync');
      me._wWalk = me._wWalkSync;
    ***REMOVED*** else ***REMOVED***
      //console.log('_walkASync');
      me._wWalk = me._wWalkAsync;
    ***REMOVED***

    options.listeners = options.listeners || ***REMOVED******REMOVED***;
    Object.keys(options.listeners).forEach(function (event) ***REMOVED***
      var callbacks = options.listeners[event]
        ;

      if ('function' === typeof callbacks) ***REMOVED***
        callbacks = [callbacks];
      ***REMOVED***

      callbacks.forEach(function (callback) ***REMOVED***
        me.on(event, callback);
      ***REMOVED***);
    ***REMOVED***);

    me._wWalk();
  ***REMOVED***

  // Inherits must come before prototype additions
  util.inherits(Walker, EventEmitter);

  Walker.prototype._wLstatHandler = function (err, stat) ***REMOVED***
    var me = this
      ;

    stat = stat || ***REMOVED******REMOVED***;
    stat.name = me._wcurfile;

    if (err) ***REMOVED***
      stat.error = err;
      //me.emit('error', curpath, stat);
      // TODO v3.0 (don't noop the next if there are listeners)
      me.emit('nodeError', me._wcurpath, stat, noop);
      me._wfnodegroups.errors.push(stat);
      me._wCurFileCallback();
    ***REMOVED*** else ***REMOVED***
      TypeEmitter.sortFnodesByType(stat, me._wfnodegroups);
      // NOTE: wCurFileCallback doesn't need thisness, so this is okay
      TypeEmitter.emitNodeType(me, me._wcurpath, stat, me._wCurFileCallback, me);
    ***REMOVED***
  ***REMOVED***;
  Walker.prototype._wFilesHandler = function (cont, file) ***REMOVED***
    var statPath
      , me = this
      ;


    me._wcurfile = file;
    me._wCurFileCallback = cont;
    me.emit('name', me._wcurpath, file, noop);

    statPath = me._wcurpath + path.sep + file;

    if (!me._wsync) ***REMOVED***
      // TODO how to remove this anony?
      fs[me._wStat](statPath, function (err, stat) ***REMOVED***
        me._wLstatHandler(err, stat);
      ***REMOVED***);
      return;
    ***REMOVED***

    try ***REMOVED***
      me._wLstatHandler(null, fs[me._wStatSync](statPath));
    ***REMOVED*** catch(e) ***REMOVED***
      me._wLstatHandler(e);
    ***REMOVED***
  ***REMOVED***;
  Walker.prototype._wOnEmitDone = function () ***REMOVED***
    var me = this
      , dirs = []
      ;

    me._wfnodegroups.directories.forEach(appendToDirs, dirs);
    dirs.forEach(me._wJoinPath, me);
    me._wqueue.push(me._wq = dirs);
    me._wNext();
  ***REMOVED***;
  Walker.prototype._wPostFilesHandler = function () ***REMOVED***
    var me = this
      ;

    if (me._wfnodegroups.errors.length) ***REMOVED***
      // TODO v3.0 (don't noop the next)
      // .errors is an array of stats with ***REMOVED*** name: name, error: error ***REMOVED***
      me.emit('errors', me._wcurpath, me._wfnodegroups.errors, noop);
    ***REMOVED***
    // XXX emitNodeTypes still needs refactor
    TypeEmitter.emitNodeTypeGroups(me, me._wcurpath, me._wfnodegroups, me._wOnEmitDone, me);
  ***REMOVED***;
  Walker.prototype._wReadFiles = function () ***REMOVED***
    var me = this
      ;

    if (!me._wcurfiles || 0 === me._wcurfiles.length) ***REMOVED***
      return me._wNext();
    ***REMOVED***

    // TODO could allow user to selectively stat
    // and don't stat if there are no stat listeners
    me.emit('names', me._wcurpath, me._wcurfiles, noop);

    if (me._wsync) ***REMOVED***
      me._wcurfiles.forEach(wFilesHandlerWrapper, me);
      me._wPostFilesHandler();
    ***REMOVED*** else ***REMOVED***
      forEachAsync(me._wcurfiles, me._wFilesHandler, me).then(me._wPostFilesHandler);
    ***REMOVED***
  ***REMOVED***;
  Walker.prototype._wReaddirHandler = function (err, files) ***REMOVED***
    var fnodeGroups = TypeEmitter.createNodeGroups()
      , me = this
      , parent
      , child
      ;

    me._wfnodegroups = fnodeGroups;
    me._wcurfiles = files;

    // no error, great
    if (!err) ***REMOVED***
      me._wReadFiles();
      return;
    ***REMOVED***

    // TODO path.sep
    me._wcurpath = me._wcurpath.replace(/\/$/, '');

    // error? not first run? => directory error
    if (!me._wfirstrun) ***REMOVED***
      // TODO v3.0 (don't noop the next if there are listeners)
      me.emit('directoryError', me._wcurpath, ***REMOVED*** error: err ***REMOVED***, noop);
      // TODO v3.0
      //me.emit('directoryError', me._wcurpath.replace(/^(.*)\/.*$/, '$1'), ***REMOVED*** name: me._wcurpath.replace(/^.*\/(.*)/, '$1'), error: err ***REMOVED***, noop);
      me._wReadFiles();
      return;
    ***REMOVED***

    // error? first run? => maybe a file, maybe a true error
    me._wfirstrun = false;

    // readdir failed (might be a file), try a stat on the parent
    parent = me._wcurpath.replace(/^(.*)\/.*$/, '$1');
    fs[me._wStat](parent, function (e, stat) ***REMOVED***

      if (stat) ***REMOVED***
        // success
        // now try stat on this as a child of the parent directory
        child = me._wcurpath.replace(/^.*\/(.*)$/, '$1');
        me._wcurfiles = [child];
        me._wcurpath = parent;
      ***REMOVED*** else ***REMOVED***
        // TODO v3.0
        //me.emit('directoryError', me._wcurpath.replace(/^(.*)\/.*$/, '$1'), ***REMOVED*** name: me._wcurpath.replace(/^.*\/(.*)/, '$1'), error: err ***REMOVED***, noop);
        // TODO v3.0 (don't noop the next)
        // the original readdir error, not the parent stat error
        me.emit('nodeError', me._wcurpath, ***REMOVED*** error: err ***REMOVED***, noop);
      ***REMOVED***

      me._wReadFiles();
    ***REMOVED***);
  ***REMOVED***;
  Walker.prototype._wFilter = function () ***REMOVED***
    var me = this
      , exclude
      ;

    // Stop directories that contain filter keywords
    // from continuing through the walk process
    exclude = me._wfilters.some(function (filter) ***REMOVED***
      if (me._wcurpath.match(filter)) ***REMOVED***
        return true;
      ***REMOVED***
    ***REMOVED***);

    return exclude;
  ***REMOVED***;
  Walker.prototype._wWalkSync = function () ***REMOVED***
    //console.log('walkSync');
    var err
      , files
      , me = this
      ;

    try ***REMOVED***
      files = fs.readdirSync(me._wcurpath);
    ***REMOVED*** catch(e) ***REMOVED***
      err = e;
    ***REMOVED***

    me._wReaddirHandler(err, files);
  ***REMOVED***;
  Walker.prototype._wWalkAsync = function () ***REMOVED***
    //console.log('walkAsync');
    var me = this
      ;

    // TODO how to remove this anony?
    fs.readdir(me._wcurpath, function (err, files) ***REMOVED***
      me._wReaddirHandler(err, files);
    ***REMOVED***);
  ***REMOVED***;
  Walker.prototype._wNext = function () ***REMOVED***
    var me = this
      ;

    if (me._paused) ***REMOVED***
      return;
    ***REMOVED***
    if (me._wq.length) ***REMOVED***
      me._wcurpath = me._wq.pop();
      while (me._wq.length && me._wFilter()) ***REMOVED***
        me._wcurpath = me._wq.pop();
      ***REMOVED***
      if (me._wcurpath && !me._wFilter()) ***REMOVED***
        me._wWalk();
      ***REMOVED*** else ***REMOVED***
        me._wNext();
      ***REMOVED***
      return;
    ***REMOVED***
    me._wqueue.length -= 1;
    if (me._wqueue.length) ***REMOVED***
      me._wq = me._wqueue[me._wqueue.length - 1];
      return me._wNext();
    ***REMOVED***

    // To not break compatibility
    //process.nextTick(function () ***REMOVED***
      me.emit('end');
    //***REMOVED***);
  ***REMOVED***;
  Walker.prototype._wJoinPath = function (v, i, o) ***REMOVED***
    var me = this
      ;

    o[i] = [me._wcurpath, path.sep, v].join('');
  ***REMOVED***;
  Walker.prototype.pause = function () ***REMOVED***
    this._paused = true;
  ***REMOVED***;
  Walker.prototype.resume = function () ***REMOVED***
    this._paused = false;
    this._wNext();
  ***REMOVED***;

  exports.walk = function (path, opts) ***REMOVED***
    return new Walker(path, opts, false);
  ***REMOVED***;

  exports.walkSync = function (path, opts) ***REMOVED***
    return new Walker(path, opts, true);
  ***REMOVED***;
***REMOVED***());
