(function () ***REMOVED***
  "use strict"

  // Array.prototype.forEachAsync(next, item, i, collection)
  require('futures/forEachAsync');

  function noop() ***REMOVED******REMOVED***

  var fs = require('fs'),
    path = require('path'),
    EventEmitter = require('events').EventEmitter,
    TypeEmitter = require('./node-type-emitter');

  // 2010-11-25 jorge@jorgechamorro.com
  function create(pathname, cb) ***REMOVED***
    var emitter = new EventEmitter(),
      q = [],
      queue = [q],
      curpath;

    function walk() ***REMOVED*** 
      fs.readdir(curpath, function(err, files) ***REMOVED***
        if (err) ***REMOVED***
          emitter.emit('directoryError', curpath, ***REMOVED*** error: err ***REMOVED***, noop);
          //emitter.emit('error', curpath, ***REMOVED*** error: err ***REMOVED***);
        ***REMOVED***
        // XXX bug was here. next() was omitted
        if (!files || 0 == files.length) ***REMOVED***
          return next();
        ***REMOVED***

        var fnodeGroups = TypeEmitter.createNodeGroups();

        // TODO could allow user to selectively stat
        // and don't stat if there are no stat listeners
        emitter.emit('names', curpath, files, noop);
        files.forEachAsync(function (cont, file) ***REMOVED***
          emitter.emit('name', curpath, file, noop);
          fs.lstat(curpath + path.sep + file, function (err, stat) ***REMOVED***
            stat = stat || ***REMOVED******REMOVED***;
            stat.name = file;
            if (err) ***REMOVED***
              stat.error = err;
              //emitter.emit('error', curpath, stat);
              emitter.emit('nodeError', curpath, stat, noop);
              fnodeGroups.errors.push(stat);
              cont();
            ***REMOVED*** else ***REMOVED***
              TypeEmitter.sortFnodesByType(stat, fnodeGroups);
              TypeEmitter.emitNodeType(emitter, curpath, stat, cont);
            ***REMOVED***
          ***REMOVED***);
        ***REMOVED***).then(function () ***REMOVED***
          if (fnodeGroups.errors.length) ***REMOVED***
            emitter.emit('errors', curpath, fnodeGroups.errors, noop);
          ***REMOVED***
          TypeEmitter.emitNodeTypeGroups(emitter, curpath, fnodeGroups, function () ***REMOVED***
            var dirs = [];
            fnodeGroups.directories.forEach(function (stat) ***REMOVED***
              dirs.push(stat.name);
            ***REMOVED***);
            dirs.forEach(fullPath);
            queue.push(q = dirs);
            next();
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***
    
    function next() ***REMOVED***
      if (q.length) ***REMOVED***
        curpath = q.pop();
        return walk();
      ***REMOVED***
      if (queue.length -= 1) ***REMOVED***
        q = queue[queue.length-1];
        return next();
      ***REMOVED***
      emitter.emit('end');
    ***REMOVED***
    
    function fullPath(v,i,o) ***REMOVED***
      o[i]= [curpath, path.sep, v].join('');
    ***REMOVED***
    
    curpath = pathname;
    walk();
    
    return emitter;
  ***REMOVED***

  module.exports = create;
***REMOVED***());
