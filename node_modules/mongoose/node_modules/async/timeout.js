'use strict';

Object.defineProperty(exports, "__esModule", ***REMOVED***
    value: true
***REMOVED***);
exports.default = timeout;

var _initialParams = require('./internal/initialParams');

var _initialParams2 = _interopRequireDefault(_initialParams);

function _interopRequireDefault(obj) ***REMOVED*** return obj && obj.__esModule ? obj : ***REMOVED*** default: obj ***REMOVED***; ***REMOVED***

/**
 * Sets a time limit on an asynchronous function. If the function does not call
 * its callback within the specified milliseconds, it will be called with a
 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
 *
 * @name timeout
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** asyncFn - The asynchronous function you want to set the
 * time limit.
 * @param ***REMOVED***number***REMOVED*** milliseconds - The specified time limit.
 * @param ***REMOVED*******REMOVED*** [info] - Any variable you want attached (`string`, `object`, etc)
 * to timeout Error for more information..
 * @returns ***REMOVED***Function***REMOVED*** Returns a wrapped function that can be used with any of
 * the control flow functions. Invoke this function with the same
 * parameters as you would `asyncFunc`.
 * @example
 *
 * function myFunction(foo, callback) ***REMOVED***
 *     doAsyncTask(foo, function(err, data) ***REMOVED***
 *         // handle errors
 *         if (err) return callback(err);
 *
 *         // do some stuff ...
 *
 *         // return processed data
 *         return callback(null, data);
 *     ***REMOVED***);
 * ***REMOVED***
 *
 * var wrapped = async.timeout(myFunction, 1000);
 *
 * // call `wrapped` as you would `myFunction`
 * wrapped(***REMOVED*** bar: 'bar' ***REMOVED***, function(err, data) ***REMOVED***
 *     // if `myFunction` takes < 1000 ms to execute, `err`
 *     // and `data` will have their expected values
 *
 *     // else `err` will be an Error with the code 'ETIMEDOUT'
 * ***REMOVED***);
 */
function timeout(asyncFn, milliseconds, info) ***REMOVED***
    var originalCallback, timer;
    var timedOut = false;

    function injectedCallback() ***REMOVED***
        if (!timedOut) ***REMOVED***
            originalCallback.apply(null, arguments);
            clearTimeout(timer);
        ***REMOVED***
    ***REMOVED***

    function timeoutCallback() ***REMOVED***
        var name = asyncFn.name || 'anonymous';
        var error = new Error('Callback function "' + name + '" timed out.');
        error.code = 'ETIMEDOUT';
        if (info) ***REMOVED***
            error.info = info;
        ***REMOVED***
        timedOut = true;
        originalCallback(error);
    ***REMOVED***

    return (0, _initialParams2.default)(function (args, origCallback) ***REMOVED***
        originalCallback = origCallback;
        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        asyncFn.apply(null, args.concat(injectedCallback));
    ***REMOVED***);
***REMOVED***
module.exports = exports['default'];