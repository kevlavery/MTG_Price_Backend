'use strict';

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
***REMOVED***);
exports.default = parallelLimit;

var _eachOf = require('./eachOf');

var _eachOf2 = _interopRequireDefault(_eachOf);

var _parallel = require('./internal/parallel');

var _parallel2 = _interopRequireDefault(_parallel);

function _interopRequireDefault(obj) ***REMOVED*** return obj && obj.__esModule ? obj : ***REMOVED*** default: obj ***REMOVED***; ***REMOVED***

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * **Hint:** Use [`reflect`]***REMOVED***@link module:Utils.reflect***REMOVED*** to continue the
 * execution of other tasks when a task fails.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from ***REMOVED***@link async.parallel***REMOVED***.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** tasks - A collection of
 * [async functions]***REMOVED***@link AsyncFunction***REMOVED*** to run.
 * Each async function can complete with any number of optional `result` values.
 * @param ***REMOVED***Function***REMOVED*** [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 *
 * @example
 * async.parallel([
 *     function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 'one');
 *         ***REMOVED***, 200);
 *     ***REMOVED***,
 *     function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 'two');
 *         ***REMOVED***, 100);
 *     ***REMOVED***
 * ],
 * // optional callback
 * function(err, results) ***REMOVED***
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * ***REMOVED***);
 *
 * // an example using an object instead of an array
 * async.parallel(***REMOVED***
 *     one: function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 1);
 *         ***REMOVED***, 200);
 *     ***REMOVED***,
 *     two: function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 2);
 *         ***REMOVED***, 100);
 *     ***REMOVED***
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     // results is now equals to: ***REMOVED***one: 1, two: 2***REMOVED***
 * ***REMOVED***);
 */
function parallelLimit(tasks, callback) ***REMOVED***
  (0, _parallel2.default)(_eachOf2.default, tasks, callback);
***REMOVED***
module.exports = exports['default'];