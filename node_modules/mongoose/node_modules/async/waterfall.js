'use strict';

Object.defineProperty(exports, "__esModule", ***REMOVED***
    value: true
***REMOVED***);

exports.default = function (tasks, callback) ***REMOVED***
    callback = (0, _once2.default)(callback || _noop2.default);
    if (!(0, _isArray2.default)(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) ***REMOVED***
        if (taskIndex === tasks.length) ***REMOVED***
            return callback.apply(null, [null].concat(args));
        ***REMOVED***

        var taskCallback = (0, _onlyOnce2.default)((0, _rest2.default)(function (err, args) ***REMOVED***
            if (err) ***REMOVED***
                return callback.apply(null, [err].concat(args));
            ***REMOVED***
            nextTask(args);
        ***REMOVED***));

        args.push(taskCallback);

        var task = tasks[taskIndex++];
        task.apply(null, args);
    ***REMOVED***

    nextTask([]);
***REMOVED***;

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _once = require('./internal/once');

var _once2 = _interopRequireDefault(_once);

var _rest = require('./internal/rest');

var _rest2 = _interopRequireDefault(_rest);

var _onlyOnce = require('./internal/onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

function _interopRequireDefault(obj) ***REMOVED*** return obj && obj.__esModule ? obj : ***REMOVED*** default: obj ***REMOVED***; ***REMOVED***

module.exports = exports['default'];

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Array***REMOVED*** tasks - An array of functions to run, each function is passed
 * a `callback(err, result1, result2, ...)` it must call on completion. The
 * first argument is an error (which can be `null`) and any further arguments
 * will be passed as arguments in order to the next task.
 * @param ***REMOVED***Function***REMOVED*** [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns undefined
 * @example
 *
 * async.waterfall([
 *     function(callback) ***REMOVED***
 *         callback(null, 'one', 'two');
 *     ***REMOVED***,
 *     function(arg1, arg2, callback) ***REMOVED***
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     ***REMOVED***,
 *     function(arg1, callback) ***REMOVED***
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     ***REMOVED***
 * ], function (err, result) ***REMOVED***
 *     // result now equals 'done'
 * ***REMOVED***);
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) ***REMOVED***
 *     // result now equals 'done'
 * ***REMOVED***);
 * function myFirstFunction(callback) ***REMOVED***
 *     callback(null, 'one', 'two');
 * ***REMOVED***
 * function mySecondFunction(arg1, arg2, callback) ***REMOVED***
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * ***REMOVED***
 * function myLastFunction(arg1, callback) ***REMOVED***
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * ***REMOVED***
 */