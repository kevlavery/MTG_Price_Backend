'use strict';

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
***REMOVED***);

exports.default = function (worker, concurrency) ***REMOVED***
  var _worker = (0, _wrapAsync2.default)(worker);
  return (0, _queue2.default)(function (items, cb) ***REMOVED***
    _worker(items[0], cb);
  ***REMOVED***, concurrency, 1);
***REMOVED***;

var _queue = require('./internal/queue');

var _queue2 = _interopRequireDefault(_queue);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) ***REMOVED*** return obj && obj.__esModule ? obj : ***REMOVED*** default: obj ***REMOVED***; ***REMOVED***

module.exports = exports['default'];

/**
 * A queue of tasks for the worker function to complete.
 * @typedef ***REMOVED***Object***REMOVED*** QueueObject
 * @memberOf module:ControlFlow
 * @property ***REMOVED***Function***REMOVED*** length - a function returning the number of items
 * waiting to be processed. Invoke with `queue.length()`.
 * @property ***REMOVED***boolean***REMOVED*** started - a boolean indicating whether or not any
 * items have been pushed and processed by the queue.
 * @property ***REMOVED***Function***REMOVED*** running - a function returning the number of items
 * currently being processed. Invoke with `queue.running()`.
 * @property ***REMOVED***Function***REMOVED*** workersList - a function returning the array of items
 * currently being processed. Invoke with `queue.workersList()`.
 * @property ***REMOVED***Function***REMOVED*** idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
 * @property ***REMOVED***number***REMOVED*** concurrency - an integer for determining how many `worker`
 * functions should be run in parallel. This property can be changed after a
 * `queue` is created to alter the concurrency on-the-fly.
 * @property ***REMOVED***Function***REMOVED*** push - add a new task to the `queue`. Calls `callback`
 * once the `worker` has finished processing the task. Instead of a single task,
 * a `tasks` array can be submitted. The respective callback is used for every
 * task in the list. Invoke with `queue.push(task, [callback])`,
 * @property ***REMOVED***Function***REMOVED*** unshift - add a new task to the front of the `queue`.
 * Invoke with `queue.unshift(task, [callback])`.
 * @property ***REMOVED***Function***REMOVED*** remove - remove items from the queue that match a test
 * function.  The test function will be passed an object with a `data` property,
 * and a `priority` property, if this is a
 * [priorityQueue]***REMOVED***@link module:ControlFlow.priorityQueue***REMOVED*** object.
 * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
 * `function (***REMOVED***data, priority***REMOVED***) ***REMOVED******REMOVED***` and returns a Boolean.
 * @property ***REMOVED***Function***REMOVED*** saturated - a callback that is called when the number of
 * running workers hits the `concurrency` limit, and further tasks will be
 * queued.
 * @property ***REMOVED***Function***REMOVED*** unsaturated - a callback that is called when the number
 * of running workers is less than the `concurrency` & `buffer` limits, and
 * further tasks will not be queued.
 * @property ***REMOVED***number***REMOVED*** buffer - A minimum threshold buffer in order to say that
 * the `queue` is `unsaturated`.
 * @property ***REMOVED***Function***REMOVED*** empty - a callback that is called when the last item
 * from the `queue` is given to a `worker`.
 * @property ***REMOVED***Function***REMOVED*** drain - a callback that is called when the last item
 * from the `queue` has returned from the `worker`.
 * @property ***REMOVED***Function***REMOVED*** error - a callback that is called when a task errors.
 * Has the signature `function(error, task)`.
 * @property ***REMOVED***boolean***REMOVED*** paused - a boolean for determining whether the queue is
 * in a paused state.
 * @property ***REMOVED***Function***REMOVED*** pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke with `queue.pause()`.
 * @property ***REMOVED***Function***REMOVED*** resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
 * @property ***REMOVED***Function***REMOVED*** kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. No more tasks
 * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
 */

/**
 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
 * `queue` are processed in parallel (up to the `concurrency` limit). If all
 * `worker`s are in progress, the task is queued until one becomes available.
 * Once a `worker` completes a `task`, that `task`'s callback is called.
 *
 * @name queue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***AsyncFunction***REMOVED*** worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`. Invoked with (task, callback).
 * @param ***REMOVED***number***REMOVED*** [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @returns ***REMOVED***module:ControlFlow.QueueObject***REMOVED*** A queue object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the queue.
 * @example
 *
 * // create a queue object with concurrency 2
 * var q = async.queue(function(task, callback) ***REMOVED***
 *     console.log('hello ' + task.name);
 *     callback();
 * ***REMOVED***, 2);
 *
 * // assign a callback
 * q.drain = function() ***REMOVED***
 *     console.log('all items have been processed');
 * ***REMOVED***;
 *
 * // add some items to the queue
 * q.push(***REMOVED***name: 'foo'***REMOVED***, function(err) ***REMOVED***
 *     console.log('finished processing foo');
 * ***REMOVED***);
 * q.push(***REMOVED***name: 'bar'***REMOVED***, function (err) ***REMOVED***
 *     console.log('finished processing bar');
 * ***REMOVED***);
 *
 * // add some items to the queue (batch-wise)
 * q.push([***REMOVED***name: 'baz'***REMOVED***,***REMOVED***name: 'bay'***REMOVED***,***REMOVED***name: 'bax'***REMOVED***], function(err) ***REMOVED***
 *     console.log('finished processing item');
 * ***REMOVED***);
 *
 * // add some items to the front of the queue
 * q.unshift(***REMOVED***name: 'bar'***REMOVED***, function (err) ***REMOVED***
 *     console.log('finished processing bar');
 * ***REMOVED***);
 */