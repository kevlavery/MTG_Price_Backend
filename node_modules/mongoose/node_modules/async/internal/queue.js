'use strict';

Object.defineProperty(exports, "__esModule", ***REMOVED***
    value: true
***REMOVED***);
exports.default = queue;

var _baseIndexOf = require('lodash/_baseIndexOf');

var _baseIndexOf2 = _interopRequireDefault(_baseIndexOf);

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _onlyOnce = require('./onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _setImmediate = require('./setImmediate');

var _setImmediate2 = _interopRequireDefault(_setImmediate);

var _DoublyLinkedList = require('./DoublyLinkedList');

var _DoublyLinkedList2 = _interopRequireDefault(_DoublyLinkedList);

var _wrapAsync = require('./wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) ***REMOVED*** return obj && obj.__esModule ? obj : ***REMOVED*** default: obj ***REMOVED***; ***REMOVED***

function queue(worker, concurrency, payload) ***REMOVED***
    if (concurrency == null) ***REMOVED***
        concurrency = 1;
    ***REMOVED*** else if (concurrency === 0) ***REMOVED***
        throw new Error('Concurrency must not be zero');
    ***REMOVED***

    var _worker = (0, _wrapAsync2.default)(worker);
    var numRunning = 0;
    var workersList = [];

    var processingScheduled = false;
    function _insert(data, insertAtFront, callback) ***REMOVED***
        if (callback != null && typeof callback !== 'function') ***REMOVED***
            throw new Error('task callback must be a function');
        ***REMOVED***
        q.started = true;
        if (!(0, _isArray2.default)(data)) ***REMOVED***
            data = [data];
        ***REMOVED***
        if (data.length === 0 && q.idle()) ***REMOVED***
            // call drain immediately if there are no tasks
            return (0, _setImmediate2.default)(function () ***REMOVED***
                q.drain();
            ***REMOVED***);
        ***REMOVED***

        for (var i = 0, l = data.length; i < l; i++) ***REMOVED***
            var item = ***REMOVED***
                data: data[i],
                callback: callback || _noop2.default
            ***REMOVED***;

            if (insertAtFront) ***REMOVED***
                q._tasks.unshift(item);
            ***REMOVED*** else ***REMOVED***
                q._tasks.push(item);
            ***REMOVED***
        ***REMOVED***

        if (!processingScheduled) ***REMOVED***
            processingScheduled = true;
            (0, _setImmediate2.default)(function () ***REMOVED***
                processingScheduled = false;
                q.process();
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***

    function _next(tasks) ***REMOVED***
        return function (err) ***REMOVED***
            numRunning -= 1;

            for (var i = 0, l = tasks.length; i < l; i++) ***REMOVED***
                var task = tasks[i];

                var index = (0, _baseIndexOf2.default)(workersList, task, 0);
                if (index === 0) ***REMOVED***
                    workersList.shift();
                ***REMOVED*** else if (index > 0) ***REMOVED***
                    workersList.splice(index, 1);
                ***REMOVED***

                task.callback.apply(task, arguments);

                if (err != null) ***REMOVED***
                    q.error(err, task.data);
                ***REMOVED***
            ***REMOVED***

            if (numRunning <= q.concurrency - q.buffer) ***REMOVED***
                q.unsaturated();
            ***REMOVED***

            if (q.idle()) ***REMOVED***
                q.drain();
            ***REMOVED***
            q.process();
        ***REMOVED***;
    ***REMOVED***

    var isProcessing = false;
    var q = ***REMOVED***
        _tasks: new _DoublyLinkedList2.default(),
        concurrency: concurrency,
        payload: payload,
        saturated: _noop2.default,
        unsaturated: _noop2.default,
        buffer: concurrency / 4,
        empty: _noop2.default,
        drain: _noop2.default,
        error: _noop2.default,
        started: false,
        paused: false,
        push: function (data, callback) ***REMOVED***
            _insert(data, false, callback);
        ***REMOVED***,
        kill: function () ***REMOVED***
            q.drain = _noop2.default;
            q._tasks.empty();
        ***REMOVED***,
        unshift: function (data, callback) ***REMOVED***
            _insert(data, true, callback);
        ***REMOVED***,
        remove: function (testFn) ***REMOVED***
            q._tasks.remove(testFn);
        ***REMOVED***,
        process: function () ***REMOVED***
            // Avoid trying to start too many processing operations. This can occur
            // when callbacks resolve synchronously (#1267).
            if (isProcessing) ***REMOVED***
                return;
            ***REMOVED***
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) ***REMOVED***
                var tasks = [],
                    data = [];
                var l = q._tasks.length;
                if (q.payload) l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) ***REMOVED***
                    var node = q._tasks.shift();
                    tasks.push(node);
                    workersList.push(node);
                    data.push(node.data);
                ***REMOVED***

                numRunning += 1;

                if (q._tasks.length === 0) ***REMOVED***
                    q.empty();
                ***REMOVED***

                if (numRunning === q.concurrency) ***REMOVED***
                    q.saturated();
                ***REMOVED***

                var cb = (0, _onlyOnce2.default)(_next(tasks));
                _worker(data, cb);
            ***REMOVED***
            isProcessing = false;
        ***REMOVED***,
        length: function () ***REMOVED***
            return q._tasks.length;
        ***REMOVED***,
        running: function () ***REMOVED***
            return numRunning;
        ***REMOVED***,
        workersList: function () ***REMOVED***
            return workersList;
        ***REMOVED***,
        idle: function () ***REMOVED***
            return q._tasks.length + numRunning === 0;
        ***REMOVED***,
        pause: function () ***REMOVED***
            q.paused = true;
        ***REMOVED***,
        resume: function () ***REMOVED***
            if (q.paused === false) ***REMOVED***
                return;
            ***REMOVED***
            q.paused = false;
            (0, _setImmediate2.default)(q.process);
        ***REMOVED***
    ***REMOVED***;
    return q;
***REMOVED***
module.exports = exports['default'];