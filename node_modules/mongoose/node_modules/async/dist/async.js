(function (global, factory) ***REMOVED***
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.async = global.async || ***REMOVED******REMOVED***)));
***REMOVED***(this, (function (exports) ***REMOVED*** 'use strict';

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param ***REMOVED***Function***REMOVED*** func The function to invoke.
 * @param ***REMOVED*******REMOVED*** thisArg The `this` binding of `func`.
 * @param ***REMOVED***Array***REMOVED*** args The arguments to invoke `func` with.
 * @returns ***REMOVED*******REMOVED*** Returns the result of `func`.
 */
function apply(func, thisArg, args) ***REMOVED***
  switch (args.length) ***REMOVED***
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  ***REMOVED***
  return func.apply(thisArg, args);
***REMOVED***

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param ***REMOVED***Function***REMOVED*** func The function to apply a rest parameter to.
 * @param ***REMOVED***number***REMOVED*** [start=func.length-1] The start position of the rest parameter.
 * @param ***REMOVED***Function***REMOVED*** transform The rest array transform.
 * @returns ***REMOVED***Function***REMOVED*** Returns the new function.
 */
function overRest$1(func, start, transform) ***REMOVED***
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() ***REMOVED***
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) ***REMOVED***
      array[index] = args[start + index];
    ***REMOVED***
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) ***REMOVED***
      otherArgs[index] = args[index];
    ***REMOVED***
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  ***REMOVED***;
***REMOVED***

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param ***REMOVED*******REMOVED*** value Any value.
 * @returns ***REMOVED*******REMOVED*** Returns `value`.
 * @example
 *
 * var object = ***REMOVED*** 'a': 1 ***REMOVED***;
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) ***REMOVED***
  return value;
***REMOVED***

// Lodash rest function without function.toString()
// remappings
function rest(func, start) ***REMOVED***
    return overRest$1(func, start, identity);
***REMOVED***

var initialParams = function (fn) ***REMOVED***
    return rest(function (args /*..., callback*/) ***REMOVED***
        var callback = args.pop();
        fn.call(this, args, callback);
    ***REMOVED***);
***REMOVED***;

function applyEach$1(eachfn) ***REMOVED***
    return rest(function (fns, args) ***REMOVED***
        var go = initialParams(function (args, callback) ***REMOVED***
            var that = this;
            return eachfn(fns, function (fn, cb) ***REMOVED***
                fn.apply(that, args.concat([cb]));
            ***REMOVED***, callback);
        ***REMOVED***);
        if (args.length) ***REMOVED***
            return go.apply(this, args);
        ***REMOVED*** else ***REMOVED***
            return go;
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param ***REMOVED*******REMOVED*** value The value to query.
 * @returns ***REMOVED***string***REMOVED*** Returns the raw `toStringTag`.
 */
function getRawTag(value) ***REMOVED***
  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try ***REMOVED***
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  ***REMOVED*** catch (e) ***REMOVED******REMOVED***

  var result = nativeObjectToString.call(value);
  if (unmasked) ***REMOVED***
    if (isOwn) ***REMOVED***
      value[symToStringTag$1] = tag;
    ***REMOVED*** else ***REMOVED***
      delete value[symToStringTag$1];
    ***REMOVED***
  ***REMOVED***
  return result;
***REMOVED***

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param ***REMOVED*******REMOVED*** value The value to convert.
 * @returns ***REMOVED***string***REMOVED*** Returns the converted string.
 */
function objectToString(value) ***REMOVED***
  return nativeObjectToString$1.call(value);
***REMOVED***

/** `Object#toString` result references. */
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param ***REMOVED*******REMOVED*** value The value to query.
 * @returns ***REMOVED***string***REMOVED*** Returns the `toStringTag`.
 */
function baseGetTag(value) ***REMOVED***
  if (value == null) ***REMOVED***
    return value === undefined ? undefinedTag : nullTag;
  ***REMOVED***
  value = Object(value);
  return (symToStringTag && symToStringTag in value)
    ? getRawTag(value)
    : objectToString(value);
***REMOVED***

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject(***REMOVED******REMOVED***);
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) ***REMOVED***
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
***REMOVED***

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]';
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';
var proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) ***REMOVED***
  if (!isObject(value)) ***REMOVED***
    return false;
  ***REMOVED***
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
***REMOVED***

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) ***REMOVED***
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
***REMOVED***

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) ***REMOVED***
  return value != null && isLength(value.length) && !isFunction(value);
***REMOVED***

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() ***REMOVED***
  // No operation performed.
***REMOVED***

function once(fn) ***REMOVED***
    return function () ***REMOVED***
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    ***REMOVED***;
***REMOVED***

var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

var getIterator = function (coll) ***REMOVED***
    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
***REMOVED***;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param ***REMOVED***number***REMOVED*** n The number of times to invoke `iteratee`.
 * @param ***REMOVED***Function***REMOVED*** iteratee The function invoked per iteration.
 * @returns ***REMOVED***Array***REMOVED*** Returns the array of results.
 */
function baseTimes(n, iteratee) ***REMOVED***
  var index = -1,
      result = Array(n);

  while (++index < n) ***REMOVED***
    result[index] = iteratee(index);
  ***REMOVED***
  return result;
***REMOVED***

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike(***REMOVED******REMOVED***);
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) ***REMOVED***
  return value != null && typeof value == 'object';
***REMOVED***

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) ***REMOVED***
  return isObjectLike(value) && baseGetTag(value) == argsTag;
***REMOVED***

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() ***REMOVED*** return arguments; ***REMOVED***());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() ***REMOVED*** return arguments; ***REMOVED***()) ? baseIsArguments : function(value) ***REMOVED***
  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
***REMOVED***;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns ***REMOVED***boolean***REMOVED*** Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() ***REMOVED***
  return false;
***REMOVED***

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @param ***REMOVED***number***REMOVED*** [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) ***REMOVED***
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
***REMOVED***

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';
var arrayTag = '[object Array]';
var boolTag = '[object Boolean]';
var dateTag = '[object Date]';
var errorTag = '[object Error]';
var funcTag$1 = '[object Function]';
var mapTag = '[object Map]';
var numberTag = '[object Number]';
var objectTag = '[object Object]';
var regexpTag = '[object RegExp]';
var setTag = '[object Set]';
var stringTag = '[object String]';
var weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]';
var dataViewTag = '[object DataView]';
var float32Tag = '[object Float32Array]';
var float64Tag = '[object Float64Array]';
var int8Tag = '[object Int8Array]';
var int16Tag = '[object Int16Array]';
var int32Tag = '[object Int32Array]';
var uint8Tag = '[object Uint8Array]';
var uint8ClampedTag = '[object Uint8ClampedArray]';
var uint16Tag = '[object Uint16Array]';
var uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = ***REMOVED******REMOVED***;
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) ***REMOVED***
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
***REMOVED***

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param ***REMOVED***Function***REMOVED*** func The function to cap arguments for.
 * @returns ***REMOVED***Function***REMOVED*** Returns the new capped function.
 */
function baseUnary(func) ***REMOVED***
  return function(value) ***REMOVED***
    return func(value);
  ***REMOVED***;
***REMOVED***

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() ***REMOVED***
  try ***REMOVED***
    return freeProcess && freeProcess.binding('util');
  ***REMOVED*** catch (e) ***REMOVED******REMOVED***
***REMOVED***());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param ***REMOVED*******REMOVED*** value The value to query.
 * @param ***REMOVED***boolean***REMOVED*** inherited Specify returning inherited property names.
 * @returns ***REMOVED***Array***REMOVED*** Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) ***REMOVED***
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) ***REMOVED***
    if ((inherited || hasOwnProperty$1.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) ***REMOVED***
      result.push(key);
    ***REMOVED***
  ***REMOVED***
  return result;
***REMOVED***

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) ***REMOVED***
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

  return value === proto;
***REMOVED***

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param ***REMOVED***Function***REMOVED*** func The function to wrap.
 * @param ***REMOVED***Function***REMOVED*** transform The argument transform.
 * @returns ***REMOVED***Function***REMOVED*** Returns the new function.
 */
function overArg(func, transform) ***REMOVED***
  return function(arg) ***REMOVED***
    return func(transform(arg));
  ***REMOVED***;
***REMOVED***

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param ***REMOVED***Object***REMOVED*** object The object to query.
 * @returns ***REMOVED***Array***REMOVED*** Returns the array of property names.
 */
function baseKeys(object) ***REMOVED***
  if (!isPrototype(object)) ***REMOVED***
    return nativeKeys(object);
  ***REMOVED***
  var result = [];
  for (var key in Object(object)) ***REMOVED***
    if (hasOwnProperty$3.call(object, key) && key != 'constructor') ***REMOVED***
      result.push(key);
    ***REMOVED***
  ***REMOVED***
  return result;
***REMOVED***

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param ***REMOVED***Object***REMOVED*** object The object to query.
 * @returns ***REMOVED***Array***REMOVED*** Returns the array of property names.
 * @example
 *
 * function Foo() ***REMOVED***
 *   this.a = 1;
 *   this.b = 2;
 * ***REMOVED***
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) ***REMOVED***
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
***REMOVED***

function createArrayIterator(coll) ***REMOVED***
    var i = -1;
    var len = coll.length;
    return function next() ***REMOVED***
        return ++i < len ? ***REMOVED*** value: coll[i], key: i ***REMOVED*** : null;
    ***REMOVED***;
***REMOVED***

function createES2015Iterator(iterator) ***REMOVED***
    var i = -1;
    return function next() ***REMOVED***
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return ***REMOVED*** value: item.value, key: i ***REMOVED***;
    ***REMOVED***;
***REMOVED***

function createObjectIterator(obj) ***REMOVED***
    var okeys = keys(obj);
    var i = -1;
    var len = okeys.length;
    return function next() ***REMOVED***
        var key = okeys[++i];
        return i < len ? ***REMOVED*** value: obj[key], key: key ***REMOVED*** : null;
    ***REMOVED***;
***REMOVED***

function iterator(coll) ***REMOVED***
    if (isArrayLike(coll)) ***REMOVED***
        return createArrayIterator(coll);
    ***REMOVED***

    var iterator = getIterator(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
***REMOVED***

function onlyOnce(fn) ***REMOVED***
    return function () ***REMOVED***
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    ***REMOVED***;
***REMOVED***

// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
var breakLoop = ***REMOVED******REMOVED***;

function _eachOfLimit(limit) ***REMOVED***
    return function (obj, iteratee, callback) ***REMOVED***
        callback = once(callback || noop);
        if (limit <= 0 || !obj) ***REMOVED***
            return callback(null);
        ***REMOVED***
        var nextElem = iterator(obj);
        var done = false;
        var running = 0;

        function iterateeCallback(err, value) ***REMOVED***
            running -= 1;
            if (err) ***REMOVED***
                done = true;
                callback(err);
            ***REMOVED*** else if (value === breakLoop || done && running <= 0) ***REMOVED***
                done = true;
                return callback(null);
            ***REMOVED*** else ***REMOVED***
                replenish();
            ***REMOVED***
        ***REMOVED***

        function replenish() ***REMOVED***
            while (running < limit && !done) ***REMOVED***
                var elem = nextElem();
                if (elem === null) ***REMOVED***
                    done = true;
                    if (running <= 0) ***REMOVED***
                        callback(null);
                    ***REMOVED***
                    return;
                ***REMOVED***
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            ***REMOVED***
        ***REMOVED***

        replenish();
    ***REMOVED***;
***REMOVED***

/**
 * The same as [`eachOf`]***REMOVED***@link module:Collections.eachOf***REMOVED*** but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]***REMOVED***@link module:Collections.eachOf***REMOVED***
 * @alias forEachOfLimit
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array. The iteratee is passed a `callback(err)` which must be called once it
 * has completed. If no error has occurred, the callback should be run without
 * arguments or with an explicit `null` argument. Invoked with
 * (item, key, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachOfLimit(coll, limit, iteratee, callback) ***REMOVED***
  _eachOfLimit(limit)(coll, iteratee, callback);
***REMOVED***

function doLimit(fn, limit) ***REMOVED***
    return function (iterable, iteratee, callback) ***REMOVED***
        return fn(iterable, limit, iteratee, callback);
    ***REMOVED***;
***REMOVED***

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) ***REMOVED***
    callback = once(callback || noop);
    var index = 0,
        completed = 0,
        length = coll.length;
    if (length === 0) ***REMOVED***
        callback(null);
    ***REMOVED***

    function iteratorCallback(err) ***REMOVED***
        if (err) ***REMOVED***
            callback(err);
        ***REMOVED*** else if (++completed === length) ***REMOVED***
            callback(null);
        ***REMOVED***
    ***REMOVED***

    for (; index < length; index++) ***REMOVED***
        iteratee(coll[index], index, onlyOnce(iteratorCallback));
    ***REMOVED***
***REMOVED***

// a generic version of eachOf which can handle array, object, and iterator cases.
var eachOfGeneric = doLimit(eachOfLimit, Infinity);

/**
 * Like [`each`]***REMOVED***@link module:Collections.each***REMOVED***, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]***REMOVED***@link module:Collections.each***REMOVED***
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array. The iteratee is passed a `callback(err)` which must be called once it
 * has completed. If no error has occurred, the callback should be run without
 * arguments or with an explicit `null` argument. Invoked with
 * (item, key, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * var obj = ***REMOVED***dev: "/dev.json", test: "/test.json", prod: "/prod.json"***REMOVED***;
 * var configs = ***REMOVED******REMOVED***;
 *
 * async.forEachOf(obj, function (value, key, callback) ***REMOVED***
 *     fs.readFile(__dirname + value, "utf8", function (err, data) ***REMOVED***
 *         if (err) return callback(err);
 *         try ***REMOVED***
 *             configs[key] = JSON.parse(data);
 *         ***REMOVED*** catch (e) ***REMOVED***
 *             return callback(e);
 *         ***REMOVED***
 *         callback();
 *     ***REMOVED***);
 * ***REMOVED***, function (err) ***REMOVED***
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * ***REMOVED***);
 */
var eachOf = function (coll, iteratee, callback) ***REMOVED***
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, iteratee, callback);
***REMOVED***;

function doParallel(fn) ***REMOVED***
    return function (obj, iteratee, callback) ***REMOVED***
        return fn(eachOf, obj, iteratee, callback);
    ***REMOVED***;
***REMOVED***

function _asyncMap(eachfn, arr, iteratee, callback) ***REMOVED***
    callback = callback || noop;
    arr = arr || [];
    var results = [];
    var counter = 0;

    eachfn(arr, function (value, _, callback) ***REMOVED***
        var index = counter++;
        iteratee(value, function (err, v) ***REMOVED***
            results[index] = v;
            callback(err);
        ***REMOVED***);
    ***REMOVED***, function (err) ***REMOVED***
        callback(err, results);
    ***REMOVED***);
***REMOVED***

/**
 * Produces a new collection of values by mapping each value in `coll` through
 * the `iteratee` function. The `iteratee` is called with an item from `coll`
 * and a callback for when it has finished processing. Each of these callback
 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
 * `iteratee` passes an error to its callback, the main `callback` (for the
 * `map` function) is immediately called with the error.
 *
 * Note, that since this function applies the `iteratee` to each item in
 * parallel, there is no guarantee that the `iteratee` functions will complete
 * in order. However, the results array will be in the same order as the
 * original `coll`.
 *
 * If `map` is passed an Object, the results will be an Array.  The results
 * will roughly be in the order of the original Objects' keys (but this can
 * vary across JavaScript engines)
 *
 * @name map
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each item in `coll`.
 * The iteratee is passed a `callback(err, transformed)` which must be called
 * once it has completed with an error (which can be `null`) and a
 * transformed item. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an Array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @example
 *
 * async.map(['file1','file2','file3'], fs.stat, function(err, results) ***REMOVED***
 *     // results is now an array of stats for each file
 * ***REMOVED***);
 */
var map = doParallel(_asyncMap);

/**
 * Applies the provided arguments to each function in the array, calling
 * `callback` after all functions have completed. If you only provide the first
 * argument, `fns`, then it will return a function which lets you pass in the
 * arguments as if it were a single function call. If more arguments are
 * provided, `callback` is required while `args` is still optional.
 *
 * @name applyEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** fns - A collection of asynchronous functions
 * to all call with the same arguments
 * @param ***REMOVED***...****REMOVED*** [args] - any number of separate arguments to pass to the
 * function.
 * @param ***REMOVED***Function***REMOVED*** [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns ***REMOVED***Function***REMOVED*** - If only the first argument, `fns`, is provided, it will
 * return a function which lets you pass in the arguments as if it were a single
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
 *
 * // partial application example:
 * async.each(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */
var applyEach = applyEach$1(map);

function doParallelLimit(fn) ***REMOVED***
    return function (obj, limit, iteratee, callback) ***REMOVED***
        return fn(_eachOfLimit(limit), obj, iteratee, callback);
    ***REMOVED***;
***REMOVED***

/**
 * The same as [`map`]***REMOVED***@link module:Collections.map***REMOVED*** but runs a maximum of `limit` async operations at a time.
 *
 * @name mapLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]***REMOVED***@link module:Collections.map***REMOVED***
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each item in `coll`.
 * The iteratee is passed a `callback(err, transformed)` which must be called
 * once it has completed with an error (which can be `null`) and a transformed
 * item. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */
var mapLimit = doParallelLimit(_asyncMap);

/**
 * The same as [`map`]***REMOVED***@link module:Collections.map***REMOVED*** but runs only a single async operation at a time.
 *
 * @name mapSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]***REMOVED***@link module:Collections.map***REMOVED***
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each item in `coll`.
 * The iteratee is passed a `callback(err, transformed)` which must be called
 * once it has completed with an error (which can be `null`) and a
 * transformed item. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */
var mapSeries = doLimit(mapLimit, 1);

/**
 * The same as [`applyEach`]***REMOVED***@link module:ControlFlow.applyEach***REMOVED*** but runs only a single async operation at a time.
 *
 * @name applyEachSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.applyEach]***REMOVED***@link module:ControlFlow.applyEach***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** fns - A collection of asynchronous functions to all
 * call with the same arguments
 * @param ***REMOVED***...****REMOVED*** [args] - any number of separate arguments to pass to the
 * function.
 * @param ***REMOVED***Function***REMOVED*** [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns ***REMOVED***Function***REMOVED*** - If only the first argument is provided, it will return
 * a function which lets you pass in the arguments as if it were a single
 * function call.
 */
var applyEachSeries = applyEach$1(mapSeries);

/**
 * Creates a continuation function with some arguments already applied.
 *
 * Useful as a shorthand when combined with other control flow functions. Any
 * arguments passed to the returned function are added to the arguments
 * originally passed to apply.
 *
 * @name apply
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** function - The function you want to eventually apply all
 * arguments to. Invokes with (arguments...).
 * @param ***REMOVED***...****REMOVED*** arguments... - Any number of arguments to automatically apply
 * when the continuation is called.
 * @example
 *
 * // using apply
 * async.parallel([
 *     async.apply(fs.writeFile, 'testfile1', 'test1'),
 *     async.apply(fs.writeFile, 'testfile2', 'test2')
 * ]);
 *
 *
 * // the same process without using apply
 * async.parallel([
 *     function(callback) ***REMOVED***
 *         fs.writeFile('testfile1', 'test1', callback);
 *     ***REMOVED***,
 *     function(callback) ***REMOVED***
 *         fs.writeFile('testfile2', 'test2', callback);
 *     ***REMOVED***
 * ]);
 *
 * // It's possible to pass any number of additional arguments when calling the
 * // continuation:
 *
 * node> var fn = async.apply(sys.puts, 'one');
 * node> fn('two', 'three');
 * one
 * two
 * three
 */
var apply$2 = rest(function (fn, args) ***REMOVED***
    return rest(function (callArgs) ***REMOVED***
        return fn.apply(null, args.concat(callArgs));
    ***REMOVED***);
***REMOVED***);

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2016 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** func - The synchronous function to convert to an
 * asynchronous function.
 * @returns ***REMOVED***Function***REMOVED*** An asynchronous wrapper of the `func`. To be invoked with
 * (callback).
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) ***REMOVED***
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     ***REMOVED***
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) ***REMOVED***
 *         return db.model.create(contents);
 *     ***REMOVED***),
 *     function (model, next) ***REMOVED***
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     ***REMOVED***
 * ], callback);
 *
 * // es6 example
 * var q = async.queue(async.asyncify(async function(file) ***REMOVED***
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * ***REMOVED***));
 *
 * q.push(files);
 */
function asyncify(func) ***REMOVED***
    return initialParams(function (args, callback) ***REMOVED***
        var result;
        try ***REMOVED***
            result = func.apply(this, args);
        ***REMOVED*** catch (e) ***REMOVED***
            return callback(e);
        ***REMOVED***
        // if result is Promise object
        if (isObject(result) && typeof result.then === 'function') ***REMOVED***
            result.then(function (value) ***REMOVED***
                callback(null, value);
            ***REMOVED***, function (err) ***REMOVED***
                callback(err.message ? err : new Error(err));
            ***REMOVED***);
        ***REMOVED*** else ***REMOVED***
            callback(null, result);
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param ***REMOVED***Array***REMOVED*** [array] The array to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee The function invoked per iteration.
 * @returns ***REMOVED***Array***REMOVED*** Returns `array`.
 */
function arrayEach(array, iteratee) ***REMOVED***
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) ***REMOVED***
    if (iteratee(array[index], index, array) === false) ***REMOVED***
      break;
    ***REMOVED***
  ***REMOVED***
  return array;
***REMOVED***

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param ***REMOVED***boolean***REMOVED*** [fromRight] Specify iterating from right to left.
 * @returns ***REMOVED***Function***REMOVED*** Returns the new base function.
 */
function createBaseFor(fromRight) ***REMOVED***
  return function(object, iteratee, keysFunc) ***REMOVED***
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) ***REMOVED***
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) ***REMOVED***
        break;
      ***REMOVED***
    ***REMOVED***
    return object;
  ***REMOVED***;
***REMOVED***

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param ***REMOVED***Object***REMOVED*** object The object to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee The function invoked per iteration.
 * @param ***REMOVED***Function***REMOVED*** keysFunc The function to get the keys of `object`.
 * @returns ***REMOVED***Object***REMOVED*** Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param ***REMOVED***Object***REMOVED*** object The object to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee The function invoked per iteration.
 * @returns ***REMOVED***Object***REMOVED*** Returns `object`.
 */
function baseForOwn(object, iteratee) ***REMOVED***
  return object && baseFor(object, iteratee, keys);
***REMOVED***

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param ***REMOVED***Array***REMOVED*** array The array to inspect.
 * @param ***REMOVED***Function***REMOVED*** predicate The function invoked per iteration.
 * @param ***REMOVED***number***REMOVED*** fromIndex The index to search from.
 * @param ***REMOVED***boolean***REMOVED*** [fromRight] Specify iterating from right to left.
 * @returns ***REMOVED***number***REMOVED*** Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) ***REMOVED***
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) ***REMOVED***
    if (predicate(array[index], index, array)) ***REMOVED***
      return index;
    ***REMOVED***
  ***REMOVED***
  return -1;
***REMOVED***

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) ***REMOVED***
  return value !== value;
***REMOVED***

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param ***REMOVED***Array***REMOVED*** array The array to inspect.
 * @param ***REMOVED*******REMOVED*** value The value to search for.
 * @param ***REMOVED***number***REMOVED*** fromIndex The index to search from.
 * @returns ***REMOVED***number***REMOVED*** Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) ***REMOVED***
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) ***REMOVED***
    if (array[index] === value) ***REMOVED***
      return index;
    ***REMOVED***
  ***REMOVED***
  return -1;
***REMOVED***

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param ***REMOVED***Array***REMOVED*** array The array to inspect.
 * @param ***REMOVED*******REMOVED*** value The value to search for.
 * @param ***REMOVED***number***REMOVED*** fromIndex The index to search from.
 * @returns ***REMOVED***number***REMOVED*** Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) ***REMOVED***
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
***REMOVED***

/**
 * Determines the best order for running the functions in `tasks`, based on
 * their requirements. Each function can optionally depend on other functions
 * being completed first, and each function is run as soon as its requirements
 * are satisfied.
 *
 * If any of the functions pass an error to their callback, the `auto` sequence
 * will stop. Further tasks will not execute (so any other functions depending
 * on it will not run), and the main `callback` is immediately called with the
 * error.
 *
 * Functions also receive an object containing the results of functions which
 * have completed so far as the first argument, if they have dependencies. If a
 * task function has no dependencies, it will only be passed a callback.
 *
 * @name auto
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Object***REMOVED*** tasks - An object. Each of its properties is either a
 * function or an array of requirements, with the function itself the last item
 * in the array. The object's key of a property serves as the name of the task
 * defined by that property, i.e. can be used when specifying requirements for
 * other tasks. The function receives one or two arguments:
 * * a `results` object, containing the results of the previously executed
 *   functions, only passed if the task has any dependencies,
 * * a `callback(err, result)` function, which must be called when finished,
 *   passing an `error` (which can be `null`) and the result of the function's
 *   execution.
 * @param ***REMOVED***number***REMOVED*** [concurrency=Infinity] - An optional `integer` for
 * determining the maximum number of tasks that can be run in parallel. By
 * default, as many as possible.
 * @param ***REMOVED***Function***REMOVED*** [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback. Results are always returned; however, if an
 * error occurs, no further `tasks` will be performed, and the results object
 * will only contain partial results. Invoked with (err, results).
 * @returns undefined
 * @example
 *
 * async.auto(***REMOVED***
 *     // this function will just be passed a callback
 *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
 *     showData: ['readData', function(results, cb) ***REMOVED***
 *         // results.readData is the file's contents
 *         // ...
 *     ***REMOVED***]
 * ***REMOVED***, callback);
 *
 * async.auto(***REMOVED***
 *     get_data: function(callback) ***REMOVED***
 *         console.log('in get_data');
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     ***REMOVED***,
 *     make_folder: function(callback) ***REMOVED***
 *         console.log('in make_folder');
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     ***REMOVED***,
 *     write_file: ['get_data', 'make_folder', function(results, callback) ***REMOVED***
 *         console.log('in write_file', JSON.stringify(results));
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     ***REMOVED***],
 *     email_link: ['write_file', function(results, callback) ***REMOVED***
 *         console.log('in email_link', JSON.stringify(results));
 *         // once the file is written let's email a link to it...
 *         // results.write_file contains the filename returned by write_file.
 *         callback(null, ***REMOVED***'file':results.write_file, 'email':'user@example.com'***REMOVED***);
 *     ***REMOVED***]
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     console.log('err = ', err);
 *     console.log('results = ', results);
 * ***REMOVED***);
 */
var auto = function (tasks, concurrency, callback) ***REMOVED***
    if (typeof concurrency === 'function') ***REMOVED***
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    ***REMOVED***
    callback = once(callback || noop);
    var keys$$1 = keys(tasks);
    var numTasks = keys$$1.length;
    if (!numTasks) ***REMOVED***
        return callback(null);
    ***REMOVED***
    if (!concurrency) ***REMOVED***
        concurrency = numTasks;
    ***REMOVED***

    var results = ***REMOVED******REMOVED***;
    var runningTasks = 0;
    var hasError = false;

    var listeners = ***REMOVED******REMOVED***;

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = ***REMOVED******REMOVED***;

    baseForOwn(tasks, function (task, key) ***REMOVED***
        if (!isArray(task)) ***REMOVED***
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        ***REMOVED***

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) ***REMOVED***
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        ***REMOVED***
        uncheckedDependencies[key] = remainingDependencies;

        arrayEach(dependencies, function (dependencyName) ***REMOVED***
            if (!tasks[dependencyName]) ***REMOVED***
                throw new Error('async.auto task `' + key + '` has a non-existent dependency in ' + dependencies.join(', '));
            ***REMOVED***
            addListener(dependencyName, function () ***REMOVED***
                remainingDependencies--;
                if (remainingDependencies === 0) ***REMOVED***
                    enqueueTask(key, task);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***);

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) ***REMOVED***
        readyTasks.push(function () ***REMOVED***
            runTask(key, task);
        ***REMOVED***);
    ***REMOVED***

    function processQueue() ***REMOVED***
        if (readyTasks.length === 0 && runningTasks === 0) ***REMOVED***
            return callback(null, results);
        ***REMOVED***
        while (readyTasks.length && runningTasks < concurrency) ***REMOVED***
            var run = readyTasks.shift();
            run();
        ***REMOVED***
    ***REMOVED***

    function addListener(taskName, fn) ***REMOVED***
        var taskListeners = listeners[taskName];
        if (!taskListeners) ***REMOVED***
            taskListeners = listeners[taskName] = [];
        ***REMOVED***

        taskListeners.push(fn);
    ***REMOVED***

    function taskComplete(taskName) ***REMOVED***
        var taskListeners = listeners[taskName] || [];
        arrayEach(taskListeners, function (fn) ***REMOVED***
            fn();
        ***REMOVED***);
        processQueue();
    ***REMOVED***

    function runTask(key, task) ***REMOVED***
        if (hasError) return;

        var taskCallback = onlyOnce(rest(function (err, args) ***REMOVED***
            runningTasks--;
            if (args.length <= 1) ***REMOVED***
                args = args[0];
            ***REMOVED***
            if (err) ***REMOVED***
                var safeResults = ***REMOVED******REMOVED***;
                baseForOwn(results, function (val, rkey) ***REMOVED***
                    safeResults[rkey] = val;
                ***REMOVED***);
                safeResults[key] = args;
                hasError = true;
                listeners = [];

                callback(err, safeResults);
            ***REMOVED*** else ***REMOVED***
                results[key] = args;
                taskComplete(key);
            ***REMOVED***
        ***REMOVED***));

        runningTasks++;
        var taskFn = task[task.length - 1];
        if (task.length > 1) ***REMOVED***
            taskFn(results, taskCallback);
        ***REMOVED*** else ***REMOVED***
            taskFn(taskCallback);
        ***REMOVED***
    ***REMOVED***

    function checkForDeadlocks() ***REMOVED***
        // Kahn's algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) ***REMOVED***
            currentTask = readyToCheck.pop();
            counter++;
            arrayEach(getDependents(currentTask), function (dependent) ***REMOVED***
                if (--uncheckedDependencies[dependent] === 0) ***REMOVED***
                    readyToCheck.push(dependent);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        if (counter !== numTasks) ***REMOVED***
            throw new Error('async.auto cannot execute tasks due to a recursive dependency');
        ***REMOVED***
    ***REMOVED***

    function getDependents(taskName) ***REMOVED***
        var result = [];
        baseForOwn(tasks, function (task, key) ***REMOVED***
            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) ***REMOVED***
                result.push(key);
            ***REMOVED***
        ***REMOVED***);
        return result;
    ***REMOVED***
***REMOVED***;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param ***REMOVED***Array***REMOVED*** [array] The array to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee The function invoked per iteration.
 * @returns ***REMOVED***Array***REMOVED*** Returns the new mapped array.
 */
function arrayMap(array, iteratee) ***REMOVED***
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) ***REMOVED***
    result[index] = iteratee(array[index], index, array);
  ***REMOVED***
  return result;
***REMOVED***

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to check.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) ***REMOVED***
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
***REMOVED***

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;
var symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param ***REMOVED*******REMOVED*** value The value to process.
 * @returns ***REMOVED***string***REMOVED*** Returns the string.
 */
function baseToString(value) ***REMOVED***
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') ***REMOVED***
    return value;
  ***REMOVED***
  if (isArray(value)) ***REMOVED***
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  ***REMOVED***
  if (isSymbol(value)) ***REMOVED***
    return symbolToString ? symbolToString.call(value) : '';
  ***REMOVED***
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
***REMOVED***

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param ***REMOVED***Array***REMOVED*** array The array to slice.
 * @param ***REMOVED***number***REMOVED*** [start=0] The start position.
 * @param ***REMOVED***number***REMOVED*** [end=array.length] The end position.
 * @returns ***REMOVED***Array***REMOVED*** Returns the slice of `array`.
 */
function baseSlice(array, start, end) ***REMOVED***
  var index = -1,
      length = array.length;

  if (start < 0) ***REMOVED***
    start = -start > length ? 0 : (length + start);
  ***REMOVED***
  end = end > length ? length : end;
  if (end < 0) ***REMOVED***
    end += length;
  ***REMOVED***
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) ***REMOVED***
    result[index] = array[index + start];
  ***REMOVED***
  return result;
***REMOVED***

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param ***REMOVED***Array***REMOVED*** array The array to inspect.
 * @param ***REMOVED***number***REMOVED*** start The start position.
 * @param ***REMOVED***number***REMOVED*** [end=array.length] The end position.
 * @returns ***REMOVED***Array***REMOVED*** Returns the cast slice.
 */
function castSlice(array, start, end) ***REMOVED***
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
***REMOVED***

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param ***REMOVED***Array***REMOVED*** strSymbols The string symbols to inspect.
 * @param ***REMOVED***Array***REMOVED*** chrSymbols The character symbols to find.
 * @returns ***REMOVED***number***REMOVED*** Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) ***REMOVED***
  var index = strSymbols.length;

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) ***REMOVED******REMOVED***
  return index;
***REMOVED***

/**
 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param ***REMOVED***Array***REMOVED*** strSymbols The string symbols to inspect.
 * @param ***REMOVED***Array***REMOVED*** chrSymbols The character symbols to find.
 * @returns ***REMOVED***number***REMOVED*** Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) ***REMOVED***
  var index = -1,
      length = strSymbols.length;

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) ***REMOVED******REMOVED***
  return index;
***REMOVED***

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param ***REMOVED***string***REMOVED*** string The string to convert.
 * @returns ***REMOVED***Array***REMOVED*** Returns the converted array.
 */
function asciiToArray(string) ***REMOVED***
  return string.split('');
***REMOVED***

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff';
var rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23';
var rsComboSymbolsRange = '\\u20d0-\\u20f0';
var rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param ***REMOVED***string***REMOVED*** string The string to inspect.
 * @returns ***REMOVED***boolean***REMOVED*** Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) ***REMOVED***
  return reHasUnicode.test(string);
***REMOVED***

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff';
var rsComboMarksRange$1 = '\\u0300-\\u036f\\ufe20-\\ufe23';
var rsComboSymbolsRange$1 = '\\u20d0-\\u20f0';
var rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']';
var rsCombo = '[' + rsComboMarksRange$1 + rsComboSymbolsRange$1 + ']';
var rsFitz = '\\ud83c[\\udffb-\\udfff]';
var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
var rsNonAstral = '[^' + rsAstralRange$1 + ']';
var rsRegional = '(?:\\ud83c[\\udde6-\\uddff])***REMOVED***2***REMOVED***';
var rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
var rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?';
var rsOptVar = '[' + rsVarRange$1 + ']?';
var rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param ***REMOVED***string***REMOVED*** string The string to convert.
 * @returns ***REMOVED***Array***REMOVED*** Returns the converted array.
 */
function unicodeToArray(string) ***REMOVED***
  return string.match(reUnicode) || [];
***REMOVED***

/**
 * Converts `string` to an array.
 *
 * @private
 * @param ***REMOVED***string***REMOVED*** string The string to convert.
 * @returns ***REMOVED***Array***REMOVED*** Returns the converted array.
 */
function stringToArray(string) ***REMOVED***
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
***REMOVED***

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param ***REMOVED*******REMOVED*** value The value to convert.
 * @returns ***REMOVED***string***REMOVED*** Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) ***REMOVED***
  return value == null ? '' : baseToString(value);
***REMOVED***

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/**
 * Removes leading and trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param ***REMOVED***string***REMOVED*** [string=''] The string to trim.
 * @param ***REMOVED***string***REMOVED*** [chars=whitespace] The characters to trim.
 * @param- ***REMOVED***Object***REMOVED*** [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns ***REMOVED***string***REMOVED*** Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim(string, chars, guard) ***REMOVED***
  string = toString(string);
  if (string && (guard || chars === undefined)) ***REMOVED***
    return string.replace(reTrim, '');
  ***REMOVED***
  if (!string || !(chars = baseToString(chars))) ***REMOVED***
    return string;
  ***REMOVED***
  var strSymbols = stringToArray(string),
      chrSymbols = stringToArray(chars),
      start = charsStartIndex(strSymbols, chrSymbols),
      end = charsEndIndex(strSymbols, chrSymbols) + 1;

  return castSlice(strSymbols, start, end).join('');
***REMOVED***

var FN_ARGS = /^(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /(=.+)?(\s*)$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

function parseParams(func) ***REMOVED***
    func = func.toString().replace(STRIP_COMMENTS, '');
    func = func.match(FN_ARGS)[2].replace(' ', '');
    func = func ? func.split(FN_ARG_SPLIT) : [];
    func = func.map(function (arg) ***REMOVED***
        return trim(arg.replace(FN_ARG, ''));
    ***REMOVED***);
    return func;
***REMOVED***

/**
 * A dependency-injected version of the [async.auto]***REMOVED***@link module:ControlFlow.auto***REMOVED*** function. Dependent
 * tasks are specified as parameters to the function, after the usual callback
 * parameter, with the parameter names matching the names of the tasks it
 * depends on. This can provide even more readable task graphs which can be
 * easier to maintain.
 *
 * If a final callback is specified, the task results are similarly injected,
 * specified as named parameters after the initial error parameter.
 *
 * The autoInject function is purely syntactic sugar and its semantics are
 * otherwise equivalent to [async.auto]***REMOVED***@link module:ControlFlow.auto***REMOVED***.
 *
 * @name autoInject
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.auto]***REMOVED***@link module:ControlFlow.auto***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Object***REMOVED*** tasks - An object, each of whose properties is a function of
 * the form 'func([dependencies...], callback). The object's key of a property
 * serves as the name of the task defined by that property, i.e. can be used
 * when specifying requirements for other tasks.
 * * The `callback` parameter is a `callback(err, result)` which must be called
 *   when finished, passing an `error` (which can be `null`) and the result of
 *   the function's execution. The remaining parameters name other tasks on
 *   which the task is dependent, and the results from those tasks are the
 *   arguments of those parameters.
 * @param ***REMOVED***Function***REMOVED*** [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback, and a `results` object with any completed
 * task results, similar to `auto`.
 * @example
 *
 * //  The example from `auto` can be rewritten as follows:
 * async.autoInject(***REMOVED***
 *     get_data: function(callback) ***REMOVED***
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     ***REMOVED***,
 *     make_folder: function(callback) ***REMOVED***
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     ***REMOVED***,
 *     write_file: function(get_data, make_folder, callback) ***REMOVED***
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     ***REMOVED***,
 *     email_link: function(write_file, callback) ***REMOVED***
 *         // once the file is written let's email a link to it...
 *         // write_file contains the filename returned by write_file.
 *         callback(null, ***REMOVED***'file':write_file, 'email':'user@example.com'***REMOVED***);
 *     ***REMOVED***
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * ***REMOVED***);
 *
 * // If you are using a JS minifier that mangles parameter names, `autoInject`
 * // will not work with plain functions, since the parameter names will be
 * // collapsed to a single letter identifier.  To work around this, you can
 * // explicitly specify the names of the parameters your task function needs
 * // in an array, similar to Angular.js dependency injection.
 *
 * // This still has an advantage over plain `auto`, since the results a task
 * // depends on are still spread into arguments.
 * async.autoInject(***REMOVED***
 *     //...
 *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) ***REMOVED***
 *         callback(null, 'filename');
 *     ***REMOVED***],
 *     email_link: ['write_file', function(write_file, callback) ***REMOVED***
 *         callback(null, ***REMOVED***'file':write_file, 'email':'user@example.com'***REMOVED***);
 *     ***REMOVED***]
 *     //...
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * ***REMOVED***);
 */
function autoInject(tasks, callback) ***REMOVED***
    var newTasks = ***REMOVED******REMOVED***;

    baseForOwn(tasks, function (taskFn, key) ***REMOVED***
        var params;

        if (isArray(taskFn)) ***REMOVED***
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];

            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        ***REMOVED*** else if (taskFn.length === 1) ***REMOVED***
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        ***REMOVED*** else ***REMOVED***
            params = parseParams(taskFn);
            if (taskFn.length === 0 && params.length === 0) ***REMOVED***
                throw new Error("autoInject task functions require explicit parameters.");
            ***REMOVED***

            params.pop();

            newTasks[key] = params.concat(newTask);
        ***REMOVED***

        function newTask(results, taskCb) ***REMOVED***
            var newArgs = arrayMap(params, function (name) ***REMOVED***
                return results[name];
            ***REMOVED***);
            newArgs.push(taskCb);
            taskFn.apply(null, newArgs);
        ***REMOVED***
    ***REMOVED***);

    auto(newTasks, callback);
***REMOVED***

var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) ***REMOVED***
    setTimeout(fn, 0);
***REMOVED***

function wrap(defer) ***REMOVED***
    return rest(function (fn, args) ***REMOVED***
        defer(function () ***REMOVED***
            fn.apply(null, args);
        ***REMOVED***);
    ***REMOVED***);
***REMOVED***

var _defer;

if (hasSetImmediate) ***REMOVED***
    _defer = setImmediate;
***REMOVED*** else if (hasNextTick) ***REMOVED***
    _defer = process.nextTick;
***REMOVED*** else ***REMOVED***
    _defer = fallback;
***REMOVED***

var setImmediate$1 = wrap(_defer);

// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
// used for queues. This implementation assumes that the node provided by the user can be modified
// to adjust the next and last properties. We implement only the minimal functionality
// for queue support.
function DLL() ***REMOVED***
    this.head = this.tail = null;
    this.length = 0;
***REMOVED***

function setInitial(dll, node) ***REMOVED***
    dll.length = 1;
    dll.head = dll.tail = node;
***REMOVED***

DLL.prototype.removeLink = function (node) ***REMOVED***
    if (node.prev) node.prev.next = node.next;else this.head = node.next;
    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;

    node.prev = node.next = null;
    this.length -= 1;
    return node;
***REMOVED***;

DLL.prototype.empty = DLL;

DLL.prototype.insertAfter = function (node, newNode) ***REMOVED***
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next) node.next.prev = newNode;else this.tail = newNode;
    node.next = newNode;
    this.length += 1;
***REMOVED***;

DLL.prototype.insertBefore = function (node, newNode) ***REMOVED***
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev) node.prev.next = newNode;else this.head = newNode;
    node.prev = newNode;
    this.length += 1;
***REMOVED***;

DLL.prototype.unshift = function (node) ***REMOVED***
    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);
***REMOVED***;

DLL.prototype.push = function (node) ***REMOVED***
    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);
***REMOVED***;

DLL.prototype.shift = function () ***REMOVED***
    return this.head && this.removeLink(this.head);
***REMOVED***;

DLL.prototype.pop = function () ***REMOVED***
    return this.tail && this.removeLink(this.tail);
***REMOVED***;

function queue(worker, concurrency, payload) ***REMOVED***
    if (concurrency == null) ***REMOVED***
        concurrency = 1;
    ***REMOVED*** else if (concurrency === 0) ***REMOVED***
        throw new Error('Concurrency must not be zero');
    ***REMOVED***

    function _insert(data, insertAtFront, callback) ***REMOVED***
        if (callback != null && typeof callback !== 'function') ***REMOVED***
            throw new Error('task callback must be a function');
        ***REMOVED***
        q.started = true;
        if (!isArray(data)) ***REMOVED***
            data = [data];
        ***REMOVED***
        if (data.length === 0 && q.idle()) ***REMOVED***
            // call drain immediately if there are no tasks
            return setImmediate$1(function () ***REMOVED***
                q.drain();
            ***REMOVED***);
        ***REMOVED***

        for (var i = 0, l = data.length; i < l; i++) ***REMOVED***
            var item = ***REMOVED***
                data: data[i],
                callback: callback || noop
            ***REMOVED***;

            if (insertAtFront) ***REMOVED***
                q._tasks.unshift(item);
            ***REMOVED*** else ***REMOVED***
                q._tasks.push(item);
            ***REMOVED***
        ***REMOVED***
        setImmediate$1(q.process);
    ***REMOVED***

    function _next(tasks) ***REMOVED***
        return rest(function (args) ***REMOVED***
            workers -= 1;

            for (var i = 0, l = tasks.length; i < l; i++) ***REMOVED***
                var task = tasks[i];
                var index = baseIndexOf(workersList, task, 0);
                if (index >= 0) ***REMOVED***
                    workersList.splice(index);
                ***REMOVED***

                task.callback.apply(task, args);

                if (args[0] != null) ***REMOVED***
                    q.error(args[0], task.data);
                ***REMOVED***
            ***REMOVED***

            if (workers <= q.concurrency - q.buffer) ***REMOVED***
                q.unsaturated();
            ***REMOVED***

            if (q.idle()) ***REMOVED***
                q.drain();
            ***REMOVED***
            q.process();
        ***REMOVED***);
    ***REMOVED***

    var workers = 0;
    var workersList = [];
    var q = ***REMOVED***
        _tasks: new DLL(),
        concurrency: concurrency,
        payload: payload,
        saturated: noop,
        unsaturated: noop,
        buffer: concurrency / 4,
        empty: noop,
        drain: noop,
        error: noop,
        started: false,
        paused: false,
        push: function (data, callback) ***REMOVED***
            _insert(data, false, callback);
        ***REMOVED***,
        kill: function () ***REMOVED***
            q.drain = noop;
            q._tasks.empty();
        ***REMOVED***,
        unshift: function (data, callback) ***REMOVED***
            _insert(data, true, callback);
        ***REMOVED***,
        process: function () ***REMOVED***
            while (!q.paused && workers < q.concurrency && q._tasks.length) ***REMOVED***
                var tasks = [],
                    data = [];
                var l = q._tasks.length;
                if (q.payload) l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) ***REMOVED***
                    var node = q._tasks.shift();
                    tasks.push(node);
                    data.push(node.data);
                ***REMOVED***

                if (q._tasks.length === 0) ***REMOVED***
                    q.empty();
                ***REMOVED***
                workers += 1;
                workersList.push(tasks[0]);

                if (workers === q.concurrency) ***REMOVED***
                    q.saturated();
                ***REMOVED***

                var cb = onlyOnce(_next(tasks));
                worker(data, cb);
            ***REMOVED***
        ***REMOVED***,
        length: function () ***REMOVED***
            return q._tasks.length;
        ***REMOVED***,
        running: function () ***REMOVED***
            return workers;
        ***REMOVED***,
        workersList: function () ***REMOVED***
            return workersList;
        ***REMOVED***,
        idle: function () ***REMOVED***
            return q._tasks.length + workers === 0;
        ***REMOVED***,
        pause: function () ***REMOVED***
            q.paused = true;
        ***REMOVED***,
        resume: function () ***REMOVED***
            if (q.paused === false) ***REMOVED***
                return;
            ***REMOVED***
            q.paused = false;
            var resumeCount = Math.min(q.concurrency, q._tasks.length);
            // Need to call q.process once per concurrent
            // worker to preserve full concurrency after pause
            for (var w = 1; w <= resumeCount; w++) ***REMOVED***
                setImmediate$1(q.process);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    return q;
***REMOVED***

/**
 * A cargo of tasks for the worker function to complete. Cargo inherits all of
 * the same methods and event callbacks as [`queue`]***REMOVED***@link module:ControlFlow.queue***REMOVED***.
 * @typedef ***REMOVED***Object***REMOVED*** CargoObject
 * @memberOf module:ControlFlow
 * @property ***REMOVED***Function***REMOVED*** length - A function returning the number of items
 * waiting to be processed. Invoke like `cargo.length()`.
 * @property ***REMOVED***number***REMOVED*** payload - An `integer` for determining how many tasks
 * should be process per round. This property can be changed after a `cargo` is
 * created to alter the payload on-the-fly.
 * @property ***REMOVED***Function***REMOVED*** push - Adds `task` to the `queue`. The callback is
 * called once the `worker` has finished processing the task. Instead of a
 * single task, an array of `tasks` can be submitted. The respective callback is
 * used for every task in the list. Invoke like `cargo.push(task, [callback])`.
 * @property ***REMOVED***Function***REMOVED*** saturated - A callback that is called when the
 * `queue.length()` hits the concurrency and further tasks will be queued.
 * @property ***REMOVED***Function***REMOVED*** empty - A callback that is called when the last item
 * from the `queue` is given to a `worker`.
 * @property ***REMOVED***Function***REMOVED*** drain - A callback that is called when the last item
 * from the `queue` has returned from the `worker`.
 * @property ***REMOVED***Function***REMOVED*** idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke like `cargo.idle()`.
 * @property ***REMOVED***Function***REMOVED*** pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke like `cargo.pause()`.
 * @property ***REMOVED***Function***REMOVED*** resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke like `cargo.resume()`.
 * @property ***REMOVED***Function***REMOVED*** kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.
 */

/**
 * Creates a `cargo` object with the specified payload. Tasks added to the
 * cargo will be processed altogether (up to the `payload` limit). If the
 * `worker` is in progress, the task is queued until it becomes available. Once
 * the `worker` has completed some tasks, each callback of those tasks is
 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
 * for how `cargo` and `queue` work.
 *
 * While [`queue`]***REMOVED***@link module:ControlFlow.queue***REMOVED*** passes only one task to one of a group of workers
 * at a time, cargo passes an array of tasks to a single worker, repeating
 * when the worker is finished.
 *
 * @name cargo
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]***REMOVED***@link module:ControlFlow.queue***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Function***REMOVED*** worker - An asynchronous function for processing an array
 * of queued tasks, which must call its `callback(err)` argument when finished,
 * with an optional `err` argument. Invoked with `(tasks, callback)`.
 * @param ***REMOVED***number***REMOVED*** [payload=Infinity] - An optional `integer` for determining
 * how many tasks should be processed per round; if omitted, the default is
 * unlimited.
 * @returns ***REMOVED***module:ControlFlow.CargoObject***REMOVED*** A cargo object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the cargo and inner queue.
 * @example
 *
 * // create a cargo object with payload 2
 * var cargo = async.cargo(function(tasks, callback) ***REMOVED***
 *     for (var i=0; i<tasks.length; i++) ***REMOVED***
 *         console.log('hello ' + tasks[i].name);
 *     ***REMOVED***
 *     callback();
 * ***REMOVED***, 2);
 *
 * // add some items
 * cargo.push(***REMOVED***name: 'foo'***REMOVED***, function(err) ***REMOVED***
 *     console.log('finished processing foo');
 * ***REMOVED***);
 * cargo.push(***REMOVED***name: 'bar'***REMOVED***, function(err) ***REMOVED***
 *     console.log('finished processing bar');
 * ***REMOVED***);
 * cargo.push(***REMOVED***name: 'baz'***REMOVED***, function(err) ***REMOVED***
 *     console.log('finished processing baz');
 * ***REMOVED***);
 */
function cargo(worker, payload) ***REMOVED***
  return queue(worker, 1, payload);
***REMOVED***

/**
 * The same as [`eachOf`]***REMOVED***@link module:Collections.eachOf***REMOVED*** but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]***REMOVED***@link module:Collections.eachOf***REMOVED***
 * @alias forEachOfSeries
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each item in `coll`. The
 * `key` is the item's key, or index in the case of an array. The iteratee is
 * passed a `callback(err)` which must be called once it has completed. If no
 * error has occurred, the callback should be run without arguments or with an
 * explicit `null` argument. Invoked with (item, key, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 */
var eachOfSeries = doLimit(eachOfLimit, 1);

/**
 * Reduces `coll` into a single value using an async `iteratee` to return each
 * successive step. `memo` is the initial state of the reduction. This function
 * only operates in series.
 *
 * For performance reasons, it may make sense to split a call to this function
 * into a parallel map, and then use the normal `Array.prototype.reduce` on the
 * results. This function is for situations where each step in the reduction
 * needs to be async; if you can get the data before reducing it, then it's
 * probably a good idea to do so.
 *
 * @name reduce
 * @static
 * @memberOf module:Collections
 * @method
 * @alias inject
 * @alias foldl
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED*******REMOVED*** memo - The initial state of the reduction.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function applied to each item in the
 * array to produce the next step in the reduction. The `iteratee` is passed a
 * `callback(err, reduction)` which accepts an optional error as its first
 * argument, and the state of the reduction as the second. If an error is
 * passed to the callback, the reduction is stopped and the main `callback` is
 * immediately called with the error. Invoked with (memo, item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @example
 *
 * async.reduce([1,2,3], 0, function(memo, item, callback) ***REMOVED***
 *     // pointless async:
 *     process.nextTick(function() ***REMOVED***
 *         callback(null, memo + item)
 *     ***REMOVED***);
 * ***REMOVED***, function(err, result) ***REMOVED***
 *     // result is now equal to the last value of memo, which is 6
 * ***REMOVED***);
 */
function reduce(coll, memo, iteratee, callback) ***REMOVED***
    callback = once(callback || noop);
    eachOfSeries(coll, function (x, i, callback) ***REMOVED***
        iteratee(memo, x, function (err, v) ***REMOVED***
            memo = v;
            callback(err);
        ***REMOVED***);
    ***REMOVED***, function (err) ***REMOVED***
        callback(err, memo);
    ***REMOVED***);
***REMOVED***

/**
 * Version of the compose function that is more natural to read. Each function
 * consumes the return value of the previous function. It is the equivalent of
 * [compose]***REMOVED***@link module:ControlFlow.compose***REMOVED*** with the arguments reversed.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name seq
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.compose]***REMOVED***@link module:ControlFlow.compose***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***...Function***REMOVED*** functions - the asynchronous functions to compose
 * @returns ***REMOVED***Function***REMOVED*** a function that composes the `functions` in order
 * @example
 *
 * // Requires lodash (or underscore), express3 and dresende's orm2.
 * // Part of an app, that fetches cats of the logged user.
 * // This example uses `seq` function to avoid overnesting and error
 * // handling clutter.
 * app.get('/cats', function(request, response) ***REMOVED***
 *     var User = request.models.User;
 *     async.seq(
 *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
 *         function(user, fn) ***REMOVED***
 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
 *         ***REMOVED***
 *     )(req.session.user_id, function (err, cats) ***REMOVED***
 *         if (err) ***REMOVED***
 *             console.error(err);
 *             response.json(***REMOVED*** status: 'error', message: err.message ***REMOVED***);
 *         ***REMOVED*** else ***REMOVED***
 *             response.json(***REMOVED*** status: 'ok', message: 'Cats found', data: cats ***REMOVED***);
 *         ***REMOVED***
 *     ***REMOVED***);
 * ***REMOVED***);
 */
var seq$1 = rest(function seq(functions) ***REMOVED***
    return rest(function (args) ***REMOVED***
        var that = this;

        var cb = args[args.length - 1];
        if (typeof cb == 'function') ***REMOVED***
            args.pop();
        ***REMOVED*** else ***REMOVED***
            cb = noop;
        ***REMOVED***

        reduce(functions, args, function (newargs, fn, cb) ***REMOVED***
            fn.apply(that, newargs.concat([rest(function (err, nextargs) ***REMOVED***
                cb(err, nextargs);
            ***REMOVED***)]));
        ***REMOVED***, function (err, results) ***REMOVED***
            cb.apply(that, [err].concat(results));
        ***REMOVED***);
    ***REMOVED***);
***REMOVED***);

/**
 * Creates a function which is a composition of the passed asynchronous
 * functions. Each function consumes the return value of the function that
 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
 * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name compose
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***...Function***REMOVED*** functions - the asynchronous functions to compose
 * @returns ***REMOVED***Function***REMOVED*** an asynchronous function that is the composed
 * asynchronous `functions`
 * @example
 *
 * function add1(n, callback) ***REMOVED***
 *     setTimeout(function () ***REMOVED***
 *         callback(null, n + 1);
 *     ***REMOVED***, 10);
 * ***REMOVED***
 *
 * function mul3(n, callback) ***REMOVED***
 *     setTimeout(function () ***REMOVED***
 *         callback(null, n * 3);
 *     ***REMOVED***, 10);
 * ***REMOVED***
 *
 * var add1mul3 = async.compose(mul3, add1);
 * add1mul3(4, function (err, result) ***REMOVED***
 *     // result now equals 15
 * ***REMOVED***);
 */
var compose = rest(function (args) ***REMOVED***
  return seq$1.apply(null, args.reverse());
***REMOVED***);

function concat$1(eachfn, arr, fn, callback) ***REMOVED***
    var result = [];
    eachfn(arr, function (x, index, cb) ***REMOVED***
        fn(x, function (err, y) ***REMOVED***
            result = result.concat(y || []);
            cb(err);
        ***REMOVED***);
    ***REMOVED***, function (err) ***REMOVED***
        callback(err, result);
    ***REMOVED***);
***REMOVED***

/**
 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
 * the concatenated list. The `iteratee`s are called in parallel, and the
 * results are concatenated as they return. There is no guarantee that the
 * results array will be returned in the original order of `coll` passed to the
 * `iteratee` function.
 *
 * @name concat
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each item in `coll`.
 * The iteratee is passed a `callback(err, results)` which must be called once
 * it has completed with an error (which can be `null`) and an array of results.
 * Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback(err)] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @example
 *
 * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) ***REMOVED***
 *     // files is now a list of filenames that exist in the 3 directories
 * ***REMOVED***);
 */
var concat = doParallel(concat$1);

function doSeries(fn) ***REMOVED***
    return function (obj, iteratee, callback) ***REMOVED***
        return fn(eachOfSeries, obj, iteratee, callback);
    ***REMOVED***;
***REMOVED***

/**
 * The same as [`concat`]***REMOVED***@link module:Collections.concat***REMOVED*** but runs only a single async operation at a time.
 *
 * @name concatSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]***REMOVED***@link module:Collections.concat***REMOVED***
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each item in `coll`.
 * The iteratee is passed a `callback(err, results)` which must be called once
 * it has completed with an error (which can be `null`) and an array of results.
 * Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback(err)] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 */
var concatSeries = doSeries(concat$1);

/**
 * Returns a function that when called, calls-back with the values provided.
 * Useful as the first function in a [`waterfall`]***REMOVED***@link module:ControlFlow.waterfall***REMOVED***, or for plugging values in to
 * [`auto`]***REMOVED***@link module:ControlFlow.auto***REMOVED***.
 *
 * @name constant
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param ***REMOVED***...****REMOVED*** arguments... - Any number of arguments to automatically invoke
 * callback with.
 * @returns ***REMOVED***Function***REMOVED*** Returns a function that when invoked, automatically
 * invokes the callback with the previous given arguments.
 * @example
 *
 * async.waterfall([
 *     async.constant(42),
 *     function (value, next) ***REMOVED***
 *         // value === 42
 *     ***REMOVED***,
 *     //...
 * ], callback);
 *
 * async.waterfall([
 *     async.constant(filename, "utf8"),
 *     fs.readFile,
 *     function (fileData, next) ***REMOVED***
 *         //...
 *     ***REMOVED***
 *     //...
 * ], callback);
 *
 * async.auto(***REMOVED***
 *     hostname: async.constant("https://server.net/"),
 *     port: findFreePort,
 *     launchServer: ["hostname", "port", function (options, cb) ***REMOVED***
 *         startServer(options, cb);
 *     ***REMOVED***],
 *     //...
 * ***REMOVED***, callback);
 */
var constant = rest(function (values) ***REMOVED***
    var args = [null].concat(values);
    return initialParams(function (ignoredArgs, callback) ***REMOVED***
        return callback.apply(this, args);
    ***REMOVED***);
***REMOVED***);

function _createTester(eachfn, check, getResult) ***REMOVED***
    return function (arr, limit, iteratee, cb) ***REMOVED***
        function done() ***REMOVED***
            if (cb) ***REMOVED***
                cb(null, getResult(false));
            ***REMOVED***
        ***REMOVED***
        function wrappedIteratee(x, _, callback) ***REMOVED***
            if (!cb) return callback();
            iteratee(x, function (err, v) ***REMOVED***
                // Check cb as another iteratee may have resolved with a
                // value or error since we started this iteratee
                if (cb && (err || check(v))) ***REMOVED***
                    if (err) cb(err);else cb(err, getResult(true, x));
                    cb = iteratee = false;
                    callback(err, breakLoop);
                ***REMOVED*** else ***REMOVED***
                    callback();
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
        if (arguments.length > 3) ***REMOVED***
            cb = cb || noop;
            eachfn(arr, limit, wrappedIteratee, done);
        ***REMOVED*** else ***REMOVED***
            cb = iteratee;
            cb = cb || noop;
            iteratee = limit;
            eachfn(arr, wrappedIteratee, done);
        ***REMOVED***
    ***REMOVED***;
***REMOVED***

function _findGetResult(v, x) ***REMOVED***
    return x;
***REMOVED***

/**
 * Returns the first value in `coll` that passes an async truth test. The
 * `iteratee` is applied in parallel, meaning the first iteratee to return
 * `true` will fire the detect `callback` with that result. That means the
 * result might not be the first item in the original `coll` (in terms of order)
 * that passes the test.

 * If order within the original `coll` is important, then look at
 * [`detectSeries`]***REMOVED***@link module:Collections.detectSeries***REMOVED***.
 *
 * @name detect
 * @static
 * @memberOf module:Collections
 * @method
 * @alias find
 * @category Collections
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in `coll`.
 * The iteratee is passed a `callback(err, truthValue)` which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @example
 *
 * async.detect(['file1','file2','file3'], function(filePath, callback) ***REMOVED***
 *     fs.access(filePath, function(err) ***REMOVED***
 *         callback(null, !err)
 *     ***REMOVED***);
 * ***REMOVED***, function(err, result) ***REMOVED***
 *     // result now equals the first file in the list that exists
 * ***REMOVED***);
 */
var detect = _createTester(eachOf, identity, _findGetResult);

/**
 * The same as [`detect`]***REMOVED***@link module:Collections.detect***REMOVED*** but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name detectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]***REMOVED***@link module:Collections.detect***REMOVED***
 * @alias findLimit
 * @category Collections
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in `coll`.
 * The iteratee is passed a `callback(err, truthValue)` which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */
var detectLimit = _createTester(eachOfLimit, identity, _findGetResult);

/**
 * The same as [`detect`]***REMOVED***@link module:Collections.detect***REMOVED*** but runs only a single async operation at a time.
 *
 * @name detectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]***REMOVED***@link module:Collections.detect***REMOVED***
 * @alias findSeries
 * @category Collections
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in `coll`.
 * The iteratee is passed a `callback(err, truthValue)` which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */
var detectSeries = _createTester(eachOfSeries, identity, _findGetResult);

function consoleFunc(name) ***REMOVED***
    return rest(function (fn, args) ***REMOVED***
        fn.apply(null, args.concat([rest(function (err, args) ***REMOVED***
            if (typeof console === 'object') ***REMOVED***
                if (err) ***REMOVED***
                    if (console.error) ***REMOVED***
                        console.error(err);
                    ***REMOVED***
                ***REMOVED*** else if (console[name]) ***REMOVED***
                    arrayEach(args, function (x) ***REMOVED***
                        console[name](x);
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***)]));
    ***REMOVED***);
***REMOVED***

/**
 * Logs the result of an `async` function to the `console` using `console.dir`
 * to display the properties of the resulting object. Only works in Node.js or
 * in browsers that support `console.dir` and `console.error` (such as FF and
 * Chrome). If multiple arguments are returned from the async function,
 * `console.dir` is called on each argument in order.
 *
 * @name dir
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** function - The function you want to eventually apply all
 * arguments to.
 * @param ***REMOVED***...****REMOVED*** arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) ***REMOVED***
 *     setTimeout(function() ***REMOVED***
 *         callback(null, ***REMOVED***hello: name***REMOVED***);
 *     ***REMOVED***, 1000);
 * ***REMOVED***;
 *
 * // in the node repl
 * node> async.dir(hello, 'world');
 * ***REMOVED***hello: 'world'***REMOVED***
 */
var dir = consoleFunc('dir');

/**
 * The post-check version of [`during`]***REMOVED***@link module:ControlFlow.during***REMOVED***. To reflect the difference in
 * the order of operations, the arguments `test` and `fn` are switched.
 *
 * Also a version of [`doWhilst`]***REMOVED***@link module:ControlFlow.doWhilst***REMOVED*** with asynchronous `test` function.
 * @name doDuring
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.during]***REMOVED***@link module:ControlFlow.during***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Function***REMOVED*** fn - A function which is called each time `test` passes.
 * The function is passed a `callback(err)`, which must be called once it has
 * completed with an optional `err` argument. Invoked with (callback).
 * @param ***REMOVED***Function***REMOVED*** test - asynchronous truth test to perform before each
 * execution of `fn`. Invoked with (...args, callback), where `...args` are the
 * non-error args from the previous callback of `fn`.
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after the test
 * function has failed and repeated execution of `fn` has stopped. `callback`
 * will be passed an error if one occured, otherwise `null`.
 */
function doDuring(fn, test, callback) ***REMOVED***
    callback = onlyOnce(callback || noop);

    var next = rest(function (err, args) ***REMOVED***
        if (err) return callback(err);
        args.push(check);
        test.apply(this, args);
    ***REMOVED***);

    function check(err, truth) ***REMOVED***
        if (err) return callback(err);
        if (!truth) return callback(null);
        fn(next);
    ***REMOVED***

    check(null, true);
***REMOVED***

/**
 * The post-check version of [`whilst`]***REMOVED***@link module:ControlFlow.whilst***REMOVED***. To reflect the difference in
 * the order of operations, the arguments `test` and `iteratee` are switched.
 *
 * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
 *
 * @name doWhilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]***REMOVED***@link module:ControlFlow.whilst***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function which is called each time `test`
 * passes. The function is passed a `callback(err)`, which must be called once
 * it has completed with an optional `err` argument. Invoked with (callback).
 * @param ***REMOVED***Function***REMOVED*** test - synchronous truth test to perform after each
 * execution of `iteratee`. Invoked with the non-error callback results of 
 * `iteratee`.
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped.
 * `callback` will be passed an error and any arguments passed to the final
 * `iteratee`'s callback. Invoked with (err, [results]);
 */
function doWhilst(iteratee, test, callback) ***REMOVED***
    callback = onlyOnce(callback || noop);
    var next = rest(function (err, args) ***REMOVED***
        if (err) return callback(err);
        if (test.apply(this, args)) return iteratee(next);
        callback.apply(null, [null].concat(args));
    ***REMOVED***);
    iteratee(next);
***REMOVED***

/**
 * Like ['doWhilst']***REMOVED***@link module:ControlFlow.doWhilst***REMOVED***, except the `test` is inverted. Note the
 * argument ordering differs from `until`.
 *
 * @name doUntil
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.doWhilst]***REMOVED***@link module:ControlFlow.doWhilst***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Function***REMOVED*** fn - A function which is called each time `test` fails.
 * The function is passed a `callback(err)`, which must be called once it has
 * completed with an optional `err` argument. Invoked with (callback).
 * @param ***REMOVED***Function***REMOVED*** test - synchronous truth test to perform after each
 * execution of `fn`. Invoked with the non-error callback results of `fn`.
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after the test
 * function has passed and repeated execution of `fn` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `fn`'s
 * callback. Invoked with (err, [results]);
 */
function doUntil(fn, test, callback) ***REMOVED***
    doWhilst(fn, function () ***REMOVED***
        return !test.apply(this, arguments);
    ***REMOVED***, callback);
***REMOVED***

/**
 * Like [`whilst`]***REMOVED***@link module:ControlFlow.whilst***REMOVED***, except the `test` is an asynchronous function that
 * is passed a callback in the form of `function (err, truth)`. If error is
 * passed to `test` or `fn`, the main callback is immediately called with the
 * value of the error.
 *
 * @name during
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]***REMOVED***@link module:ControlFlow.whilst***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Function***REMOVED*** test - asynchronous truth test to perform before each
 * execution of `fn`. Invoked with (callback).
 * @param ***REMOVED***Function***REMOVED*** fn - A function which is called each time `test` passes.
 * The function is passed a `callback(err)`, which must be called once it has
 * completed with an optional `err` argument. Invoked with (callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after the test
 * function has failed and repeated execution of `fn` has stopped. `callback`
 * will be passed an error, if one occured, otherwise `null`.
 * @example
 *
 * var count = 0;
 *
 * async.during(
 *     function (callback) ***REMOVED***
 *         return callback(null, count < 5);
 *     ***REMOVED***,
 *     function (callback) ***REMOVED***
 *         count++;
 *         setTimeout(callback, 1000);
 *     ***REMOVED***,
 *     function (err) ***REMOVED***
 *         // 5 seconds have passed
 *     ***REMOVED***
 * );
 */
function during(test, fn, callback) ***REMOVED***
    callback = onlyOnce(callback || noop);

    function next(err) ***REMOVED***
        if (err) return callback(err);
        test(check);
    ***REMOVED***

    function check(err, truth) ***REMOVED***
        if (err) return callback(err);
        if (!truth) return callback(null);
        fn(next);
    ***REMOVED***

    test(check);
***REMOVED***

function _withoutIndex(iteratee) ***REMOVED***
    return function (value, index, callback) ***REMOVED***
        return iteratee(value, callback);
    ***REMOVED***;
***REMOVED***

/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each item
 * in `coll`. The iteratee is passed a `callback(err)` which must be called once
 * it has completed. If no error has occurred, the `callback` should be run
 * without arguments or with an explicit `null` argument. The array index is not
 * passed to the iteratee. Invoked with (item, callback). If you need the index,
 * use `eachOf`.
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * // assuming openFiles is an array of file names and saveFile is a function
 * // to save the modified contents of that file:
 *
 * async.each(openFiles, saveFile, function(err)***REMOVED***
 *   // if any of the saves produced an error, err would equal that error
 * ***REMOVED***);
 *
 * // assuming openFiles is an array of file names
 * async.each(openFiles, function(file, callback) ***REMOVED***
 *
 *     // Perform operation on file here.
 *     console.log('Processing file ' + file);
 *
 *     if( file.length > 32 ) ***REMOVED***
 *       console.log('This file name is too long');
 *       callback('File name too long');
 *     ***REMOVED*** else ***REMOVED***
 *       // Do work to process file here
 *       console.log('File processed');
 *       callback();
 *     ***REMOVED***
 * ***REMOVED***, function(err) ***REMOVED***
 *     // if any of the file processing produced an error, err would equal that error
 *     if( err ) ***REMOVED***
 *       // One of the iterations produced an error.
 *       // All processing will now stop.
 *       console.log('A file failed to process');
 *     ***REMOVED*** else ***REMOVED***
 *       console.log('All files have been processed successfully');
 *     ***REMOVED***
 * ***REMOVED***);
 */
function eachLimit(coll, iteratee, callback) ***REMOVED***
  eachOf(coll, _withoutIndex(iteratee), callback);
***REMOVED***

/**
 * The same as [`each`]***REMOVED***@link module:Collections.each***REMOVED*** but runs a maximum of `limit` async operations at a time.
 *
 * @name eachLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]***REMOVED***@link module:Collections.each***REMOVED***
 * @alias forEachLimit
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each item in `coll`. The
 * iteratee is passed a `callback(err)` which must be called once it has
 * completed. If no error has occurred, the `callback` should be run without
 * arguments or with an explicit `null` argument. The array index is not passed
 * to the iteratee. Invoked with (item, callback). If you need the index, use
 * `eachOfLimit`.
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachLimit$1(coll, limit, iteratee, callback) ***REMOVED***
  _eachOfLimit(limit)(coll, _withoutIndex(iteratee), callback);
***REMOVED***

/**
 * The same as [`each`]***REMOVED***@link module:Collections.each***REMOVED*** but runs only a single async operation at a time.
 *
 * @name eachSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]***REMOVED***@link module:Collections.each***REMOVED***
 * @alias forEachSeries
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each
 * item in `coll`. The iteratee is passed a `callback(err)` which must be called
 * once it has completed. If no error has occurred, the `callback` should be run
 * without arguments or with an explicit `null` argument. The array index is
 * not passed to the iteratee. Invoked with (item, callback). If you need the
 * index, use `eachOfSeries`.
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
var eachSeries = doLimit(eachLimit$1, 1);

/**
 * Wrap an async function and ensure it calls its callback on a later tick of
 * the event loop.  If the function already calls its callback on a next tick,
 * no extra deferral is added. This is useful for preventing stack overflows
 * (`RangeError: Maximum call stack size exceeded`) and generally keeping
 * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
 * contained.
 *
 * @name ensureAsync
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** fn - an async function, one that expects a node-style
 * callback as its last argument.
 * @returns ***REMOVED***Function***REMOVED*** Returns a wrapped function with the exact same call
 * signature as the function passed in.
 * @example
 *
 * function sometimesAsync(arg, callback) ***REMOVED***
 *     if (cache[arg]) ***REMOVED***
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     ***REMOVED*** else ***REMOVED***
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     ***REMOVED***
 * ***REMOVED***
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.mapSeries(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) ***REMOVED***
    return initialParams(function (args, callback) ***REMOVED***
        var sync = true;
        args.push(function () ***REMOVED***
            var innerArgs = arguments;
            if (sync) ***REMOVED***
                setImmediate$1(function () ***REMOVED***
                    callback.apply(null, innerArgs);
                ***REMOVED***);
            ***REMOVED*** else ***REMOVED***
                callback.apply(null, innerArgs);
            ***REMOVED***
        ***REMOVED***);
        fn.apply(this, args);
        sync = false;
    ***REMOVED***);
***REMOVED***

function notId(v) ***REMOVED***
    return !v;
***REMOVED***

/**
 * Returns `true` if every element in `coll` satisfies an async test. If any
 * iteratee call returns `false`, the main `callback` is immediately called.
 *
 * @name every
 * @static
 * @memberOf module:Collections
 * @method
 * @alias all
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in the
 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
 * which must be called with a  boolean argument once it has completed. Invoked
 * with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @example
 *
 * async.every(['file1','file2','file3'], function(filePath, callback) ***REMOVED***
 *     fs.access(filePath, function(err) ***REMOVED***
 *         callback(null, !err)
 *     ***REMOVED***);
 * ***REMOVED***, function(err, result) ***REMOVED***
 *     // if result is true then every file exists
 * ***REMOVED***);
 */
var every = _createTester(eachOf, notId, notId);

/**
 * The same as [`every`]***REMOVED***@link module:Collections.every***REMOVED*** but runs a maximum of `limit` async operations at a time.
 *
 * @name everyLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]***REMOVED***@link module:Collections.every***REMOVED***
 * @alias allLimit
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in the
 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
 * which must be called with a  boolean argument once it has completed. Invoked
 * with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 */
var everyLimit = _createTester(eachOfLimit, notId, notId);

/**
 * The same as [`every`]***REMOVED***@link module:Collections.every***REMOVED*** but runs only a single async operation at a time.
 *
 * @name everySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]***REMOVED***@link module:Collections.every***REMOVED***
 * @alias allSeries
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in the
 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
 * which must be called with a  boolean argument once it has completed. Invoked
 * with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 */
var everySeries = doLimit(everyLimit, 1);

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param ***REMOVED***string***REMOVED*** key The key of the property to get.
 * @returns ***REMOVED***Function***REMOVED*** Returns the new accessor function.
 */
function baseProperty(key) ***REMOVED***
  return function(object) ***REMOVED***
    return object == null ? undefined : object[key];
  ***REMOVED***;
***REMOVED***

function filterArray(eachfn, arr, iteratee, callback) ***REMOVED***
    var truthValues = new Array(arr.length);
    eachfn(arr, function (x, index, callback) ***REMOVED***
        iteratee(x, function (err, v) ***REMOVED***
            truthValues[index] = !!v;
            callback(err);
        ***REMOVED***);
    ***REMOVED***, function (err) ***REMOVED***
        if (err) return callback(err);
        var results = [];
        for (var i = 0; i < arr.length; i++) ***REMOVED***
            if (truthValues[i]) results.push(arr[i]);
        ***REMOVED***
        callback(null, results);
    ***REMOVED***);
***REMOVED***

function filterGeneric(eachfn, coll, iteratee, callback) ***REMOVED***
    var results = [];
    eachfn(coll, function (x, index, callback) ***REMOVED***
        iteratee(x, function (err, v) ***REMOVED***
            if (err) ***REMOVED***
                callback(err);
            ***REMOVED*** else ***REMOVED***
                if (v) ***REMOVED***
                    results.push(***REMOVED*** index: index, value: x ***REMOVED***);
                ***REMOVED***
                callback();
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***, function (err) ***REMOVED***
        if (err) ***REMOVED***
            callback(err);
        ***REMOVED*** else ***REMOVED***
            callback(null, arrayMap(results.sort(function (a, b) ***REMOVED***
                return a.index - b.index;
            ***REMOVED***), baseProperty('value')));
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

function _filter(eachfn, coll, iteratee, callback) ***REMOVED***
    var filter = isArrayLike(coll) ? filterArray : filterGeneric;
    filter(eachfn, coll, iteratee, callback || noop);
***REMOVED***

/**
 * Returns a new array of all the values in `coll` which pass an async truth
 * test. This operation is performed in parallel, but the results array will be
 * in the same order as the original.
 *
 * @name filter
 * @static
 * @memberOf module:Collections
 * @method
 * @alias select
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.filter(['file1','file2','file3'], function(filePath, callback) ***REMOVED***
 *     fs.access(filePath, function(err) ***REMOVED***
 *         callback(null, !err)
 *     ***REMOVED***);
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     // results now equals an array of the existing files
 * ***REMOVED***);
 */
var filter = doParallel(_filter);

/**
 * The same as [`filter`]***REMOVED***@link module:Collections.filter***REMOVED*** but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name filterLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]***REMOVED***@link module:Collections.filter***REMOVED***
 * @alias selectLimit
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var filterLimit = doParallelLimit(_filter);

/**
 * The same as [`filter`]***REMOVED***@link module:Collections.filter***REMOVED*** but runs only a single async operation at a time.
 *
 * @name filterSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]***REMOVED***@link module:Collections.filter***REMOVED***
 * @alias selectSeries
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results)
 */
var filterSeries = doLimit(filterLimit, 1);

/**
 * Calls the asynchronous function `fn` with a callback parameter that allows it
 * to call itself again, in series, indefinitely.

 * If an error is passed to the
 * callback then `errback` is called with the error, and execution stops,
 * otherwise it will never be called.
 *
 * @name forever
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Function***REMOVED*** fn - a function to call repeatedly. Invoked with (next).
 * @param ***REMOVED***Function***REMOVED*** [errback] - when `fn` passes an error to it's callback,
 * this function will be called, and execution stops. Invoked with (err).
 * @example
 *
 * async.forever(
 *     function(next) ***REMOVED***
 *         // next is suitable for passing to things that need a callback(err [, whatever]);
 *         // it will result in this function being called again.
 *     ***REMOVED***,
 *     function(err) ***REMOVED***
 *         // if next is called with a value in its first parameter, it will appear
 *         // in here as 'err', and execution will stop.
 *     ***REMOVED***
 * );
 */
function forever(fn, errback) ***REMOVED***
    var done = onlyOnce(errback || noop);
    var task = ensureAsync(fn);

    function next(err) ***REMOVED***
        if (err) return done(err);
        task(next);
    ***REMOVED***
    next();
***REMOVED***

/**
 * Logs the result of an `async` function to the `console`. Only works in
 * Node.js or in browsers that support `console.log` and `console.error` (such
 * as FF and Chrome). If multiple arguments are returned from the async
 * function, `console.log` is called on each argument in order.
 *
 * @name log
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** function - The function you want to eventually apply all
 * arguments to.
 * @param ***REMOVED***...****REMOVED*** arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) ***REMOVED***
 *     setTimeout(function() ***REMOVED***
 *         callback(null, 'hello ' + name);
 *     ***REMOVED***, 1000);
 * ***REMOVED***;
 *
 * // in the node repl
 * node> async.log(hello, 'world');
 * 'hello world'
 */
var log = consoleFunc('log');

/**
 * The same as [`mapValues`]***REMOVED***@link module:Collections.mapValues***REMOVED*** but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name mapValuesLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]***REMOVED***@link module:Collections.mapValues***REMOVED***
 * @category Collection
 * @param ***REMOVED***Object***REMOVED*** obj - A collection to iterate over.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each value in `obj`.
 * The iteratee is passed a `callback(err, transformed)` which must be called
 * once it has completed with an error (which can be `null`) and a
 * transformed value. Invoked with (value, key, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 */
function mapValuesLimit(obj, limit, iteratee, callback) ***REMOVED***
    callback = once(callback || noop);
    var newObj = ***REMOVED******REMOVED***;
    eachOfLimit(obj, limit, function (val, key, next) ***REMOVED***
        iteratee(val, key, function (err, result) ***REMOVED***
            if (err) return next(err);
            newObj[key] = result;
            next();
        ***REMOVED***);
    ***REMOVED***, function (err) ***REMOVED***
        callback(err, newObj);
    ***REMOVED***);
***REMOVED***

/**
 * A relative of [`map`]***REMOVED***@link module:Collections.map***REMOVED***, designed for use with objects.
 *
 * Produces a new Object by mapping each value of `obj` through the `iteratee`
 * function. The `iteratee` is called each `value` and `key` from `obj` and a
 * callback for when it has finished processing. Each of these callbacks takes
 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
 * passes an error to its callback, the main `callback` (for the `mapValues`
 * function) is immediately called with the error.
 *
 * Note, the order of the keys in the result is not guaranteed.  The keys will
 * be roughly in the order they complete, (but this is very engine-specific)
 *
 * @name mapValues
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param ***REMOVED***Object***REMOVED*** obj - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each value and key in
 * `coll`. The iteratee is passed a `callback(err, transformed)` which must be
 * called once it has completed with an error (which can be `null`) and a
 * transformed value. Invoked with (value, key, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @example
 *
 * async.mapValues(***REMOVED***
 *     f1: 'file1',
 *     f2: 'file2',
 *     f3: 'file3'
 * ***REMOVED***, function (file, key, callback) ***REMOVED***
 *   fs.stat(file, callback);
 * ***REMOVED***, function(err, result) ***REMOVED***
 *     // result is now a map of stats for each file, e.g.
 *     // ***REMOVED***
 *     //     f1: [stats for file1],
 *     //     f2: [stats for file2],
 *     //     f3: [stats for file3]
 *     // ***REMOVED***
 * ***REMOVED***);
 */

var mapValues = doLimit(mapValuesLimit, Infinity);

/**
 * The same as [`mapValues`]***REMOVED***@link module:Collections.mapValues***REMOVED*** but runs only a single async operation at a time.
 *
 * @name mapValuesSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]***REMOVED***@link module:Collections.mapValues***REMOVED***
 * @category Collection
 * @param ***REMOVED***Object***REMOVED*** obj - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each value in `obj`.
 * The iteratee is passed a `callback(err, transformed)` which must be called
 * once it has completed with an error (which can be `null`) and a
 * transformed value. Invoked with (value, key, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 */
var mapValuesSeries = doLimit(mapValuesLimit, 1);

function has(obj, key) ***REMOVED***
    return key in obj;
***REMOVED***

/**
 * Caches the results of an `async` function. When creating a hash to store
 * function results against, the callback is omitted from the hash and an
 * optional hash function can be used.
 *
 * If no hash function is specified, the first argument is used as a hash key,
 * which may work reasonably if it is a string or a data type that converts to a
 * distinct string. Note that objects and arrays will not behave reasonably.
 * Neither will cases where the other arguments are significant. In such cases,
 * specify your own hash function.
 *
 * The cache of results is exposed as the `memo` property of the function
 * returned by `memoize`.
 *
 * @name memoize
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** fn - The function to proxy and cache results from.
 * @param ***REMOVED***Function***REMOVED*** hasher - An optional function for generating a custom hash
 * for storing results. It has all the arguments applied to it apart from the
 * callback, and must be synchronous.
 * @returns ***REMOVED***Function***REMOVED*** a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) ***REMOVED***
 *     // do something
 *     callback(null, result);
 * ***REMOVED***;
 * var fn = async.memoize(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn('some name', function() ***REMOVED***
 *     // callback
 * ***REMOVED***);
 */
function memoize(fn, hasher) ***REMOVED***
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || identity;
    var memoized = initialParams(function memoized(args, callback) ***REMOVED***
        var key = hasher.apply(null, args);
        if (has(memo, key)) ***REMOVED***
            setImmediate$1(function () ***REMOVED***
                callback.apply(null, memo[key]);
            ***REMOVED***);
        ***REMOVED*** else if (has(queues, key)) ***REMOVED***
            queues[key].push(callback);
        ***REMOVED*** else ***REMOVED***
            queues[key] = [callback];
            fn.apply(null, args.concat([rest(function (args) ***REMOVED***
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) ***REMOVED***
                    q[i].apply(null, args);
                ***REMOVED***
            ***REMOVED***)]));
        ***REMOVED***
    ***REMOVED***);
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
***REMOVED***

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `setImmediate`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name nextTick
 * @static
 * @memberOf module:Utils
 * @method
 * @alias setImmediate
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param ***REMOVED***...****REMOVED*** args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() ***REMOVED***
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * ***REMOVED***);
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) ***REMOVED***
 *     // a, b, and c equal 1, 2, and 3
 * ***REMOVED***, 1, 2, 3);
 */
var _defer$1;

if (hasNextTick) ***REMOVED***
    _defer$1 = process.nextTick;
***REMOVED*** else if (hasSetImmediate) ***REMOVED***
    _defer$1 = setImmediate;
***REMOVED*** else ***REMOVED***
    _defer$1 = fallback;
***REMOVED***

var nextTick = wrap(_defer$1);

function _parallel(eachfn, tasks, callback) ***REMOVED***
    callback = callback || noop;
    var results = isArrayLike(tasks) ? [] : ***REMOVED******REMOVED***;

    eachfn(tasks, function (task, key, callback) ***REMOVED***
        task(rest(function (err, args) ***REMOVED***
            if (args.length <= 1) ***REMOVED***
                args = args[0];
            ***REMOVED***
            results[key] = args;
            callback(err);
        ***REMOVED***));
    ***REMOVED***, function (err) ***REMOVED***
        callback(err, results);
    ***REMOVED***);
***REMOVED***

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from ***REMOVED***@link async.parallel***REMOVED***.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** tasks - A collection containing functions to run.
 * Each function is passed a `callback(err, result)` which it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param ***REMOVED***Function***REMOVED*** [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @example
 * async.parallel([
 *     function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 'one');
 *         ***REMOVED***, 200);
 *     ***REMOVED***,
 *     function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 'two');
 *         ***REMOVED***, 100);
 *     ***REMOVED***
 * ],
 * // optional callback
 * function(err, results) ***REMOVED***
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * ***REMOVED***);
 *
 * // an example using an object instead of an array
 * async.parallel(***REMOVED***
 *     one: function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 1);
 *         ***REMOVED***, 200);
 *     ***REMOVED***,
 *     two: function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 2);
 *         ***REMOVED***, 100);
 *     ***REMOVED***
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     // results is now equals to: ***REMOVED***one: 1, two: 2***REMOVED***
 * ***REMOVED***);
 */
function parallelLimit(tasks, callback) ***REMOVED***
  _parallel(eachOf, tasks, callback);
***REMOVED***

/**
 * The same as [`parallel`]***REMOVED***@link module:ControlFlow.parallel***REMOVED*** but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name parallelLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.parallel]***REMOVED***@link module:ControlFlow.parallel***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Array|Collection***REMOVED*** tasks - A collection containing functions to run.
 * Each function is passed a `callback(err, result)` which it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 */
function parallelLimit$1(tasks, limit, callback) ***REMOVED***
  _parallel(_eachOfLimit(limit), tasks, callback);
***REMOVED***

/**
 * A queue of tasks for the worker function to complete.
 * @typedef ***REMOVED***Object***REMOVED*** QueueObject
 * @memberOf module:ControlFlow
 * @property ***REMOVED***Function***REMOVED*** length - a function returning the number of items
 * waiting to be processed. Invoke with `queue.length()`.
 * @property ***REMOVED***boolean***REMOVED*** started - a boolean indicating whether or not any
 * items have been pushed and processed by the queue.
 * @property ***REMOVED***Function***REMOVED*** running - a function returning the number of items
 * currently being processed. Invoke with `queue.running()`.
 * @property ***REMOVED***Function***REMOVED*** workersList - a function returning the array of items
 * currently being processed. Invoke with `queue.workersList()`.
 * @property ***REMOVED***Function***REMOVED*** idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
 * @property ***REMOVED***number***REMOVED*** concurrency - an integer for determining how many `worker`
 * functions should be run in parallel. This property can be changed after a
 * `queue` is created to alter the concurrency on-the-fly.
 * @property ***REMOVED***Function***REMOVED*** push - add a new task to the `queue`. Calls `callback`
 * once the `worker` has finished processing the task. Instead of a single task,
 * a `tasks` array can be submitted. The respective callback is used for every
 * task in the list. Invoke with `queue.push(task, [callback])`,
 * @property ***REMOVED***Function***REMOVED*** unshift - add a new task to the front of the `queue`.
 * Invoke with `queue.unshift(task, [callback])`.
 * @property ***REMOVED***Function***REMOVED*** saturated - a callback that is called when the number of
 * running workers hits the `concurrency` limit, and further tasks will be
 * queued.
 * @property ***REMOVED***Function***REMOVED*** unsaturated - a callback that is called when the number
 * of running workers is less than the `concurrency` & `buffer` limits, and
 * further tasks will not be queued.
 * @property ***REMOVED***number***REMOVED*** buffer - A minimum threshold buffer in order to say that
 * the `queue` is `unsaturated`.
 * @property ***REMOVED***Function***REMOVED*** empty - a callback that is called when the last item
 * from the `queue` is given to a `worker`.
 * @property ***REMOVED***Function***REMOVED*** drain - a callback that is called when the last item
 * from the `queue` has returned from the `worker`.
 * @property ***REMOVED***Function***REMOVED*** error - a callback that is called when a task errors.
 * Has the signature `function(error, task)`.
 * @property ***REMOVED***boolean***REMOVED*** paused - a boolean for determining whether the queue is
 * in a paused state.
 * @property ***REMOVED***Function***REMOVED*** pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke with `queue.pause()`.
 * @property ***REMOVED***Function***REMOVED*** resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
 * @property ***REMOVED***Function***REMOVED*** kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`.
 */

/**
 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
 * `queue` are processed in parallel (up to the `concurrency` limit). If all
 * `worker`s are in progress, the task is queued until one becomes available.
 * Once a `worker` completes a `task`, that `task`'s callback is called.
 *
 * @name queue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Function***REMOVED*** worker - An asynchronous function for processing a queued
 * task, which must call its `callback(err)` argument when finished, with an
 * optional `error` as an argument.  If you want to handle errors from an
 * individual task, pass a callback to `q.push()`. Invoked with
 * (task, callback).
 * @param ***REMOVED***number***REMOVED*** [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @returns ***REMOVED***module:ControlFlow.QueueObject***REMOVED*** A queue object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the queue.
 * @example
 *
 * // create a queue object with concurrency 2
 * var q = async.queue(function(task, callback) ***REMOVED***
 *     console.log('hello ' + task.name);
 *     callback();
 * ***REMOVED***, 2);
 *
 * // assign a callback
 * q.drain = function() ***REMOVED***
 *     console.log('all items have been processed');
 * ***REMOVED***;
 *
 * // add some items to the queue
 * q.push(***REMOVED***name: 'foo'***REMOVED***, function(err) ***REMOVED***
 *     console.log('finished processing foo');
 * ***REMOVED***);
 * q.push(***REMOVED***name: 'bar'***REMOVED***, function (err) ***REMOVED***
 *     console.log('finished processing bar');
 * ***REMOVED***);
 *
 * // add some items to the queue (batch-wise)
 * q.push([***REMOVED***name: 'baz'***REMOVED***,***REMOVED***name: 'bay'***REMOVED***,***REMOVED***name: 'bax'***REMOVED***], function(err) ***REMOVED***
 *     console.log('finished processing item');
 * ***REMOVED***);
 *
 * // add some items to the front of the queue
 * q.unshift(***REMOVED***name: 'bar'***REMOVED***, function (err) ***REMOVED***
 *     console.log('finished processing bar');
 * ***REMOVED***);
 */
var queue$1 = function (worker, concurrency) ***REMOVED***
  return queue(function (items, cb) ***REMOVED***
    worker(items[0], cb);
  ***REMOVED***, concurrency, 1);
***REMOVED***;

/**
 * The same as [async.queue]***REMOVED***@link module:ControlFlow.queue***REMOVED*** only tasks are assigned a priority and
 * completed in ascending priority order.
 *
 * @name priorityQueue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]***REMOVED***@link module:ControlFlow.queue***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Function***REMOVED*** worker - An asynchronous function for processing a queued
 * task, which must call its `callback(err)` argument when finished, with an
 * optional `error` as an argument.  If you want to handle errors from an
 * individual task, pass a callback to `q.push()`. Invoked with
 * (task, callback).
 * @param ***REMOVED***number***REMOVED*** concurrency - An `integer` for determining how many `worker`
 * functions should be run in parallel.  If omitted, the concurrency defaults to
 * `1`.  If the concurrency is `0`, an error is thrown.
 * @returns ***REMOVED***module:ControlFlow.QueueObject***REMOVED*** A priorityQueue object to manage the tasks. There are two
 * differences between `queue` and `priorityQueue` objects:
 * * `push(task, priority, [callback])` - `priority` should be a number. If an
 *   array of `tasks` is given, all tasks will be assigned the same priority.
 * * The `unshift` method was removed.
 */
var priorityQueue = function (worker, concurrency) ***REMOVED***
    // Start with a normal queue
    var q = queue$1(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function (data, priority, callback) ***REMOVED***
        if (callback == null) callback = noop;
        if (typeof callback !== 'function') ***REMOVED***
            throw new Error('task callback must be a function');
        ***REMOVED***
        q.started = true;
        if (!isArray(data)) ***REMOVED***
            data = [data];
        ***REMOVED***
        if (data.length === 0) ***REMOVED***
            // call drain immediately if there are no tasks
            return setImmediate$1(function () ***REMOVED***
                q.drain();
            ***REMOVED***);
        ***REMOVED***

        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode && priority >= nextNode.priority) ***REMOVED***
            nextNode = nextNode.next;
        ***REMOVED***

        for (var i = 0, l = data.length; i < l; i++) ***REMOVED***
            var item = ***REMOVED***
                data: data[i],
                priority: priority,
                callback: callback
            ***REMOVED***;

            if (nextNode) ***REMOVED***
                q._tasks.insertBefore(nextNode, item);
            ***REMOVED*** else ***REMOVED***
                q._tasks.push(item);
            ***REMOVED***
        ***REMOVED***
        setImmediate$1(q.process);
    ***REMOVED***;

    // Remove unshift function
    delete q.unshift;

    return q;
***REMOVED***;

/**
 * Runs the `tasks` array of functions in parallel, without waiting until the
 * previous function has completed. Once any of the `tasks` complete or pass an
 * error to its callback, the main `callback` is immediately called. It's
 * equivalent to `Promise.race()`.
 *
 * @name race
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Array***REMOVED*** tasks - An array containing functions to run. Each function
 * is passed a `callback(err, result)` which it must call on completion with an
 * error `err` (which can be `null`) and an optional `result` value.
 * @param ***REMOVED***Function***REMOVED*** callback - A callback to run once any of the functions have
 * completed. This function gets an error or result from the first function that
 * completed. Invoked with (err, result).
 * @returns undefined
 * @example
 *
 * async.race([
 *     function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 'one');
 *         ***REMOVED***, 200);
 *     ***REMOVED***,
 *     function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 'two');
 *         ***REMOVED***, 100);
 *     ***REMOVED***
 * ],
 * // main callback
 * function(err, result) ***REMOVED***
 *     // the result will be equal to 'two' as it finishes earlier
 * ***REMOVED***);
 */
function race(tasks, callback) ***REMOVED***
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i < l; i++) ***REMOVED***
        tasks[i](callback);
    ***REMOVED***
***REMOVED***

var slice = Array.prototype.slice;

/**
 * Same as [`reduce`]***REMOVED***@link module:Collections.reduce***REMOVED***, only operates on `array` in reverse order.
 *
 * @name reduceRight
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reduce]***REMOVED***@link module:Collections.reduce***REMOVED***
 * @alias foldr
 * @category Collection
 * @param ***REMOVED***Array***REMOVED*** array - A collection to iterate over.
 * @param ***REMOVED*******REMOVED*** memo - The initial state of the reduction.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function applied to each item in the
 * array to produce the next step in the reduction. The `iteratee` is passed a
 * `callback(err, reduction)` which accepts an optional error as its first
 * argument, and the state of the reduction as the second. If an error is
 * passed to the callback, the reduction is stopped and the main `callback` is
 * immediately called with the error. Invoked with (memo, item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 */
function reduceRight(array, memo, iteratee, callback) ***REMOVED***
  var reversed = slice.call(array).reverse();
  reduce(reversed, memo, iteratee, callback);
***REMOVED***

/**
 * Wraps the function in another function that always returns data even when it
 * errors.
 *
 * The object returned has either the property `error` or `value`.
 *
 * @name reflect
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** fn - The function you want to wrap
 * @returns ***REMOVED***Function***REMOVED*** - A function that always passes null to it's callback as
 * the error. The second argument to the callback will be an `object` with
 * either an `error` or a `value` property.
 * @example
 *
 * async.parallel([
 *     async.reflect(function(callback) ***REMOVED***
 *         // do some stuff ...
 *         callback(null, 'one');
 *     ***REMOVED***),
 *     async.reflect(function(callback) ***REMOVED***
 *         // do some more stuff but error ...
 *         callback('bad stuff happened');
 *     ***REMOVED***),
 *     async.reflect(function(callback) ***REMOVED***
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     ***REMOVED***)
 * ],
 * // optional callback
 * function(err, results) ***REMOVED***
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = 'bad stuff happened'
 *     // results[2].value = 'two'
 * ***REMOVED***);
 */
function reflect(fn) ***REMOVED***
    return initialParams(function reflectOn(args, reflectCallback) ***REMOVED***
        args.push(rest(function callback(err, cbArgs) ***REMOVED***
            if (err) ***REMOVED***
                reflectCallback(null, ***REMOVED***
                    error: err
                ***REMOVED***);
            ***REMOVED*** else ***REMOVED***
                var value = null;
                if (cbArgs.length === 1) ***REMOVED***
                    value = cbArgs[0];
                ***REMOVED*** else if (cbArgs.length > 1) ***REMOVED***
                    value = cbArgs;
                ***REMOVED***
                reflectCallback(null, ***REMOVED***
                    value: value
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***));

        return fn.apply(this, args);
    ***REMOVED***);
***REMOVED***

function reject$1(eachfn, arr, iteratee, callback) ***REMOVED***
    _filter(eachfn, arr, function (value, cb) ***REMOVED***
        iteratee(value, function (err, v) ***REMOVED***
            cb(err, !v);
        ***REMOVED***);
    ***REMOVED***, callback);
***REMOVED***

/**
 * The opposite of [`filter`]***REMOVED***@link module:Collections.filter***REMOVED***. Removes values that pass an `async` truth test.
 *
 * @name reject
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]***REMOVED***@link module:Collections.filter***REMOVED***
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.reject(['file1','file2','file3'], function(filePath, callback) ***REMOVED***
 *     fs.access(filePath, function(err) ***REMOVED***
 *         callback(null, !err)
 *     ***REMOVED***);
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     // results now equals an array of missing files
 *     createFiles(results);
 * ***REMOVED***);
 */
var reject = doParallel(reject$1);

/**
 * A helper function that wraps an array or an object of functions with reflect.
 *
 * @name reflectAll
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.reflect]***REMOVED***@link module:Utils.reflect***REMOVED***
 * @category Util
 * @param ***REMOVED***Array***REMOVED*** tasks - The array of functions to wrap in `async.reflect`.
 * @returns ***REMOVED***Array***REMOVED*** Returns an array of functions, each function wrapped in
 * `async.reflect`
 * @example
 *
 * let tasks = [
 *     function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 'one');
 *         ***REMOVED***, 200);
 *     ***REMOVED***,
 *     function(callback) ***REMOVED***
 *         // do some more stuff but error ...
 *         callback(new Error('bad stuff happened'));
 *     ***REMOVED***,
 *     function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 'two');
 *         ***REMOVED***, 100);
 *     ***REMOVED***
 * ];
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) ***REMOVED***
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = Error('bad stuff happened')
 *     // results[2].value = 'two'
 * ***REMOVED***);
 *
 * // an example using an object instead of an array
 * let tasks = ***REMOVED***
 *     one: function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 'one');
 *         ***REMOVED***, 200);
 *     ***REMOVED***,
 *     two: function(callback) ***REMOVED***
 *         callback('two');
 *     ***REMOVED***,
 *     three: function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 'three');
 *         ***REMOVED***, 100);
 *     ***REMOVED***
 * ***REMOVED***;
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) ***REMOVED***
 *     // values
 *     // results.one.value = 'one'
 *     // results.two.error = 'two'
 *     // results.three.value = 'three'
 * ***REMOVED***);
 */
function reflectAll(tasks) ***REMOVED***
    var results;
    if (isArray(tasks)) ***REMOVED***
        results = arrayMap(tasks, reflect);
    ***REMOVED*** else ***REMOVED***
        results = ***REMOVED******REMOVED***;
        baseForOwn(tasks, function (task, key) ***REMOVED***
            results[key] = reflect.call(this, task);
        ***REMOVED***);
    ***REMOVED***
    return results;
***REMOVED***

/**
 * The same as [`reject`]***REMOVED***@link module:Collections.reject***REMOVED*** but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name rejectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]***REMOVED***@link module:Collections.reject***REMOVED***
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var rejectLimit = doParallelLimit(reject$1);

/**
 * The same as [`reject`]***REMOVED***@link module:Collections.reject***REMOVED*** but runs only a single async operation at a time.
 *
 * @name rejectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]***REMOVED***@link module:Collections.reject***REMOVED***
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var rejectSeries = doLimit(rejectLimit, 1);

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param ***REMOVED*******REMOVED*** value The value to return from the new function.
 * @returns ***REMOVED***Function***REMOVED*** Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant(***REMOVED*** 'a': 1 ***REMOVED***));
 *
 * console.log(objects);
 * // => [***REMOVED*** 'a': 1 ***REMOVED***, ***REMOVED*** 'a': 1 ***REMOVED***]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant$1(value) ***REMOVED***
  return function() ***REMOVED***
    return value;
  ***REMOVED***;
***REMOVED***

/**
 * Attempts to get a successful response from `task` no more than `times` times
 * before returning an error. If the task is successful, the `callback` will be
 * passed the result of the successful task. If all attempts fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name retry
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Object|number***REMOVED*** [opts = ***REMOVED***times: 5, interval: 0***REMOVED***| 5] - Can be either an
 * object with `times` and `interval` or a number.
 * * `times` - The number of attempts to make before giving up.  The default
 *   is `5`.
 * * `interval` - The time to wait between retries, in milliseconds.  The
 *   default is `0`. The interval may also be specified as a function of the
 *   retry count (see example).
 * * `errorFilter` - An optional synchronous function that is invoked on
 *   erroneous result. If it returns `true` the retry attempts will continue;
 *   if the function returns `false` the retry flow is aborted with the current
 *   attempt's error and result being returned to the final callback.
 *   Invoked with (err).
 * * If `opts` is a number, the number specifies the number of times to retry,
 *   with the default interval of `0`.
 * @param ***REMOVED***Function***REMOVED*** task - A function which receives two arguments: (1) a
 * `callback(err, result)` which must be called when finished, passing `err`
 * (which can be `null`) and the `result` of the function's execution, and (2)
 * a `results` object, containing the results of the previously executed
 * functions (if nested inside another control flow). Invoked with
 * (callback, results).
 * @param ***REMOVED***Function***REMOVED*** [callback] - An optional callback which is called when the
 * task has succeeded, or after the final failed attempt. It receives the `err`
 * and `result` arguments of the last attempt at completing the `task`. Invoked
 * with (err, results).
 * @example
 *
 * // The `retry` function can be used as a stand-alone control flow by passing
 * // a callback, as shown below:
 *
 * // try calling apiMethod 3 times
 * async.retry(3, apiMethod, function(err, result) ***REMOVED***
 *     // do something with the result
 * ***REMOVED***);
 *
 * // try calling apiMethod 3 times, waiting 200 ms between each retry
 * async.retry(***REMOVED***times: 3, interval: 200***REMOVED***, apiMethod, function(err, result) ***REMOVED***
 *     // do something with the result
 * ***REMOVED***);
 *
 * // try calling apiMethod 10 times with exponential backoff
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
 * async.retry(***REMOVED***
 *   times: 10,
 *   interval: function(retryCount) ***REMOVED***
 *     return 50 * Math.pow(2, retryCount);
 *   ***REMOVED***
 * ***REMOVED***, apiMethod, function(err, result) ***REMOVED***
 *     // do something with the result
 * ***REMOVED***);
 *
 * // try calling apiMethod the default 5 times no delay between each retry
 * async.retry(apiMethod, function(err, result) ***REMOVED***
 *     // do something with the result
 * ***REMOVED***);
 *
 * // try calling apiMethod only when error condition satisfies, all other
 * // errors will abort the retry control flow and return to final callback
 * async.retry(***REMOVED***
 *   errorFilter: function(err) ***REMOVED***
 *     return err.message === 'Temporary error'; // only retry on a specific error
 *   ***REMOVED***
 * ***REMOVED***, apiMethod, function(err, result) ***REMOVED***
 *     // do something with the result
 * ***REMOVED***);
 *
 * // It can also be embedded within other control flow functions to retry
 * // individual methods that are not as reliable, like this:
 * async.auto(***REMOVED***
 *     users: api.getUsers.bind(api),
 *     payments: async.retry(3, api.getPayments.bind(api))
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     // do something with the results
 * ***REMOVED***);
 *
 */
function retry(opts, task, callback) ***REMOVED***
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = ***REMOVED***
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
    ***REMOVED***;

    function parseTimes(acc, t) ***REMOVED***
        if (typeof t === 'object') ***REMOVED***
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        ***REMOVED*** else if (typeof t === 'number' || typeof t === 'string') ***REMOVED***
            acc.times = +t || DEFAULT_TIMES;
        ***REMOVED*** else ***REMOVED***
            throw new Error("Invalid arguments for async.retry");
        ***REMOVED***
    ***REMOVED***

    if (arguments.length < 3 && typeof opts === 'function') ***REMOVED***
        callback = task || noop;
        task = opts;
    ***REMOVED*** else ***REMOVED***
        parseTimes(options, opts);
        callback = callback || noop;
    ***REMOVED***

    if (typeof task !== 'function') ***REMOVED***
        throw new Error("Invalid arguments for async.retry");
    ***REMOVED***

    var attempt = 1;
    function retryAttempt() ***REMOVED***
        task(function (err) ***REMOVED***
            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) ***REMOVED***
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            ***REMOVED*** else ***REMOVED***
                callback.apply(null, arguments);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***

    retryAttempt();
***REMOVED***

/**
 * A close relative of [`retry`]***REMOVED***@link module:ControlFlow.retry***REMOVED***.  This method wraps a task and makes it
 * retryable, rather than immediately calling it with retries.
 *
 * @name retryable
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.retry]***REMOVED***@link module:ControlFlow.retry***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Object|number***REMOVED*** [opts = ***REMOVED***times: 5, interval: 0***REMOVED***| 5] - optional
 * options, exactly the same as from `retry`
 * @param ***REMOVED***Function***REMOVED*** task - the asynchronous function to wrap
 * @returns ***REMOVED***Functions***REMOVED*** The wrapped function, which when invoked, will retry on
 * an error, based on the parameters specified in `opts`.
 * @example
 *
 * async.auto(***REMOVED***
 *     dep1: async.retryable(3, getFromFlakyService),
 *     process: ["dep1", async.retryable(3, function (results, cb) ***REMOVED***
 *         maybeProcessData(results.dep1, cb);
 *     ***REMOVED***)]
 * ***REMOVED***, callback);
 */
var retryable = function (opts, task) ***REMOVED***
    if (!task) ***REMOVED***
        task = opts;
        opts = null;
    ***REMOVED***
    return initialParams(function (args, callback) ***REMOVED***
        function taskFn(cb) ***REMOVED***
            task.apply(null, args.concat([cb]));
        ***REMOVED***

        if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);
    ***REMOVED***);
***REMOVED***;

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from ***REMOVED***@link async.series***REMOVED***.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** tasks - A collection containing functions to run, each
 * function is passed a `callback(err, result)` it must call on completion with
 * an error `err` (which can be `null`) and an optional `result` value.
 * @param ***REMOVED***Function***REMOVED*** [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @example
 * async.series([
 *     function(callback) ***REMOVED***
 *         // do some stuff ...
 *         callback(null, 'one');
 *     ***REMOVED***,
 *     function(callback) ***REMOVED***
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     ***REMOVED***
 * ],
 * // optional callback
 * function(err, results) ***REMOVED***
 *     // results is now equal to ['one', 'two']
 * ***REMOVED***);
 *
 * async.series(***REMOVED***
 *     one: function(callback) ***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 1);
 *         ***REMOVED***, 200);
 *     ***REMOVED***,
 *     two: function(callback)***REMOVED***
 *         setTimeout(function() ***REMOVED***
 *             callback(null, 2);
 *         ***REMOVED***, 100);
 *     ***REMOVED***
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     // results is now equal to: ***REMOVED***one: 1, two: 2***REMOVED***
 * ***REMOVED***);
 */
function series(tasks, callback) ***REMOVED***
  _parallel(eachOfSeries, tasks, callback);
***REMOVED***

/**
 * Returns `true` if at least one element in the `coll` satisfies an async test.
 * If any iteratee call returns `true`, the main `callback` is immediately
 * called.
 *
 * @name some
 * @static
 * @memberOf module:Collections
 * @method
 * @alias any
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in the array
 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
 * be called with a boolean argument once it has completed. Invoked with
 * (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @example
 *
 * async.some(['file1','file2','file3'], function(filePath, callback) ***REMOVED***
 *     fs.access(filePath, function(err) ***REMOVED***
 *         callback(null, !err)
 *     ***REMOVED***);
 * ***REMOVED***, function(err, result) ***REMOVED***
 *     // if result is true then at least one of the files exists
 * ***REMOVED***);
 */
var some = _createTester(eachOf, Boolean, identity);

/**
 * The same as [`some`]***REMOVED***@link module:Collections.some***REMOVED*** but runs a maximum of `limit` async operations at a time.
 *
 * @name someLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]***REMOVED***@link module:Collections.some***REMOVED***
 * @alias anyLimit
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in the array
 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
 * be called with a boolean argument once it has completed. Invoked with
 * (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */
var someLimit = _createTester(eachOfLimit, Boolean, identity);

/**
 * The same as [`some`]***REMOVED***@link module:Collections.some***REMOVED*** but runs only a single async operation at a time.
 *
 * @name someSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]***REMOVED***@link module:Collections.some***REMOVED***
 * @alias anySeries
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A truth test to apply to each item in the array
 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
 * be called with a boolean argument once it has completed. Invoked with
 * (item, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */
var someSeries = doLimit(someLimit, 1);

/**
 * Sorts a list by the results of running each `coll` value through an async
 * `iteratee`.
 *
 * @name sortBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function to apply to each item in `coll`.
 * The iteratee is passed a `callback(err, sortValue)` which must be called once
 * it has completed with an error (which can be `null`) and a value to use as
 * the sort criteria. Invoked with (item, callback).
 * @param ***REMOVED***Function***REMOVED*** callback - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is the items
 * from the original `coll` sorted by the values returned by the `iteratee`
 * calls. Invoked with (err, results).
 * @example
 *
 * async.sortBy(['file1','file2','file3'], function(file, callback) ***REMOVED***
 *     fs.stat(file, function(err, stats) ***REMOVED***
 *         callback(err, stats.mtime);
 *     ***REMOVED***);
 * ***REMOVED***, function(err, results) ***REMOVED***
 *     // results is now the original array of files sorted by
 *     // modified date
 * ***REMOVED***);
 *
 * // By modifying the callback parameter the
 * // sorting order can be influenced:
 *
 * // ascending order
 * async.sortBy([1,9,3,5], function(x, callback) ***REMOVED***
 *     callback(null, x);
 * ***REMOVED***, function(err,result) ***REMOVED***
 *     // result callback
 * ***REMOVED***);
 *
 * // descending order
 * async.sortBy([1,9,3,5], function(x, callback) ***REMOVED***
 *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around
 * ***REMOVED***, function(err,result) ***REMOVED***
 *     // result callback
 * ***REMOVED***);
 */
function sortBy(coll, iteratee, callback) ***REMOVED***
    map(coll, function (x, callback) ***REMOVED***
        iteratee(x, function (err, criteria) ***REMOVED***
            if (err) return callback(err);
            callback(null, ***REMOVED*** value: x, criteria: criteria ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***, function (err, results) ***REMOVED***
        if (err) return callback(err);
        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));
    ***REMOVED***);

    function comparator(left, right) ***REMOVED***
        var a = left.criteria,
            b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
    ***REMOVED***
***REMOVED***

/**
 * Sets a time limit on an asynchronous function. If the function does not call
 * its callback within the specified milliseconds, it will be called with a
 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
 *
 * @name timeout
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** asyncFn - The asynchronous function you want to set the
 * time limit.
 * @param ***REMOVED***number***REMOVED*** milliseconds - The specified time limit.
 * @param ***REMOVED*******REMOVED*** [info] - Any variable you want attached (`string`, `object`, etc)
 * to timeout Error for more information..
 * @returns ***REMOVED***Function***REMOVED*** Returns a wrapped function that can be used with any of
 * the control flow functions. Invoke this function with the same
 * parameters as you would `asyncFunc`.
 * @example
 *
 * function myFunction(foo, callback) ***REMOVED***
 *     doAsyncTask(foo, function(err, data) ***REMOVED***
 *         // handle errors
 *         if (err) return callback(err);
 *
 *         // do some stuff ...
 *
 *         // return processed data
 *         return callback(null, data);
 *     ***REMOVED***);
 * ***REMOVED***
 *
 * var wrapped = async.timeout(myFunction, 1000);
 *
 * // call `wrapped` as you would `myFunction`
 * wrapped(***REMOVED*** bar: 'bar' ***REMOVED***, function(err, data) ***REMOVED***
 *     // if `myFunction` takes < 1000 ms to execute, `err`
 *     // and `data` will have their expected values
 *
 *     // else `err` will be an Error with the code 'ETIMEDOUT'
 * ***REMOVED***);
 */
function timeout(asyncFn, milliseconds, info) ***REMOVED***
    var originalCallback, timer;
    var timedOut = false;

    function injectedCallback() ***REMOVED***
        if (!timedOut) ***REMOVED***
            originalCallback.apply(null, arguments);
            clearTimeout(timer);
        ***REMOVED***
    ***REMOVED***

    function timeoutCallback() ***REMOVED***
        var name = asyncFn.name || 'anonymous';
        var error = new Error('Callback function "' + name + '" timed out.');
        error.code = 'ETIMEDOUT';
        if (info) ***REMOVED***
            error.info = info;
        ***REMOVED***
        timedOut = true;
        originalCallback(error);
    ***REMOVED***

    return initialParams(function (args, origCallback) ***REMOVED***
        originalCallback = origCallback;
        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        asyncFn.apply(null, args.concat(injectedCallback));
    ***REMOVED***);
***REMOVED***

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil;
var nativeMax$1 = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param ***REMOVED***number***REMOVED*** start The start of the range.
 * @param ***REMOVED***number***REMOVED*** end The end of the range.
 * @param ***REMOVED***number***REMOVED*** step The value to increment or decrement by.
 * @param ***REMOVED***boolean***REMOVED*** [fromRight] Specify iterating from right to left.
 * @returns ***REMOVED***Array***REMOVED*** Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) ***REMOVED***
  var index = -1,
      length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) ***REMOVED***
    result[fromRight ? length : ++index] = start;
    start += step;
  ***REMOVED***
  return result;
***REMOVED***

/**
 * The same as [times]***REMOVED***@link module:ControlFlow.times***REMOVED*** but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name timesLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]***REMOVED***@link module:ControlFlow.times***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***number***REMOVED*** count - The number of times to run the function.
 * @param ***REMOVED***number***REMOVED*** limit - The maximum number of async operations at a time.
 * @param ***REMOVED***Function***REMOVED*** iteratee - The function to call `n` times. Invoked with the
 * iteration index and a callback (n, next).
 * @param ***REMOVED***Function***REMOVED*** callback - see [async.map]***REMOVED***@link module:Collections.map***REMOVED***.
 */
function timeLimit(count, limit, iteratee, callback) ***REMOVED***
  mapLimit(baseRange(0, count, 1), limit, iteratee, callback);
***REMOVED***

/**
 * Calls the `iteratee` function `n` times, and accumulates results in the same
 * manner you would use with [map]***REMOVED***@link module:Collections.map***REMOVED***.
 *
 * @name times
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.map]***REMOVED***@link module:Collections.map***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***number***REMOVED*** n - The number of times to run the function.
 * @param ***REMOVED***Function***REMOVED*** iteratee - The function to call `n` times. Invoked with the
 * iteration index and a callback (n, next).
 * @param ***REMOVED***Function***REMOVED*** callback - see ***REMOVED***@link module:Collections.map***REMOVED***.
 * @example
 *
 * // Pretend this is some complicated async factory
 * var createUser = function(id, callback) ***REMOVED***
 *     callback(null, ***REMOVED***
 *         id: 'user' + id
 *     ***REMOVED***);
 * ***REMOVED***;
 *
 * // generate 5 users
 * async.times(5, function(n, next) ***REMOVED***
 *     createUser(n, function(err, user) ***REMOVED***
 *         next(err, user);
 *     ***REMOVED***);
 * ***REMOVED***, function(err, users) ***REMOVED***
 *     // we should now have 5 users
 * ***REMOVED***);
 */
var times = doLimit(timeLimit, Infinity);

/**
 * The same as [times]***REMOVED***@link module:ControlFlow.times***REMOVED*** but runs only a single async operation at a time.
 *
 * @name timesSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]***REMOVED***@link module:ControlFlow.times***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***number***REMOVED*** n - The number of times to run the function.
 * @param ***REMOVED***Function***REMOVED*** iteratee - The function to call `n` times. Invoked with the
 * iteration index and a callback (n, next).
 * @param ***REMOVED***Function***REMOVED*** callback - see ***REMOVED***@link module:Collections.map***REMOVED***.
 */
var timesSeries = doLimit(timeLimit, 1);

/**
 * A relative of `reduce`.  Takes an Object or Array, and iterates over each
 * element in series, each step potentially mutating an `accumulator` value.
 * The type of the accumulator defaults to the type of collection passed in.
 *
 * @name transform
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param ***REMOVED***Array|Iterable|Object***REMOVED*** coll - A collection to iterate over.
 * @param ***REMOVED*******REMOVED*** [accumulator] - The initial state of the transform.  If omitted,
 * it will default to an empty Object or Array, depending on the type of `coll`
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function applied to each item in the
 * collection that potentially modifies the accumulator. The `iteratee` is
 * passed a `callback(err)` which accepts an optional error as its first
 * argument. If an error is passed to the callback, the transform is stopped
 * and the main `callback` is immediately called with the error.
 * Invoked with (accumulator, item, key, callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the transformed accumulator.
 * Invoked with (err, result).
 * @example
 *
 * async.transform([1,2,3], function(acc, item, index, callback) ***REMOVED***
 *     // pointless async:
 *     process.nextTick(function() ***REMOVED***
 *         acc.push(item * 2)
 *         callback(null)
 *     ***REMOVED***);
 * ***REMOVED***, function(err, result) ***REMOVED***
 *     // result is now equal to [2, 4, 6]
 * ***REMOVED***);
 *
 * @example
 *
 * async.transform(***REMOVED***a: 1, b: 2, c: 3***REMOVED***, function (obj, val, key, callback) ***REMOVED***
 *     setImmediate(function () ***REMOVED***
 *         obj[key] = val * 2;
 *         callback();
 *     ***REMOVED***)
 * ***REMOVED***, function (err, result) ***REMOVED***
 *     // result is equal to ***REMOVED***a: 2, b: 4, c: 6***REMOVED***
 * ***REMOVED***)
 */
function transform(coll, accumulator, iteratee, callback) ***REMOVED***
    if (arguments.length === 3) ***REMOVED***
        callback = iteratee;
        iteratee = accumulator;
        accumulator = isArray(coll) ? [] : ***REMOVED******REMOVED***;
    ***REMOVED***
    callback = once(callback || noop);

    eachOf(coll, function (v, k, cb) ***REMOVED***
        iteratee(accumulator, v, k, cb);
    ***REMOVED***, function (err) ***REMOVED***
        callback(err, accumulator);
    ***REMOVED***);
***REMOVED***

/**
 * Undoes a [memoize]***REMOVED***@link module:Utils.memoize***REMOVED***d function, reverting it to the original,
 * unmemoized form. Handy for testing.
 *
 * @name unmemoize
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.memoize]***REMOVED***@link module:Utils.memoize***REMOVED***
 * @category Util
 * @param ***REMOVED***Function***REMOVED*** fn - the memoized function
 * @returns ***REMOVED***Function***REMOVED*** a function that calls the original unmemoized function
 */
function unmemoize(fn) ***REMOVED***
    return function () ***REMOVED***
        return (fn.unmemoized || fn).apply(null, arguments);
    ***REMOVED***;
***REMOVED***

/**
 * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs.
 *
 * @name whilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Function***REMOVED*** test - synchronous truth test to perform before each
 * execution of `iteratee`. Invoked with ().
 * @param ***REMOVED***Function***REMOVED*** iteratee - A function which is called each time `test` passes.
 * The function is passed a `callback(err)`, which must be called once it has
 * completed with an optional `err` argument. Invoked with (callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns undefined
 * @example
 *
 * var count = 0;
 * async.whilst(
 *     function() ***REMOVED*** return count < 5; ***REMOVED***,
 *     function(callback) ***REMOVED***
 *         count++;
 *         setTimeout(function() ***REMOVED***
 *             callback(null, count);
 *         ***REMOVED***, 1000);
 *     ***REMOVED***,
 *     function (err, n) ***REMOVED***
 *         // 5 seconds have passed, n = 5
 *     ***REMOVED***
 * );
 */
function whilst(test, iteratee, callback) ***REMOVED***
    callback = onlyOnce(callback || noop);
    if (!test()) return callback(null);
    var next = rest(function (err, args) ***REMOVED***
        if (err) return callback(err);
        if (test()) return iteratee(next);
        callback.apply(null, [null].concat(args));
    ***REMOVED***);
    iteratee(next);
***REMOVED***

/**
 * Repeatedly call `fn` until `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs. `callback` will be passed an error and any
 * arguments passed to the final `fn`'s callback.
 *
 * The inverse of [whilst]***REMOVED***@link module:ControlFlow.whilst***REMOVED***.
 *
 * @name until
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]***REMOVED***@link module:ControlFlow.whilst***REMOVED***
 * @category Control Flow
 * @param ***REMOVED***Function***REMOVED*** test - synchronous truth test to perform before each
 * execution of `fn`. Invoked with ().
 * @param ***REMOVED***Function***REMOVED*** fn - A function which is called each time `test` fails.
 * The function is passed a `callback(err)`, which must be called once it has
 * completed with an optional `err` argument. Invoked with (callback).
 * @param ***REMOVED***Function***REMOVED*** [callback] - A callback which is called after the test
 * function has passed and repeated execution of `fn` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `fn`'s
 * callback. Invoked with (err, [results]);
 */
function until(test, fn, callback) ***REMOVED***
    whilst(function () ***REMOVED***
        return !test.apply(this, arguments);
    ***REMOVED***, fn, callback);
***REMOVED***

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param ***REMOVED***Array***REMOVED*** tasks - An array of functions to run, each function is passed
 * a `callback(err, result1, result2, ...)` it must call on completion. The
 * first argument is an error (which can be `null`) and any further arguments
 * will be passed as arguments in order to the next task.
 * @param ***REMOVED***Function***REMOVED*** [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns undefined
 * @example
 *
 * async.waterfall([
 *     function(callback) ***REMOVED***
 *         callback(null, 'one', 'two');
 *     ***REMOVED***,
 *     function(arg1, arg2, callback) ***REMOVED***
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     ***REMOVED***,
 *     function(arg1, callback) ***REMOVED***
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     ***REMOVED***
 * ], function (err, result) ***REMOVED***
 *     // result now equals 'done'
 * ***REMOVED***);
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) ***REMOVED***
 *     // result now equals 'done'
 * ***REMOVED***);
 * function myFirstFunction(callback) ***REMOVED***
 *     callback(null, 'one', 'two');
 * ***REMOVED***
 * function mySecondFunction(arg1, arg2, callback) ***REMOVED***
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * ***REMOVED***
 * function myLastFunction(arg1, callback) ***REMOVED***
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * ***REMOVED***
 */
var waterfall = function (tasks, callback) ***REMOVED***
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) ***REMOVED***
        if (taskIndex === tasks.length) ***REMOVED***
            return callback.apply(null, [null].concat(args));
        ***REMOVED***

        var taskCallback = onlyOnce(rest(function (err, args) ***REMOVED***
            if (err) ***REMOVED***
                return callback.apply(null, [err].concat(args));
            ***REMOVED***
            nextTask(args);
        ***REMOVED***));

        args.push(taskCallback);

        var task = tasks[taskIndex++];
        task.apply(null, args);
    ***REMOVED***

    nextTask([]);
***REMOVED***;

/**
 * Async is a utility module which provides straight-forward, powerful functions
 * for working with asynchronous JavaScript. Although originally designed for
 * use with [Node.js](http://nodejs.org) and installable via
 * `npm install --save async`, it can also be used directly in the browser.
 * @module async
 */

/**
 * A collection of `async` functions for manipulating collections, such as
 * arrays and objects.
 * @module Collections
 */

/**
 * A collection of `async` functions for controlling the flow through a script.
 * @module ControlFlow
 */

/**
 * A collection of `async` utility functions.
 * @module Utils
 */
var index = ***REMOVED***
  applyEach: applyEach,
  applyEachSeries: applyEachSeries,
  apply: apply$2,
  asyncify: asyncify,
  auto: auto,
  autoInject: autoInject,
  cargo: cargo,
  compose: compose,
  concat: concat,
  concatSeries: concatSeries,
  constant: constant,
  detect: detect,
  detectLimit: detectLimit,
  detectSeries: detectSeries,
  dir: dir,
  doDuring: doDuring,
  doUntil: doUntil,
  doWhilst: doWhilst,
  during: during,
  each: eachLimit,
  eachLimit: eachLimit$1,
  eachOf: eachOf,
  eachOfLimit: eachOfLimit,
  eachOfSeries: eachOfSeries,
  eachSeries: eachSeries,
  ensureAsync: ensureAsync,
  every: every,
  everyLimit: everyLimit,
  everySeries: everySeries,
  filter: filter,
  filterLimit: filterLimit,
  filterSeries: filterSeries,
  forever: forever,
  log: log,
  map: map,
  mapLimit: mapLimit,
  mapSeries: mapSeries,
  mapValues: mapValues,
  mapValuesLimit: mapValuesLimit,
  mapValuesSeries: mapValuesSeries,
  memoize: memoize,
  nextTick: nextTick,
  parallel: parallelLimit,
  parallelLimit: parallelLimit$1,
  priorityQueue: priorityQueue,
  queue: queue$1,
  race: race,
  reduce: reduce,
  reduceRight: reduceRight,
  reflect: reflect,
  reflectAll: reflectAll,
  reject: reject,
  rejectLimit: rejectLimit,
  rejectSeries: rejectSeries,
  retry: retry,
  retryable: retryable,
  seq: seq$1,
  series: series,
  setImmediate: setImmediate$1,
  some: some,
  someLimit: someLimit,
  someSeries: someSeries,
  sortBy: sortBy,
  timeout: timeout,
  times: times,
  timesLimit: timeLimit,
  timesSeries: timesSeries,
  transform: transform,
  unmemoize: unmemoize,
  until: until,
  waterfall: waterfall,
  whilst: whilst,

  // aliases
  all: every,
  any: some,
  forEach: eachLimit,
  forEachSeries: eachSeries,
  forEachLimit: eachLimit$1,
  forEachOf: eachOf,
  forEachOfSeries: eachOfSeries,
  forEachOfLimit: eachOfLimit,
  inject: reduce,
  foldl: reduce,
  foldr: reduceRight,
  select: filter,
  selectLimit: filterLimit,
  selectSeries: filterSeries,
  wrapSync: asyncify
***REMOVED***;

exports['default'] = index;
exports.applyEach = applyEach;
exports.applyEachSeries = applyEachSeries;
exports.apply = apply$2;
exports.asyncify = asyncify;
exports.auto = auto;
exports.autoInject = autoInject;
exports.cargo = cargo;
exports.compose = compose;
exports.concat = concat;
exports.concatSeries = concatSeries;
exports.constant = constant;
exports.detect = detect;
exports.detectLimit = detectLimit;
exports.detectSeries = detectSeries;
exports.dir = dir;
exports.doDuring = doDuring;
exports.doUntil = doUntil;
exports.doWhilst = doWhilst;
exports.during = during;
exports.each = eachLimit;
exports.eachLimit = eachLimit$1;
exports.eachOf = eachOf;
exports.eachOfLimit = eachOfLimit;
exports.eachOfSeries = eachOfSeries;
exports.eachSeries = eachSeries;
exports.ensureAsync = ensureAsync;
exports.every = every;
exports.everyLimit = everyLimit;
exports.everySeries = everySeries;
exports.filter = filter;
exports.filterLimit = filterLimit;
exports.filterSeries = filterSeries;
exports.forever = forever;
exports.log = log;
exports.map = map;
exports.mapLimit = mapLimit;
exports.mapSeries = mapSeries;
exports.mapValues = mapValues;
exports.mapValuesLimit = mapValuesLimit;
exports.mapValuesSeries = mapValuesSeries;
exports.memoize = memoize;
exports.nextTick = nextTick;
exports.parallel = parallelLimit;
exports.parallelLimit = parallelLimit$1;
exports.priorityQueue = priorityQueue;
exports.queue = queue$1;
exports.race = race;
exports.reduce = reduce;
exports.reduceRight = reduceRight;
exports.reflect = reflect;
exports.reflectAll = reflectAll;
exports.reject = reject;
exports.rejectLimit = rejectLimit;
exports.rejectSeries = rejectSeries;
exports.retry = retry;
exports.retryable = retryable;
exports.seq = seq$1;
exports.series = series;
exports.setImmediate = setImmediate$1;
exports.some = some;
exports.someLimit = someLimit;
exports.someSeries = someSeries;
exports.sortBy = sortBy;
exports.timeout = timeout;
exports.times = times;
exports.timesLimit = timeLimit;
exports.timesSeries = timesSeries;
exports.transform = transform;
exports.unmemoize = unmemoize;
exports.until = until;
exports.waterfall = waterfall;
exports.whilst = whilst;
exports.all = every;
exports.allLimit = everyLimit;
exports.allSeries = everySeries;
exports.any = some;
exports.anyLimit = someLimit;
exports.anySeries = someSeries;
exports.find = detect;
exports.findLimit = detectLimit;
exports.findSeries = detectSeries;
exports.forEach = eachLimit;
exports.forEachSeries = eachSeries;
exports.forEachLimit = eachLimit$1;
exports.forEachOf = eachOf;
exports.forEachOfSeries = eachOfSeries;
exports.forEachOfLimit = eachOfLimit;
exports.inject = reduce;
exports.foldl = reduce;
exports.foldr = reduceRight;
exports.select = filter;
exports.selectLimit = filterLimit;
exports.selectSeries = filterSeries;
exports.wrapSync = asyncify;

Object.defineProperty(exports, '__esModule', ***REMOVED*** value: true ***REMOVED***);

***REMOVED***)));
