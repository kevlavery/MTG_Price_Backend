'use strict';

Object.defineProperty(exports, "__esModule", ***REMOVED***
    value: true
***REMOVED***);
exports.default = memoize;

var _identity = require('lodash/identity');

var _identity2 = _interopRequireDefault(_identity);

var _slice = require('./internal/slice');

var _slice2 = _interopRequireDefault(_slice);

var _setImmediate = require('./internal/setImmediate');

var _setImmediate2 = _interopRequireDefault(_setImmediate);

var _initialParams = require('./internal/initialParams');

var _initialParams2 = _interopRequireDefault(_initialParams);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) ***REMOVED*** return obj && obj.__esModule ? obj : ***REMOVED*** default: obj ***REMOVED***; ***REMOVED***

function has(obj, key) ***REMOVED***
    return key in obj;
***REMOVED***

/**
 * Caches the results of an async function. When creating a hash to store
 * function results against, the callback is omitted from the hash and an
 * optional hash function can be used.
 *
 * If no hash function is specified, the first argument is used as a hash key,
 * which may work reasonably if it is a string or a data type that converts to a
 * distinct string. Note that objects and arrays will not behave reasonably.
 * Neither will cases where the other arguments are significant. In such cases,
 * specify your own hash function.
 *
 * The cache of results is exposed as the `memo` property of the function
 * returned by `memoize`.
 *
 * @name memoize
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param ***REMOVED***AsyncFunction***REMOVED*** fn - The async function to proxy and cache results from.
 * @param ***REMOVED***Function***REMOVED*** hasher - An optional function for generating a custom hash
 * for storing results. It has all the arguments applied to it apart from the
 * callback, and must be synchronous.
 * @returns ***REMOVED***AsyncFunction***REMOVED*** a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) ***REMOVED***
 *     // do something
 *     callback(null, result);
 * ***REMOVED***;
 * var fn = async.memoize(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn('some name', function() ***REMOVED***
 *     // callback
 * ***REMOVED***);
 */
function memoize(fn, hasher) ***REMOVED***
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || _identity2.default;
    var _fn = (0, _wrapAsync2.default)(fn);
    var memoized = (0, _initialParams2.default)(function memoized(args, callback) ***REMOVED***
        var key = hasher.apply(null, args);
        if (has(memo, key)) ***REMOVED***
            (0, _setImmediate2.default)(function () ***REMOVED***
                callback.apply(null, memo[key]);
            ***REMOVED***);
        ***REMOVED*** else if (has(queues, key)) ***REMOVED***
            queues[key].push(callback);
        ***REMOVED*** else ***REMOVED***
            queues[key] = [callback];
            _fn.apply(null, args.concat(function () /*args*/***REMOVED***
                var args = (0, _slice2.default)(arguments);
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) ***REMOVED***
                    q[i].apply(null, args);
                ***REMOVED***
            ***REMOVED***));
        ***REMOVED***
    ***REMOVED***);
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
***REMOVED***
module.exports = exports['default'];