'use strict';

/*!
 * Module dependencies
 */

const get = require('lodash.get');
const isDefiningProjection = require('./services/projection/isDefiningProjection');
const utils = require('./utils');

/*!
 * Prepare a set of path options for query population.
 *
 * @param ***REMOVED***Query***REMOVED*** query
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Array***REMOVED***
 */

exports.preparePopulationOptions = function preparePopulationOptions(query, options) ***REMOVED***
  const pop = utils.object.vals(query.options.populate);

  // lean options should trickle through all queries
  if (options.lean) ***REMOVED***
    pop.forEach(makeLean(options.lean));
  ***REMOVED***

  return pop;
***REMOVED***;

/*!
 * Prepare a set of path options for query population. This is the MongooseQuery
 * version
 *
 * @param ***REMOVED***Query***REMOVED*** query
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Array***REMOVED***
 */

exports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) ***REMOVED***
  const pop = utils.object.vals(query._mongooseOptions.populate);

  // lean options should trickle through all queries
  if (options.lean) ***REMOVED***
    pop.forEach(makeLean(options.lean));
  ***REMOVED***

  return pop;
***REMOVED***;


/*!
 * returns discriminator by discriminatorMapping.value
 *
 * @param ***REMOVED***Model***REMOVED*** model
 * @param ***REMOVED***string***REMOVED*** value
 */
function getDiscriminatorByValue(model, value) ***REMOVED***
  let discriminator = null;
  if (!model.discriminators) ***REMOVED***
    return discriminator;
  ***REMOVED***
  for (const name in model.discriminators) ***REMOVED***
    const it = model.discriminators[name];
    if (
      it.schema &&
      it.schema.discriminatorMapping &&
      it.schema.discriminatorMapping.value == value
    ) ***REMOVED***
      discriminator = it;
      break;
    ***REMOVED***
  ***REMOVED***
  return discriminator;
***REMOVED***

exports.getDiscriminatorByValue = getDiscriminatorByValue;

/*!
 * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,
 * it returns an instance of the given model.
 *
 * @param ***REMOVED***Model***REMOVED***  model
 * @param ***REMOVED***Object***REMOVED*** doc
 * @param ***REMOVED***Object***REMOVED*** fields
 *
 * @return ***REMOVED***Model***REMOVED***
 */
exports.createModel = function createModel(model, doc, fields, userProvidedFields) ***REMOVED***
  const discriminatorMapping = model.schema ?
    model.schema.discriminatorMapping :
    null;

  const key = discriminatorMapping && discriminatorMapping.isRoot ?
    discriminatorMapping.key :
    null;

  const value = doc[key];
  if (key && value && model.discriminators) ***REMOVED***
    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model, value);
    if (discriminator) ***REMOVED***
      const _fields = utils.clone(userProvidedFields);
      exports.applyPaths(_fields, discriminator.schema);
      return new discriminator(undefined, _fields, true);
    ***REMOVED***
  ***REMOVED***

  const skipDefaults = gatherPaths(doc, ***REMOVED******REMOVED***, '');
  return new model(undefined, fields, ***REMOVED***
    skipId: true,
    isNew: false,
    skipDefaults: skipDefaults
  ***REMOVED***);
***REMOVED***;

/*!
 *
 */

function gatherPaths(obj, map, path) ***REMOVED***
  for (const key of Object.keys(obj)) ***REMOVED***
    const fullPath = path ? path + '.' + key : key;
    map[fullPath] = true;
    if (obj[key] != null &&
        typeof obj[key] === 'object' &&
        !Array.isArray(obj) &&
        !(obj instanceof Map) &&
        !obj[key]._bsontype &&
        !utils.isMongooseObject(obj[key])) ***REMOVED***
      gatherPaths(obj[key], map, fullPath);
    ***REMOVED***
  ***REMOVED***

  return map;
***REMOVED***

/*!
 * ignore
 */

exports.applyPaths = function applyPaths(fields, schema) ***REMOVED***
  // determine if query is selecting or excluding fields
  let exclude;
  let keys;
  let ki;
  let field;

  if (fields) ***REMOVED***
    keys = Object.keys(fields);
    ki = keys.length;

    while (ki--) ***REMOVED***
      if (keys[ki][0] === '+') ***REMOVED***
        continue;
      ***REMOVED***
      field = fields[keys[ki]];
      // Skip `$meta` and `$slice`
      if (!isDefiningProjection(field)) ***REMOVED***
        continue;
      ***REMOVED***
      exclude = field === 0;
      break;
    ***REMOVED***
  ***REMOVED***

  // if selecting, apply default schematype select:true fields
  // if excluding, apply schematype select:false fields

  let selected = [];
  let excluded = [];
  let stack = [];

  let analyzePath = function(path, type) ***REMOVED***
    if (typeof type.selected !== 'boolean') return;

    var plusPath = '+' + path;
    if (fields && plusPath in fields) ***REMOVED***
      // forced inclusion
      delete fields[plusPath];

      // if there are other fields being included, add this one
      // if no other included fields, leave this out (implied inclusion)
      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) ***REMOVED***
        fields[path] = 1;
      ***REMOVED***

      return;
    ***REMOVED***

    // check for parent exclusions
    let pieces = path.split('.');
    let root = pieces[0];
    if (~excluded.indexOf(root)) ***REMOVED***
      return;
    ***REMOVED***

    // Special case: if user has included a parent path of a discriminator key,
    // don't explicitly project in the discriminator key because that will
    // project out everything else under the parent path
    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) ***REMOVED***
      let cur = '';
      for (let i = 0; i < pieces.length; ++i) ***REMOVED***
        cur += (cur.length === 0 ? '' : '.') + pieces[i];
        const projection = get(fields, cur, false);
        if (projection && typeof projection !== 'object') ***REMOVED***
          return;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    (type.selected ? selected : excluded).push(path);
  ***REMOVED***;

  var analyzeSchema = function(schema, prefix) ***REMOVED***
    prefix || (prefix = '');

    // avoid recursion
    if (stack.indexOf(schema) !== -1) ***REMOVED***
      return;
    ***REMOVED***
    stack.push(schema);

    schema.eachPath(function(path, type) ***REMOVED***
      if (prefix) path = prefix + '.' + path;

      analyzePath(path, type);

      // array of subdocs?
      if (type.schema) ***REMOVED***
        analyzeSchema(type.schema, path);
      ***REMOVED***
    ***REMOVED***);

    stack.pop();
  ***REMOVED***;

  analyzeSchema(schema);

  let i;
  switch (exclude) ***REMOVED***
    case true:
      for (i = 0; i < excluded.length; ++i) ***REMOVED***
        fields[excluded[i]] = 0;
      ***REMOVED***
      break;
    case false:
      if (schema &&
          schema.paths['_id'] &&
          schema.paths['_id'].options &&
          schema.paths['_id'].options.select === false) ***REMOVED***
        fields._id = 0;
      ***REMOVED***
      for (i = 0; i < selected.length; ++i) ***REMOVED***
        fields[selected[i]] = 1;
      ***REMOVED***
      break;
    case undefined:
      // user didn't specify fields, implies returning all fields.
      // only need to apply excluded fields
      for (i = 0; i < excluded.length; ++i) ***REMOVED***
        fields[excluded[i]] = 0;
      ***REMOVED***
      break;
  ***REMOVED***
***REMOVED***;

/*!
 * Set each path query option to lean
 *
 * @param ***REMOVED***Object***REMOVED*** option
 */

function makeLean(val) ***REMOVED***
  return function(option) ***REMOVED***
    option.options || (option.options = ***REMOVED******REMOVED***);
    option.options.lean = val;
  ***REMOVED***;
***REMOVED***

/*!
 * Handle the `WriteOpResult` from the server
 */

exports.handleWriteOpResult = function handleWriteOpResult(callback) ***REMOVED***
  return function _handleWriteOpResult(error, res) ***REMOVED***
    if (error) ***REMOVED***
      return callback(error);
    ***REMOVED***
    return callback(null, res.result);
  ***REMOVED***;
***REMOVED***;
