/*!
 * Module dependencies.
 */

var Readable = require('stream').Readable;
var eachAsync = require('../helpers/cursor/eachAsync');
var helpers = require('../queryhelpers');
var util = require('util');
var utils = require('../utils');

/**
 * A QueryCursor is a concurrency primitive for processing query results
 * one document at a time. A QueryCursor fulfills the Node.js streams3 API,
 * in addition to several other mechanisms for loading documents from MongoDB
 * one at a time.
 *
 * QueryCursors execute the model's pre find hooks, but **not** the model's
 * post find hooks.
 *
 * Unless you're an advanced user, do **not** instantiate this class directly.
 * Use [`Query#cursor()`](/docs/api.html#query_Query-cursor) instead.
 *
 * @param ***REMOVED***Query***REMOVED*** query
 * @param ***REMOVED***Object***REMOVED*** options query options passed to `.find()`
 * @inherits Readable
 * @event `cursor`: Emitted when the cursor is created
 * @event `error`: Emitted when an error occurred
 * @event `data`: Emitted when the stream is flowing and the next doc is ready
 * @event `end`: Emitted when the stream is exhausted
 * @api public
 */

function QueryCursor(query, options) ***REMOVED***
  Readable.call(this, ***REMOVED*** objectMode: true ***REMOVED***);

  this.cursor = null;
  this.query = query;
  this._transforms = options.transform ? [options.transform] : [];
  var _this = this;
  var model = query.model;
  model.hooks.execPre('find', query, function() ***REMOVED***
    model.collection.find(query._conditions, options, function(err, cursor) ***REMOVED***
      if (_this._error) ***REMOVED***
        cursor.close(function() ***REMOVED******REMOVED***);
        _this.listeners('error').length > 0 && _this.emit('error', _this._error);
      ***REMOVED***
      if (err) ***REMOVED***
        return _this.emit('error', err);
      ***REMOVED***
      _this.cursor = cursor;
      _this.emit('cursor', cursor);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

util.inherits(QueryCursor, Readable);

/*!
 * Necessary to satisfy the Readable API
 */

QueryCursor.prototype._read = function() ***REMOVED***
  var _this = this;
  _next(this, function(error, doc) ***REMOVED***
    if (error) ***REMOVED***
      return _this.emit('error', error);
    ***REMOVED***
    if (!doc) ***REMOVED***
      _this.push(null);
      _this.cursor.close(function(error) ***REMOVED***
        if (error) ***REMOVED***
          return _this.emit('error', error);
        ***REMOVED***
        setTimeout(function() ***REMOVED***
          _this.emit('close');
        ***REMOVED***, 0);
      ***REMOVED***);
      return;
    ***REMOVED***
    _this.push(doc);
  ***REMOVED***);
***REMOVED***;

/**
 * Registers a transform function which subsequently maps documents retrieved
 * via the streams interface or `.next()`
 *
 * ####Example
 *
 *     // Map documents returned by `data` events
 *     Thing.
 *       find(***REMOVED*** name: /^hello/ ***REMOVED***).
 *       cursor().
 *       map(function (doc) ***REMOVED***
 *        doc.foo = "bar";
 *        return doc;
 *       ***REMOVED***)
 *       on('data', function(doc) ***REMOVED*** console.log(doc.foo); ***REMOVED***);
 *
 *     // Or map documents returned by `.next()`
 *     var cursor = Thing.find(***REMOVED*** name: /^hello/ ***REMOVED***).
 *       cursor().
 *       map(function (doc) ***REMOVED***
 *         doc.foo = "bar";
 *         return doc;
 *       ***REMOVED***);
 *     cursor.next(function(error, doc) ***REMOVED***
 *       console.log(doc.foo);
 *     ***REMOVED***);
 *
 * @param ***REMOVED***Function***REMOVED*** fn
 * @return ***REMOVED***QueryCursor***REMOVED***
 * @api public
 * @method map
 */

QueryCursor.prototype.map = function(fn) ***REMOVED***
  this._transforms.push(fn);
  return this;
***REMOVED***;

/*!
 * Marks this cursor as errored
 */

QueryCursor.prototype._markError = function(error) ***REMOVED***
  this._error = error;
  return this;
***REMOVED***;

/**
 * Marks this cursor as closed. Will stop streaming and subsequent calls to
 * `next()` will error.
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @return ***REMOVED***Promise***REMOVED***
 * @api public
 * @method close
 * @emits close
 * @see MongoDB driver cursor#close http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close
 */

QueryCursor.prototype.close = function(callback) ***REMOVED***
  return utils.promiseOrCallback(callback, cb => ***REMOVED***
    this.cursor.close(error => ***REMOVED***
      if (error) ***REMOVED***
        cb(error);
        return this.listeners('error').length > 0 && this.emit('error', error);
      ***REMOVED***
      this.emit('close');
      cb(null);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Get the next document from this cursor. Will return `null` when there are
 * no documents left.
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @return ***REMOVED***Promise***REMOVED***
 * @api public
 * @method next
 */

QueryCursor.prototype.next = function(callback) ***REMOVED***
  return utils.promiseOrCallback(callback, cb => ***REMOVED***
    _next(this, function(error, doc) ***REMOVED***
      if (error) ***REMOVED***
        return cb(error);
      ***REMOVED***
      cb(null, doc);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Execute `fn` for every document in the cursor. If `fn` returns a promise,
 * will wait for the promise to resolve before iterating on to the next one.
 * Returns a promise that resolves when done.
 *
 * @param ***REMOVED***Function***REMOVED*** fn
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @param ***REMOVED***Number***REMOVED*** [options.parallel] the number of promises to execute in parallel. Defaults to 1.
 * @param ***REMOVED***Function***REMOVED*** [callback] executed when all docs have been processed
 * @return ***REMOVED***Promise***REMOVED***
 * @api public
 * @method eachAsync
 */

QueryCursor.prototype.eachAsync = function(fn, opts, callback) ***REMOVED***
  var _this = this;
  if (typeof opts === 'function') ***REMOVED***
    callback = opts;
    opts = ***REMOVED******REMOVED***;
  ***REMOVED***
  opts = opts || ***REMOVED******REMOVED***;

  return eachAsync(function(cb) ***REMOVED*** return _next(_this, cb); ***REMOVED***, fn, opts, callback);
***REMOVED***;

/**
 * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).
 * Useful for setting the `noCursorTimeout` and `tailable` flags.
 *
 * @param ***REMOVED***String***REMOVED*** flag
 * @param ***REMOVED***Boolean***REMOVED*** value
 * @return ***REMOVED***AggregationCursor***REMOVED*** this
 * @api public
 * @method addCursorFlag
 */

QueryCursor.prototype.addCursorFlag = function(flag, value) ***REMOVED***
  var _this = this;
  _waitForCursor(this, function() ***REMOVED***
    _this.cursor.addCursorFlag(flag, value);
  ***REMOVED***);
  return this;
***REMOVED***;

/*!
 * Get the next doc from the underlying cursor and mongooseify it
 * (populate, etc.)
 */

function _next(ctx, cb) ***REMOVED***
  var callback = cb;
  if (ctx._transforms.length) ***REMOVED***
    callback = function(err, doc) ***REMOVED***
      if (err || doc === null) ***REMOVED***
        return cb(err, doc);
      ***REMOVED***
      cb(err, ctx._transforms.reduce(function(doc, fn) ***REMOVED***
        return fn(doc);
      ***REMOVED***, doc));
    ***REMOVED***;
  ***REMOVED***

  if (ctx._error) ***REMOVED***
    return process.nextTick(function() ***REMOVED***
      callback(ctx._error);
    ***REMOVED***);
  ***REMOVED***

  if (ctx.cursor) ***REMOVED***
    return ctx.cursor.next(function(error, doc) ***REMOVED***
      if (error) ***REMOVED***
        return callback(error);
      ***REMOVED***
      if (!doc) ***REMOVED***
        return callback(null, null);
      ***REMOVED***

      var opts = ctx.query._mongooseOptions;
      if (!opts.populate) ***REMOVED***
        return opts.lean === true ?
          callback(null, doc) :
          _create(ctx, doc, null, callback);
      ***REMOVED***

      var pop = helpers.preparePopulationOptionsMQ(ctx.query,
        ctx.query._mongooseOptions);
      pop.__noPromise = true;
      ctx.query.model.populate(doc, pop, function(err, doc) ***REMOVED***
        if (err) ***REMOVED***
          return callback(err);
        ***REMOVED***
        return opts.lean === true ?
          callback(null, doc) :
          _create(ctx, doc, pop, callback);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    ctx.once('cursor', function() ***REMOVED***
      _next(ctx, cb);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/*!
 * ignore
 */

function _waitForCursor(ctx, cb) ***REMOVED***
  if (ctx.cursor) ***REMOVED***
    return cb();
  ***REMOVED***
  ctx.once('cursor', function() ***REMOVED***
    cb();
  ***REMOVED***);
***REMOVED***

/*!
 * Convert a raw doc into a full mongoose doc.
 */

function _create(ctx, doc, populatedIds, cb) ***REMOVED***
  var instance = helpers.createModel(ctx.query.model, doc, ctx.query._fields);
  var opts = populatedIds ?
    ***REMOVED*** populated: populatedIds ***REMOVED*** :
    undefined;

  instance.init(doc, opts, function(err) ***REMOVED***
    if (err) ***REMOVED***
      return cb(err);
    ***REMOVED***
    cb(null, instance);
  ***REMOVED***);
***REMOVED***

module.exports = QueryCursor;
