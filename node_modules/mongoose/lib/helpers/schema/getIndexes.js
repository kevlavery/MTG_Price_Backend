'use strict';

const get = require('lodash.get');
const utils = require('../../utils');

/*!
 * Gather all indexes defined in the schema, including single nested,
 * document arrays, and embedded discriminators.
 */

module.exports = function getIndexes(schema) ***REMOVED***
  let indexes = [];
  const schemaStack = new WeakMap();
  const indexTypes = schema.constructor.indexTypes;

  const collectIndexes = function(schema, prefix) ***REMOVED***
    // Ignore infinitely nested schemas, if we've already seen this schema
    // along this path there must be a cycle
    if (schemaStack.has(schema)) ***REMOVED***
      return;
    ***REMOVED***
    schemaStack.set(schema, true);

    prefix = prefix || '';
    const keys = Object.keys(schema.paths);
    const length = keys.length;

    for (let i = 0; i < length; ++i) ***REMOVED***
      const key = keys[i];
      const path = schema.paths[key];

      if (path.$isMongooseDocumentArray || path.$isSingleNested) ***REMOVED***
        if (get(path, 'options.excludeIndexes') !== true &&
            get(path, 'schemaOptions.excludeIndexes') !== true) ***REMOVED***
          collectIndexes(path.schema, prefix + key + '.');
        ***REMOVED***

        if (path.schema.discriminators != null) ***REMOVED***
          const discriminators = path.schema.discriminators;
          const discriminatorKeys = Object.keys(discriminators);
          for (const discriminatorKey of discriminatorKeys) ***REMOVED***
            collectIndexes(discriminators[discriminatorKey]._originalSchema,
              prefix + key + '.');
          ***REMOVED***
        ***REMOVED***

        // Retained to minimize risk of backwards breaking changes due to
        // gh-6113
        if (path.$isMongooseDocumentArray) ***REMOVED***
          continue;
        ***REMOVED***
      ***REMOVED***

      const index = path._index || (path.caster && path.caster._index);

      if (index !== false && index !== null && index !== undefined) ***REMOVED***
        const field = ***REMOVED******REMOVED***;
        const isObject = utils.isObject(index);
        const options = isObject ? index : ***REMOVED******REMOVED***;
        const type = typeof index === 'string' ? index :
          isObject ? index.type :
            false;

        if (type && indexTypes.indexOf(type) !== -1) ***REMOVED***
          field[prefix + key] = type;
        ***REMOVED*** else if (options.text) ***REMOVED***
          field[prefix + key] = 'text';
          delete options.text;
        ***REMOVED*** else ***REMOVED***
          field[prefix + key] = 1;
        ***REMOVED***

        delete options.type;
        if (!('background' in options)) ***REMOVED***
          options.background = true;
        ***REMOVED***

        indexes.push([field, options]);
      ***REMOVED***
    ***REMOVED***

    schemaStack.delete(schema);

    if (prefix) ***REMOVED***
      fixSubIndexPaths(schema, prefix);
    ***REMOVED*** else ***REMOVED***
      schema._indexes.forEach(function(index) ***REMOVED***
        if (!('background' in index[1])) ***REMOVED***
          index[1].background = true;
        ***REMOVED***
      ***REMOVED***);
      indexes = indexes.concat(schema._indexes);
    ***REMOVED***
  ***REMOVED***;

  collectIndexes(schema);
  return indexes;

  /*!
   * Checks for indexes added to subdocs using Schema.index().
   * These indexes need their paths prefixed properly.
   *
   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
   */

  function fixSubIndexPaths(schema, prefix) ***REMOVED***
    const subindexes = schema._indexes;
    const len = subindexes.length;
    for (let i = 0; i < len; ++i) ***REMOVED***
      const indexObj = subindexes[i][0];
      const keys = Object.keys(indexObj);
      const klen = keys.length;
      const newindex = ***REMOVED******REMOVED***;

      // use forward iteration, order matters
      for (let j = 0; j < klen; ++j) ***REMOVED***
        const key = keys[j];
        newindex[prefix + key] = indexObj[key];
      ***REMOVED***

      indexes.push([newindex, subindexes[i][1]]);
    ***REMOVED***
  ***REMOVED***
***REMOVED***;
