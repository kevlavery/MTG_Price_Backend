'use strict';

const modifiedPaths = require('./common').modifiedPaths;

/**
 * Applies defaults to update and findOneAndUpdate operations.
 *
 * @param ***REMOVED***Object***REMOVED*** filter
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @param ***REMOVED***Object***REMOVED*** castedDoc
 * @param ***REMOVED***Object***REMOVED*** options
 * @method setDefaultsOnInsert
 * @api private
 */

module.exports = function(filter, schema, castedDoc, options) ***REMOVED***
  const keys = Object.keys(castedDoc || ***REMOVED******REMOVED***);
  const updatedKeys = ***REMOVED******REMOVED***;
  const updatedValues = ***REMOVED******REMOVED***;
  const numKeys = keys.length;
  const modified = ***REMOVED******REMOVED***;

  let hasDollarUpdate = false;

  options = options || ***REMOVED******REMOVED***;

  if (!options.upsert || !options.setDefaultsOnInsert) ***REMOVED***
    return castedDoc;
  ***REMOVED***

  for (let i = 0; i < numKeys; ++i) ***REMOVED***
    if (keys[i].charAt(0) === '$') ***REMOVED***
      modifiedPaths(castedDoc[keys[i]], '', modified);
      hasDollarUpdate = true;
    ***REMOVED***
  ***REMOVED***

  if (!hasDollarUpdate) ***REMOVED***
    modifiedPaths(castedDoc, '', modified);
  ***REMOVED***

  const paths = Object.keys(filter);
  const numPaths = paths.length;
  for (let i = 0; i < numPaths; ++i) ***REMOVED***
    const path = paths[i];
    const condition = filter[path];
    if (condition && typeof condition === 'object') ***REMOVED***
      const conditionKeys = Object.keys(condition);
      const numConditionKeys = conditionKeys.length;
      let hasDollarKey = false;
      for (var j = 0; j < numConditionKeys; ++j) ***REMOVED***
        if (conditionKeys[j].charAt(0) === '$') ***REMOVED***
          hasDollarKey = true;
          break;
        ***REMOVED***
      ***REMOVED***
      if (hasDollarKey) ***REMOVED***
        continue;
      ***REMOVED***
    ***REMOVED***
    updatedKeys[path] = true;
    modified[path] = true;
  ***REMOVED***

  if (options && options.overwrite && !hasDollarUpdate) ***REMOVED***
    // Defaults will be set later, since we're overwriting we'll cast
    // the whole update to a document
    return castedDoc;
  ***REMOVED***

  schema.eachPath(function(path, schemaType) ***REMOVED***
    if (schemaType.$isSingleNested) ***REMOVED***
      // Only handle nested schemas 1-level deep to avoid infinite
      // recursion re: https://github.com/mongodb-js/mongoose-autopopulate/issues/11
      schemaType.schema.eachPath(function(_path, _schemaType) ***REMOVED***
        if (_path === '_id' && _schemaType.auto) ***REMOVED***
          // Ignore _id if auto id so we don't create subdocs
          return;
        ***REMOVED***

        const def = _schemaType.getDefault(null, true);
        if (!isModified(modified, path + '.' + _path) &&
            typeof def !== 'undefined') ***REMOVED***
          castedDoc = castedDoc || ***REMOVED******REMOVED***;
          castedDoc.$setOnInsert = castedDoc.$setOnInsert || ***REMOVED******REMOVED***;
          castedDoc.$setOnInsert[path + '.' + _path] = def;
          updatedValues[path + '.' + _path] = def;
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      const def = schemaType.getDefault(null, true);
      if (!isModified(modified, path) && typeof def !== 'undefined') ***REMOVED***
        castedDoc = castedDoc || ***REMOVED******REMOVED***;
        castedDoc.$setOnInsert = castedDoc.$setOnInsert || ***REMOVED******REMOVED***;
        castedDoc.$setOnInsert[path] = def;
        updatedValues[path] = def;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);

  return castedDoc;
***REMOVED***;

function isModified(modified, path) ***REMOVED***
  if (modified[path]) ***REMOVED***
    return true;
  ***REMOVED***
  const sp = path.split('.');
  let cur = sp[0];
  for (let i = 1; i < sp.length; ++i) ***REMOVED***
    if (modified[cur]) ***REMOVED***
      return true;
    ***REMOVED***
    cur += '.' + sp[i];
  ***REMOVED***
  return false;
***REMOVED***
