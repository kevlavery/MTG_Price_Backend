'use strict';

const utils = require('../../utils');

/*!
 * ignore
 */

module.exports = applyHooks;

/*!
 * Register hooks for this model
 *
 * @param ***REMOVED***Model***REMOVED*** model
 * @param ***REMOVED***Schema***REMOVED*** schema
 */

function applyHooks(model, schema, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  const kareemOptions = ***REMOVED***
    useErrorHandlers: true,
    numCallbackParams: 1,
    nullResultByDefault: true,
    contextParameter: true
  ***REMOVED***;
  const objToDecorate = options.decorateDoc ? model : model.prototype;

  model.$appliedHooks = true;
  for (let i = 0; i < schema.childSchemas.length; ++i) ***REMOVED***
    const childModel = schema.childSchemas[i].model;
    if (childModel.$appliedHooks) ***REMOVED***
      continue;
    ***REMOVED***
    applyHooks(childModel, schema.childSchemas[i].schema, options);
    if (childModel.discriminators != null) ***REMOVED***
      let keys = Object.keys(childModel.discriminators);
      for (let j = 0; j < keys.length; ++j) ***REMOVED***
        applyHooks(childModel.discriminators[keys[j]],
          childModel.discriminators[keys[j]].schema, options);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Built-in hooks rely on hooking internal functions in order to support
  // promises and make it so that `doc.save.toString()` provides meaningful
  // information.
  objToDecorate.$__save = schema.s.hooks.
    createWrapper('save', objToDecorate.$__save, null, kareemOptions);
  objToDecorate.$__validate = schema.s.hooks.
    createWrapper('validate', objToDecorate.$__validate, null, kareemOptions);
  objToDecorate.$__remove = schema.s.hooks.
    createWrapper('remove', objToDecorate.$__remove, null, kareemOptions);
  objToDecorate.$__init = schema.s.hooks.
    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);

  // Support hooks for custom methods
  const customMethods = Object.keys(schema.methods);
  const customMethodOptions = Object.assign(***REMOVED******REMOVED***, kareemOptions, ***REMOVED***
    // Only use `checkForPromise` for custom methods, because mongoose
    // query thunks are not as consistent as I would like about returning
    // a nullish value rather than the query. If a query thunk returns
    // a query, `checkForPromise` causes infinite recursion
    checkForPromise: true
  ***REMOVED***);
  for (const method of customMethods) ***REMOVED***
    if (!schema.s.hooks.hasHooks(method)) ***REMOVED***
      // Don't wrap if there are no hooks for the custom method to avoid
      // surprises. Also, `createWrapper()` enforces consistent async,
      // so wrapping a sync method would break it.
      continue;
    ***REMOVED***
    const originalMethod = objToDecorate[method];
    objToDecorate[method] = function() ***REMOVED***
      const args = Array.prototype.slice.call(arguments);
      const cb = utils.last(args);
      const argsWithoutCallback = cb == null ? args :
        args.slice(0, args.length - 1);
      return utils.promiseOrCallback(cb, callback => ***REMOVED***
        this[`$__$***REMOVED***method***REMOVED***`].apply(this,
          argsWithoutCallback.concat([callback]));
      ***REMOVED***);
    ***REMOVED***;
    objToDecorate[`$__$***REMOVED***method***REMOVED***`] = schema.s.hooks.
      createWrapper(method, originalMethod, null, customMethodOptions);
  ***REMOVED***
***REMOVED***
