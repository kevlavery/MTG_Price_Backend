
/*!
 * Module dependencies.
 */

var utils = require('./utils');

/*!
 * StateMachine represents a minimal `interface` for the
 * constructors it builds via StateMachine.ctor(...).
 *
 * @api private
 */

var StateMachine = module.exports = exports = function StateMachine() ***REMOVED***
***REMOVED***;

/*!
 * StateMachine.ctor('state1', 'state2', ...)
 * A factory method for subclassing StateMachine.
 * The arguments are a list of states. For each state,
 * the constructor's prototype gets state transition
 * methods named after each state. These transition methods
 * place their path argument into the given state.
 *
 * @param ***REMOVED***String***REMOVED*** state
 * @param ***REMOVED***String***REMOVED*** [state]
 * @return ***REMOVED***Function***REMOVED*** subclass constructor
 * @private
 */

StateMachine.ctor = function() ***REMOVED***
  var states = utils.args(arguments);

  var ctor = function() ***REMOVED***
    StateMachine.apply(this, arguments);
    this.paths = ***REMOVED******REMOVED***;
    this.states = ***REMOVED******REMOVED***;
    this.stateNames = states;

    var i = states.length,
        state;

    while (i--) ***REMOVED***
      state = states[i];
      this.states[state] = ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***;

  ctor.prototype = new StateMachine();

  states.forEach(function(state) ***REMOVED***
    // Changes the `path`'s state to `state`.
    ctor.prototype[state] = function(path) ***REMOVED***
      this._changeState(path, state);
    ***REMOVED***;
  ***REMOVED***);

  return ctor;
***REMOVED***;

/*!
 * This function is wrapped by the state change functions:
 *
 * - `require(path)`
 * - `modify(path)`
 * - `init(path)`
 *
 * @api private
 */

StateMachine.prototype._changeState = function _changeState(path, nextState) ***REMOVED***
  var prevBucket = this.states[this.paths[path]];
  if (prevBucket) delete prevBucket[path];

  this.paths[path] = nextState;
  this.states[nextState][path] = true;
***REMOVED***;

/*!
 * ignore
 */

StateMachine.prototype.clear = function clear(state) ***REMOVED***
  var keys = Object.keys(this.states[state]),
      i = keys.length,
      path;

  while (i--) ***REMOVED***
    path = keys[i];
    delete this.states[state][path];
    delete this.paths[path];
  ***REMOVED***
***REMOVED***;

/*!
 * Checks to see if at least one path is in the states passed in via `arguments`
 * e.g., this.some('required', 'inited')
 *
 * @param ***REMOVED***String***REMOVED*** state that we want to check for.
 * @private
 */

StateMachine.prototype.some = function some() ***REMOVED***
  var _this = this;
  var what = arguments.length ? arguments : this.stateNames;
  return Array.prototype.some.call(what, function(state) ***REMOVED***
    return Object.keys(_this.states[state]).length;
  ***REMOVED***);
***REMOVED***;

/*!
 * This function builds the functions that get assigned to `forEach` and `map`,
 * since both of those methods share a lot of the same logic.
 *
 * @param ***REMOVED***String***REMOVED*** iterMethod is either 'forEach' or 'map'
 * @return ***REMOVED***Function***REMOVED***
 * @api private
 */

StateMachine.prototype._iter = function _iter(iterMethod) ***REMOVED***
  return function() ***REMOVED***
    var numArgs = arguments.length,
        states = utils.args(arguments, 0, numArgs - 1),
        callback = arguments[numArgs - 1];

    if (!states.length) states = this.stateNames;

    var _this = this;

    var paths = states.reduce(function(paths, state) ***REMOVED***
      return paths.concat(Object.keys(_this.states[state]));
    ***REMOVED***, []);

    return paths[iterMethod](function(path, i, paths) ***REMOVED***
      return callback(path, i, paths);
    ***REMOVED***);
  ***REMOVED***;
***REMOVED***;

/*!
 * Iterates over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param ***REMOVED***String***REMOVED*** [state]
 * @param ***REMOVED***String***REMOVED*** [state]
 * @param ***REMOVED***Function***REMOVED*** callback
 * @private
 */

StateMachine.prototype.forEach = function forEach() ***REMOVED***
  this.forEach = this._iter('forEach');
  return this.forEach.apply(this, arguments);
***REMOVED***;

/*!
 * Maps over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param ***REMOVED***String***REMOVED*** [state]
 * @param ***REMOVED***String***REMOVED*** [state]
 * @param ***REMOVED***Function***REMOVED*** callback
 * @return ***REMOVED***Array***REMOVED***
 * @private
 */

StateMachine.prototype.map = function map() ***REMOVED***
  this.map = this._iter('map');
  return this.map.apply(this, arguments);
***REMOVED***;
