'use strict';

/*!
 * Module dependencies.
 */

var ArrayType = require('./array');
var CastError = require('../error/cast');
var EventEmitter = require('events').EventEmitter;
var SchemaType = require('../schematype');
var discriminator = require('../helpers/model/discriminator');
var util = require('util');
var utils = require('../utils');
var getDiscriminatorByValue = require('../queryhelpers').getDiscriminatorByValue;

var MongooseDocumentArray;
var Subdocument;

/**
 * SubdocsArray SchemaType constructor
 *
 * @param ***REMOVED***String***REMOVED*** key
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @param ***REMOVED***Object***REMOVED*** options
 * @inherits SchemaArray
 * @api public
 */

function DocumentArray(key, schema, options, schemaOptions) ***REMOVED***
  const EmbeddedDocument = _createConstructor(schema, options);
  EmbeddedDocument.prototype.$basePath = key;

  ArrayType.call(this, key, EmbeddedDocument, options);

  this.schema = schema;
  this.schemaOptions = schemaOptions || ***REMOVED******REMOVED***;
  this.$isMongooseDocumentArray = true;
  const fn = this.defaultValue;

  if (!('defaultValue' in this) || fn !== void 0) ***REMOVED***
    this.default(function() ***REMOVED***
      var arr = fn.call(this);
      if (!Array.isArray(arr)) ***REMOVED***
        arr = [arr];
      ***REMOVED***
      // Leave it up to `cast()` to convert this to a documentarray
      return arr;
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */
DocumentArray.schemaName = 'DocumentArray';

/*!
 * Inherits from ArrayType.
 */
DocumentArray.prototype = Object.create(ArrayType.prototype);
DocumentArray.prototype.constructor = DocumentArray;

/*!
 * Ignore
 */

function _createConstructor(schema, options) ***REMOVED***
  Subdocument || (Subdocument = require('../types/embedded'));

  // compile an embedded document for this schema
  function EmbeddedDocument() ***REMOVED***
    Subdocument.apply(this, arguments);
  ***REMOVED***

  EmbeddedDocument.prototype = Object.create(Subdocument.prototype);
  EmbeddedDocument.prototype.$__setSchema(schema);
  EmbeddedDocument.schema = schema;
  EmbeddedDocument.prototype.constructor = EmbeddedDocument;
  EmbeddedDocument.$isArraySubdocument = true;

  // apply methods
  for (var i in schema.methods) ***REMOVED***
    EmbeddedDocument.prototype[i] = schema.methods[i];
  ***REMOVED***

  // apply statics
  for (i in schema.statics) ***REMOVED***
    EmbeddedDocument[i] = schema.statics[i];
  ***REMOVED***

  for (i in EventEmitter.prototype) ***REMOVED***
    EmbeddedDocument[i] = EventEmitter.prototype[i];
  ***REMOVED***

  EmbeddedDocument.options = options;

  return EmbeddedDocument;
***REMOVED***

/*!
 * Ignore
 */

DocumentArray.prototype.discriminator = function(name, schema) ***REMOVED***
  if (typeof name === 'function') ***REMOVED***
    name = utils.getFunctionName(name);
  ***REMOVED***

  schema = discriminator(this.casterConstructor, name, schema);

  var EmbeddedDocument = _createConstructor(schema);
  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;

  try ***REMOVED***
    Object.defineProperty(EmbeddedDocument, 'name', ***REMOVED***
      value: name
    ***REMOVED***);
  ***REMOVED*** catch (error) ***REMOVED***
    // Ignore error, only happens on old versions of node
  ***REMOVED***

  this.casterConstructor.discriminators[name] = EmbeddedDocument;

  return this.casterConstructor.discriminators[name];
***REMOVED***;

/**
 * Performs local validations first, then validations on each embedded doc
 *
 * @api private
 */

DocumentArray.prototype.doValidate = function(array, fn, scope, options) ***REMOVED***
  // lazy load
  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));

  var _this = this;
  SchemaType.prototype.doValidate.call(this, array, function(err) ***REMOVED***
    if (err) ***REMOVED***
      return fn(err);
    ***REMOVED***

    var count = array && array.length;
    var error;

    if (!count) ***REMOVED***
      return fn();
    ***REMOVED***
    if (options && options.updateValidator) ***REMOVED***
      return fn();
    ***REMOVED***
    if (!array.isMongooseDocumentArray) ***REMOVED***
      array = new MongooseDocumentArray(array, _this.path, scope);
    ***REMOVED***

    // handle sparse arrays, do not use array.forEach which does not
    // iterate over sparse elements yet reports array.length including
    // them :(

    function callback(err) ***REMOVED***
      if (err) ***REMOVED***
        error = err;
      ***REMOVED***
      --count || fn(error);
    ***REMOVED***

    for (var i = 0, len = count; i < len; ++i) ***REMOVED***
      // sidestep sparse entries
      var doc = array[i];
      if (doc == null) ***REMOVED***
        --count || fn(error);
        continue;
      ***REMOVED***

      // If you set the array index directly, the doc might not yet be
      // a full fledged mongoose subdoc, so make it into one.
      if (!(doc instanceof Subdocument)) ***REMOVED***
        doc = array[i] = new _this.casterConstructor(doc, array, undefined,
          undefined, i);
      ***REMOVED***

      doc.$__validate(callback);
    ***REMOVED***
  ***REMOVED***, scope);
***REMOVED***;

/**
 * Performs local validations first, then validations on each embedded doc.
 *
 * ####Note:
 *
 * This method ignores the asynchronous validators.
 *
 * @return ***REMOVED***MongooseError|undefined***REMOVED***
 * @api private
 */

DocumentArray.prototype.doValidateSync = function(array, scope) ***REMOVED***
  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
  if (schemaTypeError) ***REMOVED***
    return schemaTypeError;
  ***REMOVED***

  var count = array && array.length,
      resultError = null;

  if (!count) ***REMOVED***
    return;
  ***REMOVED***

  // handle sparse arrays, do not use array.forEach which does not
  // iterate over sparse elements yet reports array.length including
  // them :(

  for (var i = 0, len = count; i < len; ++i) ***REMOVED***
    // only first error
    if (resultError) ***REMOVED***
      break;
    ***REMOVED***
    // sidestep sparse entries
    var doc = array[i];
    if (!doc) ***REMOVED***
      continue;
    ***REMOVED***

    // If you set the array index directly, the doc might not yet be
    // a full fledged mongoose subdoc, so make it into one.
    if (!(doc instanceof Subdocument)) ***REMOVED***
      doc = array[i] = new this.casterConstructor(doc, array, undefined,
        undefined, i);
    ***REMOVED***

    var subdocValidateError = doc.validateSync();

    if (subdocValidateError) ***REMOVED***
      resultError = subdocValidateError;
    ***REMOVED***
  ***REMOVED***

  return resultError;
***REMOVED***;

/**
 * Casts contents
 *
 * @param ***REMOVED***Object***REMOVED*** value
 * @param ***REMOVED***Document***REMOVED*** document that triggers the casting
 * @api private
 */

DocumentArray.prototype.cast = function(value, doc, init, prev, options) ***REMOVED***
  // lazy load
  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));

  var selected;
  var subdoc;
  var i;
  var _opts = ***REMOVED*** transform: false, virtuals: false ***REMOVED***;

  if (!Array.isArray(value)) ***REMOVED***
    // gh-2442 mark whole array as modified if we're initializing a doc from
    // the db and the path isn't an array in the document
    if (!!doc && init) ***REMOVED***
      doc.markModified(this.path);
    ***REMOVED***
    return this.cast([value], doc, init, prev);
  ***REMOVED***

  if (!(value && value.isMongooseDocumentArray) &&
      (!options || !options.skipDocumentArrayCast)) ***REMOVED***
    value = new MongooseDocumentArray(value, this.path, doc);
    _clearListeners(prev);
  ***REMOVED*** else if (value && value.isMongooseDocumentArray) ***REMOVED***
    // We need to create a new array, otherwise change tracking will
    // update the old doc (gh-4449)
    value = new MongooseDocumentArray(value, this.path, doc);
  ***REMOVED***

  i = value.length;

  while (i--) ***REMOVED***
    if (!value[i]) ***REMOVED***
      continue;
    ***REMOVED***

    var Constructor = this.casterConstructor;
    if (Constructor.discriminators &&
        Constructor.schema &&
        Constructor.schema.options &&
        typeof value[i][Constructor.schema.options.discriminatorKey] === 'string') ***REMOVED***
      if (Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]]) ***REMOVED***
        Constructor = Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]];
      ***REMOVED*** else ***REMOVED***
        var constructorByValue = getDiscriminatorByValue(Constructor, value[i][Constructor.schema.options.discriminatorKey]);
        if (constructorByValue) ***REMOVED***
          Constructor = constructorByValue;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    // Check if the document has a different schema (re gh-3701)
    if ((value[i].$__) &&
        value[i].schema !== Constructor.schema) ***REMOVED***
      value[i] = value[i].toObject(***REMOVED*** transform: false, virtuals: false ***REMOVED***);
    ***REMOVED***
    if (!(value[i] instanceof Subdocument) && value[i]) ***REMOVED***
      if (init) ***REMOVED***
        if (doc) ***REMOVED***
          selected || (selected = scopePaths(this, doc.$__.selected, init));
        ***REMOVED*** else ***REMOVED***
          selected = true;
        ***REMOVED***

        subdoc = new Constructor(null, value, true, selected, i);
        value[i] = subdoc.init(value[i]);
      ***REMOVED*** else ***REMOVED***
        if (prev && (subdoc = prev.id(value[i]._id))) ***REMOVED***
          subdoc = prev.id(value[i]._id);
        ***REMOVED***

        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) ***REMOVED***
          // handle resetting doc with existing id and same data
          subdoc.set(value[i]);
          // if set() is hooked it will have no return value
          // see gh-746
          value[i] = subdoc;
        ***REMOVED*** else ***REMOVED***
          try ***REMOVED***
            subdoc = new Constructor(value[i], value, undefined,
              undefined, i);
            // if set() is hooked it will have no return value
            // see gh-746
            value[i] = subdoc;
          ***REMOVED*** catch (error) ***REMOVED***
            // Make sure we don't leave listeners dangling because `value`
            // won't get back up to the schema type. See gh-6723
            _clearListeners(value);
            var valueInErrorMessage = util.inspect(value[i]);
            throw new CastError('embedded', valueInErrorMessage,
              value._path, error);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return value;
***REMOVED***;

/*!
 * Removes listeners from parent
 */

function _clearListeners(arr) ***REMOVED***
  if (arr == null || arr._parent == null) ***REMOVED***
    return;
  ***REMOVED***

  for (const key in arr._handlers) ***REMOVED***
    arr._parent.removeListener(key, arr._handlers[key]);
  ***REMOVED***
***REMOVED***

/*!
 * Scopes paths selected in a query to this array.
 * Necessary for proper default application of subdocument values.
 *
 * @param ***REMOVED***DocumentArray***REMOVED*** array - the array to scope `fields` paths
 * @param ***REMOVED***Object|undefined***REMOVED*** fields - the root fields selected in the query
 * @param ***REMOVED***Boolean|undefined***REMOVED*** init - if we are being created part of a query result
 */

function scopePaths(array, fields, init) ***REMOVED***
  if (!(init && fields)) ***REMOVED***
    return undefined;
  ***REMOVED***

  var path = array.path + '.';
  var keys = Object.keys(fields);
  var i = keys.length;
  var selected = ***REMOVED******REMOVED***;
  var hasKeys;
  var key;
  var sub;

  while (i--) ***REMOVED***
    key = keys[i];
    if (key.indexOf(path) === 0) ***REMOVED***
      sub = key.substring(path.length);
      if (sub === '$') ***REMOVED***
        continue;
      ***REMOVED***
      if (sub.indexOf('$.') === 0) ***REMOVED***
        sub = sub.substr(2);
      ***REMOVED***
      hasKeys || (hasKeys = true);
      selected[sub] = fields[key];
    ***REMOVED***
  ***REMOVED***

  return hasKeys && selected || undefined;
***REMOVED***

/*!
 * Module exports.
 */

module.exports = DocumentArray;
