/*!
 * Module requirements.
 */

var MongooseError = require('../error');
var utils = require('../utils');

var SchemaType = require('../schematype');

var CastError = SchemaType.CastError;

/**
 * Date SchemaType constructor.
 *
 * @param ***REMOVED***String***REMOVED*** key
 * @param ***REMOVED***Object***REMOVED*** options
 * @inherits SchemaType
 * @api public
 */

function SchemaDate(key, options) ***REMOVED***
  SchemaType.call(this, key, options, 'Date');
***REMOVED***

/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */
SchemaDate.schemaName = 'Date';

/*!
 * Inherits from SchemaType.
 */
SchemaDate.prototype = Object.create(SchemaType.prototype);
SchemaDate.prototype.constructor = SchemaDate;

/**
 * Declares a TTL index (rounded to the nearest second) for _Date_ types only.
 *
 * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.
 * This index type is only compatible with Date types.
 *
 * ####Example:
 *
 *     // expire in 24 hours
 *     new Schema(***REMOVED*** createdAt: ***REMOVED*** type: Date, expires: 60*60*24 ***REMOVED******REMOVED***);
 *
 * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:
 *
 * ####Example:
 *
 *     // expire in 24 hours
 *     new Schema(***REMOVED*** createdAt: ***REMOVED*** type: Date, expires: '24h' ***REMOVED******REMOVED***);
 *
 *     // expire in 1.5 hours
 *     new Schema(***REMOVED*** createdAt: ***REMOVED*** type: Date, expires: '1.5h' ***REMOVED******REMOVED***);
 *
 *     // expire in 7 days
 *     var schema = new Schema(***REMOVED*** createdAt: Date ***REMOVED***);
 *     schema.path('createdAt').expires('7d');
 *
 * @param ***REMOVED***Number|String***REMOVED*** when
 * @added 3.0.0
 * @return ***REMOVED***SchemaType***REMOVED*** this
 * @api public
 */

SchemaDate.prototype.expires = function(when) ***REMOVED***
  if (!this._index || this._index.constructor.name !== 'Object') ***REMOVED***
    this._index = ***REMOVED******REMOVED***;
  ***REMOVED***

  this._index.expires = when;
  utils.expires(this._index);
  return this;
***REMOVED***;

/**
 * Check if the given value satisfies a required validator. To satisfy
 * a required validator, the given value must be an instance of `Date`.
 *
 * @param ***REMOVED***Any***REMOVED*** value
 * @param ***REMOVED***Document***REMOVED*** doc
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

SchemaDate.prototype.checkRequired = function(value) ***REMOVED***
  return value instanceof Date;
***REMOVED***;

/**
 * Sets a minimum date validator.
 *
 * ####Example:
 *
 *     var s = new Schema(***REMOVED*** d: ***REMOVED*** type: Date, min: Date('1970-01-01') ***REMOVED***)
 *     var M = db.model('M', s)
 *     var m = new M(***REMOVED*** d: Date('1969-12-31') ***REMOVED***)
 *     m.save(function (err) ***REMOVED***
 *       console.error(err) // validator error
 *       m.d = Date('2014-12-08');
 *       m.save() // success
 *     ***REMOVED***)
 *
 *     // custom error messages
 *     // We can also use the special ***REMOVED***MIN***REMOVED*** token which will be replaced with the invalid value
 *     var min = [Date('1970-01-01'), 'The value of path `***REMOVED***PATH***REMOVED***` (***REMOVED***VALUE***REMOVED***) is beneath the limit (***REMOVED***MIN***REMOVED***).'];
 *     var schema = new Schema(***REMOVED*** d: ***REMOVED*** type: Date, min: min ***REMOVED***)
 *     var M = mongoose.model('M', schema);
 *     var s= new M(***REMOVED*** d: Date('1969-12-31') ***REMOVED***);
 *     s.validate(function (err) ***REMOVED***
 *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).
 *     ***REMOVED***)
 *
 * @param ***REMOVED***Date***REMOVED*** value minimum date
 * @param ***REMOVED***String***REMOVED*** [message] optional custom error message
 * @return ***REMOVED***SchemaType***REMOVED*** this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */

SchemaDate.prototype.min = function(value, message) ***REMOVED***
  if (this.minValidator) ***REMOVED***
    this.validators = this.validators.filter(function(v) ***REMOVED***
      return v.validator !== this.minValidator;
    ***REMOVED***, this);
  ***REMOVED***

  if (value) ***REMOVED***
    var msg = message || MongooseError.messages.Date.min;
    msg = msg.replace(/***REMOVED***MIN***REMOVED***/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));
    var _this = this;
    this.validators.push(***REMOVED***
      validator: this.minValidator = function(val) ***REMOVED***
        var min = (value === Date.now ? value() : _this.cast(value));
        return val === null || val.valueOf() >= min.valueOf();
      ***REMOVED***,
      message: msg,
      type: 'min',
      min: value
    ***REMOVED***);
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Sets a maximum date validator.
 *
 * ####Example:
 *
 *     var s = new Schema(***REMOVED*** d: ***REMOVED*** type: Date, max: Date('2014-01-01') ***REMOVED***)
 *     var M = db.model('M', s)
 *     var m = new M(***REMOVED*** d: Date('2014-12-08') ***REMOVED***)
 *     m.save(function (err) ***REMOVED***
 *       console.error(err) // validator error
 *       m.d = Date('2013-12-31');
 *       m.save() // success
 *     ***REMOVED***)
 *
 *     // custom error messages
 *     // We can also use the special ***REMOVED***MAX***REMOVED*** token which will be replaced with the invalid value
 *     var max = [Date('2014-01-01'), 'The value of path `***REMOVED***PATH***REMOVED***` (***REMOVED***VALUE***REMOVED***) exceeds the limit (***REMOVED***MAX***REMOVED***).'];
 *     var schema = new Schema(***REMOVED*** d: ***REMOVED*** type: Date, max: max ***REMOVED***)
 *     var M = mongoose.model('M', schema);
 *     var s= new M(***REMOVED*** d: Date('2014-12-08') ***REMOVED***);
 *     s.validate(function (err) ***REMOVED***
 *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).
 *     ***REMOVED***)
 *
 * @param ***REMOVED***Date***REMOVED*** maximum date
 * @param ***REMOVED***String***REMOVED*** [message] optional custom error message
 * @return ***REMOVED***SchemaType***REMOVED*** this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */

SchemaDate.prototype.max = function(value, message) ***REMOVED***
  if (this.maxValidator) ***REMOVED***
    this.validators = this.validators.filter(function(v) ***REMOVED***
      return v.validator !== this.maxValidator;
    ***REMOVED***, this);
  ***REMOVED***

  if (value) ***REMOVED***
    var msg = message || MongooseError.messages.Date.max;
    msg = msg.replace(/***REMOVED***MAX***REMOVED***/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));
    var _this = this;
    this.validators.push(***REMOVED***
      validator: this.maxValidator = function(val) ***REMOVED***
        var max = (value === Date.now ? value() : _this.cast(value));
        return val === null || val.valueOf() <= max.valueOf();
      ***REMOVED***,
      message: msg,
      type: 'max',
      max: value
    ***REMOVED***);
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Casts to date
 *
 * @param ***REMOVED***Object***REMOVED*** value to cast
 * @api private
 */

SchemaDate.prototype.cast = function(value) ***REMOVED***
  // If null or undefined
  if (value === null || value === void 0 || value === '') ***REMOVED***
    return null;
  ***REMOVED***

  if (value instanceof Date) ***REMOVED***
    if (isNaN(value.valueOf())) ***REMOVED***
      throw new CastError('date', value, this.path);
    ***REMOVED***

    return value;
  ***REMOVED***

  var date;

  if (typeof value === 'boolean') ***REMOVED***
    throw new CastError('date', value, this.path);
  ***REMOVED***

  if (value instanceof Number || typeof value === 'number') ***REMOVED***
    date = new Date(value);
  ***REMOVED*** else if (typeof value.valueOf === 'function') ***REMOVED***
    // support for moment.js. This is also the path strings will take because strings
    // have a `valueOf()`
    date = new Date(value.valueOf());
  ***REMOVED*** else ***REMOVED***
    // fallback
    date = new Date(value);
  ***REMOVED***

  if (!isNaN(date.valueOf())) ***REMOVED***
    return date;
  ***REMOVED***

  throw new CastError('date', value, this.path);
***REMOVED***;

/*!
 * Date Query casting.
 *
 * @api private
 */

function handleSingle(val) ***REMOVED***
  return this.cast(val);
***REMOVED***

SchemaDate.prototype.$conditionalHandlers =
    utils.options(SchemaType.prototype.$conditionalHandlers, ***REMOVED***
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    ***REMOVED***);


/**
 * Casts contents for queries.
 *
 * @param ***REMOVED***String***REMOVED*** $conditional
 * @param ***REMOVED***any***REMOVED*** [value]
 * @api private
 */

SchemaDate.prototype.castForQuery = function($conditional, val) ***REMOVED***
  var handler;

  if (arguments.length !== 2) ***REMOVED***
    return this._castForQuery($conditional);
  ***REMOVED***

  handler = this.$conditionalHandlers[$conditional];

  if (!handler) ***REMOVED***
    throw new Error('Can\'t use ' + $conditional + ' with Date.');
  ***REMOVED***

  return handler.call(this, val);
***REMOVED***;

/*!
 * Module exports.
 */

module.exports = SchemaDate;
