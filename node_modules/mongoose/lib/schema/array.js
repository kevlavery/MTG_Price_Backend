'use strict';

/*!
 * Module dependencies.
 */

var $exists = require('./operators/exists');
var $type = require('./operators/type');
var MongooseError = require('../error/mongooseError');
var SchemaType = require('../schematype');
var CastError = SchemaType.CastError;
var Types = ***REMOVED***
  Array: SchemaArray,
  Boolean: require('./boolean'),
  Date: require('./date'),
  Number: require('./number'),
  String: require('./string'),
  ObjectId: require('./objectid'),
  Buffer: require('./buffer')
***REMOVED***;
var Mixed = require('./mixed');
var cast = require('../cast');
var get = require('lodash.get');
var util = require('util');
var utils = require('../utils');
var castToNumber = require('./operators/helpers').castToNumber;
var geospatial = require('./operators/geospatial');
var getDiscriminatorByValue = require('../queryhelpers').getDiscriminatorByValue;

var MongooseArray;
var EmbeddedDoc;

/**
 * Array SchemaType constructor
 *
 * @param ***REMOVED***String***REMOVED*** key
 * @param ***REMOVED***SchemaType***REMOVED*** cast
 * @param ***REMOVED***Object***REMOVED*** options
 * @inherits SchemaType
 * @api public
 */

function SchemaArray(key, cast, options, schemaOptions) ***REMOVED***
  // lazy load
  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);

  var typeKey = 'type';
  if (schemaOptions && schemaOptions.typeKey) ***REMOVED***
    typeKey = schemaOptions.typeKey;
  ***REMOVED***

  if (cast) ***REMOVED***
    var castOptions = ***REMOVED******REMOVED***;

    if (utils.getFunctionName(cast.constructor) === 'Object') ***REMOVED***
      if (cast[typeKey]) ***REMOVED***
        // support ***REMOVED*** type: Woot ***REMOVED***
        castOptions = utils.clone(cast); // do not alter user arguments
        delete castOptions[typeKey];
        cast = cast[typeKey];
      ***REMOVED*** else ***REMOVED***
        cast = Mixed;
      ***REMOVED***
    ***REMOVED***

    // support ***REMOVED*** type: 'String' ***REMOVED***
    var name = typeof cast === 'string'
      ? cast
      : utils.getFunctionName(cast);

    var caster = name in Types
      ? Types[name]
      : cast;

    this.casterConstructor = caster;

    if (typeof caster === 'function' && !caster.$isArraySubdocument) ***REMOVED***
      this.caster = new caster(null, castOptions);
    ***REMOVED*** else ***REMOVED***
      this.caster = caster;
    ***REMOVED***

    if (!(this.caster instanceof EmbeddedDoc)) ***REMOVED***
      this.caster.path = key;
    ***REMOVED***
  ***REMOVED***

  this.$isMongooseArray = true;

  SchemaType.call(this, key, options, 'Array');

  var defaultArr;
  var fn;

  if (this.defaultValue != null) ***REMOVED***
    defaultArr = this.defaultValue;
    fn = typeof defaultArr === 'function';
  ***REMOVED***

  if (!('defaultValue' in this) || this.defaultValue !== void 0) ***REMOVED***
    var defaultFn = function() ***REMOVED***
      var arr = [];
      if (fn) ***REMOVED***
        arr = defaultArr();
      ***REMOVED*** else if (defaultArr != null) ***REMOVED***
        arr = arr.concat(defaultArr);
      ***REMOVED***
      // Leave it up to `cast()` to convert the array
      return arr;
    ***REMOVED***;
    defaultFn.$runBeforeSetters = true;
    this.default(defaultFn);
  ***REMOVED***
***REMOVED***

/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */
SchemaArray.schemaName = 'Array';

/*!
 * Inherits from SchemaType.
 */
SchemaArray.prototype = Object.create(SchemaType.prototype);
SchemaArray.prototype.constructor = SchemaArray;

/**
 * Adds an enum validator if this is an array of strings. Equivalent to
 * `SchemaString.prototype.enum()`
 *
 * @param ***REMOVED***String|Object***REMOVED*** [args...] enumeration values
 * @return ***REMOVED***SchemaType***REMOVED*** this
 */

SchemaArray.prototype.enum = function() ***REMOVED***
  const instance = get(this, 'caster.instance');
  if (instance !== 'String') ***REMOVED***
    throw new Error('`enum` can only be set on an array of strings, not ' + instance);
  ***REMOVED***
  this.caster.enum.apply(this.caster, arguments);
  return this;
***REMOVED***;

/**
 * Overrides the getters application for the population special-case
 *
 * @param ***REMOVED***Object***REMOVED*** value
 * @param ***REMOVED***Object***REMOVED*** scope
 * @api private
 */

SchemaArray.prototype.applyGetters = function(value, scope) ***REMOVED***
  if (this.caster.options && this.caster.options.ref) ***REMOVED***
    // means the object id was populated
    return value;
  ***REMOVED***

  return SchemaType.prototype.applyGetters.call(this, value, scope);
***REMOVED***;

/**
 * Casts values for set().
 *
 * @param ***REMOVED***Object***REMOVED*** value
 * @param ***REMOVED***Document***REMOVED*** doc document that triggers the casting
 * @param ***REMOVED***Boolean***REMOVED*** init whether this is an initialization cast
 * @api private
 */

SchemaArray.prototype.cast = function(value, doc, init) ***REMOVED***
  // lazy load
  MongooseArray || (MongooseArray = require('../types').Array);

  if (Array.isArray(value)) ***REMOVED***
    if (!value.length && doc) ***REMOVED***
      var indexes = doc.schema.indexedPaths();

      for (var i = 0, l = indexes.length; i < l; ++i) ***REMOVED***
        var pathIndex = indexes[i][0][this.path];
        if (pathIndex === '2dsphere' || pathIndex === '2d') ***REMOVED***
          return;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    if (!(value && value.isMongooseArray)) ***REMOVED***
      value = new MongooseArray(value, this.path, doc);
    ***REMOVED*** else if (value && value.isMongooseArray) ***REMOVED***
      // We need to create a new array, otherwise change tracking will
      // update the old doc (gh-4449)
      value = new MongooseArray(value, this.path, doc);
    ***REMOVED***

    if (this.caster) ***REMOVED***
      try ***REMOVED***
        for (i = 0, l = value.length; i < l; i++) ***REMOVED***
          value[i] = this.caster.cast(value[i], doc, init);
        ***REMOVED***
      ***REMOVED*** catch (e) ***REMOVED***
        // rethrow
        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);
      ***REMOVED***
    ***REMOVED***

    return value;
  ***REMOVED***
  // gh-2442: if we're loading this from the db and its not an array, mark
  // the whole array as modified.
  if (!!doc && !!init) ***REMOVED***
    doc.markModified(this.path);
  ***REMOVED***
  return this.cast([value], doc, init);
***REMOVED***;

/*!
 * Ignore
 */

SchemaArray.prototype.discriminator = function(name, schema) ***REMOVED***
  let arr = this; // eslint-disable-line consistent-this
  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) ***REMOVED***
    arr = arr.casterConstructor;
    if (arr == null || typeof arr === 'function') ***REMOVED***
      throw new MongooseError('You can only add an embedded discriminator on ' +
        'a document array, ' + this.path + ' is a plain array');
    ***REMOVED***
  ***REMOVED***
  return arr.discriminator(name, schema);
***REMOVED***;

/**
 * Casts values for queries.
 *
 * @param ***REMOVED***String***REMOVED*** $conditional
 * @param ***REMOVED***any***REMOVED*** [value]
 * @api private
 */

SchemaArray.prototype.castForQuery = function($conditional, value) ***REMOVED***
  var handler;
  var val;

  if (arguments.length === 2) ***REMOVED***
    handler = this.$conditionalHandlers[$conditional];

    if (!handler) ***REMOVED***
      throw new Error('Can\'t use ' + $conditional + ' with Array.');
    ***REMOVED***

    val = handler.call(this, value);
  ***REMOVED*** else ***REMOVED***
    val = $conditional;
    var Constructor = this.casterConstructor;

    if (val &&
        Constructor.discriminators &&
        Constructor.schema &&
        Constructor.schema.options &&
        Constructor.schema.options.discriminatorKey) ***REMOVED***
      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&
          Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) ***REMOVED***
        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];
      ***REMOVED*** else ***REMOVED***
        var constructorByValue = getDiscriminatorByValue(Constructor, val[Constructor.schema.options.discriminatorKey]);
        if (constructorByValue) ***REMOVED***
          Constructor = constructorByValue;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    var proto = this.casterConstructor.prototype;
    var method = proto && (proto.castForQuery || proto.cast);
    if (!method && Constructor.castForQuery) ***REMOVED***
      method = Constructor.castForQuery;
    ***REMOVED***
    var caster = this.caster;

    if (Array.isArray(val)) ***REMOVED***
      this.setters.reverse().forEach(setter => ***REMOVED***
        val = setter.call(this, val, this);
      ***REMOVED***);
      val = val.map(function(v) ***REMOVED***
        if (utils.isObject(v) && v.$elemMatch) ***REMOVED***
          return v;
        ***REMOVED***
        if (method) ***REMOVED***
          v = method.call(caster, v);
          return v;
        ***REMOVED***
        if (v != null) ***REMOVED***
          v = new Constructor(v);
          return v;
        ***REMOVED***
        return v;
      ***REMOVED***);
    ***REMOVED*** else if (method) ***REMOVED***
      val = method.call(caster, val);
    ***REMOVED*** else if (val != null) ***REMOVED***
      val = new Constructor(val);
    ***REMOVED***
  ***REMOVED***

  return val;
***REMOVED***;

function cast$all(val) ***REMOVED***
  if (!Array.isArray(val)) ***REMOVED***
    val = [val];
  ***REMOVED***

  val = val.map(function(v) ***REMOVED***
    if (utils.isObject(v)) ***REMOVED***
      var o = ***REMOVED******REMOVED***;
      o[this.path] = v;
      return cast(this.casterConstructor.schema, o)[this.path];
    ***REMOVED***
    return v;
  ***REMOVED***, this);

  return this.castForQuery(val);
***REMOVED***

function cast$elemMatch(val) ***REMOVED***
  var keys = Object.keys(val);
  var numKeys = keys.length;
  var key;
  var value;
  for (var i = 0; i < numKeys; ++i) ***REMOVED***
    key = keys[i];
    value = val[key];
    if (key.indexOf('$') === 0 && value) ***REMOVED***
      val[key] = this.castForQuery(key, value);
    ***REMOVED***
  ***REMOVED***

  return cast(this.casterConstructor.schema, val);
***REMOVED***

var handle = SchemaArray.prototype.$conditionalHandlers = ***REMOVED******REMOVED***;

handle.$all = cast$all;
handle.$options = String;
handle.$elemMatch = cast$elemMatch;
handle.$geoIntersects = geospatial.cast$geoIntersects;
handle.$or = handle.$and = function(val) ***REMOVED***
  if (!Array.isArray(val)) ***REMOVED***
    throw new TypeError('conditional $or/$and require array');
  ***REMOVED***

  var ret = [];
  for (var i = 0; i < val.length; ++i) ***REMOVED***
    ret.push(cast(this.casterConstructor.schema, val[i]));
  ***REMOVED***

  return ret;
***REMOVED***;

handle.$near =
handle.$nearSphere = geospatial.cast$near;

handle.$within =
handle.$geoWithin = geospatial.cast$within;

handle.$size =
handle.$minDistance =
handle.$maxDistance = castToNumber;

handle.$exists = $exists;
handle.$type = $type;

handle.$eq =
handle.$gt =
handle.$gte =
handle.$lt =
handle.$lte =
handle.$ne =
handle.$nin =
handle.$regex = SchemaArray.prototype.castForQuery;

// `$in` is special because you can also include an empty array in the query
// like `$in: [1, []]`, see gh-5913
handle.$in = SchemaType.prototype.$conditionalHandlers.$in;

/*!
 * Module exports.
 */

module.exports = SchemaArray;
