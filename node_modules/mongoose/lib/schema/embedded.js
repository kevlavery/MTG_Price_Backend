'use strict';

/*!
 * Module dependencies.
 */

const $exists = require('./operators/exists');
const EventEmitter = require('events').EventEmitter;
const SchemaType = require('../schematype');
const castToNumber = require('./operators/helpers').castToNumber;
const discriminator = require('../services/model/discriminator');
const geospatial = require('./operators/geospatial');
const internalToObjectOptions = require('../options').internalToObjectOptions;
var getDiscriminatorByValue = require('../queryhelpers').getDiscriminatorByValue;

let Subdocument;

module.exports = Embedded;

/**
 * Sub-schema schematype constructor
 *
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @param ***REMOVED***String***REMOVED*** key
 * @param ***REMOVED***Object***REMOVED*** options
 * @inherits SchemaType
 * @api public
 */

function Embedded(schema, path, options) ***REMOVED***
  this.caster = _createConstructor(schema);
  this.caster.prototype.$basePath = path;
  this.schema = schema;
  this.$isSingleNested = true;
  SchemaType.call(this, path, options, 'Embedded');
***REMOVED***

/*!
 * ignore
 */

Embedded.prototype = Object.create(SchemaType.prototype);

/*!
 * ignore
 */

function _createConstructor(schema) ***REMOVED***
  // lazy load
  Subdocument || (Subdocument = require('../types/subdocument'));

  var _embedded = function SingleNested(value, path, parent) ***REMOVED***
    var _this = this;

    this.$parent = parent;
    Subdocument.apply(this, arguments);

    if (parent) ***REMOVED***
      parent.on('save', function() ***REMOVED***
        _this.emit('save', _this);
        _this.constructor.emit('save', _this);
      ***REMOVED***);

      parent.on('isNew', function(val) ***REMOVED***
        _this.isNew = val;
        _this.emit('isNew', val);
        _this.constructor.emit('isNew', val);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***;
  _embedded.prototype = Object.create(Subdocument.prototype);
  _embedded.prototype.$__setSchema(schema);
  _embedded.prototype.constructor = _embedded;
  _embedded.schema = schema;
  _embedded.$isSingleNested = true;
  _embedded.prototype.toBSON = function() ***REMOVED***
    return this.toObject(internalToObjectOptions);
  ***REMOVED***;

  // apply methods
  for (var i in schema.methods) ***REMOVED***
    _embedded.prototype[i] = schema.methods[i];
  ***REMOVED***

  // apply statics
  for (i in schema.statics) ***REMOVED***
    _embedded[i] = schema.statics[i];
  ***REMOVED***

  for (i in EventEmitter.prototype) ***REMOVED***
    _embedded[i] = EventEmitter.prototype[i];
  ***REMOVED***

  return _embedded;
***REMOVED***

/*!
 * Special case for when users use a common location schema to represent
 * locations for use with $geoWithin.
 * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/
 *
 * @param ***REMOVED***Object***REMOVED*** val
 * @api private
 */

Embedded.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) ***REMOVED***
  return ***REMOVED*** $geometry: this.castForQuery(val.$geometry) ***REMOVED***;
***REMOVED***;

/*!
 * ignore
 */

Embedded.prototype.$conditionalHandlers.$near =
Embedded.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;

Embedded.prototype.$conditionalHandlers.$within =
Embedded.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;

Embedded.prototype.$conditionalHandlers.$geoIntersects =
  geospatial.cast$geoIntersects;

Embedded.prototype.$conditionalHandlers.$minDistance = castToNumber;
Embedded.prototype.$conditionalHandlers.$maxDistance = castToNumber;

Embedded.prototype.$conditionalHandlers.$exists = $exists;

/**
 * Casts contents
 *
 * @param ***REMOVED***Object***REMOVED*** value
 * @api private
 */

Embedded.prototype.cast = function(val, doc, init, priorVal) ***REMOVED***
  if (val && val.$isSingleNested) ***REMOVED***
    return val;
  ***REMOVED***

  var Constructor = this.caster;
  var discriminatorKey = Constructor.schema.options.discriminatorKey;
  if (val != null &&
      Constructor.discriminators &&
      typeof val[discriminatorKey] === 'string') ***REMOVED***
    if (Constructor.discriminators[val[discriminatorKey]]) ***REMOVED***
      Constructor = Constructor.discriminators[val[discriminatorKey]];
    ***REMOVED*** else ***REMOVED***
      var constructorByValue = getDiscriminatorByValue(Constructor, val[discriminatorKey]);
      if (constructorByValue) ***REMOVED***
        Constructor = constructorByValue;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  var subdoc;
  if (init) ***REMOVED***
    subdoc = new Constructor(void 0, doc ? doc.$__.selected : void 0, doc);
    subdoc.init(val);
  ***REMOVED*** else ***REMOVED***
    if (Object.keys(val).length === 0) ***REMOVED***
      return new Constructor(***REMOVED******REMOVED***, doc ? doc.$__.selected : void 0, doc);
    ***REMOVED***

    return new Constructor(val, doc ? doc.$__.selected : void 0, doc, undefined, ***REMOVED***
      priorDoc: priorVal
    ***REMOVED***);
  ***REMOVED***

  return subdoc;
***REMOVED***;

/**
 * Casts contents for query
 *
 * @param ***REMOVED***string***REMOVED*** [$conditional] optional query operator (like `$eq` or `$in`)
 * @param ***REMOVED***any***REMOVED*** value
 * @api private
 */

Embedded.prototype.castForQuery = function($conditional, val) ***REMOVED***
  var handler;
  if (arguments.length === 2) ***REMOVED***
    handler = this.$conditionalHandlers[$conditional];
    if (!handler) ***REMOVED***
      throw new Error('Can\'t use ' + $conditional);
    ***REMOVED***
    return handler.call(this, val);
  ***REMOVED***
  val = $conditional;
  if (val == null) ***REMOVED***
    return val;
  ***REMOVED***

  if (this.options.runSetters) ***REMOVED***
    val = this._applySetters(val);
  ***REMOVED***

  var Constructor = this.caster;
  var discriminatorKey = Constructor.schema.options.discriminatorKey;
  if (val != null &&
      Constructor.discriminators &&
      typeof val[discriminatorKey] === 'string') ***REMOVED***
    if (Constructor.discriminators[val[discriminatorKey]]) ***REMOVED***
      Constructor = Constructor.discriminators[val[discriminatorKey]];
    ***REMOVED*** else ***REMOVED***
      var constructorByValue = getDiscriminatorByValue(Constructor, val[discriminatorKey]);
      if (constructorByValue) ***REMOVED***
        Constructor = constructorByValue;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return new Constructor(val);
***REMOVED***;

/**
 * Async validation on this single nested doc.
 *
 * @api private
 */

Embedded.prototype.doValidate = function(value, fn, scope, options) ***REMOVED***
  var Constructor = this.caster;
  var discriminatorKey = Constructor.schema.options.discriminatorKey;
  if (value != null &&
      Constructor.discriminators &&
      typeof value[discriminatorKey] === 'string') ***REMOVED***
    if (Constructor.discriminators[value[discriminatorKey]]) ***REMOVED***
      Constructor = Constructor.discriminators[value[discriminatorKey]];
    ***REMOVED*** else ***REMOVED***
      var constructorByValue = getDiscriminatorByValue(Constructor, value[discriminatorKey]);
      if (constructorByValue) ***REMOVED***
        Constructor = constructorByValue;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  if (options && options.skipSchemaValidators) ***REMOVED***
    if (!(value instanceof Constructor)) ***REMOVED***
      value = new Constructor(value, null, scope);
    ***REMOVED***

    return value.validate(fn);
  ***REMOVED***

  SchemaType.prototype.doValidate.call(this, value, function(error) ***REMOVED***
    if (error) ***REMOVED***
      return fn(error);
    ***REMOVED***
    if (!value) ***REMOVED***
      return fn(null);
    ***REMOVED***

    value.validate(fn);
  ***REMOVED***, scope);
***REMOVED***;

/**
 * Synchronously validate this single nested doc
 *
 * @api private
 */

Embedded.prototype.doValidateSync = function(value, scope, options) ***REMOVED***
  if (!options || !options.skipSchemaValidators) ***REMOVED***
    var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
    if (schemaTypeError) ***REMOVED***
      return schemaTypeError;
    ***REMOVED***
  ***REMOVED***
  if (!value) ***REMOVED***
    return;
  ***REMOVED***
  return value.validateSync();
***REMOVED***;

/**
 * Adds a discriminator to this property
 *
 * @param ***REMOVED***String***REMOVED*** name
 * @param ***REMOVED***Schema***REMOVED*** schema fields to add to the schema for instances of this sub-class
 * @api public
 */

Embedded.prototype.discriminator = function(name, schema) ***REMOVED***
  discriminator(this.caster, name, schema);

  this.caster.discriminators[name] = _createConstructor(schema);

  return this.caster.discriminators[name];
***REMOVED***;
