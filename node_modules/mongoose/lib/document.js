'use strict';

/*!
 * Module dependencies.
 */

const EventEmitter = require('events').EventEmitter;
const InternalCache = require('./internal');
const MongooseError = require('./error');
const MixedSchema = require('./schema/mixed');
const Schema = require('./schema');
const ObjectExpectedError = require('./error/objectExpected');
const ObjectParameterError = require('./error/objectParameter');
const StrictModeError = require('./error/strict');
const ValidatorError = require('./schematype').ValidatorError;
const VirtualType = require('./virtualtype');
const cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');
const compile = require('./helpers/document/compile').compile;
const defineKey = require('./helpers/document/compile').defineKey;
const flatten = require('./helpers/common').flatten;
const get = require('lodash.get');
const getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');
const idGetter = require('./plugins/idGetter');
const isDefiningProjection = require('./helpers/projection/isDefiningProjection');
const isExclusive = require('./helpers/projection/isExclusive');
const inspect = require('util').inspect;
const internalToObjectOptions = require('./options').internalToObjectOptions;
const mpath = require('mpath');
const utils = require('./utils');

const ValidationError = MongooseError.ValidationError;
const clone = utils.clone;
const deepEqual = utils.deepEqual;
const isMongooseObject = utils.isMongooseObject;

let DocumentArray;
let MongooseArray;
let Embedded;

/**
 * Document constructor.
 *
 * @param ***REMOVED***Object***REMOVED*** obj the values to set
 * @param ***REMOVED***Object***REMOVED*** [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
 * @param ***REMOVED***Boolean***REMOVED*** [skipId] bool, should we auto create an ObjectId _id
 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
 * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.
 * @event `save`: Emitted when the document is successfully saved
 * @api private
 */

function Document(obj, fields, skipId, options) ***REMOVED***
  if (typeof skipId === 'object' && skipId != null) ***REMOVED***
    options = skipId;
    skipId = options.skipId;
  ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = 'isNew' in options ? options.isNew : true;
  this.errors = undefined;
  this.$__.$options = options || ***REMOVED******REMOVED***;

  if (obj != null && typeof obj !== 'object') ***REMOVED***
    throw new ObjectParameterError(obj, 'obj', 'Document');
  ***REMOVED***

  var schema = this.schema;

  if (typeof fields === 'boolean') ***REMOVED***
    this.$__.strictMode = fields;
    fields = undefined;
  ***REMOVED*** else ***REMOVED***
    this.$__.strictMode = schema.options && schema.options.strict;
    this.$__.selected = fields;
  ***REMOVED***

  var required = schema.requiredPaths(true);
  for (var i = 0; i < required.length; ++i) ***REMOVED***
    this.$__.activePaths.require(required[i]);
  ***REMOVED***

  this.$__.emitter.setMaxListeners(0);

  let exclude = null;

  // determine if this doc is a result of a query with
  // excluded fields
  if (fields && utils.getFunctionName(fields.constructor) === 'Object') ***REMOVED***
    exclude = isExclusive(fields);
  ***REMOVED***

  let hasIncludedChildren = exclude === false && fields ?
    $__hasIncludedChildren(fields) :
    ***REMOVED******REMOVED***;

  this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);

  // By default, defaults get applied **before** setting initial values
  // Re: gh-6155
  $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true);

  if (obj) ***REMOVED***
    if (obj instanceof Document) ***REMOVED***
      this.isNew = obj.isNew;
    ***REMOVED***
    // Skip set hooks
    if (this.$__original_set) ***REMOVED***
      this.$__original_set(obj, undefined, true);
    ***REMOVED*** else ***REMOVED***
      this.$set(obj, undefined, true);
    ***REMOVED***
  ***REMOVED***

  // Function defaults get applied **after** setting initial values so they
  // see the full doc rather than an empty one, unless they opt out.
  // Re: gh-3781, gh-6155
  $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults);

  this.$__._id = this._id;

  if (!schema.options.strict && obj) ***REMOVED***
    var _this = this,
        keys = Object.keys(this._doc);

    keys.forEach(function(key) ***REMOVED***
      if (!(key in schema.tree)) ***REMOVED***
        defineKey(key, null, _this);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  applyQueue(this);
***REMOVED***

/*!
 * Document exposes the NodeJS event emitter API, so you can use
 * `on`, `once`, etc.
 */
utils.each(
  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',
    'removeAllListeners', 'addListener'],
  function(emitterFn) ***REMOVED***
    Document.prototype[emitterFn] = function() ***REMOVED***
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    ***REMOVED***;
  ***REMOVED***);

Document.prototype.constructor = Document;

/**
 * The documents schema.
 *
 * @api public
 * @property schema
 * @memberOf Document
 * @instance
 */

Document.prototype.schema;

/**
 * Boolean flag specifying if the document is new.
 *
 * @api public
 * @property isNew
 * @memberOf Document
 * @instance
 */

Document.prototype.isNew;

/**
 * The string version of this documents _id.
 *
 * ####Note:
 *
 * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.
 *
 *     new Schema(***REMOVED*** name: String ***REMOVED***, ***REMOVED*** id: false ***REMOVED***);
 *
 * @api public
 * @see Schema options /docs/guide.html#options
 * @property id
 * @memberOf Document
 * @instance
 */

Document.prototype.id;

/**
 * Hash containing current validation errors.
 *
 * @api public
 * @property errors
 * @memberOf Document
 * @instance
 */

Document.prototype.errors;

/*!
 * ignore
 */

function $__hasIncludedChildren(fields) ***REMOVED***
  let hasIncludedChildren = ***REMOVED******REMOVED***;
  let keys = Object.keys(fields);
  for (var j = 0; j < keys.length; ++j) ***REMOVED***
    let parts = keys[j].split('.');
    let c = [];
    for (var k = 0; k < parts.length; ++k) ***REMOVED***
      c.push(parts[k]);
      hasIncludedChildren[c.join('.')] = 1;
    ***REMOVED***
  ***REMOVED***

  return hasIncludedChildren;
***REMOVED***

/*!
 * ignore
 */

function $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) ***REMOVED***
  const paths = Object.keys(doc.schema.paths);
  const plen = paths.length;

  for (let i = 0; i < plen; ++i) ***REMOVED***
    let def;
    let curPath = '';
    let p = paths[i];

    if (p === '_id' && skipId) ***REMOVED***
      continue;
    ***REMOVED***

    let type = doc.schema.paths[p];
    let path = p.split('.');
    let len = path.length;
    let included = false;
    let doc_ = doc._doc;

    for (let j = 0; j < len; ++j) ***REMOVED***
      if (doc_ == null) ***REMOVED***
        break;
      ***REMOVED***

      let piece = path[j];
      curPath += (!curPath.length ? '' : '.') + piece;

      if (exclude === true) ***REMOVED***
        if (curPath in fields) ***REMOVED***
          break;
        ***REMOVED***
      ***REMOVED*** else if (exclude === false && fields && !included) ***REMOVED***
        if (curPath in fields) ***REMOVED***
          included = true;
        ***REMOVED*** else if (!hasIncludedChildren[curPath]) ***REMOVED***
          break;
        ***REMOVED***
      ***REMOVED***

      if (j === len - 1) ***REMOVED***
        if (doc_[piece] !== void 0) ***REMOVED***
          break;
        ***REMOVED***

        if (typeof type.defaultValue === 'function') ***REMOVED***
          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) ***REMOVED***
            break;
          ***REMOVED***
          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) ***REMOVED***
            break;
          ***REMOVED***
        ***REMOVED*** else if (!isBeforeSetters) ***REMOVED***
          // Non-function defaults should always run **before** setters
          continue;
        ***REMOVED***

        if (pathsToSkip && pathsToSkip[curPath]) ***REMOVED***
          break;
        ***REMOVED***

        if (fields && exclude !== null) ***REMOVED***
          if (exclude === true) ***REMOVED***
            // apply defaults to all non-excluded fields
            if (p in fields) ***REMOVED***
              continue;
            ***REMOVED***

            def = type.getDefault(doc, false);
            if (typeof def !== 'undefined') ***REMOVED***
              doc_[piece] = def;
              doc.$__.activePaths.default(p);
            ***REMOVED***
          ***REMOVED*** else if (included) ***REMOVED***
            // selected field
            def = type.getDefault(doc, false);
            if (typeof def !== 'undefined') ***REMOVED***
              doc_[piece] = def;
              doc.$__.activePaths.default(p);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          def = type.getDefault(doc, false);
          if (typeof def !== 'undefined') ***REMOVED***
            doc_[piece] = def;
            doc.$__.activePaths.default(p);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        doc_ = doc_[piece];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Builds the default doc structure
 *
 * @param ***REMOVED***Object***REMOVED*** obj
 * @param ***REMOVED***Object***REMOVED*** [fields]
 * @param ***REMOVED***Boolean***REMOVED*** [skipId]
 * @api private
 * @method $__buildDoc
 * @memberOf Document
 * @instance
 */

Document.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) ***REMOVED***
  const doc = ***REMOVED******REMOVED***;

  const paths = Object.keys(this.schema.paths).
    // Don't build up any paths that are underneath a map, we don't know
    // what the keys will be
    filter(p => !p.includes('$*'));
  const plen = paths.length;
  let ii = 0;

  for (; ii < plen; ++ii) ***REMOVED***
    var p = paths[ii];

    if (p === '_id') ***REMOVED***
      if (skipId) ***REMOVED***
        continue;
      ***REMOVED***
      if (obj && '_id' in obj) ***REMOVED***
        continue;
      ***REMOVED***
    ***REMOVED***

    const path = p.split('.');
    const len = path.length;
    const last = len - 1;
    let curPath = '';
    let doc_ = doc;
    let included = false;

    for (let i = 0; i < len; ++i) ***REMOVED***
      const piece = path[i];

      curPath += (!curPath.length ? '' : '.') + piece;

      // support excluding intermediary levels
      if (exclude === true) ***REMOVED***
        if (curPath in fields) ***REMOVED***
          break;
        ***REMOVED***
      ***REMOVED*** else if (exclude === false && fields && !included) ***REMOVED***
        if (curPath in fields) ***REMOVED***
          included = true;
        ***REMOVED*** else if (!hasIncludedChildren[curPath]) ***REMOVED***
          break;
        ***REMOVED***
      ***REMOVED***

      if (i < last) ***REMOVED***
        doc_ = doc_[piece] || (doc_[piece] = ***REMOVED******REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  this._doc = doc;
***REMOVED***;

/*!
 * Converts to POJO when you use the document for querying
 */

Document.prototype.toBSON = function() ***REMOVED***
  return this.toObject(internalToObjectOptions);
***REMOVED***;

/**
 * Initializes the document without setters or marking anything modified.
 *
 * Called internally after a document is returned from mongodb. Normally,
 * you do **not** need to call this function on your own.
 *
 * This function triggers `init` [middleware](/docs/middleware.html).
 * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).
 *
 * @param ***REMOVED***Object***REMOVED*** doc document returned by mongo
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.init = function(doc, opts, fn) ***REMOVED***
  if (typeof opts === 'function') ***REMOVED***
    fn = opts;
    opts = null;
  ***REMOVED***

  this.$__init(doc, opts);

  if (fn) ***REMOVED***
    fn(null, this);
  ***REMOVED***

  return this;
***REMOVED***;

/*!
 * ignore
 */

Document.prototype.$__init = function(doc, opts) ***REMOVED***
  this.isNew = false;
  this.$init = true;

  // handle docs with populated paths
  // If doc._id is not null or undefined
  if (doc._id !== null && doc._id !== undefined &&
    opts && opts.populated && opts.populated.length) ***REMOVED***
    var id = String(doc._id);
    for (var i = 0; i < opts.populated.length; ++i) ***REMOVED***
      var item = opts.populated[i];
      if (item.isVirtual) ***REMOVED***
        this.populated(item.path, utils.getValue(item.path, doc), item);
      ***REMOVED*** else ***REMOVED***
        this.populated(item.path, item._docs[id], item);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  init(this, doc, this._doc);

  this.emit('init', this);
  this.constructor.emit('init', this);

  this.$__._id = this._id;

  return this;
***REMOVED***;

/*!
 * Init helper.
 *
 * @param ***REMOVED***Object***REMOVED*** self document instance
 * @param ***REMOVED***Object***REMOVED*** obj raw mongodb doc
 * @param ***REMOVED***Object***REMOVED*** doc object we are initializing
 * @api private
 */

function init(self, obj, doc, prefix) ***REMOVED***
  prefix = prefix || '';

  var keys = Object.keys(obj);
  var len = keys.length;
  var schema;
  var path;
  var i;
  var index = 0;

  while (index < len) ***REMOVED***
    _init(index++);
  ***REMOVED***

  function _init(index) ***REMOVED***
    i = keys[index];
    path = prefix + i;
    schema = self.schema.path(path);

    // Should still work if not a model-level discriminator, but should not be
    // necessary. This is *only* to catch the case where we queried using the
    // base model and the discriminated model has a projection
    if (self.schema.$isRootDiscriminator && !self.isSelected(path)) ***REMOVED***
      return;
    ***REMOVED***

    if (!schema && utils.isObject(obj[i]) &&
        (!obj[i].constructor || utils.getFunctionName(obj[i].constructor) === 'Object')) ***REMOVED***
      // assume nested object
      if (!doc[i]) ***REMOVED***
        doc[i] = ***REMOVED******REMOVED***;
      ***REMOVED***
      init(self, obj[i], doc[i], path + '.');
    ***REMOVED*** else if (!schema) ***REMOVED***
      doc[i] = obj[i];
    ***REMOVED*** else ***REMOVED***
      if (obj[i] === null) ***REMOVED***
        doc[i] = null;
      ***REMOVED*** else if (obj[i] !== undefined) ***REMOVED***
        let intCache = obj[i].$__ || ***REMOVED******REMOVED***;
        let wasPopulated = intCache.wasPopulated || null;
        if (schema && !wasPopulated) ***REMOVED***
          try ***REMOVED***
            doc[i] = schema.cast(obj[i], self, true);
          ***REMOVED*** catch (e) ***REMOVED***
            self.invalidate(e.path, new ValidatorError(***REMOVED***
              path: e.path,
              message: e.message,
              type: 'cast',
              value: e.value
            ***REMOVED***));
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          doc[i] = obj[i];
        ***REMOVED***
      ***REMOVED***
      // mark as hydrated
      if (!self.isModified(path)) ***REMOVED***
        self.$__.activePaths.init(path);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Sends an update command with this document `_id` as the query selector.
 *
 * ####Example:
 *
 *     weirdCar.update(***REMOVED***$inc: ***REMOVED***wheels:1***REMOVED******REMOVED***, ***REMOVED*** w: 1 ***REMOVED***, callback);
 *
 * ####Valid options:
 *
 *  - same as in [Model.update](#model_Model.update)
 *
 * @see Model.update #model_Model.update
 * @param ***REMOVED***Object***REMOVED*** doc
 * @param ***REMOVED***Object***REMOVED*** options
 * @param ***REMOVED***Function***REMOVED*** callback
 * @return ***REMOVED***Query***REMOVED***
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.update = function update() ***REMOVED***
  var args = utils.args(arguments);
  args.unshift(***REMOVED***_id: this._id***REMOVED***);
  return this.constructor.update.apply(this.constructor, args);
***REMOVED***;

/**
 * Getter/setter around the session associated with this document. Used to
 * automatically set `session` if you `save()` a doc that you got from a
 * query with an associated session.
 *
 * @param ***REMOVED***ClientSession***REMOVED*** [session] overwrite the current session
 * @return ***REMOVED***ClientSession***REMOVED***
 * @method $session
 * @api public
 * @memberOf Document
 */

Document.prototype.$session = function $session(session) ***REMOVED***
  if (arguments.length === 0) ***REMOVED***
    return this.$__.session;
  ***REMOVED***
  this.$__.session = session;
  return session;
***REMOVED***;

/**
 * Alias for `set()`, used internally to avoid conflicts
 *
 * @param ***REMOVED***String|Object***REMOVED*** path path or object of key/vals to set
 * @param ***REMOVED***Any***REMOVED*** val the value to set
 * @param ***REMOVED***Schema|String|Number|Buffer|****REMOVED*** [type] optionally specify a type for "on-the-fly" attributes
 * @param ***REMOVED***Object***REMOVED*** [options] optionally specify options that modify the behavior of the set
 * @method $set
 * @name $set
 * @memberOf Document
 * @instance
 * @api public
 */

Document.prototype.$set = function $set(path, val, type, options) ***REMOVED***
  if (type && utils.getFunctionName(type.constructor) === 'Object') ***REMOVED***
    options = type;
    type = undefined;
  ***REMOVED***

  options = options || ***REMOVED******REMOVED***;
  var merge = options.merge;
  var adhoc = type && type !== true;
  var constructing = type === true;
  var adhocs;

  var strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) ***REMOVED***
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = ***REMOVED******REMOVED***);
    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);
  ***REMOVED***

  if (typeof path !== 'string') ***REMOVED***
    // new Document(***REMOVED*** key: val ***REMOVED***)
    if (path === null || path === void 0) ***REMOVED***
      var _ = path;
      path = val;
      val = _;
    ***REMOVED*** else ***REMOVED***
      var prefix = val ? val + '.' : '';

      if (path instanceof Document) ***REMOVED***
        if (path.$__isNested) ***REMOVED***
          path = path.toObject();
        ***REMOVED*** else ***REMOVED***
          path = path._doc;
        ***REMOVED***
      ***REMOVED***

      var keys = Object.keys(path);
      var len = keys.length;
      var i = 0;
      var pathtype;
      var key;

      if (len === 0 && !this.schema.options.minimize) ***REMOVED***
        if (val) ***REMOVED***
          this.$set(val, ***REMOVED******REMOVED***);
        ***REMOVED***
        return this;
      ***REMOVED***

      while (i < len) ***REMOVED***
        _handleIndex.call(this, i++);
      ***REMOVED***

      return this;
    ***REMOVED***
  ***REMOVED***

  function _handleIndex(i) ***REMOVED***
    key = keys[i];
    var pathName = prefix + key;
    pathtype = this.schema.pathType(pathName);

    if (path[key] !== null &&
        path[key] !== void 0 &&
        // need to know if plain object - no Buffer, ObjectId, ref, etc
        utils.isObject(path[key]) &&
        (!path[key].constructor || utils.getFunctionName(path[key].constructor) === 'Object') &&
        pathtype !== 'virtual' &&
        pathtype !== 'real' &&
        !(this.$__path(pathName) instanceof MixedSchema) &&
        !(this.schema.paths[pathName] &&
        this.schema.paths[pathName].options &&
        this.schema.paths[pathName].options.ref)) ***REMOVED***
      this.$set(path[key], prefix + key, constructing);
    ***REMOVED*** else if (strict) ***REMOVED***
      // Don't overwrite defaults with undefined keys (gh-3981)
      if (constructing && path[key] === void 0 &&
          this.get(key) !== void 0) ***REMOVED***
        return;
      ***REMOVED***

      if (pathtype === 'adhocOrUndefined') ***REMOVED***
        pathtype = getEmbeddedDiscriminatorPath(this, pathName, ***REMOVED*** typeOnly: true ***REMOVED***);
      ***REMOVED***

      if (pathtype === 'real' || pathtype === 'virtual') ***REMOVED***
        // Check for setting single embedded schema to document (gh-3535)
        var p = path[key];
        if (this.schema.paths[pathName] &&
            this.schema.paths[pathName].$isSingleNested &&
            path[key] instanceof Document) ***REMOVED***
          p = p.toObject(***REMOVED*** virtuals: false, transform: false ***REMOVED***);
        ***REMOVED***
        this.$set(prefix + key, p, constructing);
      ***REMOVED*** else if (pathtype === 'nested' && path[key] instanceof Document) ***REMOVED***
        this.$set(prefix + key,
          path[key].toObject(***REMOVED***transform: false***REMOVED***), constructing);
      ***REMOVED*** else if (strict === 'throw') ***REMOVED***
        if (pathtype === 'nested') ***REMOVED***
          throw new ObjectExpectedError(key, path[key]);
        ***REMOVED*** else ***REMOVED***
          throw new StrictModeError(key);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else if (path[key] !== void 0) ***REMOVED***
      this.$set(prefix + key, path[key], constructing);
    ***REMOVED***
  ***REMOVED***

  var pathType = this.schema.pathType(path);
  if (pathType === 'nested' && val) ***REMOVED***
    if (utils.isObject(val) &&
        (!val.constructor || utils.getFunctionName(val.constructor) === 'Object')) ***REMOVED***
      if (!merge) ***REMOVED***
        this.setValue(path, null);
        cleanModifiedSubpaths(this, path);
      ***REMOVED*** else ***REMOVED***
        return this.$set(val, path, constructing);
      ***REMOVED***

      const keys = Object.keys(val);
      this.setValue(path, ***REMOVED******REMOVED***);
      for (const key of keys) ***REMOVED***
        this.$set(path + '.' + key, val[key], constructing);
      ***REMOVED***
      this.markModified(path);
      cleanModifiedSubpaths(this, path, ***REMOVED*** skipDocArrays: true ***REMOVED***);
      return this;
    ***REMOVED***
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  ***REMOVED***

  var schema;
  var parts = path.split('.');

  if (pathType === 'adhocOrUndefined' && strict) ***REMOVED***
    // check for roots that are Mixed types
    var mixed;

    for (i = 0; i < parts.length; ++i) ***REMOVED***
      var subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') ***REMOVED***
        mpath.set(path, val, this);
        return this;
      ***REMOVED***

      schema = this.schema.path(subpath);
      if (schema == null) ***REMOVED***
        continue;
      ***REMOVED***

      if (schema instanceof MixedSchema) ***REMOVED***
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
      ***REMOVED***
    ***REMOVED***

    if (schema == null) ***REMOVED***
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    ***REMOVED***

    if (!mixed && !schema) ***REMOVED***
      if (strict === 'throw') ***REMOVED***
        throw new StrictModeError(path);
      ***REMOVED***
      return this;
    ***REMOVED***
  ***REMOVED*** else if (pathType === 'virtual') ***REMOVED***
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  ***REMOVED*** else ***REMOVED***
    schema = this.$__path(path);
  ***REMOVED***

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  var cur = this._doc;
  var curPath = '';
  for (i = 0; i < parts.length - 1; ++i) ***REMOVED***
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) ***REMOVED***
      this.$set(curPath, ***REMOVED******REMOVED***);
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
      // traverse the element (***REMOVED***nested: null***REMOVED***)` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.isSelected(curPath)) ***REMOVED***
        this.unmarkModified(curPath);
      ***REMOVED***
      cur = this.getValue(curPath);
    ***REMOVED***
  ***REMOVED***

  var pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) ***REMOVED***
    pathToMark = path;
  ***REMOVED*** else ***REMOVED***
    for (i = 0; i < parts.length; ++i) ***REMOVED***
      subpath = parts.slice(0, i + 1).join('.');
      if (this.isDirectModified(subpath) // earlier prefixes that are already
      // marked as dirty have precedence
          || this.get(subpath) === null) ***REMOVED***
        pathToMark = subpath;
        break;
      ***REMOVED***
    ***REMOVED***

    if (!pathToMark) ***REMOVED***
      pathToMark = path;
    ***REMOVED***
  ***REMOVED***

  // if this doc is being constructed we should not trigger getters
  var priorVal = constructing ?
    undefined :
    this.getValue(path);

  if (!schema) ***REMOVED***
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  ***REMOVED***

  var shouldSet = true;
  try ***REMOVED***
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    var didPopulate = false;
    if (schema.options &&
        schema.options.ref &&
        val instanceof Document &&
        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) ***REMOVED***
      if (this.ownerDocument) ***REMOVED***
        this.ownerDocument().populated(this.$__fullPath(path),
          val._id, ***REMOVED***model: val.constructor***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        this.populated(path, val._id, ***REMOVED***model: val.constructor***REMOVED***);
      ***REMOVED***
      didPopulate = true;
    ***REMOVED***

    var popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] instanceof Document &&
        val[0].constructor.modelName &&
        (schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.baseModelName || schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.modelName)) ***REMOVED***
      if (this.ownerDocument) ***REMOVED***
        popOpts = ***REMOVED*** model: val[0].constructor ***REMOVED***;
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) ***REMOVED*** return v._id; ***REMOVED***), popOpts);
      ***REMOVED*** else ***REMOVED***
        popOpts = ***REMOVED*** model: val[0].constructor ***REMOVED***;
        this.populated(path, val.map(function(v) ***REMOVED*** return v._id; ***REMOVED***), popOpts);
      ***REMOVED***
      didPopulate = true;
    ***REMOVED***

    var setterContext = constructing && this.$__.$options.priorDoc ?
      this.$__.$options.priorDoc :
      this;
    val = schema.applySetters(val, setterContext, false, priorVal);

    if (!didPopulate && this.$__.populated) ***REMOVED***
      delete this.$__.populated[path];
    ***REMOVED***

    this.$markValid(path);
  ***REMOVED*** catch (e) ***REMOVED***
    this.invalidate(path,
      new MongooseError.CastError(schema.instance, val, path, e));
    shouldSet = false;
  ***REMOVED***

  if (shouldSet) ***REMOVED***
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
  ***REMOVED***

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) ***REMOVED***
    cleanModifiedSubpaths(this, path);
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Sets the value of a path, or many paths.
 *
 * ####Example:
 *
 *     // path, value
 *     doc.set(path, value)
 *
 *     // object
 *     doc.set(***REMOVED***
 *         path  : value
 *       , path2 : ***REMOVED***
 *            path  : value
 *         ***REMOVED***
 *     ***REMOVED***)
 *
 *     // on-the-fly cast to number
 *     doc.set(path, value, Number)
 *
 *     // on-the-fly cast to string
 *     doc.set(path, value, String)
 *
 *     // changing strict mode behavior
 *     doc.set(path, value, ***REMOVED*** strict: false ***REMOVED***);
 *
 * @param ***REMOVED***String|Object***REMOVED*** path path or object of key/vals to set
 * @param ***REMOVED***Any***REMOVED*** val the value to set
 * @param ***REMOVED***Schema|String|Number|Buffer|****REMOVED*** [type] optionally specify a type for "on-the-fly" attributes
 * @param ***REMOVED***Object***REMOVED*** [options] optionally specify options that modify the behavior of the set
 * @api public
 * @method set
 * @memberOf Document
 * @instance
 */

Document.prototype.set = Document.prototype.$set;

/**
 * Determine if we should mark this change as modified.
 *
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 * @method $__shouldModify
 * @memberOf Document
 * @instance
 */

Document.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) ***REMOVED***
  if (this.isNew) ***REMOVED***
    return true;
  ***REMOVED***

  if (undefined === val && !this.isSelected(path)) ***REMOVED***
    // when a path is not selected in a query, its initial
    // value will be undefined.
    return true;
  ***REMOVED***

  if (undefined === val && path in this.$__.activePaths.states.default) ***REMOVED***
    // we're just unsetting the default value which was never saved
    return false;
  ***REMOVED***

  // gh-3992: if setting a populated field to a doc, don't mark modified
  // if they have the same _id
  if (this.populated(path) &&
      val instanceof Document &&
      deepEqual(val._id, priorVal)) ***REMOVED***
    return false;
  ***REMOVED***

  if (!deepEqual(val, priorVal || this.get(path))) ***REMOVED***
    return true;
  ***REMOVED***

  if (!constructing &&
      val !== null &&
      val !== undefined &&
      path in this.$__.activePaths.states.default &&
      deepEqual(val, schema.getDefault(this, constructing))) ***REMOVED***
    // a path with a default was $unset on the server
    // and the user is setting it to the same value again
    return true;
  ***REMOVED***
  return false;
***REMOVED***;

/**
 * Handles the actual setting of the value and marking the path modified if appropriate.
 *
 * @api private
 * @method $__set
 * @memberOf Document
 * @instance
 */

Document.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) ***REMOVED***
  Embedded = Embedded || require('./types/embedded');

  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,
    schema, val, priorVal);
  var _this = this;

  if (shouldModify) ***REMOVED***
    this.markModified(pathToMark);

    // handle directly setting arrays (gh-1126)
    MongooseArray || (MongooseArray = require('./types/array'));
    if (val && val.isMongooseArray) ***REMOVED***
      val._registerAtomic('$set', val);

      // Update embedded document parent references (gh-5189)
      if (val.isMongooseDocumentArray) ***REMOVED***
        val.forEach(function(item) ***REMOVED***
          item && item.__parentArray && (item.__parentArray = val);
        ***REMOVED***);
      ***REMOVED***

      // Small hack for gh-1638: if we're overwriting the entire array, ignore
      // paths that were modified before the array overwrite
      this.$__.activePaths.forEach(function(modifiedPath) ***REMOVED***
        if (modifiedPath.indexOf(path + '.') === 0) ***REMOVED***
          _this.$__.activePaths.ignore(modifiedPath);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  var obj = this._doc;
  var i = 0;
  var l = parts.length;
  var cur = '';

  for (; i < l; i++) ***REMOVED***
    var next = i + 1;
    var last = next === l;
    cur += (cur ? '.' + parts[i] : parts[i]);

    if (last) ***REMOVED***
      if (obj instanceof Map) ***REMOVED***
        obj.set(parts[i], val);
      ***REMOVED*** else ***REMOVED***
        obj[parts[i]] = val;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === 'Object') ***REMOVED***
        obj = obj[parts[i]];
      ***REMOVED*** else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) ***REMOVED***
        obj = obj[parts[i]];
      ***REMOVED*** else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) ***REMOVED***
        obj = obj[parts[i]];
      ***REMOVED*** else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) ***REMOVED***
        obj = obj[parts[i]];
      ***REMOVED*** else ***REMOVED***
        obj[parts[i]] = obj[parts[i]] || ***REMOVED******REMOVED***;
        obj = obj[parts[i]];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Gets a raw value from a path (no getters)
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @api private
 */

Document.prototype.getValue = function(path) ***REMOVED***
  return utils.getValue(path, this._doc);
***REMOVED***;

/**
 * Sets a raw value for a path (no casting, setters, transformations)
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @param ***REMOVED***Object***REMOVED*** value
 * @api private
 */

Document.prototype.setValue = function(path, val) ***REMOVED***
  utils.setValue(path, val, this._doc);
  return this;
***REMOVED***;

/**
 * Returns the value of a path.
 *
 * ####Example
 *
 *     // path
 *     doc.get('age') // 47
 *
 *     // dynamic casting to a string
 *     doc.get('age', String) // "47"
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @param ***REMOVED***Schema|String|Number|Buffer|****REMOVED*** [type] optionally specify a type for on-the-fly attributes
 * @api public
 */

Document.prototype.get = function(path, type, options) ***REMOVED***
  var adhoc;
  options = options || ***REMOVED******REMOVED***;
  if (type) ***REMOVED***
    adhoc = Schema.interpretAsType(path, type, this.schema.options);
  ***REMOVED***

  var schema = this.$__path(path) || this.schema.virtualpath(path);
  var pieces = path.split('.');
  var obj = this._doc;

  if (schema instanceof VirtualType) ***REMOVED***
    if (schema.getters.length === 0) ***REMOVED***
      return void 0;
    ***REMOVED***
    return schema.applyGetters(null, this);
  ***REMOVED***

  for (var i = 0, l = pieces.length; i < l; i++) ***REMOVED***
    if (obj == null) ***REMOVED***
      obj = void 0;
    ***REMOVED*** else if (obj instanceof Map) ***REMOVED***
      obj = obj.get(pieces[i]);
    ***REMOVED*** else ***REMOVED***
      obj = obj[pieces[i]];
    ***REMOVED***
  ***REMOVED***

  if (adhoc) ***REMOVED***
    obj = adhoc.cast(obj);
  ***REMOVED***

  if (schema) ***REMOVED***
    obj = schema.applyGetters(obj, this);
  ***REMOVED*** else if (this.schema.nested[path] && options.virtuals) ***REMOVED***
    // Might need to apply virtuals if this is a nested path
    return applyGetters(this, utils.clone(obj), 'virtuals', ***REMOVED*** path: path ***REMOVED***);
  ***REMOVED***

  return obj;
***REMOVED***;

/**
 * Returns the schematype for the given `path`.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @api private
 * @method $__path
 * @memberOf Document
 * @instance
 */

Document.prototype.$__path = function(path) ***REMOVED***
  var adhocs = this.$__.adhocPaths,
      adhocType = adhocs && adhocs[path];

  if (adhocType) ***REMOVED***
    return adhocType;
  ***REMOVED***
  return this.schema.path(path);
***REMOVED***;

/**
 * Marks the path as having pending changes to write to the db.
 *
 * _Very helpful when using [Mixed](./schematypes.html#mixed) types._
 *
 * ####Example:
 *
 *     doc.mixed.type = 'changed';
 *     doc.markModified('mixed.type');
 *     doc.save() // changes to mixed.type are now persisted
 *
 * @param ***REMOVED***String***REMOVED*** path the path to mark modified
 * @param ***REMOVED***Document***REMOVED*** [scope] the scope to run validators with
 * @api public
 */

Document.prototype.markModified = function(path, scope) ***REMOVED***
  this.$__.activePaths.modify(path);
  if (scope != null && !this.ownerDocument) ***REMOVED***
    this.$__.pathsToScopes[path] = scope;
  ***REMOVED***
***REMOVED***;

/**
 * Clears the modified state on the specified path.
 *
 * ####Example:
 *
 *     doc.foo = 'bar';
 *     doc.unmarkModified('foo');
 *     doc.save() // changes to foo will not be persisted
 *
 * @param ***REMOVED***String***REMOVED*** path the path to unmark modified
 * @api public
 */

Document.prototype.unmarkModified = function(path) ***REMOVED***
  this.$__.activePaths.init(path);
  delete this.$__.pathsToScopes[path];
***REMOVED***;

/**
 * Don't run validation on this path or persist changes to this path.
 *
 * ####Example:
 *
 *     doc.foo = null;
 *     doc.$ignore('foo');
 *     doc.save() // changes to foo will not be persisted and validators won't be run
 *
 * @memberOf Document
 * @instance
 * @method $ignore
 * @param ***REMOVED***String***REMOVED*** path the path to ignore
 * @api public
 */

Document.prototype.$ignore = function(path) ***REMOVED***
  this.$__.activePaths.ignore(path);
***REMOVED***;

/**
 * Returns the list of paths that have been modified.
 *
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @param ***REMOVED***Boolean***REMOVED*** [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = ***REMOVED*** primary: 'blue' ***REMOVED***;` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.
 * @return ***REMOVED***Array***REMOVED***
 * @api public
 */

Document.prototype.modifiedPaths = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
  var _this = this;
  return directModifiedPaths.reduce(function(list, path) ***REMOVED***
    var parts = path.split('.');
    list = list.concat(parts.reduce(function(chains, part, i) ***REMOVED***
      return chains.concat(parts.slice(0, i).concat(part).join('.'));
    ***REMOVED***, []).filter(function(chain) ***REMOVED***
      return (list.indexOf(chain) === -1);
    ***REMOVED***));

    if (!options.includeChildren) ***REMOVED***
      return list;
    ***REMOVED***

    var cur = _this.get(path);
    if (cur != null && typeof cur === 'object') ***REMOVED***
      if (cur._doc) ***REMOVED***
        cur = cur._doc;
      ***REMOVED***
      if (Array.isArray(cur)) ***REMOVED***
        const len = cur.length;
        for (let i = 0; i < len; ++i) ***REMOVED***
          if (list.indexOf(path + '.' + i) === -1) ***REMOVED***
            list.push(path + '.' + i);
            if (cur[i] != null && cur[i].$__) ***REMOVED***
              const modified = cur[i].modifiedPaths();
              for (const childPath of modified) ***REMOVED***
                list.push(path + '.' + i + '.' + childPath);
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        Object.keys(cur).
          filter(function(key) ***REMOVED***
            return list.indexOf(path + '.' + key) === -1;
          ***REMOVED***).
          forEach(function(key) ***REMOVED***
            list.push(path + '.' + key);
          ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    return list;
  ***REMOVED***, []);
***REMOVED***;

/**
 * Returns true if this document was modified, else false.
 *
 * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.
 *
 * ####Example
 *
 *     doc.set('documents.0.title', 'changed');
 *     doc.isModified()                      // true
 *     doc.isModified('documents')           // true
 *     doc.isModified('documents.0.title')   // true
 *     doc.isModified('documents otherProp') // true
 *     doc.isDirectModified('documents')     // false
 *
 * @param ***REMOVED***String***REMOVED*** [path] optional
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Document.prototype.isModified = function(paths, modifiedPaths) ***REMOVED***
  if (paths) ***REMOVED***
    if (!Array.isArray(paths)) ***REMOVED***
      paths = paths.split(' ');
    ***REMOVED***
    var modified = modifiedPaths || this.modifiedPaths();
    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
    var isModifiedChild = paths.some(function(path) ***REMOVED***
      return !!~modified.indexOf(path);
    ***REMOVED***);
    return isModifiedChild || paths.some(function(path) ***REMOVED***
      return directModifiedPaths.some(function(mod) ***REMOVED***
        return mod === path || path.indexOf(mod + '.') === 0;
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***
  return this.$__.activePaths.some('modify');
***REMOVED***;

/**
 * Checks if a path is set to its default.
 *
 * ####Example
 *
 *     MyModel = mongoose.model('test', ***REMOVED*** name: ***REMOVED*** type: String, default: 'Val '***REMOVED*** ***REMOVED***);
 *     var m = new MyModel();
 *     m.$isDefault('name'); // true
 *
 * @memberOf Document
 * @instance
 * @method $isDefault
 * @param ***REMOVED***String***REMOVED*** [path]
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Document.prototype.$isDefault = function(path) ***REMOVED***
  return (path in this.$__.activePaths.states.default);
***REMOVED***;

/**
 * Getter/setter, determines whether the document was removed or not.
 *
 * ####Example:
 *     product.remove(function (err, product) ***REMOVED***
 *       product.isDeleted(); // true
 *       product.remove(); // no-op, doesn't send anything to the db
 *
 *       product.isDeleted(false);
 *       product.isDeleted(); // false
 *       product.remove(); // will execute a remove against the db
 *     ***REMOVED***)
 *
 * @param ***REMOVED***Boolean***REMOVED*** [val] optional, overrides whether mongoose thinks the doc is deleted
 * @return ***REMOVED***Boolean***REMOVED*** whether mongoose thinks this doc is deleted.
 * @method $isDeleted
 * @memberOf Document
 * @instance
 * @api public
 */

Document.prototype.$isDeleted = function(val) ***REMOVED***
  if (arguments.length === 0) ***REMOVED***
    return !!this.$__.isDeleted;
  ***REMOVED***

  this.$__.isDeleted = !!val;
  return this;
***REMOVED***;

/**
 * Returns true if `path` was directly set and modified, else false.
 *
 * ####Example
 *
 *     doc.set('documents.0.title', 'changed');
 *     doc.isDirectModified('documents.0.title') // true
 *     doc.isDirectModified('documents') // false
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Document.prototype.isDirectModified = function(path) ***REMOVED***
  return (path in this.$__.activePaths.states.modify);
***REMOVED***;

/**
 * Checks if `path` was initialized.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Document.prototype.isInit = function(path) ***REMOVED***
  return (path in this.$__.activePaths.states.init);
***REMOVED***;

/**
 * Checks if `path` was selected in the source query which initialized this document.
 *
 * ####Example
 *
 *     Thing.findOne().select('name').exec(function (err, doc) ***REMOVED***
 *        doc.isSelected('name') // true
 *        doc.isSelected('age')  // false
 *     ***REMOVED***)
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Document.prototype.isSelected = function isSelected(path) ***REMOVED***
  if (this.$__.selected) ***REMOVED***
    if (path === '_id') ***REMOVED***
      return this.$__.selected._id !== 0;
    ***REMOVED***

    var paths = Object.keys(this.$__.selected);
    var i = paths.length;
    var inclusive = null;
    var cur;

    if (i === 1 && paths[0] === '_id') ***REMOVED***
      // only _id was selected.
      return this.$__.selected._id === 0;
    ***REMOVED***

    while (i--) ***REMOVED***
      cur = paths[i];
      if (cur === '_id') ***REMOVED***
        continue;
      ***REMOVED***
      if (!isDefiningProjection(this.$__.selected[cur])) ***REMOVED***
        continue;
      ***REMOVED***
      inclusive = !!this.$__.selected[cur];
      break;
    ***REMOVED***

    if (inclusive === null) ***REMOVED***
      return true;
    ***REMOVED***

    if (path in this.$__.selected) ***REMOVED***
      return inclusive;
    ***REMOVED***

    i = paths.length;
    var pathDot = path + '.';

    while (i--) ***REMOVED***
      cur = paths[i];
      if (cur === '_id') ***REMOVED***
        continue;
      ***REMOVED***

      if (cur.indexOf(pathDot) === 0) ***REMOVED***
        return inclusive || cur !== pathDot;
      ***REMOVED***

      if (pathDot.indexOf(cur + '.') === 0) ***REMOVED***
        return inclusive;
      ***REMOVED***
    ***REMOVED***

    return !inclusive;
  ***REMOVED***

  return true;
***REMOVED***;

/**
 * Checks if `path` was explicitly selected. If no projection, always returns
 * true.
 *
 * ####Example
 *
 *     Thing.findOne().select('nested.name').exec(function (err, doc) ***REMOVED***
 *        doc.isDirectSelected('nested.name') // true
 *        doc.isDirectSelected('nested.otherName') // false
 *        doc.isDirectSelected('nested')  // false
 *     ***REMOVED***)
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Document.prototype.isDirectSelected = function isDirectSelected(path) ***REMOVED***
  if (this.$__.selected) ***REMOVED***
    if (path === '_id') ***REMOVED***
      return this.$__.selected._id !== 0;
    ***REMOVED***

    var paths = Object.keys(this.$__.selected);
    var i = paths.length;
    var inclusive = null;
    var cur;

    if (i === 1 && paths[0] === '_id') ***REMOVED***
      // only _id was selected.
      return this.$__.selected._id === 0;
    ***REMOVED***

    while (i--) ***REMOVED***
      cur = paths[i];
      if (cur === '_id') ***REMOVED***
        continue;
      ***REMOVED***
      if (!isDefiningProjection(this.$__.selected[cur])) ***REMOVED***
        continue;
      ***REMOVED***
      inclusive = !!this.$__.selected[cur];
      break;
    ***REMOVED***

    if (inclusive === null) ***REMOVED***
      return true;
    ***REMOVED***

    if (path in this.$__.selected) ***REMOVED***
      return inclusive;
    ***REMOVED***

    return !inclusive;
  ***REMOVED***

  return true;
***REMOVED***;

/**
 * Executes registered validation rules for this document.
 *
 * ####Note:
 *
 * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.
 *
 * ####Example:
 *
 *     doc.validate(function (err) ***REMOVED***
 *       if (err) handleError(err);
 *       else // validation passed
 *     ***REMOVED***);
 *
 * @param ***REMOVED***Object***REMOVED*** optional options internal options
 * @param ***REMOVED***Function***REMOVED*** callback optional callback called after validation completes, passing an error if one occurred
 * @return ***REMOVED***Promise***REMOVED*** Promise
 * @api public
 */

Document.prototype.validate = function(options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    callback = options;
    options = null;
  ***REMOVED***

  return utils.promiseOrCallback(callback, cb => this.$__validate(function(error) ***REMOVED***
    cb(error);
  ***REMOVED***));
***REMOVED***;

/*!
 * ignore
 */

function _getPathsToValidate(doc) ***REMOVED***
  var i;
  var len;
  var skipSchemaValidators = ***REMOVED******REMOVED***;

  // only validate required fields when necessary
  var paths = Object.keys(doc.$__.activePaths.states.require).filter(function(path) ***REMOVED***
    if (!doc.isSelected(path) && !doc.isModified(path)) ***REMOVED***
      return false;
    ***REMOVED***
    var p = doc.schema.path(path);
    if (typeof p.originalRequiredValue === 'function') ***REMOVED***
      return p.originalRequiredValue.call(doc);
    ***REMOVED***
    return true;
  ***REMOVED***);

  paths = paths.concat(Object.keys(doc.$__.activePaths.states.init));
  paths = paths.concat(Object.keys(doc.$__.activePaths.states.modify));
  paths = paths.concat(Object.keys(doc.$__.activePaths.states.default));

  if (!doc.ownerDocument) ***REMOVED***
    var subdocs = doc.$__getAllSubdocs();
    var subdoc;
    len = subdocs.length;
    var modifiedPaths = doc.modifiedPaths();
    for (i = 0; i < len; ++i) ***REMOVED***
      subdoc = subdocs[i];
      if (doc.isModified(subdoc.$basePath, modifiedPaths) &&
          !doc.isDirectModified(subdoc.$basePath)) ***REMOVED***
        // Remove child paths for now, because we'll be validating the whole
        // subdoc
        paths = paths.filter(function(p) ***REMOVED***
          return p != null && p.indexOf(subdoc.$basePath + '.') !== 0;
        ***REMOVED***);
        paths.push(subdoc.$basePath);
        skipSchemaValidators[subdoc.$basePath] = true;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // gh-661: if a whole array is modified, make sure to run validation on all
  // the children as well
  len = paths.length;
  for (i = 0; i < len; ++i) ***REMOVED***
    var path = paths[i];

    var _pathType = doc.schema.path(path);
    if (!_pathType ||
        !_pathType.$isMongooseArray ||
        // To avoid potential performance issues, skip doc arrays whose children
        // are not required. `getPositionalPathType()` may be slow, so avoid
        // it unless we have a case of #6364
        (_pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required'))) ***REMOVED***
      continue;
    ***REMOVED***

    var val = doc.getValue(path);
    if (val) ***REMOVED***
      var numElements = val.length;
      for (var j = 0; j < numElements; ++j) ***REMOVED***
        paths.push(path + '.' + j);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  var flattenOptions = ***REMOVED*** skipArrays: true ***REMOVED***;
  len = paths.length;
  for (i = 0; i < len; ++i) ***REMOVED***
    var pathToCheck = paths[i];
    if (doc.schema.nested[pathToCheck]) ***REMOVED***
      var _v = doc.getValue(pathToCheck);
      if (isMongooseObject(_v)) ***REMOVED***
        _v = _v.toObject(***REMOVED*** transform: false ***REMOVED***);
      ***REMOVED***
      var flat = flatten(_v, '', flattenOptions);
      var _subpaths = Object.keys(flat).map(function(p) ***REMOVED***
        return pathToCheck + '.' + p;
      ***REMOVED***);
      paths = paths.concat(_subpaths);
    ***REMOVED***
  ***REMOVED***

  len = paths.length;
  for (i = 0; i < len; ++i) ***REMOVED***
    const path = paths[i];
    const _pathType = doc.schema.path(path);
    if (!_pathType || !_pathType.$isSchemaMap) ***REMOVED***
      continue;
    ***REMOVED***

    const val = doc.getValue(path);
    if (val == null) ***REMOVED***
      continue;
    ***REMOVED***
    for (let key of val.keys()) ***REMOVED***
      paths.push(path + '.' + key);
    ***REMOVED***
  ***REMOVED***

  return [paths, skipSchemaValidators];
***REMOVED***

/*!
 * ignore
 */

Document.prototype.$__validate = function(callback) ***REMOVED***
  const _this = this;
  const _complete = function() ***REMOVED***
    var err = _this.$__.validationError;
    _this.$__.validationError = undefined;
    _this.emit('validate', _this);
    _this.constructor.emit('validate', _this);
    if (err) ***REMOVED***
      for (var key in err.errors) ***REMOVED***
        // Make sure cast errors persist
        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) ***REMOVED***
          _this.invalidate(key, err.errors[key]);
        ***REMOVED***
      ***REMOVED***

      return err;
    ***REMOVED***
  ***REMOVED***;

  // only validate required fields when necessary
  const pathDetails = _getPathsToValidate(this);
  const paths = pathDetails[0];
  const skipSchemaValidators = pathDetails[1];

  if (paths.length === 0) ***REMOVED***
    return process.nextTick(function() ***REMOVED***
      const error = _complete();
      if (error) ***REMOVED***
        return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], ***REMOVED*** error: error ***REMOVED***, function(error) ***REMOVED***
          callback(error);
        ***REMOVED***);
      ***REMOVED***
      callback(null, _this);
    ***REMOVED***);
  ***REMOVED***

  const validated = ***REMOVED******REMOVED***;
  let total = 0;

  var complete = function() ***REMOVED***
    const error = _complete();
    if (error) ***REMOVED***
      return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], ***REMOVED*** error: error ***REMOVED***, function(error) ***REMOVED***
        callback(error);
      ***REMOVED***);
    ***REMOVED***
    callback(null, _this);
  ***REMOVED***;

  var validatePath = function(path) ***REMOVED***
    if (path == null || validated[path]) ***REMOVED***
      return;
    ***REMOVED***

    validated[path] = true;
    total++;

    process.nextTick(function() ***REMOVED***
      const p = _this.schema.path(path);

      if (!p) ***REMOVED***
        return --total || complete();
      ***REMOVED***

      // If user marked as invalid or there was a cast error, don't validate
      if (!_this.$isValid(path)) ***REMOVED***
        --total || complete();
        return;
      ***REMOVED***

      const val = _this.getValue(path);
      const scope = path in _this.$__.pathsToScopes ?
        _this.$__.pathsToScopes[path] :
        _this;

      p.doValidate(val, function(err) ***REMOVED***
        if (err) ***REMOVED***
          _this.invalidate(path, err, undefined, true);
        ***REMOVED***
        --total || complete();
      ***REMOVED***, scope, ***REMOVED*** skipSchemaValidators: skipSchemaValidators[path] ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***;

  const numPaths = paths.length;
  for (let i = 0; i < numPaths; ++i) ***REMOVED***
    validatePath(paths[i]);
  ***REMOVED***
***REMOVED***;

/**
 * Executes registered validation rules (skipping asynchronous validators) for this document.
 *
 * ####Note:
 *
 * This method is useful if you need synchronous validation.
 *
 * ####Example:
 *
 *     var err = doc.validateSync();
 *     if ( err )***REMOVED***
 *       handleError( err );
 *     ***REMOVED*** else ***REMOVED***
 *       // validation passed
 *     ***REMOVED***
 *
 * @param ***REMOVED***Array|string***REMOVED*** pathsToValidate only validate the given paths
 * @return ***REMOVED***MongooseError|undefined***REMOVED*** MongooseError if there are errors during validation, or undefined if there is no error.
 * @api public
 */

Document.prototype.validateSync = function(pathsToValidate) ***REMOVED***
  const _this = this;

  if (typeof pathsToValidate === 'string') ***REMOVED***
    pathsToValidate = pathsToValidate.split(' ');
  ***REMOVED***

  // only validate required fields when necessary
  const pathDetails = _getPathsToValidate(this);
  let paths = pathDetails[0];
  const skipSchemaValidators = pathDetails[1];

  if (pathsToValidate && pathsToValidate.length) ***REMOVED***
    var tmp = [];
    for (var i = 0; i < paths.length; ++i) ***REMOVED***
      if (pathsToValidate.indexOf(paths[i]) !== -1) ***REMOVED***
        tmp.push(paths[i]);
      ***REMOVED***
    ***REMOVED***
    paths = tmp;
  ***REMOVED***

  var validating = ***REMOVED******REMOVED***;

  paths.forEach(function(path) ***REMOVED***
    if (validating[path]) ***REMOVED***
      return;
    ***REMOVED***

    validating[path] = true;

    var p = _this.schema.path(path);
    if (!p) ***REMOVED***
      return;
    ***REMOVED***
    if (!_this.$isValid(path)) ***REMOVED***
      return;
    ***REMOVED***

    var val = _this.getValue(path);
    var err = p.doValidateSync(val, _this, ***REMOVED***
      skipSchemaValidators: skipSchemaValidators[path]
    ***REMOVED***);
    if (err) ***REMOVED***
      _this.invalidate(path, err, undefined, true);
    ***REMOVED***
  ***REMOVED***);

  var err = _this.$__.validationError;
  _this.$__.validationError = undefined;
  _this.emit('validate', _this);
  _this.constructor.emit('validate', _this);

  if (err) ***REMOVED***
    for (var key in err.errors) ***REMOVED***
      // Make sure cast errors persist
      if (err.errors[key] instanceof MongooseError.CastError) ***REMOVED***
        _this.invalidate(key, err.errors[key]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return err;
***REMOVED***;

/**
 * Marks a path as invalid, causing validation to fail.
 *
 * The `errorMsg` argument will become the message of the `ValidationError`.
 *
 * The `value` argument (if passed) will be available through the `ValidationError.value` property.
 *
 *     doc.invalidate('size', 'must be less than 20', 14);

 *     doc.validate(function (err) ***REMOVED***
 *       console.log(err)
 *       // prints
 *       ***REMOVED*** message: 'Validation failed',
 *         name: 'ValidationError',
 *         errors:
 *          ***REMOVED*** size:
 *             ***REMOVED*** message: 'must be less than 20',
 *               name: 'ValidatorError',
 *               path: 'size',
 *               type: 'user defined',
 *               value: 14 ***REMOVED*** ***REMOVED*** ***REMOVED***
 *     ***REMOVED***)
 *
 * @param ***REMOVED***String***REMOVED*** path the field to invalidate
 * @param ***REMOVED***String|Error***REMOVED*** errorMsg the error which states the reason `path` was invalid
 * @param ***REMOVED***Object|String|Number|any***REMOVED*** value optional invalid value
 * @param ***REMOVED***String***REMOVED*** [kind] optional `kind` property for the error
 * @return ***REMOVED***ValidationError***REMOVED*** the current ValidationError, with all currently invalidated paths
 * @api public
 */

Document.prototype.invalidate = function(path, err, val, kind) ***REMOVED***
  if (!this.$__.validationError) ***REMOVED***
    this.$__.validationError = new ValidationError(this);
  ***REMOVED***

  if (this.$__.validationError.errors[path]) ***REMOVED***
    return;
  ***REMOVED***

  if (!err || typeof err === 'string') ***REMOVED***
    err = new ValidatorError(***REMOVED***
      path: path,
      message: err,
      type: kind || 'user defined',
      value: val
    ***REMOVED***);
  ***REMOVED***

  if (this.$__.validationError === err) ***REMOVED***
    return this.$__.validationError;
  ***REMOVED***

  this.$__.validationError.addError(path, err);
  return this.$__.validationError;
***REMOVED***;

/**
 * Marks a path as valid, removing existing validation errors.
 *
 * @param ***REMOVED***String***REMOVED*** path the field to mark as valid
 * @api public
 * @memberOf Document
 * @instance
 * @method $markValid
 */

Document.prototype.$markValid = function(path) ***REMOVED***
  if (!this.$__.validationError || !this.$__.validationError.errors[path]) ***REMOVED***
    return;
  ***REMOVED***

  delete this.$__.validationError.errors[path];
  if (Object.keys(this.$__.validationError.errors).length === 0) ***REMOVED***
    this.$__.validationError = null;
  ***REMOVED***
***REMOVED***;

/**
 * Saves this document.
 *
 * ####Example:
 *
 *     product.sold = Date.now();
 *     product.save(function (err, product) ***REMOVED***
 *       if (err) ..
 *     ***REMOVED***)
 *
 * The callback will receive three parameters
 *
 * 1. `err` if an error occurred
 * 2. `product` which is the saved `product`
 *
 * As an extra measure of flow control, save will return a Promise.
 * ####Example:
 *     product.save().then(function(product) ***REMOVED***
 *        ...
 *     ***REMOVED***);
 *
 * @param ***REMOVED***Object***REMOVED*** [options] options optional options
 * @param ***REMOVED***Object***REMOVED*** [options.safe] overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe)
 * @param ***REMOVED***Boolean***REMOVED*** [options.validateBeforeSave] set to false to save without validating.
 * @param ***REMOVED***Function***REMOVED*** [fn] optional callback
 * @method save
 * @memberOf Document
 * @instance
 * @return ***REMOVED***Promise|undefined***REMOVED*** Returns undefined if used with callback or a Promise otherwise.
 * @api public
 * @see middleware http://mongoosejs.com/docs/middleware.html
 */

/**
 * Checks if a path is invalid
 *
 * @param ***REMOVED***String***REMOVED*** path the field to check
 * @method $isValid
 * @memberOf Document
 * @instance
 * @api private
 */

Document.prototype.$isValid = function(path) ***REMOVED***
  return !this.$__.validationError || !this.$__.validationError.errors[path];
***REMOVED***;

/**
 * Resets the internal modified state of this document.
 *
 * @api private
 * @return ***REMOVED***Document***REMOVED***
 * @method $__reset
 * @memberOf Document
 * @instance
 */

Document.prototype.$__reset = function reset() ***REMOVED***
  var _this = this;
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  this.$__.activePaths
    .map('init', 'modify', function(i) ***REMOVED***
      return _this.getValue(i);
    ***REMOVED***)
    .filter(function(val) ***REMOVED***
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    ***REMOVED***)
    .forEach(function(array) ***REMOVED***
      var i = array.length;
      while (i--) ***REMOVED***
        var doc = array[i];
        if (!doc) ***REMOVED***
          continue;
        ***REMOVED***
        doc.$__reset();
      ***REMOVED***
    ***REMOVED***);

  this.$__.activePaths.
    map('init', 'modify', function(i) ***REMOVED***
      return _this.getValue(i);
    ***REMOVED***).
    filter(function(val) ***REMOVED***
      return val && val.$isSingleNested;
    ***REMOVED***).
    forEach(function(doc) ***REMOVED***
      doc.$__reset();
    ***REMOVED***);

  // clear atomics
  this.$__dirty().forEach(function(dirt) ***REMOVED***
    var type = dirt.value;
    if (type && type._atomics) ***REMOVED***
      type._atomics = ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***);

  // Clear 'dirty' cache
  this.$__.activePaths.clear('modify');
  this.$__.activePaths.clear('default');
  this.$__.validationError = undefined;
  this.errors = undefined;
  _this = this;
  this.schema.requiredPaths().forEach(function(path) ***REMOVED***
    _this.$__.activePaths.require(path);
  ***REMOVED***);

  return this;
***REMOVED***;

/**
 * Returns this documents dirty paths / vals.
 *
 * @api private
 * @method $__dirty
 * @memberOf Document
 * @instance
 */

Document.prototype.$__dirty = function() ***REMOVED***
  var _this = this;

  var all = this.$__.activePaths.map('modify', function(path) ***REMOVED***
    return ***REMOVED***
      path: path,
      value: _this.getValue(path),
      schema: _this.$__path(path)
    ***REMOVED***;
  ***REMOVED***);

  // gh-2558: if we had to set a default and the value is not undefined,
  // we have to save as well
  all = all.concat(this.$__.activePaths.map('default', function(path) ***REMOVED***
    if (path === '_id' || _this.getValue(path) == null) ***REMOVED***
      return;
    ***REMOVED***
    return ***REMOVED***
      path: path,
      value: _this.getValue(path),
      schema: _this.$__path(path)
    ***REMOVED***;
  ***REMOVED***));

  // Sort dirty paths in a flat hierarchy.
  all.sort(function(a, b) ***REMOVED***
    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));
  ***REMOVED***);

  // Ignore "foo.a" if "foo" is dirty already.
  var minimal = [],
      lastPath,
      top;

  all.forEach(function(item) ***REMOVED***
    if (!item) ***REMOVED***
      return;
    ***REMOVED***
    if (item.path.indexOf(lastPath) !== 0) ***REMOVED***
      lastPath = item.path + '.';
      minimal.push(item);
      top = item;
    ***REMOVED*** else ***REMOVED***
      // special case for top level MongooseArrays
      if (top.value && top.value._atomics && top.value.hasAtomics()) ***REMOVED***
        // the `top` array itself and a sub path of `top` are being modified.
        // the only way to honor all of both modifications is through a $set
        // of entire array.
        top.value._atomics = ***REMOVED******REMOVED***;
        top.value._atomics.$set = top.value;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);

  top = lastPath = null;
  return minimal;
***REMOVED***;

/**
 * Assigns/compiles `schema` into this documents prototype.
 *
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @api private
 * @method $__setSchema
 * @memberOf Document
 * @instance
 */

Document.prototype.$__setSchema = function(schema) ***REMOVED***
  schema.plugin(idGetter, ***REMOVED*** deduplicate: true ***REMOVED***);
  compile(schema.tree, this, undefined, schema.options);

  // Apply default getters if virtual doesn't have any (gh-6262)
  for (const key of Object.keys(schema.virtuals)) ***REMOVED***
    schema.virtuals[key]._applyDefaultGetters();
  ***REMOVED***

  this.schema = schema;
***REMOVED***;


/**
 * Get active path that were changed and are arrays
 *
 * @api private
 * @method $__getArrayPathsToValidate
 * @memberOf Document
 * @instance
 */

Document.prototype.$__getArrayPathsToValidate = function() ***REMOVED***
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  // validate all document arrays.
  return this.$__.activePaths
    .map('init', 'modify', function(i) ***REMOVED***
      return this.getValue(i);
    ***REMOVED***.bind(this))
    .filter(function(val) ***REMOVED***
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    ***REMOVED***).reduce(function(seed, array) ***REMOVED***
      return seed.concat(array);
    ***REMOVED***, [])
    .filter(function(doc) ***REMOVED***
      return doc;
    ***REMOVED***);
***REMOVED***;


/**
 * Get all subdocs (by bfs)
 *
 * @api private
 * @method $__getAllSubdocs
 * @memberOf Document
 * @instance
 */

Document.prototype.$__getAllSubdocs = function() ***REMOVED***
  DocumentArray || (DocumentArray = require('./types/documentarray'));
  Embedded = Embedded || require('./types/embedded');

  function docReducer(doc, seed, path) ***REMOVED***
    var val = doc[path];

    if (val instanceof Embedded) ***REMOVED***
      seed.push(val);
    ***REMOVED***
    if (val && val.$isSingleNested) ***REMOVED***
      seed = Object.keys(val._doc).reduce(function(seed, path) ***REMOVED***
        return docReducer(val._doc, seed, path);
      ***REMOVED***, seed);
      seed.push(val);
    ***REMOVED***
    if (val && val.isMongooseDocumentArray) ***REMOVED***
      val.forEach(function _docReduce(doc) ***REMOVED***
        if (!doc || !doc._doc) ***REMOVED***
          return;
        ***REMOVED***
        if (doc instanceof Embedded) ***REMOVED***
          seed.push(doc);
        ***REMOVED***
        seed = Object.keys(doc._doc).reduce(function(seed, path) ***REMOVED***
          return docReducer(doc._doc, seed, path);
        ***REMOVED***, seed);
      ***REMOVED***);
    ***REMOVED*** else if (val instanceof Document && val.$__isNested) ***REMOVED***
      if (val) ***REMOVED***
        seed = Object.keys(val).reduce(function(seed, path) ***REMOVED***
          return docReducer(val, seed, path);
        ***REMOVED***, seed);
      ***REMOVED***
    ***REMOVED***
    return seed;
  ***REMOVED***

  var _this = this;
  var subDocs = Object.keys(this._doc).reduce(function(seed, path) ***REMOVED***
    return docReducer(_this, seed, path);
  ***REMOVED***, []);

  return subDocs;
***REMOVED***;

/*!
 * Runs queued functions
 */

function applyQueue(doc) ***REMOVED***
  var q = doc.schema && doc.schema.callQueue;
  if (!q.length) ***REMOVED***
    return;
  ***REMOVED***
  var pair;

  for (var i = 0; i < q.length; ++i) ***REMOVED***
    pair = q[i];
    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') ***REMOVED***
      doc[pair[0]].apply(doc, pair[1]);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/*!
 * ignore
 */

Document.prototype.$__handleReject = function handleReject(err) ***REMOVED***
  // emit on the Model if listening
  if (this.listeners('error').length) ***REMOVED***
    this.emit('error', err);
  ***REMOVED*** else if (this.constructor.listeners && this.constructor.listeners('error').length) ***REMOVED***
    this.constructor.emit('error', err);
  ***REMOVED*** else if (this.listeners && this.listeners('error').length) ***REMOVED***
    this.emit('error', err);
  ***REMOVED***
***REMOVED***;

/**
 * Internal helper for toObject() and toJSON() that doesn't manipulate options
 *
 * @api private
 * @method $toObject
 * @memberOf Document
 * @instance
 */

Document.prototype.$toObject = function(options, json) ***REMOVED***
  let defaultOptions = ***REMOVED***
    transform: true,
    flattenDecimals: true
  ***REMOVED***;

  const schemaOptions = get(this, 'schema.options', ***REMOVED******REMOVED***);
  // merge base default options with Schema's set default options if available.
  // `clone` is necessary here because `utils.options` directly modifies the second input.
  if (json && schemaOptions.toJSON) ***REMOVED***
    defaultOptions = utils.options(defaultOptions, clone(schemaOptions.toJSON));
  ***REMOVED*** else if (schemaOptions.toObject) ***REMOVED***
    defaultOptions = utils.options(defaultOptions, clone(schemaOptions.toObject));
  ***REMOVED***

  // If options do not exist or is not an object, set it to empty object
  options = options && utils.getFunctionName(options.constructor) === 'Object' ?
    clone(options) :
    ***REMOVED******REMOVED***;

  let _minimize;
  if (options.minimize != null) ***REMOVED***
    _minimize = options.minimize;
  ***REMOVED*** else if (defaultOptions.minimize != null) ***REMOVED***
    _minimize = defaultOptions.minimize;
  ***REMOVED*** else ***REMOVED***
    _minimize = schemaOptions.minimize;
  ***REMOVED***

  // The original options that will be passed to `clone()`. Important because
  // `clone()` will recursively call `$toObject()` on embedded docs, so we
  // need the original options the user passed in, plus `_isNested` and
  // `_parentOptions` for checking whether we need to depopulate.
  const cloneOptions = Object.assign(utils.clone(options), ***REMOVED***
    _isNested: true,
    json: json,
    minimize: _minimize
  ***REMOVED***);

  const depopulate = options.depopulate ||
    get(options, '_parentOptions.depopulate', false);
  // _isNested will only be true if this is not the top level document, we
  // should never depopulate
  if (depopulate && options._isNested && this.$__.wasPopulated) ***REMOVED***
    // populated paths that we set to a document
    return clone(this._id, cloneOptions);
  ***REMOVED***

  // merge default options with input options.
  options = utils.options(defaultOptions, options);
  options._isNested = true;
  options.json = json;
  options.minimize = _minimize;

  cloneOptions._parentOptions = options;

  // remember the root transform function
  // to save it from being overwritten by sub-transform functions
  var originalTransform = options.transform;

  var ret = clone(this._doc, cloneOptions) || ***REMOVED******REMOVED***;

  if (options.getters) ***REMOVED***
    applyGetters(this, ret, 'paths', cloneOptions);
    // applyGetters for paths will add nested empty objects;
    // if minimize is set, we need to remove them.
    if (options.minimize) ***REMOVED***
      ret = minimize(ret) || ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***

  if (options.virtuals || options.getters && options.virtuals !== false) ***REMOVED***
    applyGetters(this, ret, 'virtuals', cloneOptions);
  ***REMOVED***

  if (options.versionKey === false && this.schema.options.versionKey) ***REMOVED***
    delete ret[this.schema.options.versionKey];
  ***REMOVED***

  var transform = options.transform;

  // In the case where a subdocument has its own transform function, we need to
  // check and see if the parent has a transform (options.transform) and if the
  // child schema has a transform (this.schema.options.toObject) In this case,
  // we need to adjust options.transform to be the child schema's transform and
  // not the parent schema's
  if (transform === true || (schemaOptions.toObject && transform)) ***REMOVED***
    var opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;

    if (opts) ***REMOVED***
      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    options.transform = originalTransform;
  ***REMOVED***

  if (typeof transform === 'function') ***REMOVED***
    var xformed = transform(this, ret, options);
    if (typeof xformed !== 'undefined') ***REMOVED***
      ret = xformed;
    ***REMOVED***
  ***REMOVED***

  return ret;
***REMOVED***;

/**
 * Converts this document into a plain javascript object, ready for storage in MongoDB.
 *
 * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.
 *
 * ####Options:
 *
 * - `getters` apply all getters (path and virtual getters)
 * - `virtuals` apply virtual getters (can override `getters` option)
 * - `minimize` remove empty objects (defaults to true)
 * - `transform` a transform function to apply to the resulting document before returning
 * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)
 * - `versionKey` whether to include the version key (defaults to true)
 *
 * ####Getters/Virtuals
 *
 * Example of only applying path getters
 *
 *     doc.toObject(***REMOVED*** getters: true, virtuals: false ***REMOVED***)
 *
 * Example of only applying virtual getters
 *
 *     doc.toObject(***REMOVED*** virtuals: true ***REMOVED***)
 *
 * Example of applying both path and virtual getters
 *
 *     doc.toObject(***REMOVED*** getters: true ***REMOVED***)
 *
 * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.
 *
 *     schema.set('toObject', ***REMOVED*** virtuals: true ***REMOVED***)
 *
 * ####Transform
 *
 * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.
 *
 * Transform functions receive three arguments
 *
 *     function (doc, ret, options) ***REMOVED******REMOVED***
 *
 * - `doc` The mongoose document which is being converted
 * - `ret` The plain object representation which has been converted
 * - `options` The options in use (either schema options or the options passed inline)
 *
 * ####Example
 *
 *     // specify the transform schema option
 *     if (!schema.options.toObject) schema.options.toObject = ***REMOVED******REMOVED***;
 *     schema.options.toObject.transform = function (doc, ret, options) ***REMOVED***
 *       // remove the _id of every document before returning the result
 *       delete ret._id;
 *       return ret;
 *     ***REMOVED***
 *
 *     // without the transformation in the schema
 *     doc.toObject(); // ***REMOVED*** _id: 'anId', name: 'Wreck-it Ralph' ***REMOVED***
 *
 *     // with the transformation
 *     doc.toObject(); // ***REMOVED*** name: 'Wreck-it Ralph' ***REMOVED***
 *
 * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:
 *
 *     if (!schema.options.toObject) schema.options.toObject = ***REMOVED******REMOVED***;
 *     schema.options.toObject.transform = function (doc, ret, options) ***REMOVED***
 *       return ***REMOVED*** movie: ret.name ***REMOVED***
 *     ***REMOVED***
 *
 *     // without the transformation in the schema
 *     doc.toObject(); // ***REMOVED*** _id: 'anId', name: 'Wreck-it Ralph' ***REMOVED***
 *
 *     // with the transformation
 *     doc.toObject(); // ***REMOVED*** movie: 'Wreck-it Ralph' ***REMOVED***
 *
 * _Note: if a transform function returns `undefined`, the return value will be ignored._
 *
 * Transformations may also be applied inline, overridding any transform set in the options:
 *
 *     function xform (doc, ret, options) ***REMOVED***
 *       return ***REMOVED*** inline: ret.name, custom: true ***REMOVED***
 *     ***REMOVED***
 *
 *     // pass the transform as an inline option
 *     doc.toObject(***REMOVED*** transform: xform ***REMOVED***); // ***REMOVED*** inline: 'Wreck-it Ralph', custom: true ***REMOVED***
 *
 * If you want to skip transformations, use `transform: false`:
 *
 *     if (!schema.options.toObject) schema.options.toObject = ***REMOVED******REMOVED***;
 *     schema.options.toObject.hide = '_id';
 *     schema.options.toObject.transform = function (doc, ret, options) ***REMOVED***
 *       if (options.hide) ***REMOVED***
 *         options.hide.split(' ').forEach(function (prop) ***REMOVED***
 *           delete ret[prop];
 *         ***REMOVED***);
 *       ***REMOVED***
 *       return ret;
 *     ***REMOVED***
 *
 *     var doc = new Doc(***REMOVED*** _id: 'anId', secret: 47, name: 'Wreck-it Ralph' ***REMOVED***);
 *     doc.toObject();                                        // ***REMOVED*** secret: 47, name: 'Wreck-it Ralph' ***REMOVED***
 *     doc.toObject(***REMOVED*** hide: 'secret _id', transform: false ***REMOVED***);// ***REMOVED*** _id: 'anId', secret: 47, name: 'Wreck-it Ralph' ***REMOVED***
 *     doc.toObject(***REMOVED*** hide: 'secret _id', transform: true ***REMOVED***); // ***REMOVED*** name: 'Wreck-it Ralph' ***REMOVED***
 *
 * Transforms are applied _only to the document and are not applied to sub-documents_.
 *
 * Transforms, like all of these options, are also available for `toJSON`.
 *
 * See [schema options](/docs/guide.html#toObject) for some more details.
 *
 * _During save, no custom options are applied to the document before being sent to the database._
 *
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @return ***REMOVED***Object***REMOVED*** js object
 * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.toObject = function(options) ***REMOVED***
  return this.$toObject(options);
***REMOVED***;

/*!
 * Minimizes an object, removing undefined values and empty objects
 *
 * @param ***REMOVED***Object***REMOVED*** object to minimize
 * @return ***REMOVED***Object***REMOVED***
 */

function minimize(obj) ***REMOVED***
  var keys = Object.keys(obj),
      i = keys.length,
      hasKeys,
      key,
      val;

  while (i--) ***REMOVED***
    key = keys[i];
    val = obj[key];

    if (utils.isObject(val) && !Buffer.isBuffer(val)) ***REMOVED***
      obj[key] = minimize(val);
    ***REMOVED***

    if (undefined === obj[key]) ***REMOVED***
      delete obj[key];
      continue;
    ***REMOVED***

    hasKeys = true;
  ***REMOVED***

  return hasKeys
    ? obj
    : undefined;
***REMOVED***

/*!
 * Applies virtuals properties to `json`.
 *
 * @param ***REMOVED***Document***REMOVED*** self
 * @param ***REMOVED***Object***REMOVED*** json
 * @param ***REMOVED***String***REMOVED*** type either `virtuals` or `paths`
 * @return ***REMOVED***Object***REMOVED*** `json`
 */

function applyGetters(self, json, type, options) ***REMOVED***
  var schema = self.schema;
  var paths = Object.keys(schema[type]);
  var i = paths.length;
  var numPaths = i;
  var path;
  var assignPath;
  var cur = self._doc;
  var v;

  if (!cur) ***REMOVED***
    return json;
  ***REMOVED***

  if (type === 'virtuals') ***REMOVED***
    options = options || ***REMOVED******REMOVED***;
    for (i = 0; i < numPaths; ++i) ***REMOVED***
      path = paths[i];
      // We may be applying virtuals to a nested object, for example if calling
      // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,
      // will be a trailing substring of the `path`.
      assignPath = path;
      if (options.path != null) ***REMOVED***
        if (!path.startsWith(options.path + '.')) ***REMOVED***
          continue;
        ***REMOVED***
        assignPath = path.substr(options.path.length + 1);
      ***REMOVED***
      parts = assignPath.split('.');
      v = clone(self.get(path), options);
      if (v === void 0) ***REMOVED***
        continue;
      ***REMOVED***
      plen = parts.length;
      cur = json;
      for (var j = 0; j < plen - 1; ++j) ***REMOVED***
        cur[parts[j]] = cur[parts[j]] || ***REMOVED******REMOVED***;
        cur = cur[parts[j]];
      ***REMOVED***
      cur[parts[plen - 1]] = v;
    ***REMOVED***

    return json;
  ***REMOVED***

  while (i--) ***REMOVED***
    path = paths[i];

    var parts = path.split('.');
    var plen = parts.length;
    var last = plen - 1;
    var branch = json;
    var part;
    cur = self._doc;

    for (var ii = 0; ii < plen; ++ii) ***REMOVED***
      part = parts[ii];
      v = cur[part];
      if (ii === last) ***REMOVED***
        branch[part] = clone(self.get(path), options);
      ***REMOVED*** else if (v == null) ***REMOVED***
        if (part in cur) ***REMOVED***
          branch[part] = v;
        ***REMOVED***
        break;
      ***REMOVED*** else ***REMOVED***
        branch = branch[part] || (branch[part] = ***REMOVED******REMOVED***);
      ***REMOVED***
      cur = v;
    ***REMOVED***
  ***REMOVED***

  return json;
***REMOVED***

/**
 * The return value of this method is used in calls to JSON.stringify(doc).
 *
 * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.
 *
 *     schema.set('toJSON', ***REMOVED*** virtuals: true ***REMOVED***)
 *
 * See [schema options](/docs/guide.html#toJSON) for details.
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Object***REMOVED***
 * @see Document#toObject #document_Document-toObject
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.toJSON = function(options) ***REMOVED***
  return this.$toObject(options, true);
***REMOVED***;

/**
 * Helper for console.log
 *
 * @api public
 * @method inspect
 * @memberOf Document
 * @instance
 */

Document.prototype.inspect = function(options) ***REMOVED***
  var isPOJO = options &&
    utils.getFunctionName(options.constructor) === 'Object';
  var opts;
  if (isPOJO) ***REMOVED***
    opts = options;
    opts.minimize = false;
  ***REMOVED***
  return this.toObject(opts);
***REMOVED***;

/**
 * Helper for console.log
 *
 * @api public
 * @method toString
 * @memberOf Document
 * @instance
 */

Document.prototype.toString = function() ***REMOVED***
  return inspect(this.inspect());
***REMOVED***;

/**
 * Returns true if the Document stores the same data as doc.
 *
 * Documents are considered equal when they have matching `_id`s, unless neither
 * document has an `_id`, in which case this function falls back to using
 * `deepEqual()`.
 *
 * @param ***REMOVED***Document***REMOVED*** doc a document to compare
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.equals = function(doc) ***REMOVED***
  if (!doc) ***REMOVED***
    return false;
  ***REMOVED***

  var tid = this.get('_id');
  var docid = doc.get ? doc.get('_id') : doc;
  if (!tid && !docid) ***REMOVED***
    return deepEqual(this, doc);
  ***REMOVED***
  return tid && tid.equals
    ? tid.equals(docid)
    : tid === docid;
***REMOVED***;

/**
 * Populates document references, executing the `callback` when complete.
 * If you want to use promises instead, use this function with
 * [`execPopulate()`](#document_Document-execPopulate)
 *
 * ####Example:
 *
 *     doc
 *     .populate('company')
 *     .populate(***REMOVED***
 *       path: 'notes',
 *       match: /airline/,
 *       select: 'text',
 *       model: 'modelName'
 *       options: opts
 *     ***REMOVED***, function (err, user) ***REMOVED***
 *       assert(doc._id === user._id) // the document itself is passed
 *     ***REMOVED***)
 *
 *     // summary
 *     doc.populate(path)                   // not executed
 *     doc.populate(options);               // not executed
 *     doc.populate(path, callback)         // executed
 *     doc.populate(options, callback);     // executed
 *     doc.populate(callback);              // executed
 *     doc.populate(options).execPopulate() // executed, returns promise
 *
 *
 * ####NOTE:
 *
 * Population does not occur unless a `callback` is passed *or* you explicitly
 * call `execPopulate()`.
 * Passing the same path a second time will overwrite the previous path options.
 * See [Model.populate()](#model_Model.populate) for explaination of options.
 *
 * @see Model.populate #model_Model.populate
 * @see Document.execPopulate #document_Document-execPopulate
 * @param ***REMOVED***String|Object***REMOVED*** [path] The path to populate or an options object
 * @param ***REMOVED***Function***REMOVED*** [callback] When passed, population is invoked
 * @api public
 * @return ***REMOVED***Document***REMOVED*** this
 * @memberOf Document
 * @instance
 */

Document.prototype.populate = function populate() ***REMOVED***
  if (arguments.length === 0) ***REMOVED***
    return this;
  ***REMOVED***

  var pop = this.$__.populate || (this.$__.populate = ***REMOVED******REMOVED***);
  var args = utils.args(arguments);
  var fn;

  if (typeof args[args.length - 1] === 'function') ***REMOVED***
    fn = args.pop();
  ***REMOVED***

  // allow `doc.populate(callback)`
  if (args.length) ***REMOVED***
    // use hash to remove duplicate paths
    var res = utils.populate.apply(null, args);
    for (var i = 0; i < res.length; ++i) ***REMOVED***
      pop[res[i].path] = res[i];
    ***REMOVED***
  ***REMOVED***

  if (fn) ***REMOVED***
    var paths = utils.object.vals(pop);
    this.$__.populate = undefined;
    var topLevelModel = this.constructor;
    if (this.$__isNested) ***REMOVED***
      topLevelModel = this.$__.scope.constructor;
      var nestedPath = this.$__.nestedPath;
      paths.forEach(function(populateOptions) ***REMOVED***
        populateOptions.path = nestedPath + '.' + populateOptions.path;
      ***REMOVED***);
    ***REMOVED***
    topLevelModel.populate(this, paths, fn);
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Explicitly executes population and returns a promise. Useful for ES2015
 * integration.
 *
 * ####Example:
 *
 *     var promise = doc.
 *       populate('company').
 *       populate(***REMOVED***
 *         path: 'notes',
 *         match: /airline/,
 *         select: 'text',
 *         model: 'modelName'
 *         options: opts
 *       ***REMOVED***).
 *       execPopulate();
 *
 *     // summary
 *     doc.execPopulate().then(resolve, reject);
 *
 *
 * @see Document.populate #document_Document-populate
 * @api public
 * @return ***REMOVED***Promise***REMOVED*** promise that resolves to the document when population is done
 * @memberOf Document
 * @instance
 */

Document.prototype.execPopulate = function() ***REMOVED***
  return utils.promiseOrCallback(null, cb => ***REMOVED***
    this.populate(cb);
  ***REMOVED***);
***REMOVED***;

/**
 * Gets _id(s) used during population of the given `path`.
 *
 * ####Example:
 *
 *     Model.findOne().populate('author').exec(function (err, doc) ***REMOVED***
 *       console.log(doc.author.name)         // Dr.Seuss
 *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'
 *     ***REMOVED***)
 *
 * If the path was not populated, undefined is returned.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @return ***REMOVED***Array|ObjectId|Number|Buffer|String|undefined***REMOVED***
 * @memberOf Document
 * @instance
 * @api public
 */

Document.prototype.populated = function(path, val, options) ***REMOVED***
  // val and options are internal
  if (val === null || val === void 0) ***REMOVED***
    if (!this.$__.populated) ***REMOVED***
      return undefined;
    ***REMOVED***
    var v = this.$__.populated[path];
    if (v) ***REMOVED***
      return v.value;
    ***REMOVED***
    return undefined;
  ***REMOVED***

  // internal

  if (val === true) ***REMOVED***
    if (!this.$__.populated) ***REMOVED***
      return undefined;
    ***REMOVED***
    return this.$__.populated[path];
  ***REMOVED***

  this.$__.populated || (this.$__.populated = ***REMOVED******REMOVED***);
  this.$__.populated[path] = ***REMOVED***value: val, options: options***REMOVED***;
  return val;
***REMOVED***;

/**
 * Takes a populated field and returns it to its unpopulated state.
 *
 * ####Example:
 *
 *     Model.findOne().populate('author').exec(function (err, doc) ***REMOVED***
 *       console.log(doc.author.name); // Dr.Seuss
 *       console.log(doc.depopulate('author'));
 *       console.log(doc.author); // '5144cf8050f071d979c118a7'
 *     ***REMOVED***)
 *
 * If the path was not populated, this is a no-op.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @return ***REMOVED***Document***REMOVED*** this
 * @see Document.populate #document_Document-populate
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.depopulate = function(path) ***REMOVED***
  if (typeof path === 'string') ***REMOVED***
    path = path.split(' ');
  ***REMOVED***
  var i;
  var populatedIds;

  if (arguments.length === 0) ***REMOVED***
    // Depopulate all
    var keys = Object.keys(this.$__.populated);

    for (i = 0; i < keys.length; i++) ***REMOVED***
      populatedIds = this.populated(keys[i]);
      if (!populatedIds) ***REMOVED***
        continue;
      ***REMOVED***
      delete this.$__.populated[keys[i]];
      this.$set(keys[i], populatedIds);
    ***REMOVED***
    return this;
  ***REMOVED***

  for (i = 0; i < path.length; i++) ***REMOVED***
    populatedIds = this.populated(path[i]);
    if (!populatedIds) ***REMOVED***
      continue;
    ***REMOVED***
    delete this.$__.populated[path[i]];
    this.$set(path[i], populatedIds);
  ***REMOVED***
  return this;
***REMOVED***;


/**
 * Returns the full path to this document.
 *
 * @param ***REMOVED***String***REMOVED*** [path]
 * @return ***REMOVED***String***REMOVED***
 * @api private
 * @method $__fullPath
 * @memberOf Document
 * @instance
 */

Document.prototype.$__fullPath = function(path) ***REMOVED***
  // overridden in SubDocuments
  return path || '';
***REMOVED***;

/*!
 * Module exports.
 */

Document.ValidationError = ValidationError;
module.exports = exports = Document;
