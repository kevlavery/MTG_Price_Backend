'use strict';

/*!
 * Module dependencies.
 */

var async = require('async');
var utils = require('../../utils');

/**
 * Execute `fn` for every document in the cursor. If `fn` returns a promise,
 * will wait for the promise to resolve before iterating on to the next one.
 * Returns a promise that resolves when done.
 *
 * @param ***REMOVED***Function***REMOVED*** next the thunk to call to get the next document
 * @param ***REMOVED***Function***REMOVED*** fn
 * @param ***REMOVED***Object***REMOVED*** options
 * @param ***REMOVED***Function***REMOVED*** [callback] executed when all docs have been processed
 * @return ***REMOVED***Promise***REMOVED***
 * @api public
 * @method eachAsync
 */

module.exports = function eachAsync(next, fn, options, callback) ***REMOVED***
  var parallel = options.parallel || 1;

  var handleNextResult = function(doc, callback) ***REMOVED***
    var promise = fn(doc);
    if (promise && typeof promise.then === 'function') ***REMOVED***
      promise.then(
        function() ***REMOVED*** callback(null); ***REMOVED***,
        function(error) ***REMOVED*** callback(error || new Error('`eachAsync()` promise rejected without error')); ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      callback(null);
    ***REMOVED***
  ***REMOVED***;

  var iterate = function(callback) ***REMOVED***
    var drained = false;
    var nextQueue = async.queue(function(task, cb) ***REMOVED***
      if (drained) return cb();
      next(function(err, doc) ***REMOVED***
        if (err) return cb(err);
        if (!doc) drained = true;
        cb(null, doc);
      ***REMOVED***);
    ***REMOVED***, 1);

    var getAndRun = function(cb) ***REMOVED***
      nextQueue.push(***REMOVED******REMOVED***, function(err, doc) ***REMOVED***
        if (err) return cb(err);
        if (!doc) return cb();
        handleNextResult(doc, function(err) ***REMOVED***
          if (err) return cb(err);
          // Make sure to clear the stack re: gh-4697
          setTimeout(function() ***REMOVED***
            getAndRun(cb);
          ***REMOVED***, 0);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***;

    async.times(parallel, function(n, cb) ***REMOVED***
      getAndRun(cb);
    ***REMOVED***, callback);
  ***REMOVED***;

  return utils.promiseOrCallback(callback, cb => ***REMOVED***
    iterate(cb);
  ***REMOVED***);
***REMOVED***;
