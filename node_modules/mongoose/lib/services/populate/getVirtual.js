'use strict';

module.exports = getVirtual;

/*!
 * ignore
 */

function getVirtual(schema, name) ***REMOVED***
  if (schema.virtuals[name]) ***REMOVED***
    return schema.virtuals[name];
  ***REMOVED***
  const parts = name.split('.');
  let cur = '';
  let nestedSchemaPath = '';
  for (let i = 0; i < parts.length; ++i) ***REMOVED***
    cur += (cur.length > 0 ? '.' : '') + parts[i];
    if (schema.virtuals[cur]) ***REMOVED***
      if (i === parts.length - 1) ***REMOVED***
        schema.virtuals[cur].$nestedSchemaPath = nestedSchemaPath;
        return schema.virtuals[cur];
      ***REMOVED***
      continue;
    ***REMOVED***

    if (schema.nested[cur]) ***REMOVED***
      continue;
    ***REMOVED***

    if (schema.paths[cur] && schema.paths[cur].schema) ***REMOVED***
      schema = schema.paths[cur].schema;

      if (i === parts.length - 2 && schema.discriminators) ***REMOVED***
        // Check for embedded discriminators, don't currently support populating
        // nested virtuals underneath embedded discriminators because that will
        // require substantial refactoring.
        for (let key of Object.keys(schema.discriminators)) ***REMOVED***
          const discriminatorSchema = schema.discriminators[key];
          let _cur = parts[i + 1];
          if (discriminatorSchema.virtuals[_cur]) ***REMOVED***
            discriminatorSchema.virtuals[_cur].$nestedSchemaPath =
              (nestedSchemaPath.length > 0 ? '.' : '') + cur;
            return discriminatorSchema.virtuals[_cur];
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;
      cur = '';
      continue;
    ***REMOVED***

    return null;
  ***REMOVED***
***REMOVED***
