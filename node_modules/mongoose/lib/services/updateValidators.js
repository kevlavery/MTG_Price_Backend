'use strict';

/*!
 * Module dependencies.
 */

const Mixed = require('../schema/mixed');
const ValidationError = require('../error/validation');
const flatten = require('./common').flatten;
const modifiedPaths = require('./common').modifiedPaths;
const parallel = require('async/parallel');

/**
 * Applies validators and defaults to update and findOneAndUpdate operations,
 * specifically passing a null doc as `this` to validators and defaults
 *
 * @param ***REMOVED***Query***REMOVED*** query
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @param ***REMOVED***Object***REMOVED*** castedDoc
 * @param ***REMOVED***Object***REMOVED*** options
 * @method runValidatorsOnUpdate
 * @api private
 */

module.exports = function(query, schema, castedDoc, options) ***REMOVED***
  var _keys;
  var keys = Object.keys(castedDoc || ***REMOVED******REMOVED***);
  var updatedKeys = ***REMOVED******REMOVED***;
  var updatedValues = ***REMOVED******REMOVED***;
  var arrayAtomicUpdates = ***REMOVED******REMOVED***;
  var numKeys = keys.length;
  var hasDollarUpdate = false;
  var modified = ***REMOVED******REMOVED***;
  var currentUpdate;
  var key;

  for (var i = 0; i < numKeys; ++i) ***REMOVED***
    if (keys[i].charAt(0) === '$') ***REMOVED***
      hasDollarUpdate = true;
      if (keys[i] === '$push' || keys[i] === '$addToSet') ***REMOVED***
        _keys = Object.keys(castedDoc[keys[i]]);
        for (var ii = 0; ii < _keys.length; ++ii) ***REMOVED***
          currentUpdate = castedDoc[keys[i]][_keys[ii]];
          if (currentUpdate && currentUpdate.$each) ***REMOVED***
            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).
              concat(currentUpdate.$each);
          ***REMOVED*** else ***REMOVED***
            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).
              concat([currentUpdate]);
          ***REMOVED***
        ***REMOVED***
        continue;
      ***REMOVED***
      modifiedPaths(castedDoc[keys[i]], '', modified);
      var flat = flatten(castedDoc[keys[i]]);
      var paths = Object.keys(flat);
      var numPaths = paths.length;
      for (var j = 0; j < numPaths; ++j) ***REMOVED***
        var updatedPath = paths[j].replace('.$.', '.0.');
        updatedPath = updatedPath.replace(/\.\$$/, '.0');
        key = keys[i];
        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`
        // for the rest of the logic, it will get handled later.
        if (updatedPath.indexOf('$') !== -1) ***REMOVED***
          continue;
        ***REMOVED***
        if (key === '$set' || key === '$setOnInsert' ||
            key === '$pull' || key === '$pullAll') ***REMOVED***
          updatedValues[updatedPath] = flat[paths[j]];
        ***REMOVED*** else if (key === '$unset') ***REMOVED***
          updatedValues[updatedPath] = undefined;
        ***REMOVED***
        updatedKeys[updatedPath] = true;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  if (!hasDollarUpdate) ***REMOVED***
    modifiedPaths(castedDoc, '', modified);
    updatedValues = flatten(castedDoc);
    updatedKeys = Object.keys(updatedValues);
  ***REMOVED***

  var updates = Object.keys(updatedValues);
  var numUpdates = updates.length;
  var validatorsToExecute = [];
  var validationErrors = [];
  function iter(i, v) ***REMOVED***
    var schemaPath = schema._getSchema(updates[i]);
    if (schemaPath) ***REMOVED***
      // gh-4305: `_getSchema()` will report all sub-fields of a 'Mixed' path
      // as 'Mixed', so avoid double validating them.
      if (schemaPath instanceof Mixed && schemaPath.$fullPath !== updates[i]) ***REMOVED***
        return;
      ***REMOVED***

      if (v && Array.isArray(v.$in)) ***REMOVED***
        v.$in.forEach((v, i) => ***REMOVED***
          validatorsToExecute.push(function(callback) ***REMOVED***
            schemaPath.doValidate(
              v,
              function(err) ***REMOVED***
                if (err) ***REMOVED***
                  err.path = updates[i] + '.$in.' + i;
                  validationErrors.push(err);
                ***REMOVED***
                callback(null);
              ***REMOVED***,
              options && options.context === 'query' ? query : null,
              ***REMOVED***updateValidator: true***REMOVED***);
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        validatorsToExecute.push(function(callback) ***REMOVED***
          schemaPath.doValidate(
            v,
            function(err) ***REMOVED***
              if (err) ***REMOVED***
                err.path = updates[i];
                validationErrors.push(err);
              ***REMOVED***
              callback(null);
            ***REMOVED***,
            options && options.context === 'query' ? query : null,
            ***REMOVED***updateValidator: true***REMOVED***);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  for (i = 0; i < numUpdates; ++i) ***REMOVED***
    iter(i, updatedValues[updates[i]]);
  ***REMOVED***

  var arrayUpdates = Object.keys(arrayAtomicUpdates);
  var numArrayUpdates = arrayUpdates.length;
  for (i = 0; i < numArrayUpdates; ++i) ***REMOVED***
    (function(i) ***REMOVED***
      var schemaPath = schema._getSchema(arrayUpdates[i]);
      if (schemaPath && schemaPath.$isMongooseDocumentArray) ***REMOVED***
        validatorsToExecute.push(function(callback) ***REMOVED***
          schemaPath.doValidate(
            arrayAtomicUpdates[arrayUpdates[i]],
            function(err) ***REMOVED***
              if (err) ***REMOVED***
                err.path = arrayUpdates[i];
                validationErrors.push(err);
              ***REMOVED***
              callback(null);
            ***REMOVED***,
            options && options.context === 'query' ? query : null);
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        schemaPath = schema._getSchema(arrayUpdates[i] + '.0');
        for (var j = 0; j < arrayAtomicUpdates[arrayUpdates[i]].length; ++j) ***REMOVED***
          (function(j) ***REMOVED***
            validatorsToExecute.push(function(callback) ***REMOVED***
              schemaPath.doValidate(
                arrayAtomicUpdates[arrayUpdates[i]][j],
                function(err) ***REMOVED***
                  if (err) ***REMOVED***
                    err.path = arrayUpdates[i];
                    validationErrors.push(err);
                  ***REMOVED***
                  callback(null);
                ***REMOVED***,
                options && options.context === 'query' ? query : null,
                ***REMOVED*** updateValidator: true ***REMOVED***);
            ***REMOVED***);
          ***REMOVED***)(j);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***)(i);
  ***REMOVED***

  return function(callback) ***REMOVED***
    parallel(validatorsToExecute, function() ***REMOVED***
      if (validationErrors.length) ***REMOVED***
        var err = new ValidationError(null);
        for (var i = 0; i < validationErrors.length; ++i) ***REMOVED***
          err.addError(validationErrors[i].path, validationErrors[i]);
        ***REMOVED***
        return callback(err);
      ***REMOVED***
      callback(null);
    ***REMOVED***);
  ***REMOVED***;
***REMOVED***;
