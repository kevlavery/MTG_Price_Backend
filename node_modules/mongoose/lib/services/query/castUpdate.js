'use strict';

var StrictModeError = require('../../error/strict');
var ValidationError = require('../../error/validation');
var utils = require('../../utils');

/*!
 * Casts an update op based on the given schema
 *
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @param ***REMOVED***Object***REMOVED*** obj
 * @param ***REMOVED***Object***REMOVED*** options
 * @param ***REMOVED***Boolean***REMOVED*** [options.overwrite] defaults to false
 * @param ***REMOVED***Boolean|String***REMOVED*** [options.strict] defaults to true
 * @param ***REMOVED***Query***REMOVED*** context passed to setters
 * @return ***REMOVED***Boolean***REMOVED*** true iff the update is non-empty
 */

module.exports = function castUpdate(schema, obj, options, context) ***REMOVED***
  if (!obj) ***REMOVED***
    return undefined;
  ***REMOVED***

  var ops = Object.keys(obj);
  var i = ops.length;
  var ret = ***REMOVED******REMOVED***;
  var hasKeys;
  var val;
  var hasDollarKey = false;
  var overwrite = options.overwrite;

  while (i--) ***REMOVED***
    var op = ops[i];
    // if overwrite is set, don't do any of the special $set stuff
    if (op[0] !== '$' && !overwrite) ***REMOVED***
      // fix up $set sugar
      if (!ret.$set) ***REMOVED***
        if (obj.$set) ***REMOVED***
          ret.$set = obj.$set;
        ***REMOVED*** else ***REMOVED***
          ret.$set = ***REMOVED******REMOVED***;
        ***REMOVED***
      ***REMOVED***
      ret.$set[op] = obj[op];
      ops.splice(i, 1);
      if (!~ops.indexOf('$set')) ops.push('$set');
    ***REMOVED*** else if (op === '$set') ***REMOVED***
      if (!ret.$set) ***REMOVED***
        ret[op] = obj[op];
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      ret[op] = obj[op];
    ***REMOVED***
  ***REMOVED***

  // cast each value
  i = ops.length;

  // if we get passed ***REMOVED******REMOVED*** for the update, we still need to respect that when it
  // is an overwrite scenario
  if (overwrite) ***REMOVED***
    hasKeys = true;
  ***REMOVED***

  while (i--) ***REMOVED***
    op = ops[i];
    val = ret[op];
    hasDollarKey = hasDollarKey || op.charAt(0) === '$';

    if (val &&
        typeof val === 'object' &&
        !Buffer.isBuffer(val) &&
        (!overwrite || hasDollarKey)) ***REMOVED***
      hasKeys |= walkUpdatePath(schema, val, op, options, context);
    ***REMOVED*** else if (overwrite && ret && typeof ret === 'object') ***REMOVED***
      // if we are just using overwrite, cast the query and then we will
      // *always* return the value, even if it is an empty object. We need to
      // set hasKeys above because we need to account for the case where the
      // user passes ***REMOVED******REMOVED*** and wants to clobber the whole document
      // Also, _walkUpdatePath expects an operation, so give it $set since that
      // is basically what we're doing
      walkUpdatePath(schema, ret, '$set', options, context);
    ***REMOVED*** else ***REMOVED***
      var msg = 'Invalid atomic update value for ' + op + '. '
          + 'Expected an object, received ' + typeof val;
      throw new Error(msg);
    ***REMOVED***
  ***REMOVED***

  return hasKeys && ret;
***REMOVED***;

/*!
 * Walk each path of obj and cast its values
 * according to its schema.
 *
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @param ***REMOVED***Object***REMOVED*** obj - part of a query
 * @param ***REMOVED***String***REMOVED*** op - the atomic operator ($pull, $set, etc)
 * @param ***REMOVED***Object***REMOVED*** options
 * @param ***REMOVED***Boolean|String***REMOVED*** [options.strict]
 * @param ***REMOVED***Boolean***REMOVED*** [options.omitUndefined]
 * @param ***REMOVED***Query***REMOVED*** context
 * @param ***REMOVED***String***REMOVED*** pref - path prefix (internal only)
 * @return ***REMOVED***Bool***REMOVED*** true if this path has keys to update
 * @api private
 */

function walkUpdatePath(schema, obj, op, options, context, pref) ***REMOVED***
  var strict = options.strict;
  var prefix = pref ? pref + '.' : '';
  var keys = Object.keys(obj);
  var i = keys.length;
  var hasKeys = false;
  var schematype;
  var key;
  var val;

  var aggregatedError = null;

  var useNestedStrict = schema.options.useNestedStrict;

  while (i--) ***REMOVED***
    key = keys[i];
    val = obj[key];

    if (val && val.constructor.name === 'Object') ***REMOVED***
      // watch for embedded doc schemas
      schematype = schema._getSchema(prefix + key);
      if (schematype && schematype.caster && op in castOps) ***REMOVED***
        // embedded doc schema
        if ('$each' in val) ***REMOVED***
          hasKeys = true;
          try ***REMOVED***
            obj[key] = ***REMOVED***
              $each: castUpdateVal(schematype, val.$each, op, context)
            ***REMOVED***;
          ***REMOVED*** catch (error) ***REMOVED***
            aggregatedError = _handleCastError(error, context, key, aggregatedError);
          ***REMOVED***

          if (val.$slice != null) ***REMOVED***
            obj[key].$slice = val.$slice | 0;
          ***REMOVED***

          if (val.$sort) ***REMOVED***
            obj[key].$sort = val.$sort;
          ***REMOVED***

          if (!!val.$position || val.$position === 0) ***REMOVED***
            obj[key].$position = val.$position;
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          try ***REMOVED***
            obj[key] = castUpdateVal(schematype, val, op, context);
          ***REMOVED*** catch (error) ***REMOVED***
            aggregatedError = _handleCastError(error, context, key, aggregatedError);
          ***REMOVED***

          if (options.omitUndefined && obj[key] === void 0) ***REMOVED***
            delete obj[key];
            continue;
          ***REMOVED***

          hasKeys = true;
        ***REMOVED***
      ***REMOVED*** else if ((op === '$currentDate') || (op in castOps && schematype)) ***REMOVED***
        // $currentDate can take an object
        try ***REMOVED***
          obj[key] = castUpdateVal(schematype, val, op, context);
        ***REMOVED*** catch (error) ***REMOVED***
          aggregatedError = _handleCastError(error, context, key, aggregatedError);
        ***REMOVED***

        if (options.omitUndefined && obj[key] === void 0) ***REMOVED***
          delete obj[key];
          continue;
        ***REMOVED***

        hasKeys = true;
      ***REMOVED*** else ***REMOVED***
        var pathToCheck = (prefix + key);
        var v = schema._getPathType(pathToCheck);
        var _strict = strict;
        if (useNestedStrict &&
            v &&
            v.schema &&
            'strict' in v.schema.options) ***REMOVED***
          _strict = v.schema.options.strict;
        ***REMOVED***

        if (v.pathType === 'undefined') ***REMOVED***
          if (_strict === 'throw') ***REMOVED***
            throw new StrictModeError(pathToCheck);
          ***REMOVED*** else if (_strict) ***REMOVED***
            delete obj[key];
            continue;
          ***REMOVED***
        ***REMOVED***

        // gh-2314
        // we should be able to set a schema-less field
        // to an empty object literal
        hasKeys |= walkUpdatePath(schema, val, op, options, context, prefix + key) ||
          (utils.isObject(val) && Object.keys(val).length === 0);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      var checkPath = (key === '$each' || key === '$or' || key === '$and' || key === '$in') ?
        pref : prefix + key;
      schematype = schema._getSchema(checkPath);

      var pathDetails = schema._getPathType(checkPath);
      var isStrict = strict;
      if (useNestedStrict &&
          pathDetails &&
          pathDetails.schema &&
          'strict' in pathDetails.schema.options) ***REMOVED***
        isStrict = pathDetails.schema.options.strict;
      ***REMOVED***

      var skip = isStrict &&
          !schematype &&
          !/real|nested/.test(pathDetails.pathType);

      if (skip) ***REMOVED***
        if (isStrict === 'throw') ***REMOVED***
          throw new StrictModeError(prefix + key);
        ***REMOVED*** else ***REMOVED***
          delete obj[key];
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking
        // improving this.
        if (op === '$rename') ***REMOVED***
          hasKeys = true;
          continue;
        ***REMOVED***

        try ***REMOVED***
          obj[key] = castUpdateVal(schematype, val, op, key, context);
        ***REMOVED*** catch (error) ***REMOVED***
          aggregatedError = _handleCastError(error, context, key, aggregatedError);
        ***REMOVED***

        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') ***REMOVED***
          obj[key] = ***REMOVED*** $each: obj[key] ***REMOVED***;
        ***REMOVED***

        if (options.omitUndefined && obj[key] === void 0) ***REMOVED***
          delete obj[key];
          continue;
        ***REMOVED***

        hasKeys = true;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  if (aggregatedError != null) ***REMOVED***
    throw aggregatedError;
  ***REMOVED***

  return hasKeys;
***REMOVED***

/*!
 * ignore
 */

function _handleCastError(error, query, key, aggregatedError) ***REMOVED***
  if (typeof query !== 'object' || !query.options.multipleCastError) ***REMOVED***
    throw error;
  ***REMOVED***
  aggregatedError = aggregatedError || new ValidationError();
  aggregatedError.addError(key, error);
  return aggregatedError;
***REMOVED***

/*!
 * These operators should be cast to numbers instead
 * of their path schema type.
 */

var numberOps = ***REMOVED***
  $pop: 1,
  $unset: 1,
  $inc: 1
***REMOVED***;

/*!
 * These operators require casting docs
 * to real Documents for Update operations.
 */

var castOps = ***REMOVED***
  $push: 1,
  $addToSet: 1,
  $set: 1,
  $setOnInsert: 1
***REMOVED***;

/*!
 * ignore
 */

var overwriteOps = ***REMOVED***
  $set: 1,
  $setOnInsert: 1
***REMOVED***;

/*!
 * Casts `val` according to `schema` and atomic `op`.
 *
 * @param ***REMOVED***SchemaType***REMOVED*** schema
 * @param ***REMOVED***Object***REMOVED*** val
 * @param ***REMOVED***String***REMOVED*** op - the atomic operator ($pull, $set, etc)
 * @param ***REMOVED***String***REMOVED*** $conditional
 * @param ***REMOVED***Query***REMOVED*** context
 * @api private
 */

function castUpdateVal(schema, val, op, $conditional, context) ***REMOVED***
  if (!schema) ***REMOVED***
    // non-existing schema path
    return op in numberOps
      ? Number(val)
      : val;
  ***REMOVED***

  var cond = schema.caster && op in castOps &&
      (utils.isObject(val) || Array.isArray(val));
  if (cond) ***REMOVED***
    // Cast values for ops that add data to MongoDB.
    // Ensures embedded documents get ObjectIds etc.
    var tmp = schema.cast(val);
    if (Array.isArray(val)) ***REMOVED***
      val = tmp;
    ***REMOVED*** else if (Array.isArray(tmp)) ***REMOVED***
      val = tmp[0];
    ***REMOVED*** else ***REMOVED***
      val = tmp;
    ***REMOVED***
    return val;
  ***REMOVED***

  if (op in numberOps) ***REMOVED***
    if (op === '$inc') ***REMOVED***
      return schema.castForQueryWrapper(***REMOVED*** val: val, context: context ***REMOVED***);
    ***REMOVED***
    return Number(val);
  ***REMOVED***
  if (op === '$currentDate') ***REMOVED***
    if (typeof val === 'object') ***REMOVED***
      return ***REMOVED***$type: val.$type***REMOVED***;
    ***REMOVED***
    return Boolean(val);
  ***REMOVED***

  if (/^\$/.test($conditional)) ***REMOVED***
    return schema.castForQueryWrapper(***REMOVED***
      $conditional: $conditional,
      val: val,
      context: context
    ***REMOVED***);
  ***REMOVED***

  if (overwriteOps[op]) ***REMOVED***
    return schema.castForQueryWrapper(***REMOVED***
      val: val,
      context: context,
      $skipQueryCastForUpdate: val != null && schema.$isMongooseArray
    ***REMOVED***);
  ***REMOVED***

  return schema.castForQueryWrapper(***REMOVED*** val: val, context: context ***REMOVED***);
***REMOVED***
