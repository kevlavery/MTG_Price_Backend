'use strict';

var defineKey = require('../document/compile').defineKey;
var utils = require('../../utils');

var CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = ***REMOVED***
  toJSON: true,
  toObject: true,
  _id: true,
  id: true
***REMOVED***;

/*!
 * ignore
 */

module.exports = function discriminator(model, name, schema, tiedValue) ***REMOVED***
  if (!(schema && schema.instanceOfSchema)) ***REMOVED***
    throw new Error('You must pass a valid discriminator Schema');
  ***REMOVED***

  if (model.base && model.base.options.applyPluginsToDiscriminators) ***REMOVED***
    model.base._applyPlugins(schema);
  ***REMOVED***

  if (model.schema.discriminatorMapping &&
      !model.schema.discriminatorMapping.isRoot) ***REMOVED***
    throw new Error('Discriminator "' + name +
        '" can only be a discriminator of the root model');
  ***REMOVED***

  var key = model.schema.options.discriminatorKey;

  var baseSchemaAddition = ***REMOVED******REMOVED***;
  baseSchemaAddition[key] = ***REMOVED***
    default: void 0,
    select: true,
    $skipDiscriminatorCheck: true
  ***REMOVED***;
  baseSchemaAddition[key][model.schema.options.typeKey] = String;
  model.schema.add(baseSchemaAddition);
  defineKey(key, null, model.prototype, null, [key], model.schema.options);

  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) ***REMOVED***
    throw new Error('Discriminator "' + name +
        '" cannot have field with name "' + key + '"');
  ***REMOVED***

  var value = name;
  if (typeof tiedValue == 'string' && tiedValue.length) ***REMOVED***
    value = tiedValue;
  ***REMOVED***

  function merge(schema, baseSchema) ***REMOVED***
    if (baseSchema.paths._id &&
        baseSchema.paths._id.options &&
        !baseSchema.paths._id.options.auto) ***REMOVED***
      var originalSchema = schema;
      utils.merge(schema, originalSchema);
      delete schema.paths._id;
      delete schema.tree._id;
    ***REMOVED***

    // Find conflicting paths: if something is a path in the base schema
    // and a nested path in the child schema, overwrite the base schema path.
    // See gh-6076
    var baseSchemaPaths = Object.keys(baseSchema.paths);
    var conflictingPaths = [];
    for (i = 0; i < baseSchemaPaths.length; ++i) ***REMOVED***
      if (schema.nested[baseSchemaPaths[i]]) ***REMOVED***
        conflictingPaths.push(baseSchemaPaths[i]);
      ***REMOVED***
    ***REMOVED***

    utils.merge(schema, baseSchema, ***REMOVED***
      omit: ***REMOVED*** discriminators: true ***REMOVED***,
      omitNested: conflictingPaths.reduce((cur, path) => ***REMOVED***
        cur['tree.' + path] = true;
        return cur;
      ***REMOVED***, ***REMOVED******REMOVED***)
    ***REMOVED***);

    // Clean up conflicting paths _after_ merging re: gh-6076
    for (i = 0; i < conflictingPaths.length; ++i) ***REMOVED***
      delete schema.paths[conflictingPaths[i]];
    ***REMOVED***

    var obj = ***REMOVED******REMOVED***;
    obj[key] = ***REMOVED***
      default: value,
      select: true,
      set: function(newName) ***REMOVED***
        if (newName === value) ***REMOVED***
          return value;
        ***REMOVED***
        throw new Error('Can\'t set discriminator key "' + key + '"');
      ***REMOVED***,
      $skipDiscriminatorCheck: true
    ***REMOVED***;
    obj[key][schema.options.typeKey] = String;
    schema.add(obj);
    schema.discriminatorMapping = ***REMOVED***key: key, value: value, isRoot: false***REMOVED***;

    if (baseSchema.options.collection) ***REMOVED***
      schema.options.collection = baseSchema.options.collection;
    ***REMOVED***

    var toJSON = schema.options.toJSON;
    var toObject = schema.options.toObject;
    var _id = schema.options._id;
    var id = schema.options.id;

    var keys = Object.keys(schema.options);
    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;

    for (var i = 0; i < keys.length; ++i) ***REMOVED***
      var _key = keys[i];
      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) ***REMOVED***
        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) ***REMOVED***
          throw new Error('Can\'t customize discriminator option ' + _key +
              ' (can only modify ' +
              Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +
              ')');
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    schema.options = utils.clone(baseSchema.options);
    if (toJSON) schema.options.toJSON = toJSON;
    if (toObject) schema.options.toObject = toObject;
    if (typeof _id !== 'undefined') ***REMOVED***
      schema.options._id = _id;
    ***REMOVED***
    schema.options.id = id;
    schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);

    schema.plugins = Array.prototype.slice(baseSchema.plugins);
    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);
    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema
  ***REMOVED***

  // merges base schema into new discriminator schema and sets new type field.
  merge(schema, model.schema);

  if (!model.discriminators) ***REMOVED***
    model.discriminators = ***REMOVED******REMOVED***;
  ***REMOVED***

  if (!model.schema.discriminatorMapping) ***REMOVED***
    model.schema.discriminatorMapping = ***REMOVED***key: key, value: null, isRoot: true***REMOVED***;
  ***REMOVED***
  if (!model.schema.discriminators) ***REMOVED***
    model.schema.discriminators = ***REMOVED******REMOVED***;
  ***REMOVED***

  model.schema.discriminators[name] = schema;

  if (model.discriminators[name]) ***REMOVED***
    throw new Error('Discriminator with name "' + name + '" already exists');
  ***REMOVED***

  return schema;
***REMOVED***;
