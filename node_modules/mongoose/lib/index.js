'use strict';

/*!
 * Module dependencies.
 */

const Schema = require('./schema');
const SchemaType = require('./schematype');
const VirtualType = require('./virtualtype');
const STATES = require('./connectionstate');
const Types = require('./types');
const Query = require('./query');
const Model = require('./model');
const Document = require('./document');
const legacyPluralize = require('mongoose-legacy-pluralize');
const utils = require('./utils');
const pkg = require('../package.json');

const removeSubdocs = require('./plugins/removeSubdocs');
const saveSubdocs = require('./plugins/saveSubdocs');
const validateBeforeSave = require('./plugins/validateBeforeSave');

const Aggregate = require('./aggregate');
const PromiseProvider = require('./promise_provider');
const shardingPlugin = require('./plugins/sharding');

/**
 * Mongoose constructor.
 *
 * The exports object of the `mongoose` module is an instance of this class.
 * Most apps will only use this one instance.
 *
 * @api public
 */

function Mongoose() ***REMOVED***
  this.connections = [];
  this.models = ***REMOVED******REMOVED***;
  this.modelSchemas = ***REMOVED******REMOVED***;
  // default global options
  this.options = ***REMOVED***
    pluralization: true
  ***REMOVED***;
  var conn = this.createConnection(); // default connection
  conn.models = this.models;

  this._pluralize = legacyPluralize;

  Object.defineProperty(this, 'plugins', ***REMOVED***
    configurable: false,
    enumerable: true,
    writable: false,
    value: [
      [saveSubdocs, ***REMOVED*** deduplicate: true ***REMOVED***],
      [validateBeforeSave, ***REMOVED*** deduplicate: true ***REMOVED***],
      [shardingPlugin, ***REMOVED*** deduplicate: true ***REMOVED***],
      [removeSubdocs, ***REMOVED*** deduplicate: true ***REMOVED***]
    ]
  ***REMOVED***);
***REMOVED***

/**
 * Expose connection states for user-land
 *
 */
Mongoose.prototype.STATES = STATES;

/**
 * Sets mongoose options
 *
 * ####Example:
 *
 *     mongoose.set('test', value) // sets the 'test' option to `value`
 *
 *     mongoose.set('debug', true) // enable logging collection methods + arguments to the console
 *
 *     mongoose.set('debug', function(collectionName, methodName, arg1, arg2...) ***REMOVED******REMOVED***); // use custom function to log collection methods + arguments
 *
 * Currently supported options are:
 * - 'debug': prints the operations mongoose sends to MongoDB to the console
 * - 'bufferCommands': enable/disable mongoose's buffering mechanism for all connections and models
 * - 'useFindAndModify': true by default. Set to `false` to make `findOneAndUpdate()` and `findOneAndRemove()` use native `findOneAndUpdate()` rather than `findAndModify()`.
 * - 'cloneSchemas': false by default. Set to `true` to `clone()` all schemas before compiling into a model.
 *
 * @param ***REMOVED***String***REMOVED*** key
 * @param ***REMOVED***String|Function|Boolean***REMOVED*** value
 * @api public
 */

Mongoose.prototype.set = function(key, value) ***REMOVED***
  if (arguments.length === 1) ***REMOVED***
    return this.options[key];
  ***REMOVED***

  this.options[key] = value;
  return this;
***REMOVED***;

/**
 * Gets mongoose options
 *
 * ####Example:
 *
 *     mongoose.get('test') // returns the 'test' value
 *
 * @param ***REMOVED***String***REMOVED*** key
 * @method get
 * @api public
 */

Mongoose.prototype.get = Mongoose.prototype.set;

/**
 * Creates a Connection instance.
 *
 * Each `connection` instance maps to a single database. This method is helpful when mangaging multiple db connections.
 *
 * If arguments are passed, they are proxied to either [Connection#open](#connection_Connection-open) or [Connection#openSet](#connection_Connection-openSet) appropriately. This means we can pass `db`, `server`, and `replset` options to the driver. _Note that the `safe` option specified in your schema will overwrite the `safe` db option specified here unless you set your schemas `safe` option to `undefined`. See [this](/docs/guide.html#safe) for more information._
 *
 * _Options passed take precedence over options included in connection strings._
 *
 * ####Example:
 *
 *     // with mongodb:// URI
 *     db = mongoose.createConnection('mongodb://user:pass@localhost:port/database');
 *
 *     // and options
 *     var opts = ***REMOVED*** db: ***REMOVED*** native_parser: true ***REMOVED******REMOVED***
 *     db = mongoose.createConnection('mongodb://user:pass@localhost:port/database', opts);
 *
 *     // replica sets
 *     db = mongoose.createConnection('mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/database');
 *
 *     // and options
 *     var opts = ***REMOVED*** replset: ***REMOVED*** strategy: 'ping', rs_name: 'testSet' ***REMOVED******REMOVED***
 *     db = mongoose.createConnection('mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/database', opts);
 *
 *     // with [host, database_name[, port] signature
 *     db = mongoose.createConnection('localhost', 'database', port)
 *
 *     // and options
 *     var opts = ***REMOVED*** server: ***REMOVED*** auto_reconnect: false ***REMOVED***, user: 'username', pass: 'mypassword' ***REMOVED***
 *     db = mongoose.createConnection('localhost', 'database', port, opts)
 *
 *     // initialize now, connect later
 *     db = mongoose.createConnection();
 *     db.open('localhost', 'database', port, [opts]);
 *
 * @param ***REMOVED***String***REMOVED*** [uri] a mongodb:// URI
 * @param ***REMOVED***Object***REMOVED*** [options] passed down to the [MongoDB driver's `connect()` function](http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html), except for 4 mongoose-specific options explained below.
 * @param ***REMOVED***String***REMOVED*** [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.
 * @param ***REMOVED***String***REMOVED*** [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.
 * @param ***REMOVED***Boolean***REMOVED*** [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.
 * @param ***REMOVED***Boolean***REMOVED*** [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](http://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.
 * @return ***REMOVED***Connection***REMOVED*** the created Connection object. Connections are thenable, so you can do `await mongoose.createConnection()`
 * @api public
 */

Mongoose.prototype.createConnection = function(uri, options, callback) ***REMOVED***
  var conn = new Connection(this);
  if (typeof options === 'function') ***REMOVED***
    callback = options;
    options = null;
  ***REMOVED***
  this.connections.push(conn);

  if (arguments.length > 0) ***REMOVED***
    return conn.openUri(uri, options, callback);
  ***REMOVED***

  return conn;
***REMOVED***;

/**
 * Opens the default mongoose connection.
 *
 * ####Example:
 *
 *     mongoose.connect('mongodb://user:pass@localhost:port/database');
 *
 *     // replica sets
 *     var uri = 'mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/mydatabase';
 *     mongoose.connect(uri);
 *
 *     // with options
 *     mongoose.connect(uri, options);
 *
 *     // optional callback that gets fired when initial connection completed
 *     var uri = 'mongodb://nonexistent.domain:27000';
 *     mongoose.connect(uri, function(error) ***REMOVED***
 *       // if error is truthy, the initial connection failed.
 *     ***REMOVED***)
 *
 * @param ***REMOVED***String***REMOVED*** uri(s)
 * @param ***REMOVED***Object***REMOVED*** [options] passed down to the [MongoDB driver's `connect()` function](http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html), except for 4 mongoose-specific options explained below.
 * @param ***REMOVED***String***REMOVED*** [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.
 * @param ***REMOVED***String***REMOVED*** [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.
 * @param ***REMOVED***Boolean***REMOVED*** [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.
 * @param ***REMOVED***Boolean***REMOVED*** [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](http://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @see Mongoose#createConnection #index_Mongoose-createConnection
 * @api public
 * @return ***REMOVED***Promise***REMOVED*** resolves to `this` if connection succeeded
 */

Mongoose.prototype.connect = function() ***REMOVED***
  var conn = this.connection;
  return conn.openUri(arguments[0], arguments[1], arguments[2]).then(() => this);
***REMOVED***;

/**
 * Runs `.close()` on all connections in parallel.
 *
 * @param ***REMOVED***Function***REMOVED*** [callback] called after all connection close, or when first error occurred.
 * @return ***REMOVED***Promise***REMOVED*** resolves when all connections are closed, or rejects with the first error that occurred.
 * @api public
 */

Mongoose.prototype.disconnect = function(callback) ***REMOVED***
  return utils.promiseOrCallback(callback, cb => ***REMOVED***
    var remaining = this.connections.length;
    if (remaining <= 0) ***REMOVED***
      return cb(null);
    ***REMOVED***
    this.connections.forEach(conn => ***REMOVED***
      conn.close(function(error) ***REMOVED***
        if (error) ***REMOVED***
          return cb(error);
        ***REMOVED***
        if (!--remaining) ***REMOVED***
          cb(null);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Getter/setter around function for pluralizing collection names.
 *
 * @param ***REMOVED***Function|null***REMOVED*** [fn] overwrites the function used to pluralize collection names
 * @return ***REMOVED***Function|null***REMOVED*** the current function used to pluralize collection names, defaults to the legacy function from `mongoose-legacy-pluralize`.
 * @api public
 */

Mongoose.prototype.pluralize = function(fn) ***REMOVED***
  if (arguments.length > 0) ***REMOVED***
    this._pluralize = fn;
  ***REMOVED***
  return this._pluralize;
***REMOVED***;

/**
 * Defines a model or retrieves it.
 *
 * Models defined on the `mongoose` instance are available to all connection created by the same `mongoose` instance.
 *
 * ####Example:
 *
 *     var mongoose = require('mongoose');
 *
 *     // define an Actor model with this mongoose instance
 *     mongoose.model('Actor', new Schema(***REMOVED*** name: String ***REMOVED***));
 *
 *     // create a new connection
 *     var conn = mongoose.createConnection(..);
 *
 *     // retrieve the Actor model
 *     var Actor = conn.model('Actor');
 *
 * _When no `collection` argument is passed, Mongoose uses the model name. If you don't like this behavior, either pass a collection name, use `mongoose.pluralize()`, or set your schemas collection name option._
 *
 * ####Example:
 *
 *     var schema = new Schema(***REMOVED*** name: String ***REMOVED***, ***REMOVED*** collection: 'actor' ***REMOVED***);
 *
 *     // or
 *
 *     schema.set('collection', 'actor');
 *
 *     // or
 *
 *     var collectionName = 'actor'
 *     var M = mongoose.model('Actor', schema, collectionName)
 *
 * @param ***REMOVED***String|Function***REMOVED*** name model name or class extending Model
 * @param ***REMOVED***Schema***REMOVED*** [schema]
 * @param ***REMOVED***String***REMOVED*** [collection] name (optional, inferred from model name)
 * @param ***REMOVED***Boolean***REMOVED*** [skipInit] whether to skip initialization (defaults to false)
 * @return ***REMOVED***Model***REMOVED***
 * @api public
 */

Mongoose.prototype.model = function(name, schema, collection, skipInit) ***REMOVED***
  let model;
  if (typeof name === 'function') ***REMOVED***
    model = name;
    name = model.name;
    if (!(model.prototype instanceof Model)) ***REMOVED***
      throw new mongoose.Error('The provided class ' + name + ' must extend Model');
    ***REMOVED***
  ***REMOVED***

  if (typeof schema === 'string') ***REMOVED***
    collection = schema;
    schema = false;
  ***REMOVED***

  if (utils.isObject(schema) && !(schema.instanceOfSchema)) ***REMOVED***
    schema = new Schema(schema);
  ***REMOVED***
  if (schema && !schema.instanceOfSchema) ***REMOVED***
    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +
      'schema or a POJO');
  ***REMOVED***

  if (typeof collection === 'boolean') ***REMOVED***
    skipInit = collection;
    collection = null;
  ***REMOVED***

  // handle internal options from connection.model()
  let options;
  if (skipInit && utils.isObject(skipInit)) ***REMOVED***
    options = skipInit;
    skipInit = true;
  ***REMOVED*** else ***REMOVED***
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  // look up schema for the collection.
  if (!this.modelSchemas[name]) ***REMOVED***
    if (schema) ***REMOVED***
      // cache it so we only apply plugins once
      this.modelSchemas[name] = schema;
    ***REMOVED*** else ***REMOVED***
      throw new mongoose.Error.MissingSchemaError(name);
    ***REMOVED***
  ***REMOVED***

  const originalSchema = schema;
  if (schema) ***REMOVED***
    if (this.get('cloneSchemas')) ***REMOVED***
      schema = schema.clone();
    ***REMOVED***
    this._applyPlugins(schema);
  ***REMOVED***

  let sub;

  // connection.model() may be passing a different schema for
  // an existing model name. in this case don't read from cache.
  if (this.models[name] && options.cache !== false) ***REMOVED***
    if (originalSchema && originalSchema.instanceOfSchema && originalSchema !== this.models[name].schema) ***REMOVED***
      throw new mongoose.Error.OverwriteModelError(name);
    ***REMOVED***

    if (collection) ***REMOVED***
      // subclass current model with alternate collection
      model = this.models[name];
      schema = model.prototype.schema;
      sub = model.__subclass(this.connection, schema, collection);
      // do not cache the sub model
      return sub;
    ***REMOVED***

    return this.models[name];
  ***REMOVED***

  // ensure a schema exists
  if (!schema) ***REMOVED***
    schema = this.modelSchemas[name];
    if (!schema) ***REMOVED***
      throw new mongoose.Error.MissingSchemaError(name);
    ***REMOVED***
  ***REMOVED***

  // Apply relevant "global" options to the schema
  if (!('pluralization' in schema.options)) ***REMOVED***
    schema.options.pluralization = this.options.pluralization;
  ***REMOVED***

  if (!collection) ***REMOVED***
    collection = schema.get('collection') ||
      utils.toCollectionName(name, this.pluralize());
  ***REMOVED***

  const connection = options.connection || this.connection;
  model = this.Model.compile(model || name, schema, collection, connection, this);

  if (!skipInit) ***REMOVED***
    model.init();
  ***REMOVED***

  if (options.cache === false) ***REMOVED***
    return model;
  ***REMOVED***

  this.models[name] = model;
  return this.models[name];
***REMOVED***;

/**
 * Returns an array of model names created on this instance of Mongoose.
 *
 * ####Note:
 *
 * _Does not include names of models created using `connection.model()`._
 *
 * @api public
 * @return ***REMOVED***Array***REMOVED***
 */

Mongoose.prototype.modelNames = function() ***REMOVED***
  var names = Object.keys(this.models);
  return names;
***REMOVED***;

/**
 * Applies global plugins to `schema`.
 *
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @api private
 */

Mongoose.prototype._applyPlugins = function(schema) ***REMOVED***
  if (schema.$globalPluginsApplied) ***REMOVED***
    return;
  ***REMOVED***
  var i;
  var len;
  for (i = 0, len = this.plugins.length; i < len; ++i) ***REMOVED***
    schema.plugin(this.plugins[i][0], this.plugins[i][1]);
  ***REMOVED***
  schema.$globalPluginsApplied = true;
  for (i = 0, len = schema.childSchemas.length; i < len; ++i) ***REMOVED***
    this._applyPlugins(schema.childSchemas[i].schema);
  ***REMOVED***
***REMOVED***;

/**
 * Declares a global plugin executed on all Schemas.
 *
 * Equivalent to calling `.plugin(fn)` on each Schema you create.
 *
 * @param ***REMOVED***Function***REMOVED*** fn plugin callback
 * @param ***REMOVED***Object***REMOVED*** [opts] optional options
 * @return ***REMOVED***Mongoose***REMOVED*** this
 * @see plugins ./plugins.html
 * @api public
 */

Mongoose.prototype.plugin = function(fn, opts) ***REMOVED***
  this.plugins.push([fn, opts]);
  return this;
***REMOVED***;

/**
 * The default connection of the mongoose module.
 *
 * ####Example:
 *
 *     var mongoose = require('mongoose');
 *     mongoose.connect(...);
 *     mongoose.connection.on('error', cb);
 *
 * This is the connection used by default for every model created using [mongoose.model](#index_Mongoose-model).
 *
 * @memberOf Mongoose
 * @property connection
 * @return ***REMOVED***Connection***REMOVED***
 * @api public
 */

Mongoose.prototype.__defineGetter__('connection', function() ***REMOVED***
  return this.connections[0];
***REMOVED***);

Mongoose.prototype.__defineSetter__('connection', function(v) ***REMOVED***
  if (v instanceof Connection) ***REMOVED***
    this.connections[0] = v;
    this.models = v.models;
  ***REMOVED***
***REMOVED***);

/*!
 * Driver dependent APIs
 */

var driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';

/*!
 * Connection
 */

var Connection = require(driver + '/connection');

/*!
 * Collection
 */

var Collection = require(driver + '/collection');

/**
 * The Mongoose Aggregate constructor
 *
 * @method Aggregate
 * @api public
 */

Mongoose.prototype.Aggregate = Aggregate;

/**
 * The Mongoose Collection constructor
 *
 * @method Collection
 * @api public
 */

Mongoose.prototype.Collection = Collection;

/**
 * The Mongoose [Connection](#connection_Connection) constructor
 *
 * @memberOf Mongoose
 * @method Connection
 * @api public
 */

Mongoose.prototype.Connection = Connection;

/**
 * The Mongoose version
 *
 * @property version
 * @api public
 */

Mongoose.prototype.version = pkg.version;

/**
 * The Mongoose constructor
 *
 * The exports of the mongoose module is an instance of this class.
 *
 * ####Example:
 *
 *     var mongoose = require('mongoose');
 *     var mongoose2 = new mongoose.Mongoose();
 *
 * @method Mongoose
 * @api public
 */

Mongoose.prototype.Mongoose = Mongoose;

/**
 * The Mongoose [Schema](#schema_Schema) constructor
 *
 * ####Example:
 *
 *     var mongoose = require('mongoose');
 *     var Schema = mongoose.Schema;
 *     var CatSchema = new Schema(..);
 *
 * @method Schema
 * @api public
 */

Mongoose.prototype.Schema = Schema;

/**
 * The Mongoose [SchemaType](#schematype_SchemaType) constructor
 *
 * @method SchemaType
 * @api public
 */

Mongoose.prototype.SchemaType = SchemaType;

/**
 * The various Mongoose SchemaTypes.
 *
 * ####Note:
 *
 * _Alias of mongoose.Schema.Types for backwards compatibility._
 *
 * @property SchemaTypes
 * @see Schema.SchemaTypes #schema_Schema.Types
 * @api public
 */

Mongoose.prototype.SchemaTypes = Schema.Types;

/**
 * The Mongoose [VirtualType](#virtualtype_VirtualType) constructor
 *
 * @method VirtualType
 * @api public
 */

Mongoose.prototype.VirtualType = VirtualType;

/**
 * The various Mongoose Types.
 *
 * ####Example:
 *
 *     var mongoose = require('mongoose');
 *     var array = mongoose.Types.Array;
 *
 * ####Types:
 *
 * - [ObjectId](#types-objectid-js)
 * - [Buffer](#types-buffer-js)
 * - [SubDocument](#types-embedded-js)
 * - [Array](#types-array-js)
 * - [DocumentArray](#types-documentarray-js)
 *
 * Using this exposed access to the `ObjectId` type, we can construct ids on demand.
 *
 *     var ObjectId = mongoose.Types.ObjectId;
 *     var id1 = new ObjectId;
 *
 * @property Types
 * @api public
 */

Mongoose.prototype.Types = Types;

/**
 * The Mongoose [Query](#query_Query) constructor.
 *
 * @method Query
 * @api public
 */

Mongoose.prototype.Query = Query;

/**
 * The Mongoose [Promise](#promise_Promise) constructor.
 *
 * @memberOf Mongoose
 * @property Promise
 * @api public
 */

Object.defineProperty(Mongoose.prototype, 'Promise', ***REMOVED***
  get: function() ***REMOVED***
    return PromiseProvider.get();
  ***REMOVED***,
  set: function(lib) ***REMOVED***
    PromiseProvider.set(lib);
  ***REMOVED***
***REMOVED***);

/**
 * Storage layer for mongoose promises
 *
 * @method PromiseProvider
 * @api public
 */

Mongoose.prototype.PromiseProvider = PromiseProvider;

/**
 * The Mongoose [Model](#model_Model) constructor.
 *
 * @method Model
 * @api public
 */

Mongoose.prototype.Model = Model;

/**
 * The Mongoose [Document](#document-js) constructor.
 *
 * @method Document
 * @api public
 */

Mongoose.prototype.Document = Document;

/**
 * The Mongoose DocumentProvider constructor.
 *
 * @method DocumentProvider
 * @api public
 */

Mongoose.prototype.DocumentProvider = require('./document_provider');

/**
 * The [MongooseError](#error_MongooseError) constructor.
 *
 * @method Error
 * @api public
 */

Mongoose.prototype.Error = require('./error');

/**
 * The Mongoose CastError constructor
 *
 * @method CastError
 * @param ***REMOVED***String***REMOVED*** type The name of the type
 * @param ***REMOVED***Any***REMOVED*** value The value that failed to cast
 * @param ***REMOVED***String***REMOVED*** path The path `a.b.c` in the doc where this cast error occurred
 * @param ***REMOVED***Error***REMOVED*** [reason] The original error that was thrown
 * @api public
 */

Mongoose.prototype.CastError = require('./error/cast');

/**
 * The [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver Mongoose uses.
 *
 * @property mongo
 * @api public
 */

Mongoose.prototype.mongo = require('mongodb');

/**
 * The [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.
 *
 * @property mquery
 * @api public
 */

Mongoose.prototype.mquery = require('mquery');

/*!
 * The exports object is an instance of Mongoose.
 *
 * @api public
 */

var mongoose = module.exports = exports = new Mongoose;
