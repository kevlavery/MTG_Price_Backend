'use strict';

/*!
 * Module dependencies.
 */

const EventEmitter = require('events').EventEmitter;
const Kareem = require('kareem');
const SchemaType = require('./schematype');
const VirtualType = require('./virtualtype');
const get = require('lodash.get');
const getIndexes = require('./helpers/schema/getIndexes');
const mpath = require('mpath');
const readPref = require('./drivers').ReadPreference;
const utils = require('./utils');

let MongooseTypes;

/**
 * Schema constructor.
 *
 * ####Example:
 *
 *     var child = new Schema(***REMOVED*** name: String ***REMOVED***);
 *     var schema = new Schema(***REMOVED*** name: String, age: Number, children: [child] ***REMOVED***);
 *     var Tree = mongoose.model('Tree', schema);
 *
 *     // setting schema options
 *     new Schema(***REMOVED*** name: String ***REMOVED***, ***REMOVED*** _id: false, autoIndex: false ***REMOVED***)
 *
 * ####Options:
 *
 * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)
 * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true
 * - [capped](/docs/guide.html#capped): bool - defaults to false
 * - [collection](/docs/guide.html#collection): string - no default
 * - [id](/docs/guide.html#id): bool - defaults to true
 * - [_id](/docs/guide.html#_id): bool - defaults to true
 * - `minimize`: bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true
 * - [read](/docs/guide.html#read): string
 * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)
 * - [shardKey](/docs/guide.html#shardKey): bool - defaults to `null`
 * - [strict](/docs/guide.html#strict): bool - defaults to true
 * - [toJSON](/docs/guide.html#toJSON) - object - no default
 * - [toObject](/docs/guide.html#toObject) - object - no default
 * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'
 * - [useNestedStrict](/docs/guide.html#useNestedStrict) - boolean - defaults to false
 * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`
 * - [versionKey](/docs/guide.html#versionKey): string - defaults to "__v"
 * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)
 *
 * ####Note:
 *
 * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._
 *
 * @param ***REMOVED***Object***REMOVED*** definition
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
 * @event `init`: Emitted after the schema is compiled into a `Model`.
 * @api public
 */

function Schema(obj, options) ***REMOVED***
  if (!(this instanceof Schema)) ***REMOVED***
    return new Schema(obj, options);
  ***REMOVED***

  this.obj = obj;
  this.paths = ***REMOVED******REMOVED***;
  this.aliases = ***REMOVED******REMOVED***;
  this.subpaths = ***REMOVED******REMOVED***;
  this.virtuals = ***REMOVED******REMOVED***;
  this.singleNestedPaths = ***REMOVED******REMOVED***;
  this.nested = ***REMOVED******REMOVED***;
  this.inherits = ***REMOVED******REMOVED***;
  this.callQueue = [];
  this._indexes = [];
  this.methods = ***REMOVED******REMOVED***;
  this.methodOptions = ***REMOVED******REMOVED***;
  this.statics = ***REMOVED******REMOVED***;
  this.tree = ***REMOVED******REMOVED***;
  this.query = ***REMOVED******REMOVED***;
  this.childSchemas = [];
  this.plugins = [];

  this.s = ***REMOVED***
    hooks: new Kareem()
  ***REMOVED***;

  this.options = this.defaultOptions(options);

  // build paths
  if (obj) ***REMOVED***
    this.add(obj);
  ***REMOVED***

  // check if _id's value is a subdocument (gh-2276)
  var _idSubDoc = obj && obj._id && utils.isObject(obj._id);

  // ensure the documents get an auto _id unless disabled
  var auto_id = !this.paths['_id'] &&
      (!this.options.noId && this.options._id) && !_idSubDoc;

  if (auto_id) ***REMOVED***
    var _obj = ***REMOVED***_id: ***REMOVED***auto: true***REMOVED******REMOVED***;
    _obj._id[this.options.typeKey] = Schema.ObjectId;
    this.add(_obj);
  ***REMOVED***

  if (this.options.timestamps) ***REMOVED***
    this.setupTimestamp(this.options.timestamps);
  ***REMOVED***
***REMOVED***

/*!
 * Create virtual properties with alias field
 */
function aliasFields(schema, paths) ***REMOVED***
  paths = paths || Object.keys(schema.paths);
  for (const path of paths) ***REMOVED***
    const options = get(schema.paths[path], 'options');
    if (options == null) ***REMOVED***
      continue;
    ***REMOVED***

    const prop = schema.paths[path].path;
    const alias = options.alias;

    if (!alias) ***REMOVED***
      continue;
    ***REMOVED***

    if (typeof alias !== 'string') ***REMOVED***
      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);
    ***REMOVED***

    schema.aliases[alias] = prop;

    schema.
      virtual(alias).
      get((function(p) ***REMOVED***
        return function() ***REMOVED***
          if (typeof this.get === 'function') ***REMOVED***
            return this.get(p);
          ***REMOVED***
          return this[p];
        ***REMOVED***;
      ***REMOVED***)(prop)).
      set((function(p) ***REMOVED***
        return function(v) ***REMOVED***
          return this.set(p, v);
        ***REMOVED***;
      ***REMOVED***)(prop));
  ***REMOVED***
***REMOVED***

/*!
 * Inherit from EventEmitter.
 */
Schema.prototype = Object.create(EventEmitter.prototype);
Schema.prototype.constructor = Schema;
Schema.prototype.instanceOfSchema = true;

/**
 * Array of child schemas (from document arrays and single nested subdocs)
 * and their corresponding compiled models. Each element of the array is
 * an object with 2 properties: `schema` and `model`.
 *
 * This property is typically only useful for plugin authors and advanced users.
 * You do not need to interact with this property at all to use mongoose.
 *
 * @api public
 * @property childSchemas
 * @memberOf Schema
 * @instance
 */

Object.defineProperty(Schema.prototype, 'childSchemas', ***REMOVED***
  configurable: false,
  enumerable: true,
  writable: true
***REMOVED***);

/**
 * The original object passed to the schema constructor
 *
 * ####Example:
 *
 *     var schema = new Schema(***REMOVED*** a: String ***REMOVED***).add(***REMOVED*** b: String ***REMOVED***);
 *     schema.obj; // ***REMOVED*** a: String ***REMOVED***
 *
 * @api public
 * @property obj
 * @memberOf Schema
 * @instance
 */

Schema.prototype.obj;

/**
 * Schema as flat paths
 *
 * ####Example:
 *     ***REMOVED***
 *         '_id'        : SchemaType,
 *       , 'nested.key' : SchemaType,
 *     ***REMOVED***
 *
 * @api private
 * @property paths
 * @memberOf Schema
 * @instance
 */

Schema.prototype.paths;

/**
 * Schema as a tree
 *
 * ####Example:
 *     ***REMOVED***
 *         '_id'     : ObjectId
 *       , 'nested'  : ***REMOVED***
 *             'key' : String
 *         ***REMOVED***
 *     ***REMOVED***
 *
 * @api private
 * @property tree
 * @memberOf Schema
 * @instance
 */

Schema.prototype.tree;

/**
 * Returns a deep copy of the schema
 *
 * @return ***REMOVED***Schema***REMOVED*** the cloned schema
 * @api public
 * @memberOf Schema
 * @instance
 */

Schema.prototype.clone = function() ***REMOVED***
  var s = new Schema(***REMOVED******REMOVED***, this._userProvidedOptions);
  s.obj = this.obj;
  s.options = utils.clone(this.options);
  s.callQueue = this.callQueue.map(function(f) ***REMOVED*** return f; ***REMOVED***);
  s.methods = utils.clone(this.methods);
  s.methodOptions = utils.clone(this.methodOptions);
  s.statics = utils.clone(this.statics);
  s.query = utils.clone(this.query);
  s.plugins = Array.prototype.slice.call(this.plugins);
  s._indexes = utils.clone(this._indexes);
  s.s.hooks = this.s.hooks.clone();
  s._originalSchema = this._originalSchema == null ?
    this._originalSchema :
    this._originalSchema.clone();

  s.tree = utils.clone(this.tree);
  s.paths = utils.clone(this.paths);
  s.nested = utils.clone(this.nested);
  s.subpaths = utils.clone(this.subpaths);
  s.childSchemas = this.childSchemas.slice();
  s.singleNestedPaths = utils.clone(this.singleNestedPaths);

  s.virtuals = utils.clone(this.virtuals);
  s.$globalPluginsApplied = this.$globalPluginsApplied;
  s.$isRootDiscriminator = this.$isRootDiscriminator;

  if (this.discriminatorMapping != null) ***REMOVED***
    s.discriminatorMapping = Object.assign(***REMOVED******REMOVED***, this.discriminatorMapping);
  ***REMOVED***
  if (s.discriminators != null) ***REMOVED***
    s.discriminators = Object.assign(***REMOVED******REMOVED***, this.discriminators);
  ***REMOVED***

  s.aliases = Object.assign(***REMOVED******REMOVED***, this.aliases);

  // Bubble up `init` for backwards compat
  s.on('init', v => this.emit('init', v));

  return s;
***REMOVED***;

/**
 * Returns default options for this schema, merged with `options`.
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Object***REMOVED***
 * @api private
 */

Schema.prototype.defaultOptions = function(options) ***REMOVED***
  if (options && options.safe === false) ***REMOVED***
    options.safe = ***REMOVED***w: 0***REMOVED***;
  ***REMOVED***

  if (options && options.safe && options.safe.w === 0) ***REMOVED***
    // if you turn off safe writes, then versioning goes off as well
    options.versionKey = false;
  ***REMOVED***

  this._userProvidedOptions = options == null ? ***REMOVED******REMOVED*** : utils.clone(options);

  options = utils.options(***REMOVED***
    strict: true,
    bufferCommands: true,
    capped: false, // ***REMOVED*** size, max, autoIndexId ***REMOVED***
    versionKey: '__v',
    discriminatorKey: '__t',
    minimize: true,
    autoIndex: null,
    shardKey: null,
    read: null,
    validateBeforeSave: true,
    // the following are only applied at construction time
    noId: false, // deprecated, use ***REMOVED*** _id: false ***REMOVED***
    _id: true,
    noVirtualId: false, // deprecated, use ***REMOVED*** id: false ***REMOVED***
    id: true,
    typeKey: 'type'
  ***REMOVED***, utils.clone(options));

  if (options.read) ***REMOVED***
    options.read = readPref(options.read);
  ***REMOVED***

  return options;
***REMOVED***;

/**
 * Adds key path / schema type pairs to this schema.
 *
 * ####Example:
 *
 *     var ToySchema = new Schema;
 *     ToySchema.add(***REMOVED*** name: 'string', color: 'string', price: 'number' ***REMOVED***);
 *
 * @param ***REMOVED***Object***REMOVED*** obj
 * @param ***REMOVED***String***REMOVED*** prefix
 * @api public
 */

Schema.prototype.add = function add(obj, prefix) ***REMOVED***
  prefix = prefix || '';
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; ++i) ***REMOVED***
    var key = keys[i];

    if (obj[key] == null) ***REMOVED***
      throw new TypeError('Invalid value for schema path `' + prefix + key + '`');
    ***REMOVED***

    if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) ***REMOVED***
      throw new TypeError('Invalid value for schema Array path `' + prefix + key + '`');
    ***REMOVED***

    if (utils.isObject(obj[key]) &&
        (!obj[key].constructor || utils.getFunctionName(obj[key].constructor) === 'Object') &&
        (!obj[key][this.options.typeKey] || (this.options.typeKey === 'type' && obj[key].type.type))) ***REMOVED***
      if (Object.keys(obj[key]).length) ***REMOVED***
        // nested object ***REMOVED*** last: ***REMOVED*** name: String ***REMOVED******REMOVED***
        this.nested[prefix + key] = true;
        this.add(obj[key], prefix + key + '.');
      ***REMOVED*** else ***REMOVED***
        if (prefix) ***REMOVED***
          this.nested[prefix.substr(0, prefix.length - 1)] = true;
        ***REMOVED***
        this.path(prefix + key, obj[key]); // mixed type
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if (prefix) ***REMOVED***
        this.nested[prefix.substr(0, prefix.length - 1)] = true;
      ***REMOVED***
      this.path(prefix + key, obj[key]);
    ***REMOVED***
  ***REMOVED***

  const addedKeys = Object.keys(obj).
    map(key => prefix ? prefix + key : key);
  aliasFields(this, addedKeys);
***REMOVED***;

/**
 * Reserved document keys.
 *
 * Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.
 *
 *      on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject
 *
 * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.
 *
 *      var schema = new Schema(..);
 *      schema.methods.init = function () ***REMOVED******REMOVED*** // potentially breaking
 */

Schema.reserved = Object.create(null);
Schema.prototype.reserved = Schema.reserved;
var reserved = Schema.reserved;
// Core object
reserved['prototype'] =
// EventEmitter
reserved.emit =
reserved.on =
reserved.once =
reserved.listeners =
reserved.removeListener =
// document properties and functions
reserved.collection =
reserved.db =
reserved.errors =
reserved.init =
reserved.isModified =
reserved.isNew =
reserved.get =
reserved.modelName =
reserved.save =
reserved.schema =
reserved.toObject =
reserved.validate =
reserved.remove =
// hooks.js
reserved._pres = reserved._posts = 1;

/*!
 * Document keys to print warnings for
 */

var warnings = ***REMOVED******REMOVED***;
warnings.increment = '`increment` should not be used as a schema path name ' +
    'unless you have disabled versioning.';

/**
 * Gets/sets schema paths.
 *
 * Sets a path (if arity 2)
 * Gets a path (if arity 1)
 *
 * ####Example
 *
 *     schema.path('name') // returns a SchemaType
 *     schema.path('name', Number) // changes the schemaType of `name` to Number
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @param ***REMOVED***Object***REMOVED*** constructor
 * @api public
 */

Schema.prototype.path = function(path, obj) ***REMOVED***
  if (obj === undefined) ***REMOVED***
    if (this.paths[path]) ***REMOVED***
      return this.paths[path];
    ***REMOVED***
    if (this.subpaths[path]) ***REMOVED***
      return this.subpaths[path];
    ***REMOVED***
    if (this.singleNestedPaths[path]) ***REMOVED***
      return this.singleNestedPaths[path];
    ***REMOVED***

    // Look for maps
    for (let _path of Object.keys(this.paths)) ***REMOVED***
      if (!_path.includes('.$*')) ***REMOVED***
        continue;
      ***REMOVED***
      const re = new RegExp('^' + _path.replace(/\.\$\*/g, '.[^.]+') + '$');
      if (re.test(path)) ***REMOVED***
        return this.paths[_path];
      ***REMOVED***
    ***REMOVED***

    // subpaths?
    return /\.\d+\.?.*$/.test(path)
      ? getPositionalPath(this, path)
      : undefined;
  ***REMOVED***

  // some path names conflict with document methods
  if (reserved[path]) ***REMOVED***
    throw new Error('`' + path + '` may not be used as a schema pathname');
  ***REMOVED***

  if (warnings[path]) ***REMOVED***
    console.log('WARN: ' + warnings[path]);
  ***REMOVED***

  // update the tree
  const subpaths = path.split(/\./);
  let last = subpaths.pop();
  let branch = this.tree;

  subpaths.forEach(function(sub, i) ***REMOVED***
    if (!branch[sub]) ***REMOVED***
      branch[sub] = ***REMOVED******REMOVED***;
    ***REMOVED***
    if (typeof branch[sub] !== 'object') ***REMOVED***
      const msg = 'Cannot set nested path `' + path + '`. '
          + 'Parent path `'
          + subpaths.slice(0, i).concat([sub]).join('.')
          + '` already set to type ' + branch[sub].name
          + '.';
      throw new Error(msg);
    ***REMOVED***
    branch = branch[sub];
  ***REMOVED***);

  branch[last] = utils.clone(obj);

  this.paths[path] = Schema.interpretAsType(path, obj, this.options);
  const schemaType = this.paths[path];

  if (schemaType.$isSchemaMap) ***REMOVED***
    // Maps can have arbitrary keys, so `$*` is internal shorthand for "any key"
    // The '$' is to imply this path should never be stored in MongoDB so we
    // can easily build a regexp out of this path, and '*' to imply "any key."
    const mapPath = path + '.$*';
    this.paths[path + '.$*'] = Schema.interpretAsType(mapPath,
      obj.of || ***REMOVED*** type: ***REMOVED******REMOVED*** ***REMOVED***, this.options);
    schemaType.$__schemaType = this.paths[path + '.$*'];
  ***REMOVED***

  if (schemaType.$isSingleNested) ***REMOVED***
    for (let key in schemaType.schema.paths) ***REMOVED***
      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];
    ***REMOVED***
    for (let key in schemaType.schema.singleNestedPaths) ***REMOVED***
      this.singleNestedPaths[path + '.' + key] =
        schemaType.schema.singleNestedPaths[key];
    ***REMOVED***

    this.childSchemas.push(***REMOVED***
      schema: schemaType.schema,
      model: schemaType.caster
    ***REMOVED***);
  ***REMOVED*** else if (schemaType.$isMongooseDocumentArray) ***REMOVED***
    this.childSchemas.push(***REMOVED***
      schema: schemaType.schema,
      model: schemaType.casterConstructor
    ***REMOVED***);
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Converts type arguments into Mongoose Types.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @param ***REMOVED***Object***REMOVED*** obj constructor
 * @api private
 */

Schema.interpretAsType = function(path, obj, options) ***REMOVED***
  if (obj instanceof SchemaType) ***REMOVED***
    return obj;
  ***REMOVED***

  if (obj.constructor) ***REMOVED***
    var constructorName = utils.getFunctionName(obj.constructor);
    if (constructorName !== 'Object') ***REMOVED***
      var oldObj = obj;
      obj = ***REMOVED******REMOVED***;
      obj[options.typeKey] = oldObj;
    ***REMOVED***
  ***REMOVED***

  // Get the type making sure to allow keys named "type"
  // and default to mixed if not specified.
  // ***REMOVED*** type: ***REMOVED*** type: String, default: 'freshcut' ***REMOVED*** ***REMOVED***
  var type = obj[options.typeKey] && (options.typeKey !== 'type' || !obj.type.type)
    ? obj[options.typeKey]
    : ***REMOVED******REMOVED***;

  if (utils.getFunctionName(type.constructor) === 'Object' || type === 'mixed') ***REMOVED***
    return new MongooseTypes.Mixed(path, obj);
  ***REMOVED***

  if (Array.isArray(type) || Array === type || type === 'array') ***REMOVED***
    // if it was specified through ***REMOVED*** type ***REMOVED*** look for `cast`
    var cast = (Array === type || type === 'array')
      ? obj.cast
      : type[0];

    if (cast && cast.instanceOfSchema) ***REMOVED***
      return new MongooseTypes.DocumentArray(path, cast, obj);
    ***REMOVED***
    if (cast &&
        cast[options.typeKey] &&
        cast[options.typeKey].instanceOfSchema) ***REMOVED***
      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);
    ***REMOVED***

    if (Array.isArray(cast)) ***REMOVED***
      return new MongooseTypes.Array(path, Schema.interpretAsType(path, cast, options), obj);
    ***REMOVED***

    if (typeof cast === 'string') ***REMOVED***
      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];
    ***REMOVED*** else if (cast && (!cast[options.typeKey] || (options.typeKey === 'type' && cast.type.type))
        && utils.getFunctionName(cast.constructor) === 'Object') ***REMOVED***
      if (Object.keys(cast).length) ***REMOVED***
        // The `minimize` and `typeKey` options propagate to child schemas
        // declared inline, like `***REMOVED*** arr: [***REMOVED*** val: ***REMOVED*** $type: String ***REMOVED*** ***REMOVED***] ***REMOVED***`.
        // See gh-3560
        var childSchemaOptions = ***REMOVED***minimize: options.minimize***REMOVED***;
        if (options.typeKey) ***REMOVED***
          childSchemaOptions.typeKey = options.typeKey;
        ***REMOVED***
        //propagate 'strict' option to child schema
        if (options.hasOwnProperty('strict')) ***REMOVED***
          childSchemaOptions.strict = options.strict;
        ***REMOVED***
        var childSchema = new Schema(cast, childSchemaOptions);
        childSchema.$implicitlyCreated = true;
        return new MongooseTypes.DocumentArray(path, childSchema, obj);
      ***REMOVED*** else ***REMOVED***
        // Special case: empty object becomes mixed
        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);
      ***REMOVED***
    ***REMOVED***

    if (cast) ***REMOVED***
      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)
        ? cast[options.typeKey]
        : cast;

      name = typeof type === 'string'
        ? type
        : type.schemaName || utils.getFunctionName(type);

      if (!(name in MongooseTypes)) ***REMOVED***
        throw new TypeError('Undefined type `' + name + '` at array `' + path +
          '`');
      ***REMOVED***
    ***REMOVED***

    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);
  ***REMOVED***

  if (type && type.instanceOfSchema) ***REMOVED***
    return new MongooseTypes.Embedded(type, path, obj);
  ***REMOVED***

  var name;
  if (Buffer.isBuffer(type)) ***REMOVED***
    name = 'Buffer';
  ***REMOVED*** else ***REMOVED***
    name = typeof type === 'string'
      ? type
      // If not string, `type` is a function. Outside of IE, function.name
      // gives you the function name. In IE, you need to compute it
      : type.schemaName || utils.getFunctionName(type);
  ***REMOVED***

  if (name) ***REMOVED***
    name = name.charAt(0).toUpperCase() + name.substring(1);
  ***REMOVED***

  if (undefined == MongooseTypes[name]) ***REMOVED***
    throw new TypeError('Undefined type `' + name + '` at `' + path +
        '`\n  Did you try nesting Schemas? ' +
        'You can only nest using refs or arrays.');
  ***REMOVED***

  return new MongooseTypes[name](path, obj);
***REMOVED***;

/**
 * Iterates the schemas paths similar to Array#forEach.
 *
 * The callback is passed the pathname and schemaType as arguments on each iteration.
 *
 * @param ***REMOVED***Function***REMOVED*** fn callback function
 * @return ***REMOVED***Schema***REMOVED*** this
 * @api public
 */

Schema.prototype.eachPath = function(fn) ***REMOVED***
  var keys = Object.keys(this.paths),
      len = keys.length;

  for (var i = 0; i < len; ++i) ***REMOVED***
    fn(keys[i], this.paths[keys[i]]);
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Returns an Array of path strings that are required by this schema.
 *
 * @api public
 * @param ***REMOVED***Boolean***REMOVED*** invalidate refresh the cache
 * @return ***REMOVED***Array***REMOVED***
 */

Schema.prototype.requiredPaths = function requiredPaths(invalidate) ***REMOVED***
  if (this._requiredpaths && !invalidate) ***REMOVED***
    return this._requiredpaths;
  ***REMOVED***

  var paths = Object.keys(this.paths),
      i = paths.length,
      ret = [];

  while (i--) ***REMOVED***
    var path = paths[i];
    if (this.paths[path].isRequired) ***REMOVED***
      ret.push(path);
    ***REMOVED***
  ***REMOVED***
  this._requiredpaths = ret;
  return this._requiredpaths;
***REMOVED***;

/**
 * Returns indexes from fields and schema-level indexes (cached).
 *
 * @api private
 * @return ***REMOVED***Array***REMOVED***
 */

Schema.prototype.indexedPaths = function indexedPaths() ***REMOVED***
  if (this._indexedpaths) ***REMOVED***
    return this._indexedpaths;
  ***REMOVED***
  this._indexedpaths = this.indexes();
  return this._indexedpaths;
***REMOVED***;

/**
 * Returns the pathType of `path` for this schema.
 *
 * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @return ***REMOVED***String***REMOVED***
 * @api public
 */

Schema.prototype.pathType = function(path) ***REMOVED***
  if (path in this.paths) ***REMOVED***
    return 'real';
  ***REMOVED***
  if (path in this.virtuals) ***REMOVED***
    return 'virtual';
  ***REMOVED***
  if (path in this.nested) ***REMOVED***
    return 'nested';
  ***REMOVED***
  if (path in this.subpaths) ***REMOVED***
    return 'real';
  ***REMOVED***
  if (path in this.singleNestedPaths) ***REMOVED***
    return 'real';
  ***REMOVED***

  // Look for maps
  for (let _path of Object.keys(this.paths)) ***REMOVED***
    if (!_path.includes('.$*')) ***REMOVED***
      continue;
    ***REMOVED***
    const re = new RegExp('^' + _path.replace(/\.\$\*/g, '.[^.]+') + '$');
    if (re.test(path)) ***REMOVED***
      return this.paths[_path];
    ***REMOVED***
  ***REMOVED***

  if (/\.\d+\.|\.\d+$/.test(path)) ***REMOVED***
    return getPositionalPathType(this, path);
  ***REMOVED***
  return 'adhocOrUndefined';
***REMOVED***;

/**
 * Returns true iff this path is a child of a mixed schema.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 */

Schema.prototype.hasMixedParent = function(path) ***REMOVED***
  var subpaths = path.split(/\./g);
  path = '';
  for (var i = 0; i < subpaths.length; ++i) ***REMOVED***
    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];
    if (path in this.paths &&
        this.paths[path] instanceof MongooseTypes.Mixed) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***

  return false;
***REMOVED***;

/**
 * Setup updatedAt and createdAt timestamps to documents if enabled
 *
 * @param ***REMOVED***Boolean|Object***REMOVED*** timestamps timestamps options
 * @api private
 */
Schema.prototype.setupTimestamp = function(timestamps) ***REMOVED***
  if (timestamps) ***REMOVED***
    var createdAt = handleTimestampOption(timestamps, 'createdAt');
    var updatedAt = handleTimestampOption(timestamps, 'updatedAt');
    var schemaAdditions = ***REMOVED******REMOVED***;

    if (updatedAt && !this.paths[updatedAt]) ***REMOVED***
      schemaAdditions[updatedAt] = Date;
    ***REMOVED***

    if (createdAt && !this.paths[createdAt]) ***REMOVED***
      schemaAdditions[createdAt] = Date;
    ***REMOVED***

    this.add(schemaAdditions);

    this.pre('save', function(next) ***REMOVED***
      var defaultTimestamp = new Date();
      var auto_id = this._id && this._id.auto;

      if (createdAt && !this.get(createdAt) && this.isSelected(createdAt)) ***REMOVED***
        this.set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);
      ***REMOVED***

      if (updatedAt && (this.isNew || this.isModified())) ***REMOVED***
        var ts = defaultTimestamp;
        if (this.isNew) ***REMOVED***
          if (createdAt != null) ***REMOVED***
            ts = this.get(createdAt);
          ***REMOVED*** else if (auto_id) ***REMOVED***
            ts = this._id.getTimestamp();
          ***REMOVED***
        ***REMOVED***
        this.set(updatedAt, ts);
      ***REMOVED***

      next();
    ***REMOVED***);

    var genUpdates = function(currentUpdate, overwrite) ***REMOVED***
      var now = new Date();
      var updates = ***REMOVED******REMOVED***;
      var _updates = updates;
      if (overwrite) ***REMOVED***
        if (currentUpdate && currentUpdate.$set) ***REMOVED***
          currentUpdate = currentUpdate.$set;
          updates.$set = ***REMOVED******REMOVED***;
          _updates = updates.$set;
        ***REMOVED***
        if (updatedAt && !currentUpdate[updatedAt]) ***REMOVED***
          _updates[updatedAt] = now;
        ***REMOVED***
        if (createdAt && !currentUpdate[createdAt]) ***REMOVED***
          _updates[createdAt] = now;
        ***REMOVED***
        return updates;
      ***REMOVED***
      updates = ***REMOVED*** $set: ***REMOVED******REMOVED*** ***REMOVED***;
      currentUpdate = currentUpdate || ***REMOVED******REMOVED***;

      if (updatedAt &&
          (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) ***REMOVED***
        updates.$set[updatedAt] = now;
      ***REMOVED***

      if (createdAt) ***REMOVED***
        if (currentUpdate[createdAt]) ***REMOVED***
          delete currentUpdate[createdAt];
        ***REMOVED***
        if (currentUpdate.$set && currentUpdate.$set[createdAt]) ***REMOVED***
          delete currentUpdate.$set[createdAt];
        ***REMOVED***

        updates.$setOnInsert = ***REMOVED******REMOVED***;
        updates.$setOnInsert[createdAt] = now;
      ***REMOVED***

      return updates;
    ***REMOVED***;

    this.methods.initializeTimestamps = function() ***REMOVED***
      if (createdAt && !this.get(createdAt)) ***REMOVED***
        this.set(createdAt, new Date());
      ***REMOVED***
      if (updatedAt && !this.get(updatedAt)) ***REMOVED***
        this.set(updatedAt, new Date());
      ***REMOVED***
      return this;
    ***REMOVED***;

    this.pre('findOneAndUpdate', _setTimestampsOnUpdate);
    this.pre('update', _setTimestampsOnUpdate);
    this.pre('updateOne', _setTimestampsOnUpdate);
    this.pre('updateMany', _setTimestampsOnUpdate);
  ***REMOVED***

  function _setTimestampsOnUpdate(next) ***REMOVED***
    var overwrite = this.options.overwrite;
    this.update(***REMOVED******REMOVED***, genUpdates(this.getUpdate(), overwrite), ***REMOVED***
      overwrite: overwrite
    ***REMOVED***);
    applyTimestampsToChildren(this);
    next();
  ***REMOVED***
***REMOVED***;

/*!
 * ignore
 */

function handleTimestampOption(arg, prop) ***REMOVED***
  if (typeof arg === 'boolean') ***REMOVED***
    return prop;
  ***REMOVED***
  if (typeof arg[prop] === 'boolean') ***REMOVED***
    return arg[prop] ? prop : null;
  ***REMOVED***
  if (!(prop in arg)) ***REMOVED***
    return prop;
  ***REMOVED***
  return arg[prop];
***REMOVED***

/*!
 * ignore
 */

function applyTimestampsToChildren(query) ***REMOVED***
  var now = new Date();
  var update = query.getUpdate();
  var keys = Object.keys(update);
  var key;
  var schema = query.model.schema;
  var len;
  var createdAt;
  var updatedAt;
  var timestamps;
  var path;

  var hasDollarKey = keys.length && keys[0].charAt(0) === '$';

  if (hasDollarKey) ***REMOVED***
    if (update.$push) ***REMOVED***
      for (key in update.$push) ***REMOVED***
        var $path = schema.path(key);
        if (update.$push[key] &&
            $path &&
            $path.$isMongooseDocumentArray &&
            $path.schema.options.timestamps) ***REMOVED***
          timestamps = $path.schema.options.timestamps;
          createdAt = handleTimestampOption(timestamps, 'createdAt');
          updatedAt = handleTimestampOption(timestamps, 'updatedAt');
          if (update.$push[key].$each) ***REMOVED***
            update.$push[key].$each.forEach(function(subdoc) ***REMOVED***
              if (updatedAt != null) ***REMOVED***
                subdoc[updatedAt] = now;
              ***REMOVED***
              if (createdAt != null) ***REMOVED***
                subdoc[createdAt] = now;
              ***REMOVED***
            ***REMOVED***);
          ***REMOVED*** else ***REMOVED***
            if (updatedAt != null) ***REMOVED***
              update.$push[key][updatedAt] = now;
            ***REMOVED***
            if (createdAt != null) ***REMOVED***
              update.$push[key][createdAt] = now;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    if (update.$set) ***REMOVED***
      for (key in update.$set) ***REMOVED***
        path = schema.path(key);
        if (!path) ***REMOVED***
          continue;
        ***REMOVED***
        if (Array.isArray(update.$set[key]) && path.$isMongooseDocumentArray) ***REMOVED***
          len = update.$set[key].length;
          timestamps = schema.path(key).schema.options.timestamps;
          if (timestamps) ***REMOVED***
            createdAt = handleTimestampOption(timestamps, 'createdAt');
            updatedAt = handleTimestampOption(timestamps, 'updatedAt');
            for (var i = 0; i < len; ++i) ***REMOVED***
              if (updatedAt != null) ***REMOVED***
                update.$set[key][i][updatedAt] = now;
              ***REMOVED***
              if (createdAt != null) ***REMOVED***
                update.$set[key][i][createdAt] = now;
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED*** else if (update.$set[key] && path.$isSingleNested) ***REMOVED***
          timestamps = schema.path(key).schema.options.timestamps;
          if (timestamps) ***REMOVED***
            createdAt = handleTimestampOption(timestamps, 'createdAt');
            updatedAt = handleTimestampOption(timestamps, 'updatedAt');
            if (updatedAt != null) ***REMOVED***
              update.$set[key][updatedAt] = now;
            ***REMOVED***
            if (createdAt != null) ***REMOVED***
              update.$set[key][createdAt] = now;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/*!
 * ignore
 */

function getPositionalPathType(self, path) ***REMOVED***
  var subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
  if (subpaths.length < 2) ***REMOVED***
    return self.paths[subpaths[0]];
  ***REMOVED***

  var val = self.path(subpaths[0]);
  var isNested = false;
  if (!val) ***REMOVED***
    return val;
  ***REMOVED***

  var last = subpaths.length - 1,
      subpath,
      i = 1;

  for (; i < subpaths.length; ++i) ***REMOVED***
    isNested = false;
    subpath = subpaths[i];

    if (i === last && val && !/\D/.test(subpath)) ***REMOVED***
      if (val.$isMongooseDocumentArray) ***REMOVED***
        var oldVal = val;
        val = new SchemaType(subpath, ***REMOVED***
          required: get(val, 'schemaOptions.required', false)
        ***REMOVED***);
        val.cast = function(value, doc, init) ***REMOVED***
          return oldVal.cast(value, doc, init)[0];
        ***REMOVED***;
        val.$isMongooseDocumentArrayElement = true;
        val.caster = oldVal.caster;
        val.schema = oldVal.schema;
      ***REMOVED*** else if (val instanceof MongooseTypes.Array) ***REMOVED***
        // StringSchema, NumberSchema, etc
        val = val.caster;
      ***REMOVED*** else ***REMOVED***
        val = undefined;
      ***REMOVED***
      break;
    ***REMOVED***

    // ignore if its just a position segment: path.0.subpath
    if (!/\D/.test(subpath)) ***REMOVED***
      continue;
    ***REMOVED***

    if (!(val && val.schema)) ***REMOVED***
      val = undefined;
      break;
    ***REMOVED***

    var type = val.schema.pathType(subpath);
    isNested = (type === 'nested');
    val = val.schema.path(subpath);
  ***REMOVED***

  self.subpaths[path] = val;
  if (val) ***REMOVED***
    return 'real';
  ***REMOVED***
  if (isNested) ***REMOVED***
    return 'nested';
  ***REMOVED***
  return 'adhocOrUndefined';
***REMOVED***


/*!
 * ignore
 */

function getPositionalPath(self, path) ***REMOVED***
  getPositionalPathType(self, path);
  return self.subpaths[path];
***REMOVED***

/**
 * Adds a method call to the queue.
 *
 * @param ***REMOVED***String***REMOVED*** name name of the document method to call later
 * @param ***REMOVED***Array***REMOVED*** args arguments to pass to the method
 * @api public
 */

Schema.prototype.queue = function(name, args) ***REMOVED***
  this.callQueue.push([name, args]);
  return this;
***REMOVED***;

/**
 * Defines a pre hook for the document.
 *
 * ####Example
 *
 *     var toySchema = new Schema(..);
 *
 *     toySchema.pre('save', function (next) ***REMOVED***
 *       if (!this.created) this.created = new Date;
 *       next();
 *     ***REMOVED***)
 *
 *     toySchema.pre('validate', function (next) ***REMOVED***
 *       if (this.name !== 'Woody') this.name = 'Woody';
 *       next();
 *     ***REMOVED***)
 *
 * @param ***REMOVED***String***REMOVED*** method
 * @param ***REMOVED***Function***REMOVED*** callback
 * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3
 * @api public
 */

Schema.prototype.pre = function() ***REMOVED***
  this.s.hooks.pre.apply(this.s.hooks, arguments);
  return this;
***REMOVED***;

/**
 * Defines a post hook for the document
 *
 *     var schema = new Schema(..);
 *     schema.post('save', function (doc) ***REMOVED***
 *       console.log('this fired after a document was saved');
 *     ***REMOVED***);
 *
 *     schema.post('find', function(docs) ***REMOVED***
 *       console.log('this fired after you run a find query');
 *     ***REMOVED***);
 *
 *     var Model = mongoose.model('Model', schema);
 *
 *     var m = new Model(..);
 *     m.save(function(err) ***REMOVED***
 *       console.log('this fires after the `post` hook');
 *     ***REMOVED***);
 *
 *     m.find(function(err, docs) ***REMOVED***
 *       console.log('this fires after the post find hook');
 *     ***REMOVED***);
 *
 * @param ***REMOVED***String***REMOVED*** method name of the method to hook
 * @param ***REMOVED***Function***REMOVED*** fn callback
 * @see middleware http://mongoosejs.com/docs/middleware.html
 * @see kareem http://npmjs.org/package/kareem
 * @api public
 */

Schema.prototype.post = function() ***REMOVED***
  this.s.hooks.post.apply(this.s.hooks, arguments);
  return this;
***REMOVED***;

/**
 * Registers a plugin for this schema.
 *
 * @param ***REMOVED***Function***REMOVED*** plugin callback
 * @param ***REMOVED***Object***REMOVED*** [opts]
 * @see plugins
 * @api public
 */

Schema.prototype.plugin = function(fn, opts) ***REMOVED***
  if (typeof fn !== 'function') ***REMOVED***
    throw new Error('First param to `schema.plugin()` must be a function, ' +
      'got "' + (typeof fn) + '"');
  ***REMOVED***

  if (opts &&
      opts.deduplicate) ***REMOVED***
    for (var i = 0; i < this.plugins.length; ++i) ***REMOVED***
      if (this.plugins[i].fn === fn) ***REMOVED***
        return this;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  this.plugins.push(***REMOVED*** fn: fn, opts: opts ***REMOVED***);

  fn(this, opts);
  return this;
***REMOVED***;

/**
 * Adds an instance method to documents constructed from Models compiled from this schema.
 *
 * ####Example
 *
 *     var schema = kittySchema = new Schema(..);
 *
 *     schema.method('meow', function () ***REMOVED***
 *       console.log('meeeeeoooooooooooow');
 *     ***REMOVED***)
 *
 *     var Kitty = mongoose.model('Kitty', schema);
 *
 *     var fizz = new Kitty;
 *     fizz.meow(); // meeeeeooooooooooooow
 *
 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.
 *
 *     schema.method(***REMOVED***
 *         purr: function () ***REMOVED******REMOVED***
 *       , scratch: function () ***REMOVED******REMOVED***
 *     ***REMOVED***);
 *
 *     // later
 *     fizz.purr();
 *     fizz.scratch();
 *
 * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](./guide.html#methods)
 *
 * @param ***REMOVED***String|Object***REMOVED*** method name
 * @param ***REMOVED***Function***REMOVED*** [fn]
 * @api public
 */

Schema.prototype.method = function(name, fn, options) ***REMOVED***
  if (typeof name !== 'string') ***REMOVED***
    for (const i in name) ***REMOVED***
      this.methods[i] = name[i];
      this.methodOptions[i] = utils.clone(options);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    this.methods[name] = fn;
    this.methodOptions[name] = utils.clone(options);
  ***REMOVED***
  return this;
***REMOVED***;

/**
 * Adds static "class" methods to Models compiled from this schema.
 *
 * ####Example
 *
 *     var schema = new Schema(..);
 *     schema.static('findByName', function (name, callback) ***REMOVED***
 *       return this.find(***REMOVED*** name: name ***REMOVED***, callback);
 *     ***REMOVED***);
 *
 *     var Drink = mongoose.model('Drink', schema);
 *     Drink.findByName('sanpellegrino', function (err, drinks) ***REMOVED***
 *       //
 *     ***REMOVED***);
 *
 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.
 *
 * @param ***REMOVED***String|Object***REMOVED*** name
 * @param ***REMOVED***Function***REMOVED*** [fn]
 * @api public
 */

Schema.prototype.static = function(name, fn) ***REMOVED***
  if (typeof name !== 'string') ***REMOVED***
    for (var i in name) ***REMOVED***
      this.statics[i] = name[i];
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    this.statics[name] = fn;
  ***REMOVED***
  return this;
***REMOVED***;

/**
 * Defines an index (most likely compound) for this schema.
 *
 * ####Example
 *
 *     schema.index(***REMOVED*** first: 1, last: -1 ***REMOVED***)
 *
 * @param ***REMOVED***Object***REMOVED*** fields
 * @param ***REMOVED***Object***REMOVED*** [options] Options to pass to [MongoDB driver's `createIndex()` function](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)
 * @param ***REMOVED***String***REMOVED*** [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.
 * @api public
 */

Schema.prototype.index = function(fields, options) ***REMOVED***
  fields || (fields = ***REMOVED******REMOVED***);
  options || (options = ***REMOVED******REMOVED***);

  if (options.expires) ***REMOVED***
    utils.expires(options);
  ***REMOVED***

  this._indexes.push([fields, options]);
  return this;
***REMOVED***;

/**
 * Sets/gets a schema option.
 *
 * ####Example
 *
 *     schema.set('strict'); // 'true' by default
 *     schema.set('strict', false); // Sets 'strict' to false
 *     schema.set('strict'); // 'false'
 *
 * @param ***REMOVED***String***REMOVED*** key option name
 * @param ***REMOVED***Object***REMOVED*** [value] if not passed, the current option value is returned
 * @see Schema ./
 * @api public
 */

Schema.prototype.set = function(key, value, _tags) ***REMOVED***
  if (arguments.length === 1) ***REMOVED***
    return this.options[key];
  ***REMOVED***

  switch (key) ***REMOVED***
    case 'read':
      this.options[key] = readPref(value, _tags);
      this._userProvidedOptions[key] = this.options[key];
      break;
    case 'safe':
      this.options[key] = value === false ?
        ***REMOVED***w: 0***REMOVED*** :
        value;
      this._userProvidedOptions[key] = this.options[key];
      break;
    case 'timestamps':
      this.setupTimestamp(value);
      this.options[key] = value;
      this._userProvidedOptions[key] = this.options[key];
      break;
    default:
      this.options[key] = value;
      this._userProvidedOptions[key] = this.options[key];
      break;
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Gets a schema option.
 *
 * @param ***REMOVED***String***REMOVED*** key option name
 * @api public
 */

Schema.prototype.get = function(key) ***REMOVED***
  return this.options[key];
***REMOVED***;

/**
 * The allowed index types
 *
 * @receiver Schema
 * @static indexTypes
 * @api public
 */

var indexTypes = '2d 2dsphere hashed text'.split(' ');

Object.defineProperty(Schema, 'indexTypes', ***REMOVED***
  get: function() ***REMOVED***
    return indexTypes;
  ***REMOVED***,
  set: function() ***REMOVED***
    throw new Error('Cannot overwrite Schema.indexTypes');
  ***REMOVED***
***REMOVED***);

/**
 * Returns a list of indexes that this schema declares, via `schema.index()`
 * or by `index: true` in a path's options.
 *
 * @api public
 */

Schema.prototype.indexes = function() ***REMOVED***
  return getIndexes(this);
***REMOVED***;

/**
 * Creates a virtual type with the given name.
 *
 * @param ***REMOVED***String***REMOVED*** name
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @return ***REMOVED***VirtualType***REMOVED***
 */

Schema.prototype.virtual = function(name, options) ***REMOVED***
  if (options && options.ref) ***REMOVED***
    if (!options.localField) ***REMOVED***
      throw new Error('Reference virtuals require `localField` option');
    ***REMOVED***

    if (!options.foreignField) ***REMOVED***
      throw new Error('Reference virtuals require `foreignField` option');
    ***REMOVED***

    this.pre('init', function(obj) ***REMOVED***
      if (mpath.has(name, obj)) ***REMOVED***
        var _v = mpath.get(name, obj);
        if (!this.$$populatedVirtuals) ***REMOVED***
          this.$$populatedVirtuals = ***REMOVED******REMOVED***;
        ***REMOVED***

        if (options.justOne) ***REMOVED***
          this.$$populatedVirtuals[name] = Array.isArray(_v) ?
            _v[0] :
            _v;
        ***REMOVED*** else ***REMOVED***
          this.$$populatedVirtuals[name] = Array.isArray(_v) ?
            _v :
            _v == null ? [] : [_v];
        ***REMOVED***

        mpath.unset(name, obj);
      ***REMOVED***
    ***REMOVED***);

    var virtual = this.virtual(name);
    virtual.options = options;
    return virtual.
      get(function() ***REMOVED***
        if (!this.$$populatedVirtuals) ***REMOVED***
          this.$$populatedVirtuals = ***REMOVED******REMOVED***;
        ***REMOVED***
        if (name in this.$$populatedVirtuals) ***REMOVED***
          return this.$$populatedVirtuals[name];
        ***REMOVED***
        return null;
      ***REMOVED***).
      set(function(_v) ***REMOVED***
        if (!this.$$populatedVirtuals) ***REMOVED***
          this.$$populatedVirtuals = ***REMOVED******REMOVED***;
        ***REMOVED***

        if (options.justOne) ***REMOVED***
          this.$$populatedVirtuals[name] = Array.isArray(_v) ?
            _v[0] :
            _v;

          if (typeof this.$$populatedVirtuals[name] !== 'object') ***REMOVED***
            this.$$populatedVirtuals[name] = null;
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          this.$$populatedVirtuals[name] = Array.isArray(_v) ?
            _v :
            _v == null ? [] : [_v];

          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) ***REMOVED***
            return doc && typeof doc === 'object';
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***);
  ***REMOVED***

  var virtuals = this.virtuals;
  var parts = name.split('.');

  if (this.pathType(name) === 'real') ***REMOVED***
    throw new Error('Virtual path "' + name + '"' +
      ' conflicts with a real path in the schema');
  ***REMOVED***

  virtuals[name] = parts.reduce(function(mem, part, i) ***REMOVED***
    mem[part] || (mem[part] = (i === parts.length - 1)
      ? new VirtualType(options, name)
      : ***REMOVED******REMOVED***);
    return mem[part];
  ***REMOVED***, this.tree);

  return virtuals[name];
***REMOVED***;

/**
 * Returns the virtual type with the given `name`.
 *
 * @param ***REMOVED***String***REMOVED*** name
 * @return ***REMOVED***VirtualType***REMOVED***
 */

Schema.prototype.virtualpath = function(name) ***REMOVED***
  return this.virtuals[name];
***REMOVED***;

/**
 * Removes the given `path` (or [`paths`]).
 *
 * @param ***REMOVED***String|Array***REMOVED*** path
 *
 * @api public
 */
Schema.prototype.remove = function(path) ***REMOVED***
  if (typeof path === 'string') ***REMOVED***
    path = [path];
  ***REMOVED***
  if (Array.isArray(path)) ***REMOVED***
    path.forEach(function(name) ***REMOVED***
      if (this.path(name)) ***REMOVED***
        delete this.paths[name];

        var pieces = name.split('.');
        var last = pieces.pop();
        var branch = this.tree;
        for (var i = 0; i < pieces.length; ++i) ***REMOVED***
          branch = branch[pieces[i]];
        ***REMOVED***
        delete branch[last];
      ***REMOVED***
    ***REMOVED***, this);
  ***REMOVED***
***REMOVED***;

/**
 * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),
 * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)
 * to schema [virtuals](http://mongoosejs.com/docs/guide.html#virtuals),
 * [statics](http://mongoosejs.com/docs/guide.html#statics), and
 * [methods](http://mongoosejs.com/docs/guide.html#methods).
 *
 * ####Example:
 *
 * ```javascript
 * const md5 = require('md5');
 * const userSchema = new Schema(***REMOVED*** email: String ***REMOVED***);
 * class UserClass ***REMOVED***
 *   // `gravatarImage` becomes a virtual
 *   get gravatarImage() ***REMOVED***
 *     const hash = md5(this.email.toLowerCase());
 *     return `https://www.gravatar.com/avatar/$***REMOVED***hash***REMOVED***`;
 *   ***REMOVED***
 *
 *   // `getProfileUrl()` becomes a document method
 *   getProfileUrl() ***REMOVED***
 *     return `https://mysite.com/$***REMOVED***this.email***REMOVED***`;
 *   ***REMOVED***
 *
 *   // `findByEmail()` becomes a static
 *   static findByEmail(email) ***REMOVED***
 *     return this.findOne(***REMOVED*** email ***REMOVED***);
 *   ***REMOVED***
 * ***REMOVED***
 *
 * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,
 * // and a `findByEmail()` static
 * userSchema.loadClass(UserClass);
 * ```
 *
 * @param ***REMOVED***Function***REMOVED*** model
 * @param ***REMOVED***Boolean***REMOVED*** [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics
 */
Schema.prototype.loadClass = function(model, virtualsOnly) ***REMOVED***
  if (model === Object.prototype ||
      model === Function.prototype ||
      model.prototype.hasOwnProperty('$isMongooseModelPrototype')) ***REMOVED***
    return this;
  ***REMOVED***

  this.loadClass(Object.getPrototypeOf(model));

  // Add static methods
  if (!virtualsOnly) ***REMOVED***
    Object.getOwnPropertyNames(model).forEach(function(name) ***REMOVED***
      if (name.match(/^(length|name|prototype)$/)) ***REMOVED***
        return;
      ***REMOVED***
      var method = Object.getOwnPropertyDescriptor(model, name);
      if (typeof method.value === 'function') ***REMOVED***
        this.static(name, method.value);
      ***REMOVED***
    ***REMOVED***, this);
  ***REMOVED***

  // Add methods and virtuals
  Object.getOwnPropertyNames(model.prototype).forEach(function(name) ***REMOVED***
    if (name.match(/^(constructor)$/)) ***REMOVED***
      return;
    ***REMOVED***
    var method = Object.getOwnPropertyDescriptor(model.prototype, name);
    if (!virtualsOnly) ***REMOVED***
      if (typeof method.value === 'function') ***REMOVED***
        this.method(name, method.value);
      ***REMOVED***
    ***REMOVED***
    if (typeof method.get === 'function') ***REMOVED***
      this.virtual(name).get(method.get);
    ***REMOVED***
    if (typeof method.set === 'function') ***REMOVED***
      this.virtual(name).set(method.set);
    ***REMOVED***
  ***REMOVED***, this);

  return this;
***REMOVED***;

/*!
 * ignore
 */

Schema.prototype._getSchema = function(path) ***REMOVED***
  var _this = this;
  var pathschema = _this.path(path);
  var resultPath = [];

  if (pathschema) ***REMOVED***
    pathschema.$fullPath = path;
    return pathschema;
  ***REMOVED***

  function search(parts, schema) ***REMOVED***
    var p = parts.length + 1;
    var foundschema;
    var trypath;

    while (p--) ***REMOVED***
      trypath = parts.slice(0, p).join('.');
      foundschema = schema.path(trypath);
      if (foundschema) ***REMOVED***
        resultPath.push(trypath);

        if (foundschema.caster) ***REMOVED***
          // array of Mixed?
          if (foundschema.caster instanceof MongooseTypes.Mixed) ***REMOVED***
            foundschema.caster.$fullPath = resultPath.join('.');
            return foundschema.caster;
          ***REMOVED***

          // Now that we found the array, we need to check if there
          // are remaining document paths to look up for casting.
          // Also we need to handle array.$.path since schema.path
          // doesn't work for that.
          // If there is no foundschema.schema we are dealing with
          // a path like array.$
          if (p !== parts.length && foundschema.schema) ***REMOVED***
            var ret;
            if (parts[p] === '$' || isArrayFilter(parts[p])) ***REMOVED***
              if (p + 1 === parts.length) ***REMOVED***
                // comments.$
                return foundschema;
              ***REMOVED***
              // comments.$.comments.$.title
              ret = search(parts.slice(p + 1), foundschema.schema);
              if (ret) ***REMOVED***
                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||
                  !foundschema.schema.$isSingleNested;
              ***REMOVED***
              return ret;
            ***REMOVED***
            // this is the last path of the selector
            ret = search(parts.slice(p), foundschema.schema);
            if (ret) ***REMOVED***
              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||
                !foundschema.schema.$isSingleNested;
            ***REMOVED***
            return ret;
          ***REMOVED***
        ***REMOVED***

        foundschema.$fullPath = resultPath.join('.');

        return foundschema;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // look for arrays
  var parts = path.split('.');
  for (var i = 0; i < parts.length; ++i) ***REMOVED***
    if (parts[i] === '$' || isArrayFilter(parts[i])) ***REMOVED***
      // Re: gh-5628, because `schema.path()` doesn't take $ into account.
      parts[i] = '0';
    ***REMOVED***
  ***REMOVED***
  return search(parts, _this);
***REMOVED***;

/*!
 * ignore
 */

Schema.prototype._getPathType = function(path) ***REMOVED***
  var _this = this;
  var pathschema = _this.path(path);

  if (pathschema) ***REMOVED***
    return 'real';
  ***REMOVED***

  function search(parts, schema) ***REMOVED***
    var p = parts.length + 1,
        foundschema,
        trypath;

    while (p--) ***REMOVED***
      trypath = parts.slice(0, p).join('.');
      foundschema = schema.path(trypath);
      if (foundschema) ***REMOVED***
        if (foundschema.caster) ***REMOVED***
          // array of Mixed?
          if (foundschema.caster instanceof MongooseTypes.Mixed) ***REMOVED***
            return ***REMOVED*** schema: foundschema, pathType: 'mixed' ***REMOVED***;
          ***REMOVED***

          // Now that we found the array, we need to check if there
          // are remaining document paths to look up for casting.
          // Also we need to handle array.$.path since schema.path
          // doesn't work for that.
          // If there is no foundschema.schema we are dealing with
          // a path like array.$
          if (p !== parts.length && foundschema.schema) ***REMOVED***
            if (parts[p] === '$' || isArrayFilter(parts[p])) ***REMOVED***
              if (p === parts.length - 1) ***REMOVED***
                return ***REMOVED*** schema: foundschema, pathType: 'nested' ***REMOVED***;
              ***REMOVED***
              // comments.$.comments.$.title
              return search(parts.slice(p + 1), foundschema.schema);
            ***REMOVED***
            // this is the last path of the selector
            return search(parts.slice(p), foundschema.schema);
          ***REMOVED***
          return ***REMOVED***
            schema: foundschema,
            pathType: foundschema.$isSingleNested ? 'nested' : 'array'
          ***REMOVED***;
        ***REMOVED***
        return ***REMOVED*** schema: foundschema, pathType: 'real' ***REMOVED***;
      ***REMOVED*** else if (p === parts.length && schema.nested[trypath]) ***REMOVED***
        return ***REMOVED*** schema: schema, pathType: 'nested' ***REMOVED***;
      ***REMOVED***
    ***REMOVED***
    return ***REMOVED*** schema: foundschema || schema, pathType: 'undefined' ***REMOVED***;
  ***REMOVED***

  // look for arrays
  return search(path.split('.'), _this);
***REMOVED***;

/*!
 * ignore
 */

function isArrayFilter(piece) ***REMOVED***
  return piece.indexOf('$[') === 0 &&
    piece.lastIndexOf(']') === piece.length - 1;
***REMOVED***

/*!
 * Module exports.
 */

module.exports = exports = Schema;

// require down here because of reference issues

/**
 * The various built-in Mongoose Schema Types.
 *
 * ####Example:
 *
 *     var mongoose = require('mongoose');
 *     var ObjectId = mongoose.Schema.Types.ObjectId;
 *
 * ####Types:
 *
 * - [String](#schema-string-js)
 * - [Number](#schema-number-js)
 * - [Boolean](#schema-boolean-js) | Bool
 * - [Array](#schema-array-js)
 * - [Buffer](#schema-buffer-js)
 * - [Date](#schema-date-js)
 * - [ObjectId](#schema-objectid-js) | Oid
 * - [Mixed](#schema-mixed-js)
 *
 * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.
 *
 *     var Mixed = mongoose.Schema.Types.Mixed;
 *     new mongoose.Schema(***REMOVED*** _user: Mixed ***REMOVED***)
 *
 * @api public
 */

Schema.Types = MongooseTypes = require('./schema/index');

/*!
 * ignore
 */

exports.ObjectId = MongooseTypes.ObjectId;
