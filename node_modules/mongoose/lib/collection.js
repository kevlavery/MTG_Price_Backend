'use strict';

/*!
 * Module dependencies.
 */

const EventEmitter = require('events').EventEmitter;
const STATES = require('./connectionstate');
const utils = require('./utils');

/**
 * Abstract Collection constructor
 *
 * This is the base class that drivers inherit from and implement.
 *
 * @param ***REMOVED***String***REMOVED*** name name of the collection
 * @param ***REMOVED***Connection***REMOVED*** conn A MongooseConnection instance
 * @param ***REMOVED***Object***REMOVED*** opts optional collection options
 * @api public
 */

function Collection(name, conn, opts) ***REMOVED***
  if (opts === void 0) ***REMOVED***
    opts = ***REMOVED******REMOVED***;
  ***REMOVED***
  if (opts.capped === void 0) ***REMOVED***
    opts.capped = ***REMOVED******REMOVED***;
  ***REMOVED***

  opts.bufferCommands = undefined === opts.bufferCommands
    ? true
    : opts.bufferCommands;

  if (typeof opts.capped === 'number') ***REMOVED***
    opts.capped = ***REMOVED***size: opts.capped***REMOVED***;
  ***REMOVED***

  this.opts = opts;
  this.name = name;
  this.collectionName = name;
  this.conn = conn;
  this.queue = [];
  this.buffer = this.opts.bufferCommands;
  this.emitter = new EventEmitter();

  if (STATES.connected === this.conn.readyState) ***REMOVED***
    this.onOpen();
  ***REMOVED***
***REMOVED***

/**
 * The collection name
 *
 * @api public
 * @property name
 */

Collection.prototype.name;

/**
 * The collection name
 *
 * @api public
 * @property collectionName
 */

Collection.prototype.collectionName;

/**
 * The Connection instance
 *
 * @api public
 * @property conn
 */

Collection.prototype.conn;

/**
 * Called when the database connects
 *
 * @api private
 */

Collection.prototype.onOpen = function() ***REMOVED***
  this.buffer = false;
  var _this = this;
  utils.immediate(function() ***REMOVED***
    _this.doQueue();
  ***REMOVED***);
***REMOVED***;

/**
 * Called when the database disconnects
 *
 * @api private
 */

Collection.prototype.onClose = function(force) ***REMOVED***
  if (this.opts.bufferCommands && !force) ***REMOVED***
    this.buffer = true;
  ***REMOVED***
***REMOVED***;

/**
 * Queues a method for later execution when its
 * database connection opens.
 *
 * @param ***REMOVED***String***REMOVED*** name name of the method to queue
 * @param ***REMOVED***Array***REMOVED*** args arguments to pass to the method when executed
 * @api private
 */

Collection.prototype.addQueue = function(name, args) ***REMOVED***
  this.queue.push([name, args]);
  return this;
***REMOVED***;

/**
 * Executes all queued methods and clears the queue.
 *
 * @api private
 */

Collection.prototype.doQueue = function() ***REMOVED***
  for (var i = 0, l = this.queue.length; i < l; i++) ***REMOVED***
    if (typeof this.queue[i][0] === 'function') ***REMOVED***
      this.queue[i][0].apply(this, this.queue[i][1]);
    ***REMOVED*** else ***REMOVED***
      this[this.queue[i][0]].apply(this, this.queue[i][1]);
    ***REMOVED***
  ***REMOVED***
  this.queue = [];
  var _this = this;
  process.nextTick(function() ***REMOVED***
    _this.emitter.emit('queue');
  ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.ensureIndex = function() ***REMOVED***
  throw new Error('Collection#ensureIndex unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.createIndex = function() ***REMOVED***
  throw new Error('Collection#ensureIndex unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.findAndModify = function() ***REMOVED***
  throw new Error('Collection#findAndModify unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.findOneAndUpdate = function() ***REMOVED***
  throw new Error('Collection#findOneAndUpdate unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.findOneAndDelete = function() ***REMOVED***
  throw new Error('Collection#findOneAndDelete unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.findOne = function() ***REMOVED***
  throw new Error('Collection#findOne unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.find = function() ***REMOVED***
  throw new Error('Collection#find unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.insert = function() ***REMOVED***
  throw new Error('Collection#insert unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.save = function() ***REMOVED***
  throw new Error('Collection#save unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.update = function() ***REMOVED***
  throw new Error('Collection#update unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.getIndexes = function() ***REMOVED***
  throw new Error('Collection#getIndexes unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.mapReduce = function() ***REMOVED***
  throw new Error('Collection#mapReduce unimplemented by driver');
***REMOVED***;

/**
 * Abstract method that drivers must implement.
 */

Collection.prototype.watch = function() ***REMOVED***
  throw new Error('Collection#watch unimplemented by driver');
***REMOVED***;

/*!
 * Module exports.
 */

module.exports = Collection;
