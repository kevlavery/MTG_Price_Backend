'use strict';

/*!
 * Module dependencies.
 */

const Decimal = require('./types/decimal128');
const ObjectId = require('./types/objectid');
const PromiseProvider = require('./promise_provider');
const cloneRegExp = require('regexp-clone');
const sliced = require('sliced');
const mpath = require('mpath');
const ms = require('ms');

let MongooseBuffer;
let MongooseArray;
let Document;

/*!
 * Produces a collection name from model `name`. By default, just returns
 * the model name
 *
 * @param ***REMOVED***String***REMOVED*** name a model name
 * @param ***REMOVED***Function***REMOVED*** pluralize function that pluralizes the collection name
 * @return ***REMOVED***String***REMOVED*** a collection name
 * @api private
 */

exports.toCollectionName = function(name, pluralize) ***REMOVED***
  if (name === 'system.profile') ***REMOVED***
    return name;
  ***REMOVED***
  if (name === 'system.indexes') ***REMOVED***
    return name;
  ***REMOVED***
  if (typeof pluralize === 'function') ***REMOVED***
    return pluralize(name);
  ***REMOVED***
  return name;
***REMOVED***;

/*!
 * Determines if `a` and `b` are deep equal.
 *
 * Modified from node/lib/assert.js
 *
 * @param ***REMOVED***any***REMOVED*** a a value to compare to `b`
 * @param ***REMOVED***any***REMOVED*** b a value to compare to `a`
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 */

exports.deepEqual = function deepEqual(a, b) ***REMOVED***
  if (a === b) ***REMOVED***
    return true;
  ***REMOVED***

  if (a instanceof Date && b instanceof Date) ***REMOVED***
    return a.getTime() === b.getTime();
  ***REMOVED***

  if ((a instanceof ObjectId && b instanceof ObjectId) ||
      (a instanceof Decimal && b instanceof Decimal)) ***REMOVED***
    return a.toString() === b.toString();
  ***REMOVED***

  if (a instanceof RegExp && b instanceof RegExp) ***REMOVED***
    return a.source === b.source &&
        a.ignoreCase === b.ignoreCase &&
        a.multiline === b.multiline &&
        a.global === b.global;
  ***REMOVED***

  if (typeof a !== 'object' && typeof b !== 'object') ***REMOVED***
    return a == b;
  ***REMOVED***

  if (a === null || b === null || a === undefined || b === undefined) ***REMOVED***
    return false;
  ***REMOVED***

  if (a.prototype !== b.prototype) ***REMOVED***
    return false;
  ***REMOVED***

  // Handle MongooseNumbers
  if (a instanceof Number && b instanceof Number) ***REMOVED***
    return a.valueOf() === b.valueOf();
  ***REMOVED***

  if (Buffer.isBuffer(a)) ***REMOVED***
    return exports.buffer.areEqual(a, b);
  ***REMOVED***

  if (isMongooseObject(a)) ***REMOVED***
    a = a.toObject();
  ***REMOVED***
  if (isMongooseObject(b)) ***REMOVED***
    b = b.toObject();
  ***REMOVED***

  try ***REMOVED***
    var ka = Object.keys(a),
        kb = Object.keys(b),
        key, i;
  ***REMOVED*** catch (e) ***REMOVED***
    // happens when one is a string literal and the other isn't
    return false;
  ***REMOVED***

  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length) ***REMOVED***
    return false;
  ***REMOVED***

  // the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();

  // ~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) ***REMOVED***
    if (ka[i] !== kb[i]) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  // equivalent values for every corresponding key, and
  // ~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) ***REMOVED***
    key = ka[i];
    if (!deepEqual(a[key], b[key])) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***;

/*!
 * Object clone with Mongoose natives support.
 *
 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
 *
 * Functions are never cloned.
 *
 * @param ***REMOVED***Object***REMOVED*** obj the object to clone
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Object***REMOVED*** the cloned object
 * @api private
 */

exports.clone = function clone(obj, options) ***REMOVED***
  if (obj === undefined || obj === null) ***REMOVED***
    return obj;
  ***REMOVED***

  if (Array.isArray(obj)) ***REMOVED***
    return cloneArray(obj, options);
  ***REMOVED***

  if (isMongooseObject(obj)) ***REMOVED***
    if (options && options.json && typeof obj.toJSON === 'function') ***REMOVED***
      return obj.toJSON(options);
    ***REMOVED***
    return obj.toObject(options);
  ***REMOVED***

  if (obj.constructor) ***REMOVED***
    switch (exports.getFunctionName(obj.constructor)) ***REMOVED***
      case 'Object':
        return cloneObject(obj, options);
      case 'Date':
        return new obj.constructor(+obj);
      case 'RegExp':
        return cloneRegExp(obj);
      default:
        // ignore
        break;
    ***REMOVED***
  ***REMOVED***

  if (obj instanceof ObjectId) ***REMOVED***
    return new ObjectId(obj.id);
  ***REMOVED***
  if (obj instanceof Decimal) ***REMOVED***
    if (options && options.flattenDecimals) ***REMOVED***
      return obj.toJSON();
    ***REMOVED***
    return Decimal.fromString(obj.toString());
  ***REMOVED***

  if (!obj.constructor && exports.isObject(obj)) ***REMOVED***
    // object created with Object.create(null)
    return cloneObject(obj, options);
  ***REMOVED***

  if (obj.valueOf) ***REMOVED***
    return obj.valueOf();
  ***REMOVED***
***REMOVED***;
var clone = exports.clone;

/*!
 * ignore
 */

exports.promiseOrCallback = function promiseOrCallback(callback, fn) ***REMOVED***
  if (typeof callback === 'function') ***REMOVED***
    try ***REMOVED***
      return fn(callback);
    ***REMOVED*** catch (error) ***REMOVED***
      return process.nextTick(() => ***REMOVED***
        throw error;
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  const Promise = PromiseProvider.get();

  return new Promise((resolve, reject) => ***REMOVED***
    fn(function(error, res) ***REMOVED***
      if (error != null) ***REMOVED***
        return reject(error);
      ***REMOVED***
      if (arguments.length > 2) ***REMOVED***
        return resolve(Array.prototype.slice.call(arguments, 1));
      ***REMOVED***
      resolve(res);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/*!
 * ignore
 */

function cloneObject(obj, options) ***REMOVED***
  const minimize = options && options.minimize;
  const ret = ***REMOVED******REMOVED***;
  let hasKeys;
  let val;
  let k;

  for (k in obj) ***REMOVED***
    val = clone(obj[k], options);

    if (!minimize || (typeof val !== 'undefined')) ***REMOVED***
      hasKeys || (hasKeys = true);
      ret[k] = val;
    ***REMOVED***
  ***REMOVED***

  return minimize ? hasKeys && ret : ret;
***REMOVED***

function cloneArray(arr, options) ***REMOVED***
  var ret = [];
  for (var i = 0, l = arr.length; i < l; i++) ***REMOVED***
    ret.push(clone(arr[i], options));
  ***REMOVED***
  return ret;
***REMOVED***

/*!
 * Shallow copies defaults into options.
 *
 * @param ***REMOVED***Object***REMOVED*** defaults
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Object***REMOVED*** the merged object
 * @api private
 */

exports.options = function(defaults, options) ***REMOVED***
  var keys = Object.keys(defaults),
      i = keys.length,
      k;

  options = options || ***REMOVED******REMOVED***;

  while (i--) ***REMOVED***
    k = keys[i];
    if (!(k in options)) ***REMOVED***
      options[k] = defaults[k];
    ***REMOVED***
  ***REMOVED***

  return options;
***REMOVED***;

/*!
 * Generates a random string
 *
 * @api private
 */

exports.random = function() ***REMOVED***
  return Math.random().toString().substr(3);
***REMOVED***;

/*!
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param ***REMOVED***Object***REMOVED*** to
 * @param ***REMOVED***Object***REMOVED*** from
 * @api private
 */

exports.merge = function merge(to, from, options, path) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  const keys = Object.keys(from);
  let i = 0;
  const len = keys.length;
  let key;

  path = path || '';
  const omitNested = options.omitNested || ***REMOVED******REMOVED***;

  while (i < len) ***REMOVED***
    key = keys[i++];
    if (options.omit && options.omit[key]) ***REMOVED***
      continue;
    ***REMOVED***
    if (omitNested[path]) ***REMOVED***
      continue;
    ***REMOVED***
    if (to[key] == null) ***REMOVED***
      to[key] = from[key];
    ***REMOVED*** else if (exports.isObject(from[key])) ***REMOVED***
      if (!exports.isObject(to[key])) ***REMOVED***
        to[key] = ***REMOVED******REMOVED***;
      ***REMOVED***
      merge(to[key], from[key], options, path ? path + '.' + key : key);
    ***REMOVED*** else if (options.overwrite) ***REMOVED***
      to[key] = from[key];
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/*!
 * Applies toObject recursively.
 *
 * @param ***REMOVED***Document|Array|Object***REMOVED*** obj
 * @return ***REMOVED***Object***REMOVED***
 * @api private
 */

exports.toObject = function toObject(obj) ***REMOVED***
  Document || (Document = require('./document'));
  var ret;

  if (obj == null) ***REMOVED***
    return obj;
  ***REMOVED***

  if (obj instanceof Document) ***REMOVED***
    return obj.toObject();
  ***REMOVED***

  if (Array.isArray(obj)) ***REMOVED***
    ret = [];

    for (var i = 0, len = obj.length; i < len; ++i) ***REMOVED***
      ret.push(toObject(obj[i]));
    ***REMOVED***

    return ret;
  ***REMOVED***

  if ((obj.constructor && exports.getFunctionName(obj.constructor) === 'Object') ||
      (!obj.constructor && exports.isObject(obj))) ***REMOVED***
    ret = ***REMOVED******REMOVED***;

    for (var k in obj) ***REMOVED***
      ret[k] = toObject(obj[k]);
    ***REMOVED***

    return ret;
  ***REMOVED***

  return obj;
***REMOVED***;

/*!
 * Determines if `arg` is an object.
 *
 * @param ***REMOVED***Object|Array|String|Function|RegExp|any***REMOVED*** arg
 * @api private
 * @return ***REMOVED***Boolean***REMOVED***
 */

exports.isObject = function(arg) ***REMOVED***
  if (Buffer.isBuffer(arg)) ***REMOVED***
    return true;
  ***REMOVED***
  return Object.prototype.toString.call(arg) === '[object Object]';
***REMOVED***;

/*!
 * A faster Array.prototype.slice.call(arguments) alternative
 * @api private
 */

exports.args = sliced;

/*!
 * process.nextTick helper.
 *
 * Wraps `callback` in a try/catch + nextTick.
 *
 * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @api private
 */

exports.tick = function tick(callback) ***REMOVED***
  if (typeof callback !== 'function') ***REMOVED***
    return;
  ***REMOVED***
  return function() ***REMOVED***
    try ***REMOVED***
      callback.apply(this, arguments);
    ***REMOVED*** catch (err) ***REMOVED***
      // only nextTick on err to get out of
      // the event loop and avoid state corruption.
      process.nextTick(function() ***REMOVED***
        throw err;
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***;

/*!
 * Returns if `v` is a mongoose object that has a `toObject()` method we can use.
 *
 * This is for compatibility with libs like Date.js which do foolish things to Natives.
 *
 * @param ***REMOVED***any***REMOVED*** v
 * @api private
 */

exports.isMongooseObject = function(v) ***REMOVED***
  Document || (Document = require('./document'));
  MongooseArray || (MongooseArray = require('./types').Array);
  MongooseBuffer || (MongooseBuffer = require('./types').Buffer);

  if (v == null) ***REMOVED***
    return false;
  ***REMOVED***

  return v.$__ != null || v.isMongooseArray || v.isMongooseBuffer;
***REMOVED***;
var isMongooseObject = exports.isMongooseObject;

/*!
 * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
 *
 * @param ***REMOVED***Object***REMOVED*** object
 * @api private
 */

exports.expires = function expires(object) ***REMOVED***
  if (!(object && object.constructor.name === 'Object')) ***REMOVED***
    return;
  ***REMOVED***
  if (!('expires' in object)) ***REMOVED***
    return;
  ***REMOVED***

  var when;
  if (typeof object.expires !== 'string') ***REMOVED***
    when = object.expires;
  ***REMOVED*** else ***REMOVED***
    when = Math.round(ms(object.expires) / 1000);
  ***REMOVED***
  object.expireAfterSeconds = when;
  delete object.expires;
***REMOVED***;

/*!
 * Populate options constructor
 */

function PopulateOptions(path, select, match, options, model, subPopulate) ***REMOVED***
  this.path = path;
  this.match = match;
  this.select = select;
  this.options = options;
  this.model = model;
  if (typeof subPopulate === 'object') ***REMOVED***
    this.populate = subPopulate;
  ***REMOVED***
  this._docs = ***REMOVED******REMOVED***;
***REMOVED***

// make it compatible with utils.clone
PopulateOptions.prototype.constructor = Object;

// expose
exports.PopulateOptions = PopulateOptions;

/*!
 * populate helper
 */

exports.populate = function populate(path, select, model, match, options, subPopulate) ***REMOVED***
  // The order of select/conditions args is opposite Model.find but
  // necessary to keep backward compatibility (select could be
  // an array, string, or object literal).

  function makeSingles(arr) ***REMOVED***
    let ret = [];
    arr.forEach(function(obj) ***REMOVED***
      if (/[\s]/.test(obj.path)) ***REMOVED***
        let paths = obj.path.split(' ');
        paths.forEach(function(p) ***REMOVED***
          let copy = Object.assign(***REMOVED******REMOVED***, obj);
          copy.path = p;
          ret.push(copy);
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        ret.push(obj);
      ***REMOVED***
    ***REMOVED***);

    return ret;
  ***REMOVED***

  // might have passed an object specifying all arguments
  if (arguments.length === 1) ***REMOVED***
    if (path instanceof PopulateOptions) ***REMOVED***
      return [path];
    ***REMOVED***

    if (Array.isArray(path)) ***REMOVED***
      let singles = makeSingles(path);
      return singles.map(function(o) ***REMOVED***
        if (o.populate && !o.match) ***REMOVED***
          return exports.populate(
            o.path,
            o.select,
            o.model,
            o.match,
            o.options,
            o.populate)[0];
        ***REMOVED*** else ***REMOVED***
          return exports.populate(o)[0];
        ***REMOVED***

      ***REMOVED***);
    ***REMOVED***

    if (exports.isObject(path)) ***REMOVED***
      match = path.match;
      options = path.options;
      select = path.select;
      model = path.model;
      subPopulate = path.populate;
      path = path.path;
    ***REMOVED***
  ***REMOVED*** else if (typeof model !== 'string' && typeof model !== 'function') ***REMOVED***
    options = match;
    match = model;
    model = undefined;
  ***REMOVED***

  if (typeof path !== 'string') ***REMOVED***
    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');
  ***REMOVED***

  if (Array.isArray(subPopulate)) ***REMOVED***
    let ret = [];
    subPopulate.forEach(function(obj) ***REMOVED***
      if (/[\s]/.test(obj.path)) ***REMOVED***
        let copy = Object.assign(***REMOVED******REMOVED***, obj);
        let paths = copy.path.split(' ');
        paths.forEach(function(p) ***REMOVED***
          copy.path = p;
          ret.push(exports.populate(copy)[0]);
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        ret.push(exports.populate(obj)[0]);
      ***REMOVED***
    ***REMOVED***);
    subPopulate = exports.populate(ret);
  ***REMOVED*** else if (typeof subPopulate === 'object') ***REMOVED***
    subPopulate = exports.populate(subPopulate);
  ***REMOVED***

  var ret = [];
  var paths = path.split(' ');
  options = exports.clone(options);
  for (var i = 0; i < paths.length; ++i) ***REMOVED***
    ret.push(new PopulateOptions(paths[i], select, match, options, model, subPopulate));
  ***REMOVED***

  return ret;
***REMOVED***;

/*!
 * Return the value of `obj` at the given `path`.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @param ***REMOVED***Object***REMOVED*** obj
 */

exports.getValue = function(path, obj, map) ***REMOVED***
  return mpath.get(path, obj, '_doc', map);
***REMOVED***;

/*!
 * Sets the value of `obj` at the given `path`.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @param ***REMOVED***Anything***REMOVED*** val
 * @param ***REMOVED***Object***REMOVED*** obj
 */

exports.setValue = function(path, val, obj, map, _copying) ***REMOVED***
  mpath.set(path, val, obj, '_doc', map, _copying);
***REMOVED***;

/*!
 * Returns an array of values from object `o`.
 *
 * @param ***REMOVED***Object***REMOVED*** o
 * @return ***REMOVED***Array***REMOVED***
 * @private
 */

exports.object = ***REMOVED******REMOVED***;
exports.object.vals = function vals(o) ***REMOVED***
  var keys = Object.keys(o),
      i = keys.length,
      ret = [];

  while (i--) ***REMOVED***
    ret.push(o[keys[i]]);
  ***REMOVED***

  return ret;
***REMOVED***;

/*!
 * @see exports.options
 */

exports.object.shallowCopy = exports.options;

/*!
 * Safer helper for hasOwnProperty checks
 *
 * @param ***REMOVED***Object***REMOVED*** obj
 * @param ***REMOVED***String***REMOVED*** prop
 */

var hop = Object.prototype.hasOwnProperty;
exports.object.hasOwnProperty = function(obj, prop) ***REMOVED***
  return hop.call(obj, prop);
***REMOVED***;

/*!
 * Determine if `val` is null or undefined
 *
 * @return ***REMOVED***Boolean***REMOVED***
 */

exports.isNullOrUndefined = function(val) ***REMOVED***
  return val === null || val === undefined;
***REMOVED***;

/*!
 * ignore
 */

exports.array = ***REMOVED******REMOVED***;

/*!
 * Flattens an array.
 *
 * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
 *
 * @param ***REMOVED***Array***REMOVED*** arr
 * @param ***REMOVED***Function***REMOVED*** [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsey value, the item will not be included in the results.
 * @return ***REMOVED***Array***REMOVED***
 * @private
 */

exports.array.flatten = function flatten(arr, filter, ret) ***REMOVED***
  ret || (ret = []);

  arr.forEach(function(item) ***REMOVED***
    if (Array.isArray(item)) ***REMOVED***
      flatten(item, filter, ret);
    ***REMOVED*** else ***REMOVED***
      if (!filter || filter(item)) ***REMOVED***
        ret.push(item);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);

  return ret;
***REMOVED***;

/*!
 * Removes duplicate values from an array
 *
 * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
 * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
 *    => [ObjectId("550988ba0c19d57f697dc45e")]
 *
 * @param ***REMOVED***Array***REMOVED*** arr
 * @return ***REMOVED***Array***REMOVED***
 * @private
 */

exports.array.unique = function(arr) ***REMOVED***
  var primitives = ***REMOVED******REMOVED***;
  var ids = ***REMOVED******REMOVED***;
  var ret = [];
  var length = arr.length;
  for (var i = 0; i < length; ++i) ***REMOVED***
    if (typeof arr[i] === 'number' || typeof arr[i] === 'string' || arr[i] == null) ***REMOVED***
      if (primitives[arr[i]]) ***REMOVED***
        continue;
      ***REMOVED***
      ret.push(arr[i]);
      primitives[arr[i]] = true;
    ***REMOVED*** else if (arr[i] instanceof ObjectId) ***REMOVED***
      if (ids[arr[i].toString()]) ***REMOVED***
        continue;
      ***REMOVED***
      ret.push(arr[i]);
      ids[arr[i].toString()] = true;
    ***REMOVED*** else ***REMOVED***
      ret.push(arr[i]);
    ***REMOVED***
  ***REMOVED***

  return ret;
***REMOVED***;

/*!
 * Determines if two buffers are equal.
 *
 * @param ***REMOVED***Buffer***REMOVED*** a
 * @param ***REMOVED***Object***REMOVED*** b
 */

exports.buffer = ***REMOVED******REMOVED***;
exports.buffer.areEqual = function(a, b) ***REMOVED***
  if (!Buffer.isBuffer(a)) ***REMOVED***
    return false;
  ***REMOVED***
  if (!Buffer.isBuffer(b)) ***REMOVED***
    return false;
  ***REMOVED***
  if (a.length !== b.length) ***REMOVED***
    return false;
  ***REMOVED***
  for (var i = 0, len = a.length; i < len; ++i) ***REMOVED***
    if (a[i] !== b[i]) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***
  return true;
***REMOVED***;

exports.getFunctionName = function(fn) ***REMOVED***
  if (fn.name) ***REMOVED***
    return fn.name;
  ***REMOVED***
  return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
***REMOVED***;

exports.decorate = function(destination, source) ***REMOVED***
  for (var key in source) ***REMOVED***
    destination[key] = source[key];
  ***REMOVED***
***REMOVED***;

/**
 * merges to with a copy of from
 *
 * @param ***REMOVED***Object***REMOVED*** to
 * @param ***REMOVED***Object***REMOVED*** fromObj
 * @api private
 */

exports.mergeClone = function(to, fromObj) ***REMOVED***
  if (isMongooseObject(fromObj)) ***REMOVED***
    fromObj = fromObj.toObject(***REMOVED***
      transform: false,
      virtuals: false,
      depopulate: true,
      getters: false,
      flattenDecimals: false
    ***REMOVED***);
  ***REMOVED***
  var keys = Object.keys(fromObj);
  var len = keys.length;
  var i = 0;
  var key;

  while (i < len) ***REMOVED***
    key = keys[i++];
    if (typeof to[key] === 'undefined') ***REMOVED***
      to[key] = exports.clone(fromObj[key], ***REMOVED***
        transform: false,
        virtuals: false,
        depopulate: true,
        getters: false,
        flattenDecimals: false
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      var val = fromObj[key];
      if (val != null && val.valueOf && !(val instanceof Date)) ***REMOVED***
        val = val.valueOf();
      ***REMOVED***
      if (exports.isObject(val)) ***REMOVED***
        var obj = val;
        if (isMongooseObject(val) && !val.isMongooseBuffer) ***REMOVED***
          obj = obj.toObject(***REMOVED***
            transform: false,
            virtuals: false,
            depopulate: true,
            getters: false,
            flattenDecimals: false
          ***REMOVED***);
        ***REMOVED***
        if (val.isMongooseBuffer) ***REMOVED***
          obj = new Buffer(obj);
        ***REMOVED***
        exports.mergeClone(to[key], obj);
      ***REMOVED*** else ***REMOVED***
        to[key] = exports.clone(val, ***REMOVED***
          flattenDecimals: false
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Executes a function on each element of an array (like _.each)
 *
 * @param ***REMOVED***Array***REMOVED*** arr
 * @param ***REMOVED***Function***REMOVED*** fn
 * @api private
 */

exports.each = function(arr, fn) ***REMOVED***
  for (var i = 0; i < arr.length; ++i) ***REMOVED***
    fn(arr[i]);
  ***REMOVED***
***REMOVED***;

/*!
 * Centralize this so we can more easily work around issues with people
 * stubbing out `process.nextTick()` in tests using sinon:
 * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time
 * See gh-6074
 */

exports.immediate = function immediate(cb) ***REMOVED***
  return process.nextTick(cb);
***REMOVED***;

/*!
 * ignore
 */

exports.noop = function() ***REMOVED******REMOVED***;
