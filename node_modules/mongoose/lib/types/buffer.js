/*!
 * Module dependencies.
 */

var Binary = require('../drivers').Binary,
    utils = require('../utils');

/**
 * Mongoose Buffer constructor.
 *
 * Values always have to be passed to the constructor to initialize.
 *
 * @param ***REMOVED***Buffer***REMOVED*** value
 * @param ***REMOVED***String***REMOVED*** encode
 * @param ***REMOVED***Number***REMOVED*** offset
 * @api private
 * @inherits Buffer
 * @see http://bit.ly/f6CnZU
 */

function MongooseBuffer(value, encode, offset) ***REMOVED***
  var length = arguments.length;
  var val;

  if (length === 0 || arguments[0] === null || arguments[0] === undefined) ***REMOVED***
    val = 0;
  ***REMOVED*** else ***REMOVED***
    val = value;
  ***REMOVED***

  var encoding;
  var path;
  var doc;

  if (Array.isArray(encode)) ***REMOVED***
    // internal casting
    path = encode[0];
    doc = encode[1];
  ***REMOVED*** else ***REMOVED***
    encoding = encode;
  ***REMOVED***

  var buf = new Buffer(val, encoding, offset);
  utils.decorate(buf, MongooseBuffer.mixin);
  buf.isMongooseBuffer = true;

  // make sure these internal props don't show up in Object.keys()
  Object.defineProperties(buf, ***REMOVED***
    validators: ***REMOVED***
      value: [],
      enumerable: false
    ***REMOVED***,
    _path: ***REMOVED***
      value: path,
      enumerable: false
    ***REMOVED***,
    _parent: ***REMOVED***
      value: doc,
      enumerable: false
    ***REMOVED***
  ***REMOVED***);

  if (doc && typeof path === 'string') ***REMOVED***
    Object.defineProperty(buf, '_schema', ***REMOVED***
      value: doc.schema.path(path)
    ***REMOVED***);
  ***REMOVED***

  buf._subtype = 0;
  return buf;
***REMOVED***

/*!
 * Inherit from Buffer.
 */

// MongooseBuffer.prototype = new Buffer(0);

MongooseBuffer.mixin = ***REMOVED***

  /**
   * Parent owner document
   *
   * @api private
   * @property _parent
   * @receiver MongooseBuffer
   */

  _parent: undefined,

  /**
   * Default subtype for the Binary representing this Buffer
   *
   * @api private
   * @property _subtype
   * @receiver MongooseBuffer
   */

  _subtype: undefined,

  /**
   * Marks this buffer as modified.
   *
   * @api private
   * @method _markModified
   * @receiver MongooseBuffer
   */

  _markModified: function() ***REMOVED***
    var parent = this._parent;

    if (parent) ***REMOVED***
      parent.markModified(this._path);
    ***REMOVED***
    return this;
  ***REMOVED***,

  /**
   * Writes the buffer.
   *
   * @api public
   * @method write
   * @receiver MongooseBuffer
   */

  write: function() ***REMOVED***
    var written = Buffer.prototype.write.apply(this, arguments);

    if (written > 0) ***REMOVED***
      this._markModified();
    ***REMOVED***

    return written;
  ***REMOVED***,

  /**
   * Copies the buffer.
   *
   * ####Note:
   *
   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.
   *
   * @return ***REMOVED***Number***REMOVED*** The number of bytes copied.
   * @param ***REMOVED***Buffer***REMOVED*** target
   * @method copy
   * @receiver MongooseBuffer
   */

  copy: function(target) ***REMOVED***
    var ret = Buffer.prototype.copy.apply(this, arguments);

    if (target && target.isMongooseBuffer) ***REMOVED***
      target._markModified();
    ***REMOVED***

    return ret;
  ***REMOVED***
***REMOVED***;

/*!
 * Compile other Buffer methods marking this buffer as modified.
 */

(
// node < 0.5
  'writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 ' +
    'writeFloat writeDouble fill ' +
    'utf8Write binaryWrite asciiWrite set ' +

  // node >= 0.5
    'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE ' +
    'writeInt16LE writeInt16BE writeInt32LE writeInt32BE ' +
    'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE'
).split(' ').forEach(function(method) ***REMOVED***
  if (!Buffer.prototype[method]) ***REMOVED***
    return;
  ***REMOVED***
  MongooseBuffer.mixin[method] = function() ***REMOVED***
    var ret = Buffer.prototype[method].apply(this, arguments);
    this._markModified();
    return ret;
  ***REMOVED***;
***REMOVED***);

/**
 * Converts this buffer to its Binary type representation.
 *
 * ####SubTypes:
 *
 *   var bson = require('bson')
 *   bson.BSON_BINARY_SUBTYPE_DEFAULT
 *   bson.BSON_BINARY_SUBTYPE_FUNCTION
 *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
 *   bson.BSON_BINARY_SUBTYPE_UUID
 *   bson.BSON_BINARY_SUBTYPE_MD5
 *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED
 *
 *   doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);
 *
 * @see http://bsonspec.org/#/specification
 * @param ***REMOVED***Hex***REMOVED*** [subtype]
 * @return ***REMOVED***Binary***REMOVED***
 * @api public
 * @method toObject
 * @receiver MongooseBuffer
 */

MongooseBuffer.mixin.toObject = function(options) ***REMOVED***
  var subtype = typeof options === 'number'
    ? options
    : (this._subtype || 0);
  return new Binary(this, subtype);
***REMOVED***;

/**
 * Converts this buffer for storage in MongoDB, including subtype
 *
 * @return ***REMOVED***Binary***REMOVED***
 * @api public
 * @method toBSON
 * @receiver MongooseBuffer
 */

MongooseBuffer.mixin.toBSON = function() ***REMOVED***
  return new Binary(this, this._subtype || 0);
***REMOVED***;

/**
 * Determines if this buffer is equals to `other` buffer
 *
 * @param ***REMOVED***Buffer***REMOVED*** other
 * @return ***REMOVED***Boolean***REMOVED***
 * @method equals
 * @receiver MongooseBuffer
 */

MongooseBuffer.mixin.equals = function(other) ***REMOVED***
  if (!Buffer.isBuffer(other)) ***REMOVED***
    return false;
  ***REMOVED***

  if (this.length !== other.length) ***REMOVED***
    return false;
  ***REMOVED***

  for (var i = 0; i < this.length; ++i) ***REMOVED***
    if (this[i] !== other[i]) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***;

/**
 * Sets the subtype option and marks the buffer modified.
 *
 * ####SubTypes:
 *
 *   var bson = require('bson')
 *   bson.BSON_BINARY_SUBTYPE_DEFAULT
 *   bson.BSON_BINARY_SUBTYPE_FUNCTION
 *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
 *   bson.BSON_BINARY_SUBTYPE_UUID
 *   bson.BSON_BINARY_SUBTYPE_MD5
 *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED
 *
 *   doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);
 *
 * @see http://bsonspec.org/#/specification
 * @param ***REMOVED***Hex***REMOVED*** subtype
 * @api public
 * @method subtype
 * @receiver MongooseBuffer
 */

MongooseBuffer.mixin.subtype = function(subtype) ***REMOVED***
  if (typeof subtype !== 'number') ***REMOVED***
    throw new TypeError('Invalid subtype. Expected a number');
  ***REMOVED***

  if (this._subtype !== subtype) ***REMOVED***
    this._markModified();
  ***REMOVED***

  this._subtype = subtype;
***REMOVED***;

/*!
 * Module exports.
 */

MongooseBuffer.Binary = Binary;

module.exports = MongooseBuffer;
