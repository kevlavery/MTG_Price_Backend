/*!
 * Module dependencies.
 */

var MongooseConnection = require('../../connection');
var STATES = require('../../connectionstate');

/**
 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.
 *
 * @inherits Connection
 * @api private
 */

function NativeConnection() ***REMOVED***
  MongooseConnection.apply(this, arguments);
  this._listening = false;
***REMOVED***

/**
 * Expose the possible connection states.
 * @api public
 */

NativeConnection.STATES = STATES;

/*!
 * Inherits from Connection.
 */

NativeConnection.prototype.__proto__ = MongooseConnection.prototype;

/**
 * Switches to a different database using the same connection pool.
 *
 * Returns a new connection object, with the new db.
 *
 * @param ***REMOVED***String***REMOVED*** name The database name
 * @return ***REMOVED***Connection***REMOVED*** New Connection Object
 * @api public
 */

NativeConnection.prototype.useDb = function(name, options) ***REMOVED***
  // Return immediately if cached
  if (options && options.useCache && this.relatedDbs[name]) return this.relatedDbs[name];

  // we have to manually copy all of the attributes...
  var newConn = new this.constructor();
  newConn.name = name;
  newConn.base = this.base;
  newConn.collections = ***REMOVED******REMOVED***;
  newConn.models = ***REMOVED******REMOVED***;
  newConn.replica = this.replica;
  newConn.name = this.name;
  newConn.options = this.options;
  newConn._readyState = this._readyState;
  newConn._closeCalled = this._closeCalled;
  newConn._hasOpened = this._hasOpened;
  newConn._listening = false;

  // First, when we create another db object, we are not guaranteed to have a
  // db object to work with. So, in the case where we have a db object and it
  // is connected, we can just proceed with setting everything up. However, if
  // we do not have a db or the state is not connected, then we need to wait on
  // the 'open' event of the connection before doing the rest of the setup
  // the 'connected' event is the first time we'll have access to the db object

  var _this = this;

  newConn.client = _this.client;

  if (this.db && this._readyState === STATES.connected) ***REMOVED***
    wireup();
  ***REMOVED*** else ***REMOVED***
    this.once('connected', wireup);
  ***REMOVED***

  function wireup() ***REMOVED***
    newConn.client = _this.client;
    newConn.db = _this.client.db(name);
    newConn.onOpen();
    // setup the events appropriately
    listen(newConn);
  ***REMOVED***

  newConn.name = name;

  // push onto the otherDbs stack, this is used when state changes
  this.otherDbs.push(newConn);
  newConn.otherDbs.push(this);

  // push onto the relatedDbs cache, this is used when state changes
  if (options && options.useCache) ***REMOVED***
    this.relatedDbs[newConn.name] = newConn;
    newConn.relatedDbs = this.relatedDbs;
  ***REMOVED***

  return newConn;
***REMOVED***;

/*!
 * Register listeners for important events and bubble appropriately.
 */

function listen(conn) ***REMOVED***
  if (conn.db._listening) ***REMOVED***
    return;
  ***REMOVED***
  conn.db._listening = true;

  conn.db.on('close', function(force) ***REMOVED***
    if (conn._closeCalled) return;

    // the driver never emits an `open` event. auto_reconnect still
    // emits a `close` event but since we never get another
    // `open` we can't emit close
    if (conn.db.serverConfig.autoReconnect) ***REMOVED***
      conn.readyState = STATES.disconnected;
      conn.emit('close');
      return;
    ***REMOVED***
    conn.onClose(force);
  ***REMOVED***);
  conn.db.on('error', function(err) ***REMOVED***
    conn.emit('error', err);
  ***REMOVED***);
  conn.db.on('reconnect', function() ***REMOVED***
    conn.readyState = STATES.connected;
    conn.emit('reconnect');
    conn.emit('reconnected');
    conn.onOpen();
  ***REMOVED***);
  conn.db.on('timeout', function(err) ***REMOVED***
    conn.emit('timeout', err);
  ***REMOVED***);
  conn.db.on('open', function(err, db) ***REMOVED***
    if (STATES.disconnected === conn.readyState && db && db.databaseName) ***REMOVED***
      conn.readyState = STATES.connected;
      conn.emit('reconnect');
      conn.emit('reconnected');
    ***REMOVED***
  ***REMOVED***);
  conn.db.on('parseError', function(err) ***REMOVED***
    conn.emit('parseError', err);
  ***REMOVED***);
***REMOVED***

/**
 * Closes the connection
 *
 * @param ***REMOVED***Boolean***REMOVED*** [force]
 * @param ***REMOVED***Function***REMOVED*** [fn]
 * @return ***REMOVED***Connection***REMOVED*** this
 * @api private
 */

NativeConnection.prototype.doClose = function(force, fn) ***REMOVED***
  this.client.close(force, fn);
  return this;
***REMOVED***;

/*!
 * Module exports.
 */

module.exports = NativeConnection;
