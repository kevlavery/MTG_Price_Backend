'use strict';

var isNative = /\.node$/;

function forEach(obj, callback) ***REMOVED***
    for ( var key in obj ) ***REMOVED***
        if (!Object.prototype.hasOwnProperty.call(obj, key)) ***REMOVED***
            continue;
        ***REMOVED***
        callback(key);
    ***REMOVED***
***REMOVED***

function assign(target, source) ***REMOVED***
    forEach(source, function (key) ***REMOVED***
        target[key] = source[key];
    ***REMOVED***);
    return target;
***REMOVED***

function clearCache(requireCache) ***REMOVED***
    forEach(requireCache, function (resolvedPath) ***REMOVED***
        if (!isNative.test(resolvedPath)) ***REMOVED***
            delete requireCache[resolvedPath];
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

module.exports = function (requireCache, callback, callbackForModulesToKeep, module) ***REMOVED***

    var originalCache = assign(***REMOVED******REMOVED***, requireCache);
    clearCache(requireCache);

    if (callbackForModulesToKeep) ***REMOVED***

        var originalModuleChildren = module.children ? module.children.slice() : false; // Creates a shallow copy of module.children

        callbackForModulesToKeep();

        // Lists the cache entries made by callbackForModulesToKeep()
        var modulesToKeep = [];
        forEach(requireCache, function (key) ***REMOVED***
            modulesToKeep.push(key);
        ***REMOVED***);

        // Discards the modules required in callbackForModulesToKeep()
        clearCache(requireCache);

        if (module.children) ***REMOVED*** // Only true for node.js
            module.children = originalModuleChildren; // Removes last references to modules required in callbackForModulesToKeep() -> No memory leak
        ***REMOVED***

        // Takes the cache entries of the original cache in case the modules where required before
        for ( var i = 0; i < modulesToKeep.length; i+=1 ) ***REMOVED***
            if (originalCache[modulesToKeep[i]]) ***REMOVED***
                requireCache[modulesToKeep[i]] = originalCache[modulesToKeep[i]];
            ***REMOVED***
        ***REMOVED***

    ***REMOVED***

    var freshModule = callback();

    var stealthCache = callbackForModulesToKeep ? assign(***REMOVED******REMOVED***, requireCache) : false;

    clearCache(requireCache);

    if (callbackForModulesToKeep) ***REMOVED***
        // In case modules to keep were required inside the stealthy require for the first time, copy them to the restored cache
        for ( var k = 0; k < modulesToKeep.length; k+=1 ) ***REMOVED***
            if (stealthCache[modulesToKeep[k]]) ***REMOVED***
                requireCache[modulesToKeep[k]] = stealthCache[modulesToKeep[k]];
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    assign(requireCache, originalCache);

    return freshModule;

***REMOVED***;
