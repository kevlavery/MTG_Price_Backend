var path = require('path');
var minimist = require('minimist');
var wordwrap = require('wordwrap');

/*  Hack an instance of Argv with process.argv into Argv
    so people can do
        require('optimist')(['--beeble=1','-z','zizzle']).argv
    to parse a list of args and
        require('optimist').argv
    to get a parsed version of process.argv.
*/

var inst = Argv(process.argv.slice(2));
Object.keys(inst).forEach(function (key) ***REMOVED***
    Argv[key] = typeof inst[key] == 'function'
        ? inst[key].bind(inst)
        : inst[key];
***REMOVED***);

var exports = module.exports = Argv;
function Argv (processArgs, cwd) ***REMOVED***
    var self = ***REMOVED******REMOVED***;
    if (!cwd) cwd = process.cwd();
    
    self.$0 = process.argv
        .slice(0,2)
        .map(function (x) ***REMOVED***
            var b = rebase(cwd, x);
            return x.match(/^\//) && b.length < x.length
                ? b : x
        ***REMOVED***)
        .join(' ')
    ;
    
    if (process.env._ != undefined && process.argv[1] == process.env._) ***REMOVED***
        self.$0 = process.env._.replace(
            path.dirname(process.execPath) + '/', ''
        );
    ***REMOVED***
    
    var options = ***REMOVED***
        boolean: [],
        string: [],
        alias: ***REMOVED******REMOVED***,
        default: []
    ***REMOVED***;
    
    self.boolean = function (bools) ***REMOVED***
        options.boolean.push.apply(options.boolean, [].concat(bools));
        return self;
    ***REMOVED***;
    
    self.string = function (strings) ***REMOVED***
        options.string.push.apply(options.string, [].concat(strings));
        return self;
    ***REMOVED***;
    
    self.default = function (key, value) ***REMOVED***
        if (typeof key === 'object') ***REMOVED***
            Object.keys(key).forEach(function (k) ***REMOVED***
                self.default(k, key[k]);
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            options.default[key] = value;
        ***REMOVED***
        return self;
    ***REMOVED***;
    
    self.alias = function (x, y) ***REMOVED***
        if (typeof x === 'object') ***REMOVED***
            Object.keys(x).forEach(function (key) ***REMOVED***
                self.alias(key, x[key]);
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            options.alias[x] = (options.alias[x] || []).concat(y);
        ***REMOVED***
        return self;
    ***REMOVED***;
    
    var demanded = ***REMOVED******REMOVED***;
    self.demand = function (keys) ***REMOVED***
        if (typeof keys == 'number') ***REMOVED***
            if (!demanded._) demanded._ = 0;
            demanded._ += keys;
        ***REMOVED***
        else if (Array.isArray(keys)) ***REMOVED***
            keys.forEach(function (key) ***REMOVED***
                self.demand(key);
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            demanded[keys] = true;
        ***REMOVED***
        
        return self;
    ***REMOVED***;
    
    var usage;
    self.usage = function (msg, opts) ***REMOVED***
        if (!opts && typeof msg === 'object') ***REMOVED***
            opts = msg;
            msg = null;
        ***REMOVED***
        
        usage = msg;
        
        if (opts) self.options(opts);
        
        return self;
    ***REMOVED***;
    
    function fail (msg) ***REMOVED***
        self.showHelp();
        if (msg) console.error(msg);
        process.exit(1);
    ***REMOVED***
    
    var checks = [];
    self.check = function (f) ***REMOVED***
        checks.push(f);
        return self;
    ***REMOVED***;
    
    var descriptions = ***REMOVED******REMOVED***;
    self.describe = function (key, desc) ***REMOVED***
        if (typeof key === 'object') ***REMOVED***
            Object.keys(key).forEach(function (k) ***REMOVED***
                self.describe(k, key[k]);
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            descriptions[key] = desc;
        ***REMOVED***
        return self;
    ***REMOVED***;
    
    self.parse = function (args) ***REMOVED***
        return parseArgs(args);
    ***REMOVED***;
    
    self.option = self.options = function (key, opt) ***REMOVED***
        if (typeof key === 'object') ***REMOVED***
            Object.keys(key).forEach(function (k) ***REMOVED***
                self.options(k, key[k]);
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            if (opt.alias) self.alias(key, opt.alias);
            if (opt.demand) self.demand(key);
            if (typeof opt.default !== 'undefined') ***REMOVED***
                self.default(key, opt.default);
            ***REMOVED***
            
            if (opt.boolean || opt.type === 'boolean') ***REMOVED***
                self.boolean(key);
            ***REMOVED***
            if (opt.string || opt.type === 'string') ***REMOVED***
                self.string(key);
            ***REMOVED***
            
            var desc = opt.describe || opt.description || opt.desc;
            if (desc) ***REMOVED***
                self.describe(key, desc);
            ***REMOVED***
        ***REMOVED***
        
        return self;
    ***REMOVED***;
    
    var wrap = null;
    self.wrap = function (cols) ***REMOVED***
        wrap = cols;
        return self;
    ***REMOVED***;
    
    self.showHelp = function (fn) ***REMOVED***
        if (!fn) fn = console.error;
        fn(self.help());
    ***REMOVED***;
    
    self.help = function () ***REMOVED***
        var keys = Object.keys(
            Object.keys(descriptions)
            .concat(Object.keys(demanded))
            .concat(Object.keys(options.default))
            .reduce(function (acc, key) ***REMOVED***
                if (key !== '_') acc[key] = true;
                return acc;
            ***REMOVED***, ***REMOVED******REMOVED***)
        );
        
        var help = keys.length ? [ 'Options:' ] : [];
        
        if (usage) ***REMOVED***
            help.unshift(usage.replace(/\$0/g, self.$0), '');
        ***REMOVED***
        
        var switches = keys.reduce(function (acc, key) ***REMOVED***
            acc[key] = [ key ].concat(options.alias[key] || [])
                .map(function (sw) ***REMOVED***
                    return (sw.length > 1 ? '--' : '-') + sw
                ***REMOVED***)
                .join(', ')
            ;
            return acc;
        ***REMOVED***, ***REMOVED******REMOVED***);
        
        var switchlen = longest(Object.keys(switches).map(function (s) ***REMOVED***
            return switches[s] || '';
        ***REMOVED***));
        
        var desclen = longest(Object.keys(descriptions).map(function (d) ***REMOVED*** 
            return descriptions[d] || '';
        ***REMOVED***));
        
        keys.forEach(function (key) ***REMOVED***
            var kswitch = switches[key];
            var desc = descriptions[key] || '';
            
            if (wrap) ***REMOVED***
                desc = wordwrap(switchlen + 4, wrap)(desc)
                    .slice(switchlen + 4)
                ;
            ***REMOVED***
            
            var spadding = new Array(
                Math.max(switchlen - kswitch.length + 3, 0)
            ).join(' ');
            
            var dpadding = new Array(
                Math.max(desclen - desc.length + 1, 0)
            ).join(' ');
            
            var type = null;
            
            if (options.boolean[key]) type = '[boolean]';
            if (options.string[key]) type = '[string]';
            
            if (!wrap && dpadding.length > 0) ***REMOVED***
                desc += dpadding;
            ***REMOVED***
            
            var prelude = '  ' + kswitch + spadding;
            var extra = [
                type,
                demanded[key]
                    ? '[required]'
                    : null
                ,
                options.default[key] !== undefined
                    ? '[default: ' + JSON.stringify(options.default[key]) + ']'
                    : null
                ,
            ].filter(Boolean).join('  ');
            
            var body = [ desc, extra ].filter(Boolean).join('  ');
            
            if (wrap) ***REMOVED***
                var dlines = desc.split('\n');
                var dlen = dlines.slice(-1)[0].length
                    + (dlines.length === 1 ? prelude.length : 0)
                
                body = desc + (dlen + extra.length > wrap - 2
                    ? '\n'
                        + new Array(wrap - extra.length + 1).join(' ')
                        + extra
                    : new Array(wrap - extra.length - dlen + 1).join(' ')
                        + extra
                );
            ***REMOVED***
            
            help.push(prelude + body);
        ***REMOVED***);
        
        help.push('');
        return help.join('\n');
    ***REMOVED***;
    
    Object.defineProperty(self, 'argv', ***REMOVED***
        get : function () ***REMOVED*** return parseArgs(processArgs) ***REMOVED***,
        enumerable : true,
    ***REMOVED***);
    
    function parseArgs (args) ***REMOVED***
        var argv = minimist(args, options);
        argv.$0 = self.$0;
        
        if (demanded._ && argv._.length < demanded._) ***REMOVED***
            fail('Not enough non-option arguments: got '
                + argv._.length + ', need at least ' + demanded._
            );
        ***REMOVED***
        
        var missing = [];
        Object.keys(demanded).forEach(function (key) ***REMOVED***
            if (!argv[key]) missing.push(key);
        ***REMOVED***);
        
        if (missing.length) ***REMOVED***
            fail('Missing required arguments: ' + missing.join(', '));
        ***REMOVED***
        
        checks.forEach(function (f) ***REMOVED***
            try ***REMOVED***
                if (f(argv) === false) ***REMOVED***
                    fail('Argument check failed: ' + f.toString());
                ***REMOVED***
            ***REMOVED***
            catch (err) ***REMOVED***
                fail(err)
            ***REMOVED***
        ***REMOVED***);
        
        return argv;
    ***REMOVED***
    
    function longest (xs) ***REMOVED***
        return Math.max.apply(
            null,
            xs.map(function (x) ***REMOVED*** return x.length ***REMOVED***)
        );
    ***REMOVED***
    
    return self;
***REMOVED***;

// rebase an absolute path to a relative one with respect to a base directory
// exported for tests
exports.rebase = rebase;
function rebase (base, dir) ***REMOVED***
    var ds = path.normalize(dir).split('/').slice(1);
    var bs = path.normalize(base).split('/').slice(1);
    
    for (var i = 0; ds[i] && ds[i] == bs[i]; i++);
    ds.splice(0, i); bs.splice(0, i);
    
    var p = path.normalize(
        bs.map(function () ***REMOVED*** return '..' ***REMOVED***).concat(ds).join('/')
    ).replace(/\/$/,'').replace(/^$/, '.');
    return p.match(/^[.\/]/) ? p : './' + p;
***REMOVED***;
