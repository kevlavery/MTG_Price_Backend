/* eslint-disable no-console */
import Async from 'async';
import fs from 'fs';
import * as Handlebars from './handlebars';
import ***REMOVED***basename***REMOVED*** from 'path';
import ***REMOVED***SourceMapConsumer, SourceNode***REMOVED*** from 'source-map';
import uglify from 'uglify-js';

module.exports.loadTemplates = function(opts, callback) ***REMOVED***
  loadStrings(opts, function(err, strings) ***REMOVED***
    if (err) ***REMOVED***
      callback(err);
    ***REMOVED*** else ***REMOVED***
      loadFiles(opts, function(err, files) ***REMOVED***
        if (err) ***REMOVED***
          callback(err);
        ***REMOVED*** else ***REMOVED***
          opts.templates = strings.concat(files);
          callback(undefined, opts);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

function loadStrings(opts, callback) ***REMOVED***
  let strings = arrayCast(opts.string),
      names = arrayCast(opts.name);

  if (names.length !== strings.length
      && strings.length > 1) ***REMOVED***
    return callback(new Handlebars.Exception('Number of names did not match the number of string inputs'));
  ***REMOVED***

  Async.map(strings, function(string, callback) ***REMOVED***
      if (string !== '-') ***REMOVED***
        callback(undefined, string);
      ***REMOVED*** else ***REMOVED***
        // Load from stdin
        let buffer = '';
        process.stdin.setEncoding('utf8');

        process.stdin.on('data', function(chunk) ***REMOVED***
          buffer += chunk;
        ***REMOVED***);
        process.stdin.on('end', function() ***REMOVED***
          callback(undefined, buffer);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***,
    function(err, strings) ***REMOVED***
      strings = strings.map((string, index) => (***REMOVED***
        name: names[index],
        path: names[index],
        source: string
      ***REMOVED***));
      callback(err, strings);
    ***REMOVED***);
***REMOVED***

function loadFiles(opts, callback) ***REMOVED***
  // Build file extension pattern
  let extension = (opts.extension || 'handlebars').replace(/[\\^$*+?.():=!|***REMOVED******REMOVED***\-\[\]]/g, function(arg) ***REMOVED*** return '\\' + arg; ***REMOVED***);
  extension = new RegExp('\\.' + extension + '$');

  let ret = [],
      queue = (opts.files || []).map((template) => (***REMOVED***template, root: opts.root***REMOVED***));
  Async.whilst(() => queue.length, function(callback) ***REMOVED***
    let ***REMOVED***template: path, root***REMOVED*** = queue.shift();

    fs.stat(path, function(err, stat) ***REMOVED***
      if (err) ***REMOVED***
        return callback(new Handlebars.Exception(`Unable to open template file "$***REMOVED***path***REMOVED***"`));
      ***REMOVED***

      if (stat.isDirectory()) ***REMOVED***
        opts.hasDirectory = true;

        fs.readdir(path, function(err, children) ***REMOVED***
          /* istanbul ignore next : Race condition that being too lazy to test */
          if (err) ***REMOVED***
            return callback(err);
          ***REMOVED***
          children.forEach(function(file) ***REMOVED***
            let childPath = path + '/' + file;

            if (extension.test(childPath) || fs.statSync(childPath).isDirectory()) ***REMOVED***
              queue.push(***REMOVED***template: childPath, root: root || path***REMOVED***);
            ***REMOVED***
          ***REMOVED***);

          callback();
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        fs.readFile(path, 'utf8', function(err, data) ***REMOVED***
          /* istanbul ignore next : Race condition that being too lazy to test */
          if (err) ***REMOVED***
            return callback(err);
          ***REMOVED***

          if (opts.bom && data.indexOf('\uFEFF') === 0) ***REMOVED***
            data = data.substring(1);
          ***REMOVED***

          // Clean the template name
          let name = path;
          if (!root) ***REMOVED***
            name = basename(name);
          ***REMOVED*** else if (name.indexOf(root) === 0) ***REMOVED***
            name = name.substring(root.length + 1);
          ***REMOVED***
          name = name.replace(extension, '');

          ret.push(***REMOVED***
            path: path,
            name: name,
            source: data
          ***REMOVED***);

          callback();
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***,
  function(err) ***REMOVED***
    if (err) ***REMOVED***
      callback(err);
    ***REMOVED*** else ***REMOVED***
      callback(undefined, ret);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

module.exports.cli = function(opts) ***REMOVED***
  if (opts.version) ***REMOVED***
    console.log(Handlebars.VERSION);
    return;
  ***REMOVED***

  if (!opts.templates.length && !opts.hasDirectory) ***REMOVED***
    throw new Handlebars.Exception('Must define at least one template or directory.');
  ***REMOVED***

  if (opts.simple && opts.min) ***REMOVED***
    throw new Handlebars.Exception('Unable to minimize simple output');
  ***REMOVED***

  const multiple = opts.templates.length !== 1 || opts.hasDirectory;
  if (opts.simple && multiple) ***REMOVED***
    throw new Handlebars.Exception('Unable to output multiple templates in simple mode');
  ***REMOVED***

  // Force simple mode if we have only one template and it's unnamed.
  if (!opts.amd && !opts.commonjs && opts.templates.length === 1
      && !opts.templates[0].name) ***REMOVED***
    opts.simple = true;
  ***REMOVED***

  // Convert the known list into a hash
  let known = ***REMOVED******REMOVED***;
  if (opts.known && !Array.isArray(opts.known)) ***REMOVED***
    opts.known = [opts.known];
  ***REMOVED***
  if (opts.known) ***REMOVED***
    for (let i = 0, len = opts.known.length; i < len; i++) ***REMOVED***
      known[opts.known[i]] = true;
    ***REMOVED***
  ***REMOVED***

  const objectName = opts.partial ? 'Handlebars.partials' : 'templates';

  let output = new SourceNode();
  if (!opts.simple) ***REMOVED***
    if (opts.amd) ***REMOVED***
      output.add('define([\'' + opts.handlebarPath + 'handlebars.runtime\'], function(Handlebars) ***REMOVED***\n  Handlebars = Handlebars["default"];');
    ***REMOVED*** else if (opts.commonjs) ***REMOVED***
      output.add('var Handlebars = require("' + opts.commonjs + '");');
    ***REMOVED*** else ***REMOVED***
      output.add('(function() ***REMOVED***\n');
    ***REMOVED***
    output.add('  var template = Handlebars.template, templates = ');
    if (opts.namespace) ***REMOVED***
      output.add(opts.namespace);
      output.add(' = ');
      output.add(opts.namespace);
      output.add(' || ');
    ***REMOVED***
    output.add('***REMOVED******REMOVED***;\n');
  ***REMOVED***

  opts.templates.forEach(function(template) ***REMOVED***
    let options = ***REMOVED***
      knownHelpers: known,
      knownHelpersOnly: opts.o
    ***REMOVED***;

    if (opts.map) ***REMOVED***
      options.srcName = template.path;
    ***REMOVED***
    if (opts.data) ***REMOVED***
      options.data = true;
    ***REMOVED***

    let precompiled = Handlebars.precompile(template.source, options);

    // If we are generating a source map, we have to reconstruct the SourceNode object
    if (opts.map) ***REMOVED***
      let consumer = new SourceMapConsumer(precompiled.map);
      precompiled = SourceNode.fromStringWithSourceMap(precompiled.code, consumer);
    ***REMOVED***

    if (opts.simple) ***REMOVED***
      output.add([precompiled, '\n']);
    ***REMOVED*** else ***REMOVED***
      if (!template.name) ***REMOVED***
        throw new Handlebars.Exception('Name missing for template');
      ***REMOVED***

      if (opts.amd && !multiple) ***REMOVED***
        output.add('return ');
      ***REMOVED***
      output.add([objectName, '[\'', template.name, '\'] = template(', precompiled, ');\n']);
    ***REMOVED***
  ***REMOVED***);

  // Output the content
  if (!opts.simple) ***REMOVED***
    if (opts.amd) ***REMOVED***
      if (multiple) ***REMOVED***
        output.add(['return ', objectName, ';\n']);
      ***REMOVED***
      output.add('***REMOVED***);');
    ***REMOVED*** else if (!opts.commonjs) ***REMOVED***
      output.add('***REMOVED***)();');
    ***REMOVED***
  ***REMOVED***


  if (opts.map) ***REMOVED***
    output.add('\n//# sourceMappingURL=' + opts.map + '\n');
  ***REMOVED***

  output = output.toStringWithSourceMap();
  output.map = output.map + '';

  if (opts.min) ***REMOVED***
    output = uglify.minify(output.code, ***REMOVED***
      fromString: true,

      outSourceMap: opts.map,
      inSourceMap: JSON.parse(output.map)
    ***REMOVED***);
    if (opts.map) ***REMOVED***
      output.code += '\n//# sourceMappingURL=' + opts.map + '\n';
    ***REMOVED***
  ***REMOVED***

  if (opts.map) ***REMOVED***
    fs.writeFileSync(opts.map, output.map, 'utf8');
  ***REMOVED***
  output = output.code;

  if (opts.output) ***REMOVED***
    fs.writeFileSync(opts.output, output, 'utf8');
  ***REMOVED*** else ***REMOVED***
    console.log(output);
  ***REMOVED***
***REMOVED***;

function arrayCast(value) ***REMOVED***
  value = value != null ? value : [];
  if (!Array.isArray(value)) ***REMOVED***
    value = [value];
  ***REMOVED***
  return value;
***REMOVED***
