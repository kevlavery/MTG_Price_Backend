import ***REMOVED*** COMPILER_REVISION, REVISION_CHANGES ***REMOVED*** from '../base';
import Exception from '../exception';
import ***REMOVED***isArray***REMOVED*** from '../utils';
import CodeGen from './code-gen';

function Literal(value) ***REMOVED***
  this.value = value;
***REMOVED***

function JavaScriptCompiler() ***REMOVED******REMOVED***

JavaScriptCompiler.prototype = ***REMOVED***
  // PUBLIC API: You can override these methods in a subclass to provide
  // alternative compiled forms for name lookup and buffering semantics
  nameLookup: function(parent, name/* , type*/) ***REMOVED***
    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) ***REMOVED***
      return [parent, '.', name];
    ***REMOVED*** else ***REMOVED***
      return [parent, '[', JSON.stringify(name), ']'];
    ***REMOVED***
  ***REMOVED***,
  depthedLookup: function(name) ***REMOVED***
    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
  ***REMOVED***,

  compilerInfo: function() ***REMOVED***
    const revision = COMPILER_REVISION,
          versions = REVISION_CHANGES[revision];
    return [revision, versions];
  ***REMOVED***,

  appendToBuffer: function(source, location, explicit) ***REMOVED***
    // Force a source as this simplifies the merge logic.
    if (!isArray(source)) ***REMOVED***
      source = [source];
    ***REMOVED***
    source = this.source.wrap(source, location);

    if (this.environment.isSimple) ***REMOVED***
      return ['return ', source, ';'];
    ***REMOVED*** else if (explicit) ***REMOVED***
      // This is a case where the buffer operation occurs as a child of another
      // construct, generally braces. We have to explicitly output these buffer
      // operations to ensure that the emitted code goes in the correct location.
      return ['buffer += ', source, ';'];
    ***REMOVED*** else ***REMOVED***
      source.appendToBuffer = true;
      return source;
    ***REMOVED***
  ***REMOVED***,

  initializeBuffer: function() ***REMOVED***
    return this.quotedString('');
  ***REMOVED***,
  // END PUBLIC API

  compile: function(environment, options, context, asObject) ***REMOVED***
    this.environment = environment;
    this.options = options;
    this.stringParams = this.options.stringParams;
    this.trackIds = this.options.trackIds;
    this.precompile = !asObject;

    this.name = this.environment.name;
    this.isChild = !!context;
    this.context = context || ***REMOVED***
      decorators: [],
      programs: [],
      environments: []
    ***REMOVED***;

    this.preamble();

    this.stackSlot = 0;
    this.stackVars = [];
    this.aliases = ***REMOVED******REMOVED***;
    this.registers = ***REMOVED*** list: [] ***REMOVED***;
    this.hashes = [];
    this.compileStack = [];
    this.inlineStack = [];
    this.blockParams = [];

    this.compileChildren(environment, options);

    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

    let opcodes = environment.opcodes,
        opcode,
        firstLoc,
        i,
        l;

    for (i = 0, l = opcodes.length; i < l; i++) ***REMOVED***
      opcode = opcodes[i];

      this.source.currentLocation = opcode.loc;
      firstLoc = firstLoc || opcode.loc;
      this[opcode.opcode].apply(this, opcode.args);
    ***REMOVED***

    // Flush any trailing content that might be pending.
    this.source.currentLocation = firstLoc;
    this.pushSource('');

    /* istanbul ignore next */
    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) ***REMOVED***
      throw new Exception('Compile completed with content left on stack');
    ***REMOVED***

    if (!this.decorators.isEmpty()) ***REMOVED***
      this.useDecorators = true;

      this.decorators.prepend('var decorators = container.decorators;\n');
      this.decorators.push('return fn;');

      if (asObject) ***REMOVED***
        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
      ***REMOVED*** else ***REMOVED***
        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) ***REMOVED***\n');
        this.decorators.push('***REMOVED***\n');
        this.decorators = this.decorators.merge();
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      this.decorators = undefined;
    ***REMOVED***

    let fn = this.createFunctionContext(asObject);
    if (!this.isChild) ***REMOVED***
      let ret = ***REMOVED***
        compiler: this.compilerInfo(),
        main: fn
      ***REMOVED***;

      if (this.decorators) ***REMOVED***
        ret.main_d = this.decorators;   // eslint-disable-line camelcase
        ret.useDecorators = true;
      ***REMOVED***

      let ***REMOVED***programs, decorators***REMOVED*** = this.context;
      for (i = 0, l = programs.length; i < l; i++) ***REMOVED***
        if (programs[i]) ***REMOVED***
          ret[i] = programs[i];
          if (decorators[i]) ***REMOVED***
            ret[i + '_d'] = decorators[i];
            ret.useDecorators = true;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      if (this.environment.usePartial) ***REMOVED***
        ret.usePartial = true;
      ***REMOVED***
      if (this.options.data) ***REMOVED***
        ret.useData = true;
      ***REMOVED***
      if (this.useDepths) ***REMOVED***
        ret.useDepths = true;
      ***REMOVED***
      if (this.useBlockParams) ***REMOVED***
        ret.useBlockParams = true;
      ***REMOVED***
      if (this.options.compat) ***REMOVED***
        ret.compat = true;
      ***REMOVED***

      if (!asObject) ***REMOVED***
        ret.compiler = JSON.stringify(ret.compiler);

        this.source.currentLocation = ***REMOVED***start: ***REMOVED***line: 1, column: 0***REMOVED******REMOVED***;
        ret = this.objectLiteral(ret);

        if (options.srcName) ***REMOVED***
          ret = ret.toStringWithSourceMap(***REMOVED***file: options.destName***REMOVED***);
          ret.map = ret.map && ret.map.toString();
        ***REMOVED*** else ***REMOVED***
          ret = ret.toString();
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        ret.compilerOptions = this.options;
      ***REMOVED***

      return ret;
    ***REMOVED*** else ***REMOVED***
      return fn;
    ***REMOVED***
  ***REMOVED***,

  preamble: function() ***REMOVED***
    // track the last context pushed into place to allow skipping the
    // getContext opcode when it would be a noop
    this.lastContext = 0;
    this.source = new CodeGen(this.options.srcName);
    this.decorators = new CodeGen(this.options.srcName);
  ***REMOVED***,

  createFunctionContext: function(asObject) ***REMOVED***
    let varDeclarations = '';

    let locals = this.stackVars.concat(this.registers.list);
    if (locals.length > 0) ***REMOVED***
      varDeclarations += ', ' + locals.join(', ');
    ***REMOVED***

    // Generate minimizer alias mappings
    //
    // When using true SourceNodes, this will update all references to the given alias
    // as the source nodes are reused in situ. For the non-source node compilation mode,
    // aliases will not be used, but this case is already being run on the client and
    // we aren't concern about minimizing the template size.
    let aliasCount = 0;
    for (let alias in this.aliases) ***REMOVED***    // eslint-disable-line guard-for-in
      let node = this.aliases[alias];

      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) ***REMOVED***
        varDeclarations += ', alias' + (++aliasCount) + '=' + alias;
        node.children[0] = 'alias' + aliasCount;
      ***REMOVED***
    ***REMOVED***

    let params = ['container', 'depth0', 'helpers', 'partials', 'data'];

    if (this.useBlockParams || this.useDepths) ***REMOVED***
      params.push('blockParams');
    ***REMOVED***
    if (this.useDepths) ***REMOVED***
      params.push('depths');
    ***REMOVED***

    // Perform a second pass over the output to merge content when possible
    let source = this.mergeSource(varDeclarations);

    if (asObject) ***REMOVED***
      params.push(source);

      return Function.apply(this, params);
    ***REMOVED*** else ***REMOVED***
      return this.source.wrap(['function(', params.join(','), ') ***REMOVED***\n  ', source, '***REMOVED***']);
    ***REMOVED***
  ***REMOVED***,
  mergeSource: function(varDeclarations) ***REMOVED***
    let isSimple = this.environment.isSimple,
        appendOnly = !this.forceBuffer,
        appendFirst,

        sourceSeen,
        bufferStart,
        bufferEnd;
    this.source.each((line) => ***REMOVED***
      if (line.appendToBuffer) ***REMOVED***
        if (bufferStart) ***REMOVED***
          line.prepend('  + ');
        ***REMOVED*** else ***REMOVED***
          bufferStart = line;
        ***REMOVED***
        bufferEnd = line;
      ***REMOVED*** else ***REMOVED***
        if (bufferStart) ***REMOVED***
          if (!sourceSeen) ***REMOVED***
            appendFirst = true;
          ***REMOVED*** else ***REMOVED***
            bufferStart.prepend('buffer += ');
          ***REMOVED***
          bufferEnd.add(';');
          bufferStart = bufferEnd = undefined;
        ***REMOVED***

        sourceSeen = true;
        if (!isSimple) ***REMOVED***
          appendOnly = false;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***);


    if (appendOnly) ***REMOVED***
      if (bufferStart) ***REMOVED***
        bufferStart.prepend('return ');
        bufferEnd.add(';');
      ***REMOVED*** else if (!sourceSeen) ***REMOVED***
        this.source.push('return "";');
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

      if (bufferStart) ***REMOVED***
        bufferStart.prepend('return buffer + ');
        bufferEnd.add(';');
      ***REMOVED*** else ***REMOVED***
        this.source.push('return buffer;');
      ***REMOVED***
    ***REMOVED***

    if (varDeclarations) ***REMOVED***
      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
    ***REMOVED***

    return this.source.merge();
  ***REMOVED***,

  // [blockValue]
  //
  // On stack, before: hash, inverse, program, value
  // On stack, after: return value of blockHelperMissing
  //
  // The purpose of this opcode is to take a block of the form
  // `***REMOVED******REMOVED***#this.foo***REMOVED******REMOVED***...***REMOVED******REMOVED***/this.foo***REMOVED******REMOVED***`, resolve the value of `foo`, and
  // replace it on the stack with the result of properly
  // invoking blockHelperMissing.
  blockValue: function(name) ***REMOVED***
    let blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
        params = [this.contextName(0)];
    this.setupHelperArgs(name, 0, params);

    let blockName = this.popStack();
    params.splice(1, 0, blockName);

    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
  ***REMOVED***,

  // [ambiguousBlockValue]
  //
  // On stack, before: hash, inverse, program, value
  // Compiler value, before: lastHelper=value of last found helper, if any
  // On stack, after, if no lastHelper: same as [blockValue]
  // On stack, after, if lastHelper: value
  ambiguousBlockValue: function() ***REMOVED***
    // We're being a bit cheeky and reusing the options value from the prior exec
    let blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
        params = [this.contextName(0)];
    this.setupHelperArgs('', 0, params, true);

    this.flushInline();

    let current = this.topStack();
    params.splice(1, 0, current);

    this.pushSource([
        'if (!', this.lastHelper, ') ***REMOVED*** ',
          current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params),
        '***REMOVED***']);
  ***REMOVED***,

  // [appendContent]
  //
  // On stack, before: ...
  // On stack, after: ...
  //
  // Appends the string value of `content` to the current buffer
  appendContent: function(content) ***REMOVED***
    if (this.pendingContent) ***REMOVED***
      content = this.pendingContent + content;
    ***REMOVED*** else ***REMOVED***
      this.pendingLocation = this.source.currentLocation;
    ***REMOVED***

    this.pendingContent = content;
  ***REMOVED***,

  // [append]
  //
  // On stack, before: value, ...
  // On stack, after: ...
  //
  // Coerces `value` to a String and appends it to the current buffer.
  //
  // If `value` is truthy, or 0, it is coerced into a string and appended
  // Otherwise, the empty string is appended
  append: function() ***REMOVED***
    if (this.isInline()) ***REMOVED***
      this.replaceStack((current) => [' != null ? ', current, ' : ""']);

      this.pushSource(this.appendToBuffer(this.popStack()));
    ***REMOVED*** else ***REMOVED***
      let local = this.popStack();
      this.pushSource(['if (', local, ' != null) ***REMOVED*** ', this.appendToBuffer(local, undefined, true), ' ***REMOVED***']);
      if (this.environment.isSimple) ***REMOVED***
        this.pushSource(['else ***REMOVED*** ', this.appendToBuffer("''", undefined, true), ' ***REMOVED***']);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,

  // [appendEscaped]
  //
  // On stack, before: value, ...
  // On stack, after: ...
  //
  // Escape `value` and append it to the buffer
  appendEscaped: function() ***REMOVED***
    this.pushSource(this.appendToBuffer(
        [this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
  ***REMOVED***,

  // [getContext]
  //
  // On stack, before: ...
  // On stack, after: ...
  // Compiler value, after: lastContext=depth
  //
  // Set the value of the `lastContext` compiler value to the depth
  getContext: function(depth) ***REMOVED***
    this.lastContext = depth;
  ***REMOVED***,

  // [pushContext]
  //
  // On stack, before: ...
  // On stack, after: currentContext, ...
  //
  // Pushes the value of the current context onto the stack.
  pushContext: function() ***REMOVED***
    this.pushStackLiteral(this.contextName(this.lastContext));
  ***REMOVED***,

  // [lookupOnContext]
  //
  // On stack, before: ...
  // On stack, after: currentContext[name], ...
  //
  // Looks up the value of `name` on the current context and pushes
  // it onto the stack.
  lookupOnContext: function(parts, falsy, strict, scoped) ***REMOVED***
    let i = 0;

    if (!scoped && this.options.compat && !this.lastContext) ***REMOVED***
      // The depthed query is expected to handle the undefined logic for the root level that
      // is implemented below, so we evaluate that directly in compat mode
      this.push(this.depthedLookup(parts[i++]));
    ***REMOVED*** else ***REMOVED***
      this.pushContext();
    ***REMOVED***

    this.resolvePath('context', parts, i, falsy, strict);
  ***REMOVED***,

  // [lookupBlockParam]
  //
  // On stack, before: ...
  // On stack, after: blockParam[name], ...
  //
  // Looks up the value of `parts` on the given block param and pushes
  // it onto the stack.
  lookupBlockParam: function(blockParamId, parts) ***REMOVED***
    this.useBlockParams = true;

    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
    this.resolvePath('context', parts, 1);
  ***REMOVED***,

  // [lookupData]
  //
  // On stack, before: ...
  // On stack, after: data, ...
  //
  // Push the data lookup operator
  lookupData: function(depth, parts, strict) ***REMOVED***
    if (!depth) ***REMOVED***
      this.pushStackLiteral('data');
    ***REMOVED*** else ***REMOVED***
      this.pushStackLiteral('container.data(data, ' + depth + ')');
    ***REMOVED***

    this.resolvePath('data', parts, 0, true, strict);
  ***REMOVED***,

  resolvePath: function(type, parts, i, falsy, strict) ***REMOVED***
    if (this.options.strict || this.options.assumeObjects) ***REMOVED***
      this.push(strictLookup(this.options.strict && strict, this, parts, type));
      return;
    ***REMOVED***

    let len = parts.length;
    for (; i < len; i++) ***REMOVED***
      /* eslint-disable no-loop-func */
      this.replaceStack((current) => ***REMOVED***
        let lookup = this.nameLookup(current, parts[i], type);
        // We want to ensure that zero and false are handled properly if the context (falsy flag)
        // needs to have the special handling for these values.
        if (!falsy) ***REMOVED***
          return [' != null ? ', lookup, ' : ', current];
        ***REMOVED*** else ***REMOVED***
          // Otherwise we can use generic falsy handling
          return [' && ', lookup];
        ***REMOVED***
      ***REMOVED***);
      /* eslint-enable no-loop-func */
    ***REMOVED***
  ***REMOVED***,

  // [resolvePossibleLambda]
  //
  // On stack, before: value, ...
  // On stack, after: resolved value, ...
  //
  // If the `value` is a lambda, replace it on the stack by
  // the return value of the lambda
  resolvePossibleLambda: function() ***REMOVED***
    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
  ***REMOVED***,

  // [pushStringParam]
  //
  // On stack, before: ...
  // On stack, after: string, currentContext, ...
  //
  // This opcode is designed for use in string mode, which
  // provides the string value of a parameter along with its
  // depth rather than resolving it immediately.
  pushStringParam: function(string, type) ***REMOVED***
    this.pushContext();
    this.pushString(type);

    // If it's a subexpression, the string result
    // will be pushed after this opcode.
    if (type !== 'SubExpression') ***REMOVED***
      if (typeof string === 'string') ***REMOVED***
        this.pushString(string);
      ***REMOVED*** else ***REMOVED***
        this.pushStackLiteral(string);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,

  emptyHash: function(omitEmpty) ***REMOVED***
    if (this.trackIds) ***REMOVED***
      this.push('***REMOVED******REMOVED***'); // hashIds
    ***REMOVED***
    if (this.stringParams) ***REMOVED***
      this.push('***REMOVED******REMOVED***'); // hashContexts
      this.push('***REMOVED******REMOVED***'); // hashTypes
    ***REMOVED***
    this.pushStackLiteral(omitEmpty ? 'undefined' : '***REMOVED******REMOVED***');
  ***REMOVED***,
  pushHash: function() ***REMOVED***
    if (this.hash) ***REMOVED***
      this.hashes.push(this.hash);
    ***REMOVED***
    this.hash = ***REMOVED***values: [], types: [], contexts: [], ids: []***REMOVED***;
  ***REMOVED***,
  popHash: function() ***REMOVED***
    let hash = this.hash;
    this.hash = this.hashes.pop();

    if (this.trackIds) ***REMOVED***
      this.push(this.objectLiteral(hash.ids));
    ***REMOVED***
    if (this.stringParams) ***REMOVED***
      this.push(this.objectLiteral(hash.contexts));
      this.push(this.objectLiteral(hash.types));
    ***REMOVED***

    this.push(this.objectLiteral(hash.values));
  ***REMOVED***,

  // [pushString]
  //
  // On stack, before: ...
  // On stack, after: quotedString(string), ...
  //
  // Push a quoted version of `string` onto the stack
  pushString: function(string) ***REMOVED***
    this.pushStackLiteral(this.quotedString(string));
  ***REMOVED***,

  // [pushLiteral]
  //
  // On stack, before: ...
  // On stack, after: value, ...
  //
  // Pushes a value onto the stack. This operation prevents
  // the compiler from creating a temporary variable to hold
  // it.
  pushLiteral: function(value) ***REMOVED***
    this.pushStackLiteral(value);
  ***REMOVED***,

  // [pushProgram]
  //
  // On stack, before: ...
  // On stack, after: program(guid), ...
  //
  // Push a program expression onto the stack. This takes
  // a compile-time guid and converts it into a runtime-accessible
  // expression.
  pushProgram: function(guid) ***REMOVED***
    if (guid != null) ***REMOVED***
      this.pushStackLiteral(this.programExpression(guid));
    ***REMOVED*** else ***REMOVED***
      this.pushStackLiteral(null);
    ***REMOVED***
  ***REMOVED***,

  // [registerDecorator]
  //
  // On stack, before: hash, program, params..., ...
  // On stack, after: ...
  //
  // Pops off the decorator's parameters, invokes the decorator,
  // and inserts the decorator into the decorators list.
  registerDecorator(paramSize, name) ***REMOVED***
    let foundDecorator = this.nameLookup('decorators', name, 'decorator'),
        options = this.setupHelperArgs(name, paramSize);

    this.decorators.push([
      'fn = ',
      this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]),
      ' || fn;'
    ]);
  ***REMOVED***,

  // [invokeHelper]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of helper invocation
  //
  // Pops off the helper's parameters, invokes the helper,
  // and pushes the helper's return value onto the stack.
  //
  // If the helper is not found, `helperMissing` is called.
  invokeHelper: function(paramSize, name, isSimple) ***REMOVED***
    let nonHelper = this.popStack(),
        helper = this.setupHelper(paramSize, name),
        simple = isSimple ? [helper.name, ' || '] : '';

    let lookup = ['('].concat(simple, nonHelper);
    if (!this.options.strict) ***REMOVED***
      lookup.push(' || ', this.aliasable('helpers.helperMissing'));
    ***REMOVED***
    lookup.push(')');

    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
  ***REMOVED***,

  // [invokeKnownHelper]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of helper invocation
  //
  // This operation is used when the helper is known to exist,
  // so a `helperMissing` fallback is not required.
  invokeKnownHelper: function(paramSize, name) ***REMOVED***
    let helper = this.setupHelper(paramSize, name);
    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
  ***REMOVED***,

  // [invokeAmbiguous]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of disambiguation
  //
  // This operation is used when an expression like `***REMOVED******REMOVED***foo***REMOVED******REMOVED***`
  // is provided, but we don't know at compile-time whether it
  // is a helper or a path.
  //
  // This operation emits more code than the other options,
  // and can be avoided by passing the `knownHelpers` and
  // `knownHelpersOnly` flags at compile-time.
  invokeAmbiguous: function(name, helperCall) ***REMOVED***
    this.useRegister('helper');

    let nonHelper = this.popStack();

    this.emptyHash();
    let helper = this.setupHelper(0, name, helperCall);

    let helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

    let lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
    if (!this.options.strict) ***REMOVED***
      lookup[0] = '(helper = ';
      lookup.push(
        ' != null ? helper : ',
        this.aliasable('helpers.helperMissing')
      );
    ***REMOVED***

    this.push([
        '(', lookup,
        (helper.paramsInit ? ['),(', helper.paramsInit] : []), '),',
        '(typeof helper === ', this.aliasable('"function"'), ' ? ',
        this.source.functionCall('helper', 'call', helper.callParams), ' : helper))'
    ]);
  ***REMOVED***,

  // [invokePartial]
  //
  // On stack, before: context, ...
  // On stack after: result of partial invocation
  //
  // This operation pops off a context, invokes a partial with that context,
  // and pushes the result of the invocation back.
  invokePartial: function(isDynamic, name, indent) ***REMOVED***
    let params = [],
        options = this.setupParams(name, 1, params);

    if (isDynamic) ***REMOVED***
      name = this.popStack();
      delete options.name;
    ***REMOVED***

    if (indent) ***REMOVED***
      options.indent = JSON.stringify(indent);
    ***REMOVED***
    options.helpers = 'helpers';
    options.partials = 'partials';
    options.decorators = 'container.decorators';

    if (!isDynamic) ***REMOVED***
      params.unshift(this.nameLookup('partials', name, 'partial'));
    ***REMOVED*** else ***REMOVED***
      params.unshift(name);
    ***REMOVED***

    if (this.options.compat) ***REMOVED***
      options.depths = 'depths';
    ***REMOVED***
    options = this.objectLiteral(options);
    params.push(options);

    this.push(this.source.functionCall('container.invokePartial', '', params));
  ***REMOVED***,

  // [assignToHash]
  //
  // On stack, before: value, ..., hash, ...
  // On stack, after: ..., hash, ...
  //
  // Pops a value off the stack and assigns it to the current hash
  assignToHash: function(key) ***REMOVED***
    let value = this.popStack(),
        context,
        type,
        id;

    if (this.trackIds) ***REMOVED***
      id = this.popStack();
    ***REMOVED***
    if (this.stringParams) ***REMOVED***
      type = this.popStack();
      context = this.popStack();
    ***REMOVED***

    let hash = this.hash;
    if (context) ***REMOVED***
      hash.contexts[key] = context;
    ***REMOVED***
    if (type) ***REMOVED***
      hash.types[key] = type;
    ***REMOVED***
    if (id) ***REMOVED***
      hash.ids[key] = id;
    ***REMOVED***
    hash.values[key] = value;
  ***REMOVED***,

  pushId: function(type, name, child) ***REMOVED***
    if (type === 'BlockParam') ***REMOVED***
      this.pushStackLiteral(
          'blockParams[' + name[0] + '].path[' + name[1] + ']'
          + (child ? ' + ' + JSON.stringify('.' + child) : ''));
    ***REMOVED*** else if (type === 'PathExpression') ***REMOVED***
      this.pushString(name);
    ***REMOVED*** else if (type === 'SubExpression') ***REMOVED***
      this.pushStackLiteral('true');
    ***REMOVED*** else ***REMOVED***
      this.pushStackLiteral('null');
    ***REMOVED***
  ***REMOVED***,

  // HELPERS

  compiler: JavaScriptCompiler,

  compileChildren: function(environment, options) ***REMOVED***
    let children = environment.children, child, compiler;

    for (let i = 0, l = children.length; i < l; i++) ***REMOVED***
      child = children[i];
      compiler = new this.compiler();    // eslint-disable-line new-cap

      let index = this.matchExistingProgram(child);

      if (index == null) ***REMOVED***
        this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children
        index = this.context.programs.length;
        child.index = index;
        child.name = 'program' + index;
        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
        this.context.decorators[index] = compiler.decorators;
        this.context.environments[index] = child;

        this.useDepths = this.useDepths || compiler.useDepths;
        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
      ***REMOVED*** else ***REMOVED***
        child.index = index;
        child.name = 'program' + index;

        this.useDepths = this.useDepths || child.useDepths;
        this.useBlockParams = this.useBlockParams || child.useBlockParams;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,
  matchExistingProgram: function(child) ***REMOVED***
    for (let i = 0, len = this.context.environments.length; i < len; i++) ***REMOVED***
      let environment = this.context.environments[i];
      if (environment && environment.equals(child)) ***REMOVED***
        return i;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,

  programExpression: function(guid) ***REMOVED***
    let child = this.environment.children[guid],
        programParams = [child.index, 'data', child.blockParams];

    if (this.useBlockParams || this.useDepths) ***REMOVED***
      programParams.push('blockParams');
    ***REMOVED***
    if (this.useDepths) ***REMOVED***
      programParams.push('depths');
    ***REMOVED***

    return 'container.program(' + programParams.join(', ') + ')';
  ***REMOVED***,

  useRegister: function(name) ***REMOVED***
    if (!this.registers[name]) ***REMOVED***
      this.registers[name] = true;
      this.registers.list.push(name);
    ***REMOVED***
  ***REMOVED***,

  push: function(expr) ***REMOVED***
    if (!(expr instanceof Literal)) ***REMOVED***
      expr = this.source.wrap(expr);
    ***REMOVED***

    this.inlineStack.push(expr);
    return expr;
  ***REMOVED***,

  pushStackLiteral: function(item) ***REMOVED***
    this.push(new Literal(item));
  ***REMOVED***,

  pushSource: function(source) ***REMOVED***
    if (this.pendingContent) ***REMOVED***
      this.source.push(
          this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
      this.pendingContent = undefined;
    ***REMOVED***

    if (source) ***REMOVED***
      this.source.push(source);
    ***REMOVED***
  ***REMOVED***,

  replaceStack: function(callback) ***REMOVED***
    let prefix = ['('],
        stack,
        createdStack,
        usedLiteral;

    /* istanbul ignore next */
    if (!this.isInline()) ***REMOVED***
      throw new Exception('replaceStack on non-inline');
    ***REMOVED***

    // We want to merge the inline statement into the replacement statement via ','
    let top = this.popStack(true);

    if (top instanceof Literal) ***REMOVED***
      // Literals do not need to be inlined
      stack = [top.value];
      prefix = ['(', stack];
      usedLiteral = true;
    ***REMOVED*** else ***REMOVED***
      // Get or create the current stack name for use by the inline
      createdStack = true;
      let name = this.incrStack();

      prefix = ['((', this.push(name), ' = ', top, ')'];
      stack = this.topStack();
    ***REMOVED***

    let item = callback.call(this, stack);

    if (!usedLiteral) ***REMOVED***
      this.popStack();
    ***REMOVED***
    if (createdStack) ***REMOVED***
      this.stackSlot--;
    ***REMOVED***
    this.push(prefix.concat(item, ')'));
  ***REMOVED***,

  incrStack: function() ***REMOVED***
    this.stackSlot++;
    if (this.stackSlot > this.stackVars.length) ***REMOVED*** this.stackVars.push('stack' + this.stackSlot); ***REMOVED***
    return this.topStackName();
  ***REMOVED***,
  topStackName: function() ***REMOVED***
    return 'stack' + this.stackSlot;
  ***REMOVED***,
  flushInline: function() ***REMOVED***
    let inlineStack = this.inlineStack;
    this.inlineStack = [];
    for (let i = 0, len = inlineStack.length; i < len; i++) ***REMOVED***
      let entry = inlineStack[i];
      /* istanbul ignore if */
      if (entry instanceof Literal) ***REMOVED***
        this.compileStack.push(entry);
      ***REMOVED*** else ***REMOVED***
        let stack = this.incrStack();
        this.pushSource([stack, ' = ', entry, ';']);
        this.compileStack.push(stack);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,
  isInline: function() ***REMOVED***
    return this.inlineStack.length;
  ***REMOVED***,

  popStack: function(wrapped) ***REMOVED***
    let inline = this.isInline(),
        item = (inline ? this.inlineStack : this.compileStack).pop();

    if (!wrapped && (item instanceof Literal)) ***REMOVED***
      return item.value;
    ***REMOVED*** else ***REMOVED***
      if (!inline) ***REMOVED***
        /* istanbul ignore next */
        if (!this.stackSlot) ***REMOVED***
          throw new Exception('Invalid stack pop');
        ***REMOVED***
        this.stackSlot--;
      ***REMOVED***
      return item;
    ***REMOVED***
  ***REMOVED***,

  topStack: function() ***REMOVED***
    let stack = (this.isInline() ? this.inlineStack : this.compileStack),
        item = stack[stack.length - 1];

    /* istanbul ignore if */
    if (item instanceof Literal) ***REMOVED***
      return item.value;
    ***REMOVED*** else ***REMOVED***
      return item;
    ***REMOVED***
  ***REMOVED***,

  contextName: function(context) ***REMOVED***
    if (this.useDepths && context) ***REMOVED***
      return 'depths[' + context + ']';
    ***REMOVED*** else ***REMOVED***
      return 'depth' + context;
    ***REMOVED***
  ***REMOVED***,

  quotedString: function(str) ***REMOVED***
    return this.source.quotedString(str);
  ***REMOVED***,

  objectLiteral: function(obj) ***REMOVED***
    return this.source.objectLiteral(obj);
  ***REMOVED***,

  aliasable: function(name) ***REMOVED***
    let ret = this.aliases[name];
    if (ret) ***REMOVED***
      ret.referenceCount++;
      return ret;
    ***REMOVED***

    ret = this.aliases[name] = this.source.wrap(name);
    ret.aliasable = true;
    ret.referenceCount = 1;

    return ret;
  ***REMOVED***,

  setupHelper: function(paramSize, name, blockHelper) ***REMOVED***
    let params = [],
        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
    let foundHelper = this.nameLookup('helpers', name, 'helper'),
        callContext = this.aliasable(`$***REMOVED***this.contextName(0)***REMOVED*** != null ? $***REMOVED***this.contextName(0)***REMOVED*** : ***REMOVED******REMOVED***`);

    return ***REMOVED***
      params: params,
      paramsInit: paramsInit,
      name: foundHelper,
      callParams: [callContext].concat(params)
    ***REMOVED***;
  ***REMOVED***,

  setupParams: function(helper, paramSize, params) ***REMOVED***
    let options = ***REMOVED******REMOVED***,
        contexts = [],
        types = [],
        ids = [],
        objectArgs = !params,
        param;

    if (objectArgs) ***REMOVED***
      params = [];
    ***REMOVED***

    options.name = this.quotedString(helper);
    options.hash = this.popStack();

    if (this.trackIds) ***REMOVED***
      options.hashIds = this.popStack();
    ***REMOVED***
    if (this.stringParams) ***REMOVED***
      options.hashTypes = this.popStack();
      options.hashContexts = this.popStack();
    ***REMOVED***

    let inverse = this.popStack(),
        program = this.popStack();

    // Avoid setting fn and inverse if neither are set. This allows
    // helpers to do a check for `if (options.fn)`
    if (program || inverse) ***REMOVED***
      options.fn = program || 'container.noop';
      options.inverse = inverse || 'container.noop';
    ***REMOVED***

    // The parameters go on to the stack in order (making sure that they are evaluated in order)
    // so we need to pop them off the stack in reverse order
    let i = paramSize;
    while (i--) ***REMOVED***
      param = this.popStack();
      params[i] = param;

      if (this.trackIds) ***REMOVED***
        ids[i] = this.popStack();
      ***REMOVED***
      if (this.stringParams) ***REMOVED***
        types[i] = this.popStack();
        contexts[i] = this.popStack();
      ***REMOVED***
    ***REMOVED***

    if (objectArgs) ***REMOVED***
      options.args = this.source.generateArray(params);
    ***REMOVED***

    if (this.trackIds) ***REMOVED***
      options.ids = this.source.generateArray(ids);
    ***REMOVED***
    if (this.stringParams) ***REMOVED***
      options.types = this.source.generateArray(types);
      options.contexts = this.source.generateArray(contexts);
    ***REMOVED***

    if (this.options.data) ***REMOVED***
      options.data = 'data';
    ***REMOVED***
    if (this.useBlockParams) ***REMOVED***
      options.blockParams = 'blockParams';
    ***REMOVED***
    return options;
  ***REMOVED***,

  setupHelperArgs: function(helper, paramSize, params, useRegister) ***REMOVED***
    let options = this.setupParams(helper, paramSize, params);
    options = this.objectLiteral(options);
    if (useRegister) ***REMOVED***
      this.useRegister('options');
      params.push('options');
      return ['options=', options];
    ***REMOVED*** else if (params) ***REMOVED***
      params.push(options);
      return '';
    ***REMOVED*** else ***REMOVED***
      return options;
    ***REMOVED***
  ***REMOVED***
***REMOVED***;


(function() ***REMOVED***
  const reservedWords = (
    'break else new var' +
    ' case finally return void' +
    ' catch for switch while' +
    ' continue function this with' +
    ' default if throw' +
    ' delete in try' +
    ' do instanceof typeof' +
    ' abstract enum int short' +
    ' boolean export interface static' +
    ' byte extends long super' +
    ' char final native synchronized' +
    ' class float package throws' +
    ' const goto private transient' +
    ' debugger implements protected volatile' +
    ' double import public let yield await' +
    ' null true false'
  ).split(' ');

  const compilerWords = JavaScriptCompiler.RESERVED_WORDS = ***REMOVED******REMOVED***;

  for (let i = 0, l = reservedWords.length; i < l; i++) ***REMOVED***
    compilerWords[reservedWords[i]] = true;
  ***REMOVED***
***REMOVED***());

JavaScriptCompiler.isValidJavaScriptVariableName = function(name) ***REMOVED***
  return !JavaScriptCompiler.RESERVED_WORDS[name] && (/^[a-zA-Z_$][0-9a-zA-Z_$]*$/).test(name);
***REMOVED***;

function strictLookup(requireTerminal, compiler, parts, type) ***REMOVED***
  let stack = compiler.popStack(),
      i = 0,
      len = parts.length;
  if (requireTerminal) ***REMOVED***
    len--;
  ***REMOVED***

  for (; i < len; i++) ***REMOVED***
    stack = compiler.nameLookup(stack, parts[i], type);
  ***REMOVED***

  if (requireTerminal) ***REMOVED***
    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
  ***REMOVED*** else ***REMOVED***
    return stack;
  ***REMOVED***
***REMOVED***

export default JavaScriptCompiler;
