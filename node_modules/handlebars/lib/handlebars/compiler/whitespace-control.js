import Visitor from './visitor';

function WhitespaceControl(options = ***REMOVED******REMOVED***) ***REMOVED***
  this.options = options;
***REMOVED***
WhitespaceControl.prototype = new Visitor();

WhitespaceControl.prototype.Program = function(program) ***REMOVED***
  const doStandalone = !this.options.ignoreStandalone;

  let isRoot = !this.isRootSeen;
  this.isRootSeen = true;

  let body = program.body;
  for (let i = 0, l = body.length; i < l; i++) ***REMOVED***
    let current = body[i],
        strip = this.accept(current);

    if (!strip) ***REMOVED***
      continue;
    ***REMOVED***

    let _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
        _isNextWhitespace = isNextWhitespace(body, i, isRoot),

        openStandalone = strip.openStandalone && _isPrevWhitespace,
        closeStandalone = strip.closeStandalone && _isNextWhitespace,
        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

    if (strip.close) ***REMOVED***
      omitRight(body, i, true);
    ***REMOVED***
    if (strip.open) ***REMOVED***
      omitLeft(body, i, true);
    ***REMOVED***

    if (doStandalone && inlineStandalone) ***REMOVED***
      omitRight(body, i);

      if (omitLeft(body, i)) ***REMOVED***
        // If we are on a standalone node, save the indent info for partials
        if (current.type === 'PartialStatement') ***REMOVED***
          // Pull out the whitespace from the final line
          current.indent = (/([ \t]+$)/).exec(body[i - 1].original)[1];
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    if (doStandalone && openStandalone) ***REMOVED***
      omitRight((current.program || current.inverse).body);

      // Strip out the previous content node if it's whitespace only
      omitLeft(body, i);
    ***REMOVED***
    if (doStandalone && closeStandalone) ***REMOVED***
      // Always strip the next node
      omitRight(body, i);

      omitLeft((current.inverse || current.program).body);
    ***REMOVED***
  ***REMOVED***

  return program;
***REMOVED***;

WhitespaceControl.prototype.BlockStatement =
WhitespaceControl.prototype.DecoratorBlock =
WhitespaceControl.prototype.PartialBlockStatement = function(block) ***REMOVED***
  this.accept(block.program);
  this.accept(block.inverse);

  // Find the inverse program that is involed with whitespace stripping.
  let program = block.program || block.inverse,
      inverse = block.program && block.inverse,
      firstInverse = inverse,
      lastInverse = inverse;

  if (inverse && inverse.chained) ***REMOVED***
    firstInverse = inverse.body[0].program;

    // Walk the inverse chain to find the last inverse that is actually in the chain.
    while (lastInverse.chained) ***REMOVED***
      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
    ***REMOVED***
  ***REMOVED***

  let strip = ***REMOVED***
    open: block.openStrip.open,
    close: block.closeStrip.close,

    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
    // so our parent can determine if we actually are standalone
    openStandalone: isNextWhitespace(program.body),
    closeStandalone: isPrevWhitespace((firstInverse || program).body)
  ***REMOVED***;

  if (block.openStrip.close) ***REMOVED***
    omitRight(program.body, null, true);
  ***REMOVED***

  if (inverse) ***REMOVED***
    let inverseStrip = block.inverseStrip;

    if (inverseStrip.open) ***REMOVED***
      omitLeft(program.body, null, true);
    ***REMOVED***

    if (inverseStrip.close) ***REMOVED***
      omitRight(firstInverse.body, null, true);
    ***REMOVED***
    if (block.closeStrip.open) ***REMOVED***
      omitLeft(lastInverse.body, null, true);
    ***REMOVED***

    // Find standalone else statments
    if (!this.options.ignoreStandalone
        && isPrevWhitespace(program.body)
        && isNextWhitespace(firstInverse.body)) ***REMOVED***
      omitLeft(program.body);
      omitRight(firstInverse.body);
    ***REMOVED***
  ***REMOVED*** else if (block.closeStrip.open) ***REMOVED***
    omitLeft(program.body, null, true);
  ***REMOVED***

  return strip;
***REMOVED***;

WhitespaceControl.prototype.Decorator =
WhitespaceControl.prototype.MustacheStatement = function(mustache) ***REMOVED***
  return mustache.strip;
***REMOVED***;

WhitespaceControl.prototype.PartialStatement =
    WhitespaceControl.prototype.CommentStatement = function(node) ***REMOVED***
  /* istanbul ignore next */
  let strip = node.strip || ***REMOVED******REMOVED***;
  return ***REMOVED***
    inlineStandalone: true,
    open: strip.open,
    close: strip.close
  ***REMOVED***;
***REMOVED***;


function isPrevWhitespace(body, i, isRoot) ***REMOVED***
  if (i === undefined) ***REMOVED***
    i = body.length;
  ***REMOVED***

  // Nodes that end with newlines are considered whitespace (but are special
  // cased for strip operations)
  let prev = body[i - 1],
      sibling = body[i - 2];
  if (!prev) ***REMOVED***
    return isRoot;
  ***REMOVED***

  if (prev.type === 'ContentStatement') ***REMOVED***
    return (sibling || !isRoot ? (/\r?\n\s*?$/) : (/(^|\r?\n)\s*?$/)).test(prev.original);
  ***REMOVED***
***REMOVED***
function isNextWhitespace(body, i, isRoot) ***REMOVED***
  if (i === undefined) ***REMOVED***
    i = -1;
  ***REMOVED***

  let next = body[i + 1],
      sibling = body[i + 2];
  if (!next) ***REMOVED***
    return isRoot;
  ***REMOVED***

  if (next.type === 'ContentStatement') ***REMOVED***
    return (sibling || !isRoot ? (/^\s*?\r?\n/) : (/^\s*?(\r?\n|$)/)).test(next.original);
  ***REMOVED***
***REMOVED***

// Marks the node to the right of the position as omitted.
// I.e. ***REMOVED******REMOVED***foo***REMOVED******REMOVED***' ' will mark the ' ' node as omitted.
//
// If i is undefined, then the first child will be marked as such.
//
// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
// content is met.
function omitRight(body, i, multiple) ***REMOVED***
  let current = body[i == null ? 0 : i + 1];
  if (!current || current.type !== 'ContentStatement' || (!multiple && current.rightStripped)) ***REMOVED***
    return;
  ***REMOVED***

  let original = current.value;
  current.value = current.value.replace(multiple ? (/^\s+/) : (/^[ \t]*\r?\n?/), '');
  current.rightStripped = current.value !== original;
***REMOVED***

// Marks the node to the left of the position as omitted.
// I.e. ' '***REMOVED******REMOVED***foo***REMOVED******REMOVED*** will mark the ' ' node as omitted.
//
// If i is undefined then the last child will be marked as such.
//
// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
// content is met.
function omitLeft(body, i, multiple) ***REMOVED***
  let current = body[i == null ? body.length - 1 : i - 1];
  if (!current || current.type !== 'ContentStatement' || (!multiple && current.leftStripped)) ***REMOVED***
    return;
  ***REMOVED***

  // We omit the last node if it's whitespace only and not preceeded by a non-content node.
  let original = current.value;
  current.value = current.value.replace(multiple ? (/\s+$/) : (/[ \t]+$/), '');
  current.leftStripped = current.value !== original;
  return current.leftStripped;
***REMOVED***

export default WhitespaceControl;
