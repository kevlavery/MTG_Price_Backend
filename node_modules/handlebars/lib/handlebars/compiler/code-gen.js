/* global define */
import ***REMOVED***isArray***REMOVED*** from '../utils';

let SourceNode;

try ***REMOVED***
  /* istanbul ignore next */
  if (typeof define !== 'function' || !define.amd) ***REMOVED***
    // We don't support this in AMD environments. For these environments, we asusme that
    // they are running on the browser and thus have no need for the source-map library.
    let SourceMap = require('source-map');
    SourceNode = SourceMap.SourceNode;
  ***REMOVED***
***REMOVED*** catch (err) ***REMOVED***
  /* NOP */
***REMOVED***

/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
if (!SourceNode) ***REMOVED***
  SourceNode = function(line, column, srcFile, chunks) ***REMOVED***
    this.src = '';
    if (chunks) ***REMOVED***
      this.add(chunks);
    ***REMOVED***
  ***REMOVED***;
  /* istanbul ignore next */
  SourceNode.prototype = ***REMOVED***
    add: function(chunks) ***REMOVED***
      if (isArray(chunks)) ***REMOVED***
        chunks = chunks.join('');
      ***REMOVED***
      this.src += chunks;
    ***REMOVED***,
    prepend: function(chunks) ***REMOVED***
      if (isArray(chunks)) ***REMOVED***
        chunks = chunks.join('');
      ***REMOVED***
      this.src = chunks + this.src;
    ***REMOVED***,
    toStringWithSourceMap: function() ***REMOVED***
      return ***REMOVED***code: this.toString()***REMOVED***;
    ***REMOVED***,
    toString: function() ***REMOVED***
      return this.src;
    ***REMOVED***
  ***REMOVED***;
***REMOVED***


function castChunk(chunk, codeGen, loc) ***REMOVED***
  if (isArray(chunk)) ***REMOVED***
    let ret = [];

    for (let i = 0, len = chunk.length; i < len; i++) ***REMOVED***
      ret.push(codeGen.wrap(chunk[i], loc));
    ***REMOVED***
    return ret;
  ***REMOVED*** else if (typeof chunk === 'boolean' || typeof chunk === 'number') ***REMOVED***
    // Handle primitives that the SourceNode will throw up on
    return chunk + '';
  ***REMOVED***
  return chunk;
***REMOVED***


function CodeGen(srcFile) ***REMOVED***
  this.srcFile = srcFile;
  this.source = [];
***REMOVED***

CodeGen.prototype = ***REMOVED***
  isEmpty() ***REMOVED***
    return !this.source.length;
  ***REMOVED***,
  prepend: function(source, loc) ***REMOVED***
    this.source.unshift(this.wrap(source, loc));
  ***REMOVED***,
  push: function(source, loc) ***REMOVED***
    this.source.push(this.wrap(source, loc));
  ***REMOVED***,

  merge: function() ***REMOVED***
    let source = this.empty();
    this.each(function(line) ***REMOVED***
      source.add(['  ', line, '\n']);
    ***REMOVED***);
    return source;
  ***REMOVED***,

  each: function(iter) ***REMOVED***
    for (let i = 0, len = this.source.length; i < len; i++) ***REMOVED***
      iter(this.source[i]);
    ***REMOVED***
  ***REMOVED***,

  empty: function() ***REMOVED***
    let loc = this.currentLocation || ***REMOVED***start: ***REMOVED******REMOVED******REMOVED***;
    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
  ***REMOVED***,
  wrap: function(chunk, loc = this.currentLocation || ***REMOVED***start: ***REMOVED******REMOVED******REMOVED***) ***REMOVED***
    if (chunk instanceof SourceNode) ***REMOVED***
      return chunk;
    ***REMOVED***

    chunk = castChunk(chunk, this, loc);

    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
  ***REMOVED***,

  functionCall: function(fn, type, params) ***REMOVED***
    params = this.generateList(params);
    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
  ***REMOVED***,

  quotedString: function(str) ***REMOVED***
    return '"' + (str + '')
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\u2028/g, '\\u2028')   // Per Ecma-262 7.3 + 7.8.4
      .replace(/\u2029/g, '\\u2029') + '"';
  ***REMOVED***,

  objectLiteral: function(obj) ***REMOVED***
    let pairs = [];

    for (let key in obj) ***REMOVED***
      if (obj.hasOwnProperty(key)) ***REMOVED***
        let value = castChunk(obj[key], this);
        if (value !== 'undefined') ***REMOVED***
          pairs.push([this.quotedString(key), ':', value]);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    let ret = this.generateList(pairs);
    ret.prepend('***REMOVED***');
    ret.add('***REMOVED***');
    return ret;
  ***REMOVED***,


  generateList: function(entries) ***REMOVED***
    let ret = this.empty();

    for (let i = 0, len = entries.length; i < len; i++) ***REMOVED***
      if (i) ***REMOVED***
        ret.add(',');
      ***REMOVED***

      ret.add(castChunk(entries[i], this));
    ***REMOVED***

    return ret;
  ***REMOVED***,

  generateArray: function(entries) ***REMOVED***
    let ret = this.generateList(entries);
    ret.prepend('[');
    ret.add(']');

    return ret;
  ***REMOVED***
***REMOVED***;

export default CodeGen;

