/* eslint-disable new-cap */

import Exception from '../exception';
import ***REMOVED***isArray, indexOf***REMOVED*** from '../utils';
import AST from './ast';

const slice = [].slice;

export function Compiler() ***REMOVED******REMOVED***

// the foundHelper register will disambiguate helper lookup from finding a
// function in a context. This is necessary for mustache compatibility, which
// requires that context functions in blocks are evaluated by blockHelperMissing,
// and then proceed as if the resulting value was provided to blockHelperMissing.

Compiler.prototype = ***REMOVED***
  compiler: Compiler,

  equals: function(other) ***REMOVED***
    let len = this.opcodes.length;
    if (other.opcodes.length !== len) ***REMOVED***
      return false;
    ***REMOVED***

    for (let i = 0; i < len; i++) ***REMOVED***
      let opcode = this.opcodes[i],
          otherOpcode = other.opcodes[i];
      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED***

    // We know that length is the same between the two arrays because they are directly tied
    // to the opcode behavior above.
    len = this.children.length;
    for (let i = 0; i < len; i++) ***REMOVED***
      if (!this.children[i].equals(other.children[i])) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED***

    return true;
  ***REMOVED***,

  guid: 0,

  compile: function(program, options) ***REMOVED***
    this.sourceNode = [];
    this.opcodes = [];
    this.children = [];
    this.options = options;
    this.stringParams = options.stringParams;
    this.trackIds = options.trackIds;

    options.blockParams = options.blockParams || [];

    // These changes will propagate to the other compiler components
    let knownHelpers = options.knownHelpers;
    options.knownHelpers = ***REMOVED***
      'helperMissing': true,
      'blockHelperMissing': true,
      'each': true,
      'if': true,
      'unless': true,
      'with': true,
      'log': true,
      'lookup': true
    ***REMOVED***;
    if (knownHelpers) ***REMOVED***
      for (let name in knownHelpers) ***REMOVED***
        /* istanbul ignore else */
        if (name in knownHelpers) ***REMOVED***
          options.knownHelpers[name] = knownHelpers[name];
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    return this.accept(program);
  ***REMOVED***,

  compileProgram: function(program) ***REMOVED***
    let childCompiler = new this.compiler(), // eslint-disable-line new-cap
        result = childCompiler.compile(program, this.options),
        guid = this.guid++;

    this.usePartial = this.usePartial || result.usePartial;

    this.children[guid] = result;
    this.useDepths = this.useDepths || result.useDepths;

    return guid;
  ***REMOVED***,

  accept: function(node) ***REMOVED***
    /* istanbul ignore next: Sanity code */
    if (!this[node.type]) ***REMOVED***
      throw new Exception('Unknown type: ' + node.type, node);
    ***REMOVED***

    this.sourceNode.unshift(node);
    let ret = this[node.type](node);
    this.sourceNode.shift();
    return ret;
  ***REMOVED***,

  Program: function(program) ***REMOVED***
    this.options.blockParams.unshift(program.blockParams);

    let body = program.body,
        bodyLength = body.length;
    for (let i = 0; i < bodyLength; i++) ***REMOVED***
      this.accept(body[i]);
    ***REMOVED***

    this.options.blockParams.shift();

    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;

    return this;
  ***REMOVED***,

  BlockStatement: function(block) ***REMOVED***
    transformLiteralToPath(block);

    let program = block.program,
        inverse = block.inverse;

    program = program && this.compileProgram(program);
    inverse = inverse && this.compileProgram(inverse);

    let type = this.classifySexpr(block);

    if (type === 'helper') ***REMOVED***
      this.helperSexpr(block, program, inverse);
    ***REMOVED*** else if (type === 'simple') ***REMOVED***
      this.simpleSexpr(block);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('blockValue', block.path.original);
    ***REMOVED*** else ***REMOVED***
      this.ambiguousSexpr(block, program, inverse);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('ambiguousBlockValue');
    ***REMOVED***

    this.opcode('append');
  ***REMOVED***,

  DecoratorBlock(decorator) ***REMOVED***
    let program = decorator.program && this.compileProgram(decorator.program);
    let params = this.setupFullMustacheParams(decorator, program, undefined),
        path = decorator.path;

    this.useDecorators = true;
    this.opcode('registerDecorator', params.length, path.original);
  ***REMOVED***,

  PartialStatement: function(partial) ***REMOVED***
    this.usePartial = true;

    let program = partial.program;
    if (program) ***REMOVED***
      program = this.compileProgram(partial.program);
    ***REMOVED***

    let params = partial.params;
    if (params.length > 1) ***REMOVED***
      throw new Exception('Unsupported number of partial arguments: ' + params.length, partial);
    ***REMOVED*** else if (!params.length) ***REMOVED***
      if (this.options.explicitPartialContext) ***REMOVED***
        this.opcode('pushLiteral', 'undefined');
      ***REMOVED*** else ***REMOVED***
        params.push(***REMOVED***type: 'PathExpression', parts: [], depth: 0***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    let partialName = partial.name.original,
        isDynamic = partial.name.type === 'SubExpression';
    if (isDynamic) ***REMOVED***
      this.accept(partial.name);
    ***REMOVED***

    this.setupFullMustacheParams(partial, program, undefined, true);

    let indent = partial.indent || '';
    if (this.options.preventIndent && indent) ***REMOVED***
      this.opcode('appendContent', indent);
      indent = '';
    ***REMOVED***

    this.opcode('invokePartial', isDynamic, partialName, indent);
    this.opcode('append');
  ***REMOVED***,
  PartialBlockStatement: function(partialBlock) ***REMOVED***
    this.PartialStatement(partialBlock);
  ***REMOVED***,

  MustacheStatement: function(mustache) ***REMOVED***
    this.SubExpression(mustache);

    if (mustache.escaped && !this.options.noEscape) ***REMOVED***
      this.opcode('appendEscaped');
    ***REMOVED*** else ***REMOVED***
      this.opcode('append');
    ***REMOVED***
  ***REMOVED***,
  Decorator(decorator) ***REMOVED***
    this.DecoratorBlock(decorator);
  ***REMOVED***,


  ContentStatement: function(content) ***REMOVED***
    if (content.value) ***REMOVED***
      this.opcode('appendContent', content.value);
    ***REMOVED***
  ***REMOVED***,

  CommentStatement: function() ***REMOVED******REMOVED***,

  SubExpression: function(sexpr) ***REMOVED***
    transformLiteralToPath(sexpr);
    let type = this.classifySexpr(sexpr);

    if (type === 'simple') ***REMOVED***
      this.simpleSexpr(sexpr);
    ***REMOVED*** else if (type === 'helper') ***REMOVED***
      this.helperSexpr(sexpr);
    ***REMOVED*** else ***REMOVED***
      this.ambiguousSexpr(sexpr);
    ***REMOVED***
  ***REMOVED***,
  ambiguousSexpr: function(sexpr, program, inverse) ***REMOVED***
    let path = sexpr.path,
        name = path.parts[0],
        isBlock = program != null || inverse != null;

    this.opcode('getContext', path.depth);

    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    path.strict = true;
    this.accept(path);

    this.opcode('invokeAmbiguous', name, isBlock);
  ***REMOVED***,

  simpleSexpr: function(sexpr) ***REMOVED***
    let path = sexpr.path;
    path.strict = true;
    this.accept(path);
    this.opcode('resolvePossibleLambda');
  ***REMOVED***,

  helperSexpr: function(sexpr, program, inverse) ***REMOVED***
    let params = this.setupFullMustacheParams(sexpr, program, inverse),
        path = sexpr.path,
        name = path.parts[0];

    if (this.options.knownHelpers[name]) ***REMOVED***
      this.opcode('invokeKnownHelper', params.length, name);
    ***REMOVED*** else if (this.options.knownHelpersOnly) ***REMOVED***
      throw new Exception('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
    ***REMOVED*** else ***REMOVED***
      path.strict = true;
      path.falsy = true;

      this.accept(path);
      this.opcode('invokeHelper', params.length, path.original, AST.helpers.simpleId(path));
    ***REMOVED***
  ***REMOVED***,

  PathExpression: function(path) ***REMOVED***
    this.addDepth(path.depth);
    this.opcode('getContext', path.depth);

    let name = path.parts[0],
        scoped = AST.helpers.scopedId(path),
        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

    if (blockParamId) ***REMOVED***
      this.opcode('lookupBlockParam', blockParamId, path.parts);
    ***REMOVED*** else if (!name) ***REMOVED***
      // Context reference, i.e. `***REMOVED******REMOVED***foo .***REMOVED******REMOVED***` or `***REMOVED******REMOVED***foo ..***REMOVED******REMOVED***`
      this.opcode('pushContext');
    ***REMOVED*** else if (path.data) ***REMOVED***
      this.options.data = true;
      this.opcode('lookupData', path.depth, path.parts, path.strict);
    ***REMOVED*** else ***REMOVED***
      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
    ***REMOVED***
  ***REMOVED***,

  StringLiteral: function(string) ***REMOVED***
    this.opcode('pushString', string.value);
  ***REMOVED***,

  NumberLiteral: function(number) ***REMOVED***
    this.opcode('pushLiteral', number.value);
  ***REMOVED***,

  BooleanLiteral: function(bool) ***REMOVED***
    this.opcode('pushLiteral', bool.value);
  ***REMOVED***,

  UndefinedLiteral: function() ***REMOVED***
    this.opcode('pushLiteral', 'undefined');
  ***REMOVED***,

  NullLiteral: function() ***REMOVED***
    this.opcode('pushLiteral', 'null');
  ***REMOVED***,

  Hash: function(hash) ***REMOVED***
    let pairs = hash.pairs,
        i = 0,
        l = pairs.length;

    this.opcode('pushHash');

    for (; i < l; i++) ***REMOVED***
      this.pushParam(pairs[i].value);
    ***REMOVED***
    while (i--) ***REMOVED***
      this.opcode('assignToHash', pairs[i].key);
    ***REMOVED***
    this.opcode('popHash');
  ***REMOVED***,

  // HELPERS
  opcode: function(name) ***REMOVED***
    this.opcodes.push(***REMOVED*** opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc ***REMOVED***);
  ***REMOVED***,

  addDepth: function(depth) ***REMOVED***
    if (!depth) ***REMOVED***
      return;
    ***REMOVED***

    this.useDepths = true;
  ***REMOVED***,

  classifySexpr: function(sexpr) ***REMOVED***
    let isSimple = AST.helpers.simpleId(sexpr.path);

    let isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

    // a mustache is an eligible helper if:
    // * its id is simple (a single part, not `this` or `..`)
    let isHelper = !isBlockParam && AST.helpers.helperExpression(sexpr);

    // if a mustache is an eligible helper but not a definite
    // helper, it is ambiguous, and will be resolved in a later
    // pass or at runtime.
    let isEligible = !isBlockParam && (isHelper || isSimple);

    // if ambiguous, we can possibly resolve the ambiguity now
    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
    if (isEligible && !isHelper) ***REMOVED***
      let name = sexpr.path.parts[0],
          options = this.options;

      if (options.knownHelpers[name]) ***REMOVED***
        isHelper = true;
      ***REMOVED*** else if (options.knownHelpersOnly) ***REMOVED***
        isEligible = false;
      ***REMOVED***
    ***REMOVED***

    if (isHelper) ***REMOVED***
      return 'helper';
    ***REMOVED*** else if (isEligible) ***REMOVED***
      return 'ambiguous';
    ***REMOVED*** else ***REMOVED***
      return 'simple';
    ***REMOVED***
  ***REMOVED***,

  pushParams: function(params) ***REMOVED***
    for (let i = 0, l = params.length; i < l; i++) ***REMOVED***
      this.pushParam(params[i]);
    ***REMOVED***
  ***REMOVED***,

  pushParam: function(val) ***REMOVED***
    let value = val.value != null ? val.value : val.original || '';

    if (this.stringParams) ***REMOVED***
      if (value.replace) ***REMOVED***
        value = value
            .replace(/^(\.?\.\/)*/g, '')
            .replace(/\//g, '.');
      ***REMOVED***

      if (val.depth) ***REMOVED***
        this.addDepth(val.depth);
      ***REMOVED***
      this.opcode('getContext', val.depth || 0);
      this.opcode('pushStringParam', value, val.type);

      if (val.type === 'SubExpression') ***REMOVED***
        // SubExpressions get evaluated and passed in
        // in string params mode.
        this.accept(val);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if (this.trackIds) ***REMOVED***
        let blockParamIndex;
        if (val.parts && !AST.helpers.scopedId(val) && !val.depth) ***REMOVED***
           blockParamIndex = this.blockParamIndex(val.parts[0]);
        ***REMOVED***
        if (blockParamIndex) ***REMOVED***
          let blockParamChild = val.parts.slice(1).join('.');
          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
        ***REMOVED*** else ***REMOVED***
          value = val.original || value;
          if (value.replace) ***REMOVED***
            value = value
                .replace(/^this(?:\.|$)/, '')
                .replace(/^\.\//, '')
                .replace(/^\.$/, '');
          ***REMOVED***

          this.opcode('pushId', val.type, value);
        ***REMOVED***
      ***REMOVED***
      this.accept(val);
    ***REMOVED***
  ***REMOVED***,

  setupFullMustacheParams: function(sexpr, program, inverse, omitEmpty) ***REMOVED***
    let params = sexpr.params;
    this.pushParams(params);

    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    if (sexpr.hash) ***REMOVED***
      this.accept(sexpr.hash);
    ***REMOVED*** else ***REMOVED***
      this.opcode('emptyHash', omitEmpty);
    ***REMOVED***

    return params;
  ***REMOVED***,

  blockParamIndex: function(name) ***REMOVED***
    for (let depth = 0, len = this.options.blockParams.length; depth < len; depth++) ***REMOVED***
      let blockParams = this.options.blockParams[depth],
          param = blockParams && indexOf(blockParams, name);
      if (blockParams && param >= 0) ***REMOVED***
        return [depth, param];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

export function precompile(input, options, env) ***REMOVED***
  if (input == null || (typeof input !== 'string' && input.type !== 'Program')) ***REMOVED***
    throw new Exception('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
  ***REMOVED***

  options = options || ***REMOVED******REMOVED***;
  if (!('data' in options)) ***REMOVED***
    options.data = true;
  ***REMOVED***
  if (options.compat) ***REMOVED***
    options.useDepths = true;
  ***REMOVED***

  let ast = env.parse(input, options),
      environment = new env.Compiler().compile(ast, options);
  return new env.JavaScriptCompiler().compile(environment, options);
***REMOVED***

export function compile(input, options = ***REMOVED******REMOVED***, env) ***REMOVED***
  if (input == null || (typeof input !== 'string' && input.type !== 'Program')) ***REMOVED***
    throw new Exception('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
  ***REMOVED***

  if (!('data' in options)) ***REMOVED***
    options.data = true;
  ***REMOVED***
  if (options.compat) ***REMOVED***
    options.useDepths = true;
  ***REMOVED***

  let compiled;

  function compileInput() ***REMOVED***
    let ast = env.parse(input, options),
        environment = new env.Compiler().compile(ast, options),
        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
    return env.template(templateSpec);
  ***REMOVED***

  // Template is only compiled on first use and cached after that point.
  function ret(context, execOptions) ***REMOVED***
    if (!compiled) ***REMOVED***
      compiled = compileInput();
    ***REMOVED***
    return compiled.call(this, context, execOptions);
  ***REMOVED***
  ret._setup = function(setupOptions) ***REMOVED***
    if (!compiled) ***REMOVED***
      compiled = compileInput();
    ***REMOVED***
    return compiled._setup(setupOptions);
  ***REMOVED***;
  ret._child = function(i, data, blockParams, depths) ***REMOVED***
    if (!compiled) ***REMOVED***
      compiled = compileInput();
    ***REMOVED***
    return compiled._child(i, data, blockParams, depths);
  ***REMOVED***;
  return ret;
***REMOVED***

function argEquals(a, b) ***REMOVED***
  if (a === b) ***REMOVED***
    return true;
  ***REMOVED***

  if (isArray(a) && isArray(b) && a.length === b.length) ***REMOVED***
    for (let i = 0; i < a.length; i++) ***REMOVED***
      if (!argEquals(a[i], b[i])) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED***
    return true;
  ***REMOVED***
***REMOVED***

function transformLiteralToPath(sexpr) ***REMOVED***
  if (!sexpr.path.parts) ***REMOVED***
    let literal = sexpr.path;
    // Casting to string here to make false and 0 literal values play nicely with the rest
    // of the system.
    sexpr.path = ***REMOVED***
      type: 'PathExpression',
      data: false,
      depth: 0,
      parts: [literal.original + ''],
      original: literal.original + '',
      loc: literal.loc
    ***REMOVED***;
  ***REMOVED***
***REMOVED***
