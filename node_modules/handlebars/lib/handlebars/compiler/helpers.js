import Exception from '../exception';

function validateClose(open, close) ***REMOVED***
  close = close.path ? close.path.original : close;

  if (open.path.original !== close) ***REMOVED***
    let errorNode = ***REMOVED***loc: open.path.loc***REMOVED***;

    throw new Exception(open.path.original + " doesn't match " + close, errorNode);
  ***REMOVED***
***REMOVED***

export function SourceLocation(source, locInfo) ***REMOVED***
  this.source = source;
  this.start = ***REMOVED***
    line: locInfo.first_line,
    column: locInfo.first_column
  ***REMOVED***;
  this.end = ***REMOVED***
    line: locInfo.last_line,
    column: locInfo.last_column
  ***REMOVED***;
***REMOVED***

export function id(token) ***REMOVED***
  if (/^\[.*\]$/.test(token)) ***REMOVED***
    return token.substr(1, token.length - 2);
  ***REMOVED*** else ***REMOVED***
    return token;
  ***REMOVED***
***REMOVED***

export function stripFlags(open, close) ***REMOVED***
  return ***REMOVED***
    open: open.charAt(2) === '~',
    close: close.charAt(close.length - 3) === '~'
  ***REMOVED***;
***REMOVED***

export function stripComment(comment) ***REMOVED***
  return comment.replace(/^\***REMOVED***\***REMOVED***~?\!-?-?/, '')
                .replace(/-?-?~?\***REMOVED***\***REMOVED***$/, '');
***REMOVED***

export function preparePath(data, parts, loc) ***REMOVED***
  loc = this.locInfo(loc);

  let original = data ? '@' : '',
      dig = [],
      depth = 0,
      depthString = '';

  for (let i = 0, l = parts.length; i < l; i++) ***REMOVED***
    let part = parts[i].part,
        // If we have [] syntax then we do not treat path references as operators,
        // i.e. foo.[this] resolves to approximately context.foo['this']
        isLiteral = parts[i].original !== part;
    original += (parts[i].separator || '') + part;

    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) ***REMOVED***
      if (dig.length > 0) ***REMOVED***
        throw new Exception('Invalid path: ' + original, ***REMOVED***loc***REMOVED***);
      ***REMOVED*** else if (part === '..') ***REMOVED***
        depth++;
        depthString += '../';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      dig.push(part);
    ***REMOVED***
  ***REMOVED***

  return ***REMOVED***
    type: 'PathExpression',
    data,
    depth,
    parts: dig,
    original,
    loc
  ***REMOVED***;
***REMOVED***

export function prepareMustache(path, params, hash, open, strip, locInfo) ***REMOVED***
  // Must use charAt to support IE pre-10
  let escapeFlag = open.charAt(3) || open.charAt(2),
      escaped = escapeFlag !== '***REMOVED***' && escapeFlag !== '&';

  let decorator = (/\*/.test(open));
  return ***REMOVED***
    type: decorator ? 'Decorator' : 'MustacheStatement',
    path,
    params,
    hash,
    escaped,
    strip,
    loc: this.locInfo(locInfo)
  ***REMOVED***;
***REMOVED***

export function prepareRawBlock(openRawBlock, contents, close, locInfo) ***REMOVED***
  validateClose(openRawBlock, close);

  locInfo = this.locInfo(locInfo);
  let program = ***REMOVED***
    type: 'Program',
    body: contents,
    strip: ***REMOVED******REMOVED***,
    loc: locInfo
  ***REMOVED***;

  return ***REMOVED***
    type: 'BlockStatement',
    path: openRawBlock.path,
    params: openRawBlock.params,
    hash: openRawBlock.hash,
    program,
    openStrip: ***REMOVED******REMOVED***,
    inverseStrip: ***REMOVED******REMOVED***,
    closeStrip: ***REMOVED******REMOVED***,
    loc: locInfo
  ***REMOVED***;
***REMOVED***

export function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) ***REMOVED***
  if (close && close.path) ***REMOVED***
    validateClose(openBlock, close);
  ***REMOVED***

  let decorator = (/\*/.test(openBlock.open));

  program.blockParams = openBlock.blockParams;

  let inverse,
      inverseStrip;

  if (inverseAndProgram) ***REMOVED***
    if (decorator) ***REMOVED***
      throw new Exception('Unexpected inverse block on decorator', inverseAndProgram);
    ***REMOVED***

    if (inverseAndProgram.chain) ***REMOVED***
      inverseAndProgram.program.body[0].closeStrip = close.strip;
    ***REMOVED***

    inverseStrip = inverseAndProgram.strip;
    inverse = inverseAndProgram.program;
  ***REMOVED***

  if (inverted) ***REMOVED***
    inverted = inverse;
    inverse = program;
    program = inverted;
  ***REMOVED***

  return ***REMOVED***
    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
    path: openBlock.path,
    params: openBlock.params,
    hash: openBlock.hash,
    program,
    inverse,
    openStrip: openBlock.strip,
    inverseStrip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  ***REMOVED***;
***REMOVED***

export function prepareProgram(statements, loc) ***REMOVED***
  if (!loc && statements.length) ***REMOVED***
    const firstLoc = statements[0].loc,
          lastLoc = statements[statements.length - 1].loc;

    /* istanbul ignore else */
    if (firstLoc && lastLoc) ***REMOVED***
      loc = ***REMOVED***
        source: firstLoc.source,
        start: ***REMOVED***
          line: firstLoc.start.line,
          column: firstLoc.start.column
        ***REMOVED***,
        end: ***REMOVED***
          line: lastLoc.end.line,
          column: lastLoc.end.column
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***

  return ***REMOVED***
    type: 'Program',
    body: statements,
    strip: ***REMOVED******REMOVED***,
    loc: loc
  ***REMOVED***;
***REMOVED***


export function preparePartialBlock(open, program, close, locInfo) ***REMOVED***
  validateClose(open, close);

  return ***REMOVED***
    type: 'PartialBlockStatement',
    name: open.path,
    params: open.params,
    hash: open.hash,
    program,
    openStrip: open.strip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  ***REMOVED***;
***REMOVED***

