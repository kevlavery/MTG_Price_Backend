const escape = ***REMOVED***
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
***REMOVED***;

const badChars = /[&<>"'`=]/g,
      possible = /[&<>"'`=]/;

function escapeChar(chr) ***REMOVED***
  return escape[chr];
***REMOVED***

export function extend(obj/* , ...source */) ***REMOVED***
  for (let i = 1; i < arguments.length; i++) ***REMOVED***
    for (let key in arguments[i]) ***REMOVED***
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) ***REMOVED***
        obj[key] = arguments[i][key];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return obj;
***REMOVED***

export let toString = Object.prototype.toString;

// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
let isFunction = function(value) ***REMOVED***
  return typeof value === 'function';
***REMOVED***;
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) ***REMOVED***
  isFunction = function(value) ***REMOVED***
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  ***REMOVED***;
***REMOVED***
export ***REMOVED***isFunction***REMOVED***;
/* eslint-enable func-style */

/* istanbul ignore next */
export const isArray = Array.isArray || function(value) ***REMOVED***
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
***REMOVED***;

// Older IE versions do not directly support indexOf so we must implement our own, sadly.
export function indexOf(array, value) ***REMOVED***
  for (let i = 0, len = array.length; i < len; i++) ***REMOVED***
    if (array[i] === value) ***REMOVED***
      return i;
    ***REMOVED***
  ***REMOVED***
  return -1;
***REMOVED***


export function escapeExpression(string) ***REMOVED***
  if (typeof string !== 'string') ***REMOVED***
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) ***REMOVED***
      return string.toHTML();
    ***REMOVED*** else if (string == null) ***REMOVED***
      return '';
    ***REMOVED*** else if (!string) ***REMOVED***
      return string + '';
    ***REMOVED***

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  ***REMOVED***

  if (!possible.test(string)) ***REMOVED*** return string; ***REMOVED***
  return string.replace(badChars, escapeChar);
***REMOVED***

export function isEmpty(value) ***REMOVED***
  if (!value && value !== 0) ***REMOVED***
    return true;
  ***REMOVED*** else if (isArray(value) && value.length === 0) ***REMOVED***
    return true;
  ***REMOVED*** else ***REMOVED***
    return false;
  ***REMOVED***
***REMOVED***

export function createFrame(object) ***REMOVED***
  let frame = extend(***REMOVED******REMOVED***, object);
  frame._parent = object;
  return frame;
***REMOVED***

export function blockParams(params, ids) ***REMOVED***
  params.path = ids;
  return params;
***REMOVED***

export function appendContextPath(contextPath, id) ***REMOVED***
  return (contextPath ? contextPath + '.' : '') + id;
***REMOVED***
