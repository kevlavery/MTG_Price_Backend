import * as Utils from './utils';
import Exception from './exception';
import ***REMOVED*** COMPILER_REVISION, REVISION_CHANGES, createFrame ***REMOVED*** from './base';

export function checkRevision(compilerInfo) ***REMOVED***
  const compilerRevision = compilerInfo && compilerInfo[0] || 1,
        currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) ***REMOVED***
    if (compilerRevision < currentRevision) ***REMOVED***
      const runtimeVersions = REVISION_CHANGES[currentRevision],
            compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception('Template was precompiled with an older version of Handlebars than the current runtime. ' +
            'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    ***REMOVED*** else ***REMOVED***
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception('Template was precompiled with a newer version of Handlebars than the current runtime. ' +
            'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    ***REMOVED***
  ***REMOVED***
***REMOVED***

export function template(templateSpec, env) ***REMOVED***
  /* istanbul ignore next */
  if (!env) ***REMOVED***
    throw new Exception('No environment passed to template');
  ***REMOVED***
  if (!templateSpec || !templateSpec.main) ***REMOVED***
    throw new Exception('Unknown template object: ' + typeof templateSpec);
  ***REMOVED***

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) ***REMOVED***
    if (options.hash) ***REMOVED***
      context = Utils.extend(***REMOVED******REMOVED***, context, options.hash);
      if (options.ids) ***REMOVED***
        options.ids[0] = true;
      ***REMOVED***
    ***REMOVED***

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    let result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) ***REMOVED***
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    ***REMOVED***
    if (result != null) ***REMOVED***
      if (options.indent) ***REMOVED***
        let lines = result.split('\n');
        for (let i = 0, l = lines.length; i < l; i++) ***REMOVED***
          if (!lines[i] && i + 1 === l) ***REMOVED***
            break;
          ***REMOVED***

          lines[i] = options.indent + lines[i];
        ***REMOVED***
        result = lines.join('\n');
      ***REMOVED***
      return result;
    ***REMOVED*** else ***REMOVED***
      throw new Exception('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    ***REMOVED***
  ***REMOVED***

  // Just add water
  let container = ***REMOVED***
    strict: function(obj, name) ***REMOVED***
      if (!(name in obj)) ***REMOVED***
        throw new Exception('"' + name + '" not defined in ' + obj);
      ***REMOVED***
      return obj[name];
    ***REMOVED***,
    lookup: function(depths, name) ***REMOVED***
      const len = depths.length;
      for (let i = 0; i < len; i++) ***REMOVED***
        if (depths[i] && depths[i][name] != null) ***REMOVED***
          return depths[i][name];
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***,
    lambda: function(current, context) ***REMOVED***
      return typeof current === 'function' ? current.call(context) : current;
    ***REMOVED***,

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function(i) ***REMOVED***
      let ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    ***REMOVED***,

    programs: [],
    program: function(i, data, declaredBlockParams, blockParams, depths) ***REMOVED***
      let programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) ***REMOVED***
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      ***REMOVED*** else if (!programWrapper) ***REMOVED***
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      ***REMOVED***
      return programWrapper;
    ***REMOVED***,

    data: function(value, depth) ***REMOVED***
      while (value && depth--) ***REMOVED***
        value = value._parent;
      ***REMOVED***
      return value;
    ***REMOVED***,
    merge: function(param, common) ***REMOVED***
      let obj = param || common;

      if (param && common && (param !== common)) ***REMOVED***
        obj = Utils.extend(***REMOVED******REMOVED***, common, param);
      ***REMOVED***

      return obj;
    ***REMOVED***,

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  ***REMOVED***;

  function ret(context, options = ***REMOVED******REMOVED***) ***REMOVED***
    let data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) ***REMOVED***
      data = initData(context, data);
    ***REMOVED***
    let depths,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) ***REMOVED***
      if (options.depths) ***REMOVED***
        depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
      ***REMOVED*** else ***REMOVED***
        depths = [context];
      ***REMOVED***
    ***REMOVED***

    function main(context/*, options*/) ***REMOVED***
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    ***REMOVED***
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  ***REMOVED***
  ret.isTop = true;

  ret._setup = function(options) ***REMOVED***
    if (!options.partial) ***REMOVED***
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) ***REMOVED***
        container.partials = container.merge(options.partials, env.partials);
      ***REMOVED***
      if (templateSpec.usePartial || templateSpec.useDecorators) ***REMOVED***
        container.decorators = container.merge(options.decorators, env.decorators);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    ***REMOVED***
  ***REMOVED***;

  ret._child = function(i, data, blockParams, depths) ***REMOVED***
    if (templateSpec.useBlockParams && !blockParams) ***REMOVED***
      throw new Exception('must pass block params');
    ***REMOVED***
    if (templateSpec.useDepths && !depths) ***REMOVED***
      throw new Exception('must pass parent depths');
    ***REMOVED***

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  ***REMOVED***;
  return ret;
***REMOVED***

export function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) ***REMOVED***
  function prog(context, options = ***REMOVED******REMOVED***) ***REMOVED***
    let currentDepths = depths;
    if (depths && context !== depths[0]) ***REMOVED***
      currentDepths = [context].concat(depths);
    ***REMOVED***

    return fn(container,
        context,
        container.helpers, container.partials,
        options.data || data,
        blockParams && [options.blockParams].concat(blockParams),
        currentDepths);
  ***REMOVED***

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
***REMOVED***

export function resolvePartial(partial, context, options) ***REMOVED***
  if (!partial) ***REMOVED***
    if (options.name === '@partial-block') ***REMOVED***
      partial = options.data['partial-block'];
    ***REMOVED*** else ***REMOVED***
      partial = options.partials[options.name];
    ***REMOVED***
  ***REMOVED*** else if (!partial.call && !options.name) ***REMOVED***
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  ***REMOVED***
  return partial;
***REMOVED***

export function invokePartial(partial, context, options) ***REMOVED***
  options.partial = true;
  if (options.ids) ***REMOVED***
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  ***REMOVED***

  let partialBlock;
  if (options.fn && options.fn !== noop) ***REMOVED***
    options.data = createFrame(options.data);
    partialBlock = options.data['partial-block'] = options.fn;

    if (partialBlock.partials) ***REMOVED***
      options.partials = Utils.extend(***REMOVED******REMOVED***, options.partials, partialBlock.partials);
    ***REMOVED***
  ***REMOVED***

  if (partial === undefined && partialBlock) ***REMOVED***
    partial = partialBlock;
  ***REMOVED***

  if (partial === undefined) ***REMOVED***
    throw new Exception('The partial ' + options.name + ' could not be found');
  ***REMOVED*** else if (partial instanceof Function) ***REMOVED***
    return partial(context, options);
  ***REMOVED***
***REMOVED***

export function noop() ***REMOVED*** return ''; ***REMOVED***

function initData(context, data) ***REMOVED***
  if (!data || !('root' in data)) ***REMOVED***
    data = data ? createFrame(data) : ***REMOVED******REMOVED***;
    data.root = context;
  ***REMOVED***
  return data;
***REMOVED***

function executeDecorators(fn, prog, container, depths, data, blockParams) ***REMOVED***
  if (fn.decorator) ***REMOVED***
    let props = ***REMOVED******REMOVED***;
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  ***REMOVED***
  return prog;
***REMOVED***
