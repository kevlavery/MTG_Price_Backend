'use strict';

// Load modules

const Crypto = require('crypto');
const Path = require('path');
const Util = require('util');
const Escape = require('./escape');


// Declare internals

const internals = ***REMOVED******REMOVED***;


// Clone object or array

exports.clone = function (obj, seen) ***REMOVED***

    if (typeof obj !== 'object' ||
        obj === null) ***REMOVED***

        return obj;
    ***REMOVED***

    seen = seen || new Map();

    const lookup = seen.get(obj);
    if (lookup) ***REMOVED***
        return lookup;
    ***REMOVED***

    let newObj;
    let cloneDeep = false;

    if (!Array.isArray(obj)) ***REMOVED***
        if (Buffer.isBuffer(obj)) ***REMOVED***
            newObj = new Buffer(obj);
        ***REMOVED***
        else if (obj instanceof Date) ***REMOVED***
            newObj = new Date(obj.getTime());
        ***REMOVED***
        else if (obj instanceof RegExp) ***REMOVED***
            newObj = new RegExp(obj);
        ***REMOVED***
        else ***REMOVED***
            const proto = Object.getPrototypeOf(obj);
            if (proto &&
                proto.isImmutable) ***REMOVED***

                newObj = obj;
            ***REMOVED***
            else ***REMOVED***
                newObj = Object.create(proto);
                cloneDeep = true;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    else ***REMOVED***
        newObj = [];
        cloneDeep = true;
    ***REMOVED***

    seen.set(obj, newObj);

    if (cloneDeep) ***REMOVED***
        const keys = Object.getOwnPropertyNames(obj);
        for (let i = 0; i < keys.length; ++i) ***REMOVED***
            const key = keys[i];
            const descriptor = Object.getOwnPropertyDescriptor(obj, key);
            if (descriptor &&
                (descriptor.get ||
                 descriptor.set)) ***REMOVED***

                Object.defineProperty(newObj, key, descriptor);
            ***REMOVED***
            else ***REMOVED***
                newObj[key] = exports.clone(obj[key], seen);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return newObj;
***REMOVED***;


// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied

/*eslint-disable */
exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) ***REMOVED***
/*eslint-enable */

    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) ***REMOVED***
        return target;
    ***REMOVED***

    if (Array.isArray(source)) ***REMOVED***
        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
        if (isMergeArrays === false) ***REMOVED***                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        ***REMOVED***

        for (let i = 0; i < source.length; ++i) ***REMOVED***
            target.push(exports.clone(source[i]));
        ***REMOVED***

        return target;
    ***REMOVED***

    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; ++i) ***REMOVED***
        const key = keys[i];
        if (key === '__proto__') ***REMOVED***
            continue;
        ***REMOVED***

        const value = source[key];
        if (value &&
            typeof value === 'object') ***REMOVED***

            if (!target[key] ||
                typeof target[key] !== 'object' ||
                (Array.isArray(target[key]) !== Array.isArray(value)) ||
                value instanceof Date ||
                Buffer.isBuffer(value) ||
                value instanceof RegExp) ***REMOVED***

                target[key] = exports.clone(value);
            ***REMOVED***
            else ***REMOVED***
                exports.merge(target[key], value, isNullOverride, isMergeArrays);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            if (value !== null &&
                value !== undefined) ***REMOVED***                              // Explicit to preserve empty strings

                target[key] = value;
            ***REMOVED***
            else if (isNullOverride !== false) ***REMOVED***                    // Defaults to true
                target[key] = value;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return target;
***REMOVED***;


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options, isNullOverride) ***REMOVED***

    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) ***REMOVED***                                                 // If no options, return null
        return null;
    ***REMOVED***

    const copy = exports.clone(defaults);

    if (options === true) ***REMOVED***                                         // If options is set to true, use defaults
        return copy;
    ***REMOVED***

    return exports.merge(copy, options, isNullOverride === true, false);
***REMOVED***;


// Clone an object except for the listed keys which are shallow copied

exports.cloneWithShallow = function (source, keys) ***REMOVED***

    if (!source ||
        typeof source !== 'object') ***REMOVED***

        return source;
    ***REMOVED***

    const storage = internals.store(source, keys);    // Move shallow copy items to storage
    const copy = exports.clone(source);               // Deep copy the rest
    internals.restore(copy, source, storage);       // Shallow copy the stored items and restore
    return copy;
***REMOVED***;


internals.store = function (source, keys) ***REMOVED***

    const storage = ***REMOVED******REMOVED***;
    for (let i = 0; i < keys.length; ++i) ***REMOVED***
        const key = keys[i];
        const value = exports.reach(source, key);
        if (value !== undefined) ***REMOVED***
            storage[key] = value;
            internals.reachSet(source, key, undefined);
        ***REMOVED***
    ***REMOVED***

    return storage;
***REMOVED***;


internals.restore = function (copy, source, storage) ***REMOVED***

    const keys = Object.keys(storage);
    for (let i = 0; i < keys.length; ++i) ***REMOVED***
        const key = keys[i];
        internals.reachSet(copy, key, storage[key]);
        internals.reachSet(source, key, storage[key]);
    ***REMOVED***
***REMOVED***;


internals.reachSet = function (obj, key, value) ***REMOVED***

    const path = key.split('.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) ***REMOVED***
        const segment = path[i];
        if (i + 1 === path.length) ***REMOVED***
            ref[segment] = value;
        ***REMOVED***

        ref = ref[segment];
    ***REMOVED***
***REMOVED***;


// Apply options to defaults except for the listed keys which are shallow copied from option without merging

exports.applyToDefaultsWithShallow = function (defaults, options, keys) ***REMOVED***

    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
    exports.assert(keys && Array.isArray(keys), 'Invalid keys');

    if (!options) ***REMOVED***                                                 // If no options, return null
        return null;
    ***REMOVED***

    const copy = exports.cloneWithShallow(defaults, keys);

    if (options === true) ***REMOVED***                                         // If options is set to true, use defaults
        return copy;
    ***REMOVED***

    const storage = internals.store(options, keys);   // Move shallow copy items to storage
    exports.merge(copy, options, false, false);     // Deep copy the rest
    internals.restore(copy, options, storage);      // Shallow copy the stored items and restore
    return copy;
***REMOVED***;


// Deep object or array comparison

exports.deepEqual = function (obj, ref, options, seen) ***REMOVED***

    options = options || ***REMOVED*** prototype: true ***REMOVED***;

    const type = typeof obj;

    if (type !== typeof ref) ***REMOVED***
        return false;
    ***REMOVED***

    if (type !== 'object' ||
        obj === null ||
        ref === null) ***REMOVED***

        if (obj === ref) ***REMOVED***                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
            return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0
        ***REMOVED***

        return obj !== obj && ref !== ref;                  // NaN
    ***REMOVED***

    seen = seen || [];
    if (seen.indexOf(obj) !== -1) ***REMOVED***
        return true;                            // If previous comparison failed, it would have stopped execution
    ***REMOVED***

    seen.push(obj);

    if (Array.isArray(obj)) ***REMOVED***
        if (!Array.isArray(ref)) ***REMOVED***
            return false;
        ***REMOVED***

        if (!options.part && obj.length !== ref.length) ***REMOVED***
            return false;
        ***REMOVED***

        for (let i = 0; i < obj.length; ++i) ***REMOVED***
            if (options.part) ***REMOVED***
                let found = false;
                for (let j = 0; j < ref.length; ++j) ***REMOVED***
                    if (exports.deepEqual(obj[i], ref[j], options)) ***REMOVED***
                        found = true;
                        break;
                    ***REMOVED***
                ***REMOVED***

                return found;
            ***REMOVED***

            if (!exports.deepEqual(obj[i], ref[i], options)) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***

        return true;
    ***REMOVED***

    if (Buffer.isBuffer(obj)) ***REMOVED***
        if (!Buffer.isBuffer(ref)) ***REMOVED***
            return false;
        ***REMOVED***

        if (obj.length !== ref.length) ***REMOVED***
            return false;
        ***REMOVED***

        for (let i = 0; i < obj.length; ++i) ***REMOVED***
            if (obj[i] !== ref[i]) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***

        return true;
    ***REMOVED***

    if (obj instanceof Date) ***REMOVED***
        return (ref instanceof Date && obj.getTime() === ref.getTime());
    ***REMOVED***

    if (obj instanceof RegExp) ***REMOVED***
        return (ref instanceof RegExp && obj.toString() === ref.toString());
    ***REMOVED***

    if (options.prototype) ***REMOVED***
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***

    const keys = Object.getOwnPropertyNames(obj);

    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) ***REMOVED***
        return false;
    ***REMOVED***

    for (let i = 0; i < keys.length; ++i) ***REMOVED***
        const key = keys[i];
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor.get) ***REMOVED***
            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        else if (!exports.deepEqual(obj[key], ref[key], options, seen)) ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***

    return true;
***REMOVED***;


// Remove duplicate items from array

exports.unique = (array, key) => ***REMOVED***

    let result;
    if (key) ***REMOVED***
        result = [];
        const index = new Set();
        array.forEach((item) => ***REMOVED***

            const identifier = item[key];
            if (!index.has(identifier)) ***REMOVED***
                index.add(identifier);
                result.push(item);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
    else ***REMOVED***
        result = Array.from(new Set(array));
    ***REMOVED***

    return result;
***REMOVED***;


// Convert array into object

exports.mapToObject = function (array, key) ***REMOVED***

    if (!array) ***REMOVED***
        return null;
    ***REMOVED***

    const obj = ***REMOVED******REMOVED***;
    for (let i = 0; i < array.length; ++i) ***REMOVED***
        if (key) ***REMOVED***
            if (array[i][key]) ***REMOVED***
                obj[array[i][key]] = true;
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            obj[array[i]] = true;
        ***REMOVED***
    ***REMOVED***

    return obj;
***REMOVED***;


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst) ***REMOVED***

    if (!array1 || !array2) ***REMOVED***
        return [];
    ***REMOVED***

    const common = [];
    const hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);
    const found = ***REMOVED******REMOVED***;
    for (let i = 0; i < array2.length; ++i) ***REMOVED***
        if (hash[array2[i]] && !found[array2[i]]) ***REMOVED***
            if (justFirst) ***REMOVED***
                return array2[i];
            ***REMOVED***

            common.push(array2[i]);
            found[array2[i]] = true;
        ***REMOVED***
    ***REMOVED***

    return (justFirst ? null : common);
***REMOVED***;


// Test if the reference contains the values

exports.contain = function (ref, values, options) ***REMOVED***

    /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

    let valuePairs = null;
    if (typeof ref === 'object' &&
        typeof values === 'object' &&
        !Array.isArray(ref) &&
        !Array.isArray(values)) ***REMOVED***

        valuePairs = values;
        values = Object.keys(values);
    ***REMOVED***
    else ***REMOVED***
        values = [].concat(values);
    ***REMOVED***

    options = options || ***REMOVED******REMOVED***;            // deep, once, only, part

    exports.assert(arguments.length >= 2, 'Insufficient arguments');
    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');
    exports.assert(values.length, 'Values array cannot be empty');

    let compare;
    let compareFlags;
    if (options.deep) ***REMOVED***
        compare = exports.deepEqual;

        const hasOnly = options.hasOwnProperty('only');
        const hasPart = options.hasOwnProperty('part');

        compareFlags = ***REMOVED***
            prototype: hasOnly ? options.only : hasPart ? !options.part : false,
            part: hasOnly ? !options.only : hasPart ? options.part : true
        ***REMOVED***;
    ***REMOVED***
    else ***REMOVED***
        compare = (a, b) => a === b;
    ***REMOVED***

    let misses = false;
    const matches = new Array(values.length);
    for (let i = 0; i < matches.length; ++i) ***REMOVED***
        matches[i] = 0;
    ***REMOVED***

    if (typeof ref === 'string') ***REMOVED***
        let pattern = '(';
        for (let i = 0; i < values.length; ++i) ***REMOVED***
            const value = values[i];
            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
            pattern += (i ? '|' : '') + exports.escapeRegex(value);
        ***REMOVED***

        const regex = new RegExp(pattern + ')', 'g');
        const leftovers = ref.replace(regex, ($0, $1) => ***REMOVED***

            const index = values.indexOf($1);
            ++matches[index];
            return '';          // Remove from string
        ***REMOVED***);

        misses = !!leftovers;
    ***REMOVED***
    else if (Array.isArray(ref)) ***REMOVED***
        for (let i = 0; i < ref.length; ++i) ***REMOVED***
            let matched = false;
            for (let j = 0; j < values.length && matched === false; ++j) ***REMOVED***
                matched = compare(values[j], ref[i], compareFlags) && j;
            ***REMOVED***

            if (matched !== false) ***REMOVED***
                ++matches[matched];
            ***REMOVED***
            else ***REMOVED***
                misses = true;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    else ***REMOVED***
        const keys = Object.getOwnPropertyNames(ref);
        for (let i = 0; i < keys.length; ++i) ***REMOVED***
            const key = keys[i];
            const pos = values.indexOf(key);
            if (pos !== -1) ***REMOVED***
                if (valuePairs &&
                    !compare(valuePairs[key], ref[key], compareFlags)) ***REMOVED***

                    return false;
                ***REMOVED***

                ++matches[pos];
            ***REMOVED***
            else ***REMOVED***
                misses = true;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    let result = false;
    for (let i = 0; i < matches.length; ++i) ***REMOVED***
        result = result || !!matches[i];
        if ((options.once && matches[i] > 1) ||
            (!options.part && !matches[i])) ***REMOVED***

            return false;
        ***REMOVED***
    ***REMOVED***

    if (options.only &&
        misses) ***REMOVED***

        return false;
    ***REMOVED***

    return result;
***REMOVED***;


// Flatten array

exports.flatten = function (array, target) ***REMOVED***

    const result = target || [];

    for (let i = 0; i < array.length; ++i) ***REMOVED***
        if (Array.isArray(array[i])) ***REMOVED***
            exports.flatten(array[i], result);
        ***REMOVED***
        else ***REMOVED***
            result.push(array[i]);
        ***REMOVED***
    ***REMOVED***

    return result;
***REMOVED***;


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain, options) ***REMOVED***

    if (chain === false ||
        chain === null ||
        typeof chain === 'undefined') ***REMOVED***

        return obj;
    ***REMOVED***

    options = options || ***REMOVED******REMOVED***;
    if (typeof options === 'string') ***REMOVED***
        options = ***REMOVED*** separator: options ***REMOVED***;
    ***REMOVED***

    const path = chain.split(options.separator || '.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) ***REMOVED***
        let key = path[i];
        if (key[0] === '-' && Array.isArray(ref)) ***REMOVED***
            key = key.slice(1, key.length);
            key = ref.length - key;
        ***REMOVED***

        if (!ref ||
            !((typeof ref === 'object' || typeof ref === 'function') && key in ref) ||
            (typeof ref !== 'object' && options.functions === false)) ***REMOVED***         // Only object and function can have properties

            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);
            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
            ref = options.default;
            break;
        ***REMOVED***

        ref = ref[key];
    ***REMOVED***

    return ref;
***REMOVED***;


exports.reachTemplate = function (obj, template, options) ***REMOVED***

    return template.replace(/***REMOVED***([^***REMOVED***]+)***REMOVED***/g, ($0, chain) => ***REMOVED***

        const value = exports.reach(obj, chain, options);
        return (value === undefined || value === null ? '' : value);
    ***REMOVED***);
***REMOVED***;


exports.formatStack = function (stack) ***REMOVED***

    const trace = [];
    for (let i = 0; i < stack.length; ++i) ***REMOVED***
        const item = stack[i];
        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    ***REMOVED***

    return trace;
***REMOVED***;


exports.formatTrace = function (trace) ***REMOVED***

    const display = [];

    for (let i = 0; i < trace.length; ++i) ***REMOVED***
        const row = trace[i];
        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    ***REMOVED***

    return display;
***REMOVED***;


exports.callStack = function (slice) ***REMOVED***

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    const v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) ***REMOVED***

        return stack;
    ***REMOVED***;

    const capture = ***REMOVED******REMOVED***;
    Error.captureStackTrace(capture, this);     // arguments.callee is not supported in strict mode so we use this and slice the trace of this off the result
    const stack = capture.stack;

    Error.prepareStackTrace = v8;

    const trace = exports.formatStack(stack);

    return trace.slice(1 + slice);
***REMOVED***;


exports.displayStack = function (slice) ***REMOVED***

    const trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
***REMOVED***;


exports.abortThrow = false;


exports.abort = function (message, hideStack) ***REMOVED***

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) ***REMOVED***
        throw new Error(message || 'Unknown error');
    ***REMOVED***

    let stack = '';
    if (!hideStack) ***REMOVED***
        stack = exports.displayStack(1).join('\n\t');
    ***REMOVED***
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
***REMOVED***;


exports.assert = function (condition /*, msg1, msg2, msg3 */) ***REMOVED***

    if (condition) ***REMOVED***
        return;
    ***REMOVED***

    if (arguments.length === 2 && arguments[1] instanceof Error) ***REMOVED***
        throw arguments[1];
    ***REMOVED***

    let msgs = [];
    for (let i = 1; i < arguments.length; ++i) ***REMOVED***
        if (arguments[i] !== '') ***REMOVED***
            msgs.push(arguments[i]);            // Avoids Array.slice arguments leak, allowing for V8 optimizations
        ***REMOVED***
    ***REMOVED***

    msgs = msgs.map((msg) => ***REMOVED***

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);
    ***REMOVED***);

    throw new Error(msgs.join(' ') || 'Unknown error');
***REMOVED***;


exports.Timer = function () ***REMOVED***

    this.ts = 0;
    this.reset();
***REMOVED***;


exports.Timer.prototype.reset = function () ***REMOVED***

    this.ts = Date.now();
***REMOVED***;


exports.Timer.prototype.elapsed = function () ***REMOVED***

    return Date.now() - this.ts;
***REMOVED***;


exports.Bench = function () ***REMOVED***

    this.ts = 0;
    this.reset();
***REMOVED***;


exports.Bench.prototype.reset = function () ***REMOVED***

    this.ts = exports.Bench.now();
***REMOVED***;


exports.Bench.prototype.elapsed = function () ***REMOVED***

    return exports.Bench.now() - this.ts;
***REMOVED***;


exports.Bench.now = function () ***REMOVED***

    const ts = process.hrtime();
    return (ts[0] * 1e3) + (ts[1] / 1e6);
***REMOVED***;


// Escape string for Regex construction

exports.escapeRegex = function (string) ***REMOVED***

    // Escape ^$.*+-?=!:|\/()[]***REMOVED******REMOVED***,
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\***REMOVED***\***REMOVED***\,]/g, '\\$&');
***REMOVED***;


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value, encoding) ***REMOVED***

    exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');
    const buf = (Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary'));
    return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
***REMOVED***;


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (value, encoding) ***REMOVED***

    if (typeof value !== 'string') ***REMOVED***

        return new Error('Value not a string');
    ***REMOVED***

    if (!/^[\w\-]*$/.test(value)) ***REMOVED***

        return new Error('Invalid character');
    ***REMOVED***

    const buf = new Buffer(value, 'base64');
    return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));
***REMOVED***;


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) ***REMOVED***

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`***REMOVED***|***REMOVED***~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\***REMOVED***\|\***REMOVED***~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
***REMOVED***;


exports.escapeHtml = function (string) ***REMOVED***

    return Escape.escapeHtml(string);
***REMOVED***;


exports.escapeJavaScript = function (string) ***REMOVED***

    return Escape.escapeJavaScript(string);
***REMOVED***;

exports.escapeJson = function (string) ***REMOVED***

    return Escape.escapeJson(string);
***REMOVED***;

exports.nextTick = function (callback) ***REMOVED***

    return function () ***REMOVED***

        const args = arguments;
        process.nextTick(() => ***REMOVED***

            callback.apply(null, args);
        ***REMOVED***);
    ***REMOVED***;
***REMOVED***;


exports.once = function (method) ***REMOVED***

    if (method._hoekOnce) ***REMOVED***
        return method;
    ***REMOVED***

    let once = false;
    const wrapped = function () ***REMOVED***

        if (!once) ***REMOVED***
            once = true;
            method.apply(null, arguments);
        ***REMOVED***
    ***REMOVED***;

    wrapped._hoekOnce = true;

    return wrapped;
***REMOVED***;


exports.isInteger = Number.isSafeInteger;


exports.ignore = function () ***REMOVED*** ***REMOVED***;


exports.inherits = Util.inherits;


exports.format = Util.format;


exports.transform = function (source, transform, options) ***REMOVED***

    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');
    const separator = (typeof options === 'object' && options !== null) ? (options.separator || '.') : '.';

    if (Array.isArray(source)) ***REMOVED***
        const results = [];
        for (let i = 0; i < source.length; ++i) ***REMOVED***
            results.push(exports.transform(source[i], transform, options));
        ***REMOVED***
        return results;
    ***REMOVED***

    const result = ***REMOVED******REMOVED***;
    const keys = Object.keys(transform);

    for (let i = 0; i < keys.length; ++i) ***REMOVED***
        const key = keys[i];
        const path = key.split(separator);
        const sourcePath = transform[key];

        exports.assert(typeof sourcePath === 'string', 'All mappings must be "." delineated strings');

        let segment;
        let res = result;

        while (path.length > 1) ***REMOVED***
            segment = path.shift();
            if (!res[segment]) ***REMOVED***
                res[segment] = ***REMOVED******REMOVED***;
            ***REMOVED***
            res = res[segment];
        ***REMOVED***
        segment = path.shift();
        res[segment] = exports.reach(source, sourcePath, options);
    ***REMOVED***

    return result;
***REMOVED***;


exports.uniqueFilename = function (path, extension) ***REMOVED***

    if (extension) ***REMOVED***
        extension = extension[0] !== '.' ? '.' + extension : extension;
    ***REMOVED***
    else ***REMOVED***
        extension = '';
    ***REMOVED***

    path = Path.resolve(path);
    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
    return Path.join(path, name);
***REMOVED***;


exports.stringify = function () ***REMOVED***

    try ***REMOVED***
        return JSON.stringify.apply(null, arguments);
    ***REMOVED***
    catch (err) ***REMOVED***
        return '[Cannot display object: ' + err.message + ']';
    ***REMOVED***
***REMOVED***;


exports.shallow = function (source) ***REMOVED***

    const target = ***REMOVED******REMOVED***;
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; ++i) ***REMOVED***
        const key = keys[i];
        target[key] = source[key];
    ***REMOVED***

    return target;
***REMOVED***;
