'use strict';

/*
    HTTP Hawk Authentication Scheme
    Copyright (c) 2012-2016, Eran Hammer <eran@hammer.io>
    BSD Licensed
*/

// Declare namespace

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) ***REMOVED*** return typeof obj; ***REMOVED*** : function (obj) ***REMOVED*** return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; ***REMOVED***;

var hawk = ***REMOVED***
    internals: ***REMOVED******REMOVED***
***REMOVED***;

hawk.client = ***REMOVED***

    // Generate an Authorization header for a given request

    /*
        uri: 'http://example.com/resource?a=b' or object generated by hawk.utils.parseUri()
        method: HTTP verb (e.g. 'GET', 'POST')
        options: ***REMOVED***
             // Required
             credentials: ***REMOVED***
                id: 'dh37fgj492je',
                key: 'aoijedoaijsdlaksjdl',
                algorithm: 'sha256'                                 // 'sha1', 'sha256'
            ***REMOVED***,
             // Optional
             ext: 'application-specific',                        // Application specific data sent via the ext attribute
            timestamp: Date.now() / 1000,                       // A pre-calculated timestamp in seconds
            nonce: '2334f34f',                                  // A pre-generated nonce
            localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
            payload: '***REMOVED***"some":"payload"***REMOVED***',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
            contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
            hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
            app: '24s23423f34dx',                               // Oz application id
            dlg: '234sz34tww3sd'                                // Oz delegated-by application id
        ***REMOVED***
    */

    header: function header(uri, method, options) ***REMOVED***

        var result = ***REMOVED***
            field: '',
            artifacts: ***REMOVED******REMOVED***
        ***REMOVED***;

        // Validate inputs

        if (!uri || typeof uri !== 'string' && (typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) !== 'object' || !method || typeof method !== 'string' || !options || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') ***REMOVED***

            result.err = 'Invalid argument type';
            return result;
        ***REMOVED***

        // Application time

        var timestamp = options.timestamp || hawk.utils.nowSec(options.localtimeOffsetMsec);

        // Validate credentials

        var credentials = options.credentials;
        if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) ***REMOVED***

            result.err = 'Invalid credentials object';
            return result;
        ***REMOVED***

        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) ***REMOVED***
            result.err = 'Unknown algorithm';
            return result;
        ***REMOVED***

        // Parse URI

        if (typeof uri === 'string') ***REMOVED***
            uri = hawk.utils.parseUri(uri);
        ***REMOVED***

        // Calculate signature

        var artifacts = ***REMOVED***
            ts: timestamp,
            nonce: options.nonce || hawk.utils.randomString(6),
            method: method,
            resource: uri.resource,
            host: uri.host,
            port: uri.port,
            hash: options.hash,
            ext: options.ext,
            app: options.app,
            dlg: options.dlg
        ***REMOVED***;

        result.artifacts = artifacts;

        // Calculate payload hash

        if (!artifacts.hash && (options.payload || options.payload === '')) ***REMOVED***

            artifacts.hash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
        ***REMOVED***

        var mac = hawk.crypto.calculateMac('header', credentials, artifacts);

        // Construct header

        var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== ''; // Other falsey values allowed
        var header = 'Hawk id="' + credentials.id + '", ts="' + artifacts.ts + '", nonce="' + artifacts.nonce + (artifacts.hash ? '", hash="' + artifacts.hash : '') + (hasExt ? '", ext="' + hawk.utils.escapeHeaderAttribute(artifacts.ext) : '') + '", mac="' + mac + '"';

        if (artifacts.app) ***REMOVED***
            header += ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
        ***REMOVED***

        result.field = header;

        return result;
    ***REMOVED***,

    // Generate a bewit value for a given URI

    /*
        uri: 'http://example.com/resource?a=b'
        options: ***REMOVED***
             // Required
             credentials: ***REMOVED***
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
            ***REMOVED***,
            ttlSec: 60 * 60,                                    // TTL in seconds
             // Optional
             ext: 'application-specific',                        // Application specific data sent via the ext attribute
            localtimeOffsetMsec: 400                            // Time offset to sync with server time
         ***REMOVED***;
    */

    bewit: function bewit(uri, options) ***REMOVED***

        // Validate inputs

        if (!uri || typeof uri !== 'string' || !options || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' || !options.ttlSec) ***REMOVED***

            return '';
        ***REMOVED***

        options.ext = options.ext === null || options.ext === undefined ? '' : options.ext; // Zero is valid value

        // Application time

        var now = hawk.utils.nowSec(options.localtimeOffsetMsec);

        // Validate credentials

        var credentials = options.credentials;
        if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) ***REMOVED***

            return '';
        ***REMOVED***

        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) ***REMOVED***
            return '';
        ***REMOVED***

        // Parse URI

        uri = hawk.utils.parseUri(uri);

        // Calculate signature

        var exp = now + options.ttlSec;
        var mac = hawk.crypto.calculateMac('bewit', credentials, ***REMOVED***
            ts: exp,
            nonce: '',
            method: 'GET',
            resource: uri.resource, // Maintain trailing '?' and query params
            host: uri.host,
            port: uri.port,
            ext: options.ext
        ***REMOVED***);

        // Construct bewit: id\exp\mac\ext

        var bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
        return hawk.utils.base64urlEncode(bewit);
    ***REMOVED***,

    // Validate server response

    /*
        request:    object created via 'new XMLHttpRequest()' after response received or fetch API 'Response'
        artifacts:  object received from header().artifacts
        options: ***REMOVED***
            payload:    optional payload received
            required:   specifies if a Server-Authorization header is required. Defaults to 'false'
        ***REMOVED***
    */

    authenticate: function authenticate(request, credentials, artifacts, options) ***REMOVED***

        options = options || ***REMOVED******REMOVED***;

        var getHeader = function getHeader(name) ***REMOVED***

            // Fetch API or plain headers

            if (request.headers) ***REMOVED***
                return typeof request.headers.get === 'function' ? request.headers.get(name) : request.headers[name];
            ***REMOVED***

            // XMLHttpRequest

            return request.getResponseHeader ? request.getResponseHeader(name) : request.getHeader(name);
        ***REMOVED***;

        var wwwAuthenticate = getHeader('www-authenticate');
        if (wwwAuthenticate) ***REMOVED***

            // Parse HTTP WWW-Authenticate header

            var wwwAttributes = hawk.utils.parseAuthorizationHeader(wwwAuthenticate, ['ts', 'tsm', 'error']);
            if (!wwwAttributes) ***REMOVED***
                return false;
            ***REMOVED***

            if (wwwAttributes.ts) ***REMOVED***
                var tsm = hawk.crypto.calculateTsMac(wwwAttributes.ts, credentials);
                if (tsm !== wwwAttributes.tsm) ***REMOVED***
                    return false;
                ***REMOVED***

                hawk.utils.setNtpSecOffset(wwwAttributes.ts - Math.floor(Date.now() / 1000)); // Keep offset at 1 second precision
            ***REMOVED***
        ***REMOVED***

        // Parse HTTP Server-Authorization header

        var serverAuthorization = getHeader('server-authorization');
        if (!serverAuthorization && !options.required) ***REMOVED***

            return true;
        ***REMOVED***

        var attributes = hawk.utils.parseAuthorizationHeader(serverAuthorization, ['mac', 'ext', 'hash']);
        if (!attributes) ***REMOVED***
            return false;
        ***REMOVED***

        var modArtifacts = ***REMOVED***
            ts: artifacts.ts,
            nonce: artifacts.nonce,
            method: artifacts.method,
            resource: artifacts.resource,
            host: artifacts.host,
            port: artifacts.port,
            hash: attributes.hash,
            ext: attributes.ext,
            app: artifacts.app,
            dlg: artifacts.dlg
        ***REMOVED***;

        var mac = hawk.crypto.calculateMac('response', credentials, modArtifacts);
        if (mac !== attributes.mac) ***REMOVED***
            return false;
        ***REMOVED***

        if (!options.payload && options.payload !== '') ***REMOVED***

            return true;
        ***REMOVED***

        if (!attributes.hash) ***REMOVED***
            return false;
        ***REMOVED***

        var calculatedHash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, getHeader('content-type'));
        return calculatedHash === attributes.hash;
    ***REMOVED***,

    message: function message(host, port, _message, options) ***REMOVED***

        // Validate inputs

        if (!host || typeof host !== 'string' || !port || typeof port !== 'number' || _message === null || _message === undefined || typeof _message !== 'string' || !options || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') ***REMOVED***

            return null;
        ***REMOVED***

        // Application time

        var timestamp = options.timestamp || hawk.utils.nowSec(options.localtimeOffsetMsec);

        // Validate credentials

        var credentials = options.credentials;
        if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) ***REMOVED***

            // Invalid credential object
            return null;
        ***REMOVED***

        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) ***REMOVED***
            return null;
        ***REMOVED***

        // Calculate signature

        var artifacts = ***REMOVED***
            ts: timestamp,
            nonce: options.nonce || hawk.utils.randomString(6),
            host: host,
            port: port,
            hash: hawk.crypto.calculatePayloadHash(_message, credentials.algorithm)
        ***REMOVED***;

        // Construct authorization

        var result = ***REMOVED***
            id: credentials.id,
            ts: artifacts.ts,
            nonce: artifacts.nonce,
            hash: artifacts.hash,
            mac: hawk.crypto.calculateMac('message', credentials, artifacts)
        ***REMOVED***;

        return result;
    ***REMOVED***,

    authenticateTimestamp: function authenticateTimestamp(message, credentials, updateClock) ***REMOVED***
        // updateClock defaults to true

        var tsm = hawk.crypto.calculateTsMac(message.ts, credentials);
        if (tsm !== message.tsm) ***REMOVED***
            return false;
        ***REMOVED***

        if (updateClock !== false) ***REMOVED***
            hawk.utils.setNtpSecOffset(message.ts - Math.floor(Date.now() / 1000)); // Keep offset at 1 second precision
        ***REMOVED***

        return true;
    ***REMOVED***
***REMOVED***;

hawk.crypto = ***REMOVED***

    headerVersion: '1',

    algorithms: ['sha1', 'sha256'],

    calculateMac: function calculateMac(type, credentials, options) ***REMOVED***

        var normalized = hawk.crypto.generateNormalizedString(type, options);

        var hmac = CryptoJS['Hmac' + credentials.algorithm.toUpperCase()](normalized, credentials.key);
        return hmac.toString(CryptoJS.enc.Base64);
    ***REMOVED***,

    generateNormalizedString: function generateNormalizedString(type, options) ***REMOVED***

        var normalized = 'hawk.' + hawk.crypto.headerVersion + '.' + type + '\n' + options.ts + '\n' + options.nonce + '\n' + (options.method || '').toUpperCase() + '\n' + (options.resource || '') + '\n' + options.host.toLowerCase() + '\n' + options.port + '\n' + (options.hash || '') + '\n';

        if (options.ext) ***REMOVED***
            normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
        ***REMOVED***

        normalized += '\n';

        if (options.app) ***REMOVED***
            normalized += options.app + '\n' + (options.dlg || '') + '\n';
        ***REMOVED***

        return normalized;
    ***REMOVED***,

    calculatePayloadHash: function calculatePayloadHash(payload, algorithm, contentType) ***REMOVED***

        var hash = CryptoJS.algo[algorithm.toUpperCase()].create();
        hash.update('hawk.' + hawk.crypto.headerVersion + '.payload\n');
        hash.update(hawk.utils.parseContentType(contentType) + '\n');
        hash.update(payload);
        hash.update('\n');
        return hash.finalize().toString(CryptoJS.enc.Base64);
    ***REMOVED***,

    calculateTsMac: function calculateTsMac(ts, credentials) ***REMOVED***

        var hash = CryptoJS['Hmac' + credentials.algorithm.toUpperCase()]('hawk.' + hawk.crypto.headerVersion + '.ts\n' + ts + '\n', credentials.key);
        return hash.toString(CryptoJS.enc.Base64);
    ***REMOVED***
***REMOVED***;

// localStorage compatible interface

hawk.internals.LocalStorage = function () ***REMOVED***

    this._cache = ***REMOVED******REMOVED***;
    this.length = 0;

    this.getItem = function (key) ***REMOVED***

        return this._cache.hasOwnProperty(key) ? String(this._cache[key]) : null;
    ***REMOVED***;

    this.setItem = function (key, value) ***REMOVED***

        this._cache[key] = String(value);
        this.length = Object.keys(this._cache).length;
    ***REMOVED***;

    this.removeItem = function (key) ***REMOVED***

        delete this._cache[key];
        this.length = Object.keys(this._cache).length;
    ***REMOVED***;

    this.clear = function () ***REMOVED***

        this._cache = ***REMOVED******REMOVED***;
        this.length = 0;
    ***REMOVED***;

    this.key = function (i) ***REMOVED***

        return Object.keys(this._cache)[i || 0];
    ***REMOVED***;
***REMOVED***;

hawk.utils = ***REMOVED***

    storage: new hawk.internals.LocalStorage(),

    setStorage: function setStorage(storage) ***REMOVED***

        var ntpOffset = hawk.utils.storage.getItem('hawk_ntp_offset');
        hawk.utils.storage = storage;
        if (ntpOffset) ***REMOVED***
            hawk.utils.setNtpSecOffset(ntpOffset);
        ***REMOVED***
    ***REMOVED***,

    setNtpSecOffset: function setNtpSecOffset(offset) ***REMOVED***

        try ***REMOVED***
            hawk.utils.storage.setItem('hawk_ntp_offset', offset);
        ***REMOVED*** catch (err) ***REMOVED***
            console.error('[hawk] could not write to storage.');
            console.error(err);
        ***REMOVED***
    ***REMOVED***,

    getNtpSecOffset: function getNtpSecOffset() ***REMOVED***

        var offset = hawk.utils.storage.getItem('hawk_ntp_offset');
        if (!offset) ***REMOVED***
            return 0;
        ***REMOVED***

        return parseInt(offset, 10);
    ***REMOVED***,

    now: function now(localtimeOffsetMsec) ***REMOVED***

        return Date.now() + (localtimeOffsetMsec || 0) + hawk.utils.getNtpSecOffset() * 1000;
    ***REMOVED***,

    nowSec: function nowSec(localtimeOffsetMsec) ***REMOVED***

        return Math.floor(hawk.utils.now(localtimeOffsetMsec) / 1000);
    ***REMOVED***,

    escapeHeaderAttribute: function escapeHeaderAttribute(attribute) ***REMOVED***

        return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');
    ***REMOVED***,

    parseContentType: function parseContentType(header) ***REMOVED***

        if (!header) ***REMOVED***
            return '';
        ***REMOVED***

        return header.split(';')[0].replace(/^\s+|\s+$/g, '').toLowerCase();
    ***REMOVED***,

    parseAuthorizationHeader: function parseAuthorizationHeader(header, keys) ***REMOVED***

        if (!header) ***REMOVED***
            return null;
        ***REMOVED***

        var headerParts = header.match(/^(\w+)(?:\s+(.*))?$/); // Header: scheme[ something]
        if (!headerParts) ***REMOVED***
            return null;
        ***REMOVED***

        var scheme = headerParts[1];
        if (scheme.toLowerCase() !== 'hawk') ***REMOVED***
            return null;
        ***REMOVED***

        var attributesString = headerParts[2];
        if (!attributesString) ***REMOVED***
            return null;
        ***REMOVED***

        var attributes = ***REMOVED******REMOVED***;
        var verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function ($0, $1, $2) ***REMOVED***

            // Check valid attribute names

            if (keys.indexOf($1) === -1) ***REMOVED***
                return;
            ***REMOVED***

            // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`***REMOVED***|***REMOVED***~ and space, a-z, A-Z, 0-9

            if ($2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\***REMOVED***\|\***REMOVED***~]+$/) === null) ***REMOVED***
                return;
            ***REMOVED***

            // Check for duplicates

            if (attributes.hasOwnProperty($1)) ***REMOVED***
                return;
            ***REMOVED***

            attributes[$1] = $2;
            return '';
        ***REMOVED***);

        if (verify !== '') ***REMOVED***
            return null;
        ***REMOVED***

        return attributes;
    ***REMOVED***,

    randomString: function randomString(size) ***REMOVED***

        var randomSource = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        var len = randomSource.length;

        var result = [];
        for (var i = 0; i < size; ++i) ***REMOVED***
            result[i] = randomSource[Math.floor(Math.random() * len)];
        ***REMOVED***

        return result.join('');
    ***REMOVED***,

    //          1                        2             3      4
    uriRegex: /^([^:]+)\:\/\/(?:[^@/]*@)?([^\/:]+)(?:\:(\d+))?([^#]*)(?:#.*)?$/, // scheme://credentials@host:port/resource#fragment
    parseUri: function parseUri(input) ***REMOVED***

        var parts = input.match(hawk.utils.uriRegex);
        if (!parts) ***REMOVED***
            return ***REMOVED*** host: '', port: '', resource: '' ***REMOVED***;
        ***REMOVED***

        var scheme = parts[1].toLowerCase();
        var uri = ***REMOVED***
            host: parts[2],
            port: parts[3] || (scheme === 'http' ? '80' : scheme === 'https' ? '443' : ''),
            resource: parts[4]
        ***REMOVED***;

        return uri;
    ***REMOVED***,

    base64urlEncode: function base64urlEncode(value) ***REMOVED***

        var wordArray = CryptoJS.enc.Utf8.parse(value);
        var encoded = CryptoJS.enc.Base64.stringify(wordArray);
        return encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    ***REMOVED***
***REMOVED***;

// $lab:coverage:off$
/* eslint-disable */

// Based on: Crypto-JS v3.1.2
// Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
// http://code.google.com/p/crypto-js/
// http://code.google.com/p/crypto-js/wiki/License

var CryptoJS = CryptoJS || function (h, r) ***REMOVED***
    var k = ***REMOVED******REMOVED***,
        l = k.lib = ***REMOVED******REMOVED***,
        n = function n() ***REMOVED******REMOVED***,
        f = l.Base = ***REMOVED*** extend: function extend(a) ***REMOVED***
            n.prototype = this;var b = new n();a && b.mixIn(a);b.hasOwnProperty("init") || (b.init = function () ***REMOVED***
                b.$super.init.apply(this, arguments);
            ***REMOVED***);b.init.prototype = b;b.$super = this;return b;
        ***REMOVED***, create: function create() ***REMOVED***
            var a = this.extend();a.init.apply(a, arguments);return a;
        ***REMOVED***, init: function init() ***REMOVED******REMOVED***, mixIn: function mixIn(a) ***REMOVED***
            for (var _b in a) ***REMOVED***
                a.hasOwnProperty(_b) && (this[_b] = a[_b]);
            ***REMOVED***a.hasOwnProperty("toString") && (this.toString = a.toString);
        ***REMOVED***, clone: function clone() ***REMOVED***
            return this.init.prototype.extend(this);
        ***REMOVED*** ***REMOVED***,
        j = l.WordArray = f.extend(***REMOVED*** init: function init(a, b) ***REMOVED***
            a = this.words = a || [];this.sigBytes = b != r ? b : 4 * a.length;
        ***REMOVED***, toString: function toString(a) ***REMOVED***
            return (a || s).stringify(this);
        ***REMOVED***, concat: function concat(a) ***REMOVED***
            var b = this.words,
                d = a.words,
                c = this.sigBytes;a = a.sigBytes;this.clamp();if (c % 4) for (var e = 0; e < a; e++) ***REMOVED***
                b[c + e >>> 2] |= (d[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((c + e) % 4);
            ***REMOVED*** else if (65535 < d.length) for (var _e = 0; _e < a; _e += 4) ***REMOVED***
                b[c + _e >>> 2] = d[_e >>> 2];
            ***REMOVED*** else b.push.apply(b, d);this.sigBytes += a;return this;
        ***REMOVED***, clamp: function clamp() ***REMOVED***
            var a = this.words,
                b = this.sigBytes;a[b >>> 2] &= 4294967295 << 32 - 8 * (b % 4);a.length = h.ceil(b / 4);
        ***REMOVED***, clone: function clone() ***REMOVED***
            var a = f.clone.call(this);a.words = this.words.slice(0);return a;
        ***REMOVED***, random: function random(a) ***REMOVED***
            for (var _b2 = [], d = 0; d < a; d += 4) ***REMOVED***
                _b2.push(4294967296 * h.random() | 0);
            ***REMOVED***return new j.init(b, a);
        ***REMOVED*** ***REMOVED***),
        m = k.enc = ***REMOVED******REMOVED***,
        s = m.Hex = ***REMOVED*** stringify: function stringify(a) ***REMOVED***
            var b = a.words;a = a.sigBytes;for (var d = [], c = 0; c < a; c++) ***REMOVED***
                var e = b[c >>> 2] >>> 24 - 8 * (c % 4) & 255;d.push((e >>> 4).toString(16));d.push((e & 15).toString(16));
            ***REMOVED***return d.join("");
        ***REMOVED***, parse: function parse(a) ***REMOVED***
            for (var b = a.length, d = [], c = 0; c < b; c += 2) ***REMOVED***
                d[c >>> 3] |= parseInt(a.substr(c, 2), 16) << 24 - 4 * (c % 8);
            ***REMOVED***return new j.init(d, b / 2);
        ***REMOVED*** ***REMOVED***,
        p = m.Latin1 = ***REMOVED*** stringify: function stringify(a) ***REMOVED***
            var b = a.words;a = a.sigBytes;for (var d = [], c = 0; c < a; c++) ***REMOVED***
                d.push(String.fromCharCode(b[c >>> 2] >>> 24 - 8 * (c % 4) & 255));
            ***REMOVED***return d.join("");
        ***REMOVED***, parse: function parse(a) ***REMOVED***
            for (var b = a.length, d = [], c = 0; c < b; c++) ***REMOVED***
                d[c >>> 2] |= (a.charCodeAt(c) & 255) << 24 - 8 * (c % 4);
            ***REMOVED***return new j.init(d, b);
        ***REMOVED*** ***REMOVED***,
        t = m.Utf8 = ***REMOVED*** stringify: function stringify(a) ***REMOVED***
            try ***REMOVED***
                return decodeURIComponent(escape(p.stringify(a)));
            ***REMOVED*** catch (b) ***REMOVED***
                throw Error("Malformed UTF-8 data");
            ***REMOVED***
        ***REMOVED***, parse: function parse(a) ***REMOVED***
            return p.parse(unescape(encodeURIComponent(a)));
        ***REMOVED*** ***REMOVED***,
        q = l.BufferedBlockAlgorithm = f.extend(***REMOVED*** reset: function reset() ***REMOVED***
            this._data = new j.init();this._nDataBytes = 0;
        ***REMOVED***, _append: function _append(a) ***REMOVED***
            "string" == typeof a && (a = t.parse(a));this._data.concat(a);this._nDataBytes += a.sigBytes;
        ***REMOVED***, _process: function _process(a) ***REMOVED***
            var b = this._data,
                d = b.words,
                c = b.sigBytes,
                e = this.blockSize,
                f = c / (4 * e),
                f = a ? h.ceil(f) : h.max((f | 0) - this._minBufferSize, 0);a = f * e;c = h.min(4 * a, c);if (a) ***REMOVED***
                for (var g = 0; g < a; g += e) ***REMOVED***
                    this._doProcessBlock(d, g);
                ***REMOVED***g = d.splice(0, a);b.sigBytes -= c;
            ***REMOVED***return new j.init(g, c);
        ***REMOVED***, clone: function clone() ***REMOVED***
            var a = f.clone.call(this);a._data = this._data.clone();return a;
        ***REMOVED***, _minBufferSize: 0 ***REMOVED***);l.Hasher = q.extend(***REMOVED*** cfg: f.extend(), init: function init(a) ***REMOVED***
            this.cfg = this.cfg.extend(a);this.reset();
        ***REMOVED***, reset: function reset() ***REMOVED***
            q.reset.call(this);this._doReset();
        ***REMOVED***, update: function update(a) ***REMOVED***
            this._append(a);this._process();return this;
        ***REMOVED***, finalize: function finalize(a) ***REMOVED***
            a && this._append(a);return this._doFinalize();
        ***REMOVED***, blockSize: 16, _createHelper: function _createHelper(a) ***REMOVED***
            return function (b, d) ***REMOVED***
                return new a.init(d).finalize(b);
            ***REMOVED***;
        ***REMOVED***, _createHmacHelper: function _createHmacHelper(a) ***REMOVED***
            return function (b, d) ***REMOVED***
                return new u.HMAC.init(a, d).finalize(b);
            ***REMOVED***;
        ***REMOVED*** ***REMOVED***);var u = k.algo = ***REMOVED******REMOVED***;return k;
***REMOVED***(Math);
(function () ***REMOVED***
    var k = CryptoJS,
        b = k.lib,
        m = b.WordArray,
        l = b.Hasher,
        d = [],
        b = k.algo.SHA1 = l.extend(***REMOVED*** _doReset: function _doReset() ***REMOVED***
            this._hash = new m.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
        ***REMOVED***, _doProcessBlock: function _doProcessBlock(n, p) ***REMOVED***
            for (var a = this._hash.words, e = a[0], f = a[1], h = a[2], j = a[3], b = a[4], c = 0; 80 > c; c++) ***REMOVED***
                if (16 > c) d[c] = n[p + c] | 0;else ***REMOVED***
                    var g = d[c - 3] ^ d[c - 8] ^ d[c - 14] ^ d[c - 16];d[c] = g << 1 | g >>> 31;
                ***REMOVED***g = (e << 5 | e >>> 27) + b + d[c];g = 20 > c ? g + ((f & h | ~f & j) + 1518500249) : 40 > c ? g + ((f ^ h ^ j) + 1859775393) : 60 > c ? g + ((f & h | f & j | h & j) - 1894007588) : g + ((f ^ h ^ j) - 899497514);b = j;j = h;h = f << 30 | f >>> 2;f = e;e = g;
            ***REMOVED***a[0] = a[0] + e | 0;a[1] = a[1] + f | 0;a[2] = a[2] + h | 0;a[3] = a[3] + j | 0;a[4] = a[4] + b | 0;
        ***REMOVED***, _doFinalize: function _doFinalize() ***REMOVED***
            var b = this._data,
                d = b.words,
                a = 8 * this._nDataBytes,
                e = 8 * b.sigBytes;d[e >>> 5] |= 128 << 24 - e % 32;d[(e + 64 >>> 9 << 4) + 14] = Math.floor(a / 4294967296);d[(e + 64 >>> 9 << 4) + 15] = a;b.sigBytes = 4 * d.length;this._process();return this._hash;
        ***REMOVED***, clone: function clone() ***REMOVED***
            var b = l.clone.call(this);b._hash = this._hash.clone();return b;
        ***REMOVED*** ***REMOVED***);k.SHA1 = l._createHelper(b);k.HmacSHA1 = l._createHmacHelper(b);
***REMOVED***)();
(function (k) ***REMOVED***
    for (var g = CryptoJS, h = g.lib, v = h.WordArray, j = h.Hasher, h = g.algo, s = [], t = [], u = function u(q) ***REMOVED***
        return 4294967296 * (q - (q | 0)) | 0;
    ***REMOVED***, l = 2, b = 0; 64 > b;) ***REMOVED***
        var d;a: ***REMOVED***
            d = l;for (var w = k.sqrt(d), r = 2; r <= w; r++) ***REMOVED***
                if (!(d % r)) ***REMOVED***
                    d = !1;break a;
                ***REMOVED***
            ***REMOVED***d = !0;
        ***REMOVED***d && (8 > b && (s[b] = u(k.pow(l, 0.5))), t[b] = u(k.pow(l, 1 / 3)), b++);l++;
    ***REMOVED***var n = [],
        h = h.SHA256 = j.extend(***REMOVED*** _doReset: function _doReset() ***REMOVED***
            this._hash = new v.init(s.slice(0));
        ***REMOVED***, _doProcessBlock: function _doProcessBlock(q, h) ***REMOVED***
            for (var a = this._hash.words, c = a[0], d = a[1], b = a[2], k = a[3], f = a[4], g = a[5], j = a[6], l = a[7], e = 0; 64 > e; e++) ***REMOVED***
                if (16 > e) n[e] = q[h + e] | 0;else ***REMOVED***
                    var m = n[e - 15],
                        p = n[e - 2];n[e] = ((m << 25 | m >>> 7) ^ (m << 14 | m >>> 18) ^ m >>> 3) + n[e - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + n[e - 16];
                ***REMOVED***m = l + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & g ^ ~f & j) + t[e] + n[e];p = ((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + (c & d ^ c & b ^ d & b);l = j;j = g;g = f;f = k + m | 0;k = b;b = d;d = c;c = m + p | 0;
            ***REMOVED***a[0] = a[0] + c | 0;a[1] = a[1] + d | 0;a[2] = a[2] + b | 0;a[3] = a[3] + k | 0;a[4] = a[4] + f | 0;a[5] = a[5] + g | 0;a[6] = a[6] + j | 0;a[7] = a[7] + l | 0;
        ***REMOVED***, _doFinalize: function _doFinalize() ***REMOVED***
            var d = this._data,
                b = d.words,
                a = 8 * this._nDataBytes,
                c = 8 * d.sigBytes;b[c >>> 5] |= 128 << 24 - c % 32;b[(c + 64 >>> 9 << 4) + 14] = k.floor(a / 4294967296);b[(c + 64 >>> 9 << 4) + 15] = a;d.sigBytes = 4 * b.length;this._process();return this._hash;
        ***REMOVED***, clone: function clone() ***REMOVED***
            var b = j.clone.call(this);b._hash = this._hash.clone();return b;
        ***REMOVED*** ***REMOVED***);g.SHA256 = j._createHelper(h);g.HmacSHA256 = j._createHmacHelper(h);
***REMOVED***)(Math);
(function () ***REMOVED***
    var c = CryptoJS,
        k = c.enc.Utf8;c.algo.HMAC = c.lib.Base.extend(***REMOVED*** init: function init(a, b) ***REMOVED***
            a = this._hasher = new a.init();"string" == typeof b && (b = k.parse(b));var c = a.blockSize,
                e = 4 * c;b.sigBytes > e && (b = a.finalize(b));b.clamp();for (var f = this._oKey = b.clone(), g = this._iKey = b.clone(), h = f.words, j = g.words, d = 0; d < c; d++) ***REMOVED***
                h[d] ^= 1549556828, j[d] ^= 909522486;
            ***REMOVED***f.sigBytes = g.sigBytes = e;this.reset();
        ***REMOVED***, reset: function reset() ***REMOVED***
            var a = this._hasher;a.reset();a.update(this._iKey);
        ***REMOVED***, update: function update(a) ***REMOVED***
            this._hasher.update(a);return this;
        ***REMOVED***, finalize: function finalize(a) ***REMOVED***
            var b = this._hasher;a = b.finalize(a);b.reset();return b.finalize(this._oKey.clone().concat(a));
        ***REMOVED*** ***REMOVED***);
***REMOVED***)();
(function () ***REMOVED***
    var h = CryptoJS,
        j = h.lib.WordArray;h.enc.Base64 = ***REMOVED*** stringify: function stringify(b) ***REMOVED***
            var e = b.words,
                f = b.sigBytes,
                c = this._map;b.clamp();b = [];for (var a = 0; a < f; a += 3) ***REMOVED***
                for (var d = (e[a >>> 2] >>> 24 - 8 * (a % 4) & 255) << 16 | (e[a + 1 >>> 2] >>> 24 - 8 * ((a + 1) % 4) & 255) << 8 | e[a + 2 >>> 2] >>> 24 - 8 * ((a + 2) % 4) & 255, g = 0; 4 > g && a + 0.75 * g < f; g++) ***REMOVED***
                    b.push(c.charAt(d >>> 6 * (3 - g) & 63));
                ***REMOVED***
            ***REMOVED***if (e = c.charAt(64)) for (; b.length % 4;) ***REMOVED***
                b.push(e);
            ***REMOVED***return b.join("");
        ***REMOVED***, parse: function parse(b) ***REMOVED***
            var e = b.length,
                f = this._map,
                c = f.charAt(64);c && (c = b.indexOf(c), -1 != c && (e = c));for (var c = [], a = 0, d = 0; d < e; d++) ***REMOVED***
                if (d % 4) ***REMOVED***
                    var g = f.indexOf(b.charAt(d - 1)) << 2 * (d % 4),
                        h = f.indexOf(b.charAt(d)) >>> 6 - 2 * (d % 4);c[a >>> 2] |= (g | h) << 24 - 8 * (a % 4);a++;
                ***REMOVED***
            ***REMOVED***return j.create(c, a);
        ***REMOVED***, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" ***REMOVED***;
***REMOVED***)();

hawk.crypto.utils = CryptoJS;

// Export if used as a module

if (typeof module !== 'undefined' && module.exports) ***REMOVED***
    module.exports = hawk;
***REMOVED***

/* eslint-enable */
// $lab:coverage:on$
