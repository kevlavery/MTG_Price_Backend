'use strict';

/*
    HTTP Hawk Authentication Scheme
    Copyright (c) 2012-2016, Eran Hammer <eran@hammer.io>
    BSD Licensed
*/


// Declare namespace

const hawk = ***REMOVED***
    internals: ***REMOVED******REMOVED***
***REMOVED***;


hawk.client = ***REMOVED***

    // Generate an Authorization header for a given request

    /*
        uri: 'http://example.com/resource?a=b' or object generated by hawk.utils.parseUri()
        method: HTTP verb (e.g. 'GET', 'POST')
        options: ***REMOVED***

            // Required

            credentials: ***REMOVED***
                id: 'dh37fgj492je',
                key: 'aoijedoaijsdlaksjdl',
                algorithm: 'sha256'                                 // 'sha1', 'sha256'
            ***REMOVED***,

            // Optional

            ext: 'application-specific',                        // Application specific data sent via the ext attribute
            timestamp: Date.now() / 1000,                       // A pre-calculated timestamp in seconds
            nonce: '2334f34f',                                  // A pre-generated nonce
            localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
            payload: '***REMOVED***"some":"payload"***REMOVED***',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
            contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
            hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
            app: '24s23423f34dx',                               // Oz application id
            dlg: '234sz34tww3sd'                                // Oz delegated-by application id
        ***REMOVED***
    */

    header: function (uri, method, options) ***REMOVED***

        const result = ***REMOVED***
            field: '',
            artifacts: ***REMOVED******REMOVED***
        ***REMOVED***;

        // Validate inputs

        if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||
            !method || typeof method !== 'string' ||
            !options || typeof options !== 'object') ***REMOVED***

            result.err = 'Invalid argument type';
            return result;
        ***REMOVED***

        // Application time

        const timestamp = options.timestamp || hawk.utils.nowSec(options.localtimeOffsetMsec);

        // Validate credentials

        const credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) ***REMOVED***

            result.err = 'Invalid credentials object';
            return result;
        ***REMOVED***

        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) ***REMOVED***
            result.err = 'Unknown algorithm';
            return result;
        ***REMOVED***

        // Parse URI

        if (typeof uri === 'string') ***REMOVED***
            uri = hawk.utils.parseUri(uri);
        ***REMOVED***

        // Calculate signature

        const artifacts = ***REMOVED***
            ts: timestamp,
            nonce: options.nonce || hawk.utils.randomString(6),
            method,
            resource: uri.resource,
            host: uri.host,
            port: uri.port,
            hash: options.hash,
            ext: options.ext,
            app: options.app,
            dlg: options.dlg
        ***REMOVED***;

        result.artifacts = artifacts;

        // Calculate payload hash

        if (!artifacts.hash &&
            (options.payload || options.payload === '')) ***REMOVED***

            artifacts.hash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
        ***REMOVED***

        const mac = hawk.crypto.calculateMac('header', credentials, artifacts);

        // Construct header

        const hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
        let header = 'Hawk id="' + credentials.id +
                     '", ts="' + artifacts.ts +
                     '", nonce="' + artifacts.nonce +
                     (artifacts.hash ? '", hash="' + artifacts.hash : '') +
                     (hasExt ? '", ext="' + hawk.utils.escapeHeaderAttribute(artifacts.ext) : '') +
                     '", mac="' + mac + '"';

        if (artifacts.app) ***REMOVED***
            header += ', app="' + artifacts.app +
                      (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
        ***REMOVED***

        result.field = header;

        return result;
    ***REMOVED***,

    // Generate a bewit value for a given URI

    /*
        uri: 'http://example.com/resource?a=b'
        options: ***REMOVED***

            // Required

            credentials: ***REMOVED***
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
            ***REMOVED***,
            ttlSec: 60 * 60,                                    // TTL in seconds

            // Optional

            ext: 'application-specific',                        // Application specific data sent via the ext attribute
            localtimeOffsetMsec: 400                            // Time offset to sync with server time
         ***REMOVED***;
    */

    bewit: function (uri, options) ***REMOVED***

        // Validate inputs

        if (!uri ||
            (typeof uri !== 'string') ||
            !options ||
            typeof options !== 'object' ||
            !options.ttlSec) ***REMOVED***

            return '';
        ***REMOVED***

        options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value

        // Application time

        const now = hawk.utils.nowSec(options.localtimeOffsetMsec);

        // Validate credentials

        const credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) ***REMOVED***

            return '';
        ***REMOVED***

        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) ***REMOVED***
            return '';
        ***REMOVED***

        // Parse URI

        uri = hawk.utils.parseUri(uri);

        // Calculate signature

        const exp = now + options.ttlSec;
        const mac = hawk.crypto.calculateMac('bewit', credentials, ***REMOVED***
            ts: exp,
            nonce: '',
            method: 'GET',
            resource: uri.resource,                            // Maintain trailing '?' and query params
            host: uri.host,
            port: uri.port,
            ext: options.ext
        ***REMOVED***);

        // Construct bewit: id\exp\mac\ext

        const bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
        return hawk.utils.base64urlEncode(bewit);
    ***REMOVED***,

    // Validate server response

    /*
        request:    object created via 'new XMLHttpRequest()' after response received or fetch API 'Response'
        artifacts:  object received from header().artifacts
        options: ***REMOVED***
            payload:    optional payload received
            required:   specifies if a Server-Authorization header is required. Defaults to 'false'
        ***REMOVED***
    */

    authenticate: function (request, credentials, artifacts, options) ***REMOVED***

        options = options || ***REMOVED******REMOVED***;

        const getHeader = function (name) ***REMOVED***

            // Fetch API or plain headers

            if (request.headers) ***REMOVED***
                return (typeof request.headers.get === 'function' ? request.headers.get(name) : request.headers[name]);
            ***REMOVED***

            // XMLHttpRequest

            return (request.getResponseHeader ? request.getResponseHeader(name) : request.getHeader(name));
        ***REMOVED***;

        const wwwAuthenticate = getHeader('www-authenticate');
        if (wwwAuthenticate) ***REMOVED***

            // Parse HTTP WWW-Authenticate header

            const wwwAttributes = hawk.utils.parseAuthorizationHeader(wwwAuthenticate, ['ts', 'tsm', 'error']);
            if (!wwwAttributes) ***REMOVED***
                return false;
            ***REMOVED***

            if (wwwAttributes.ts) ***REMOVED***
                const tsm = hawk.crypto.calculateTsMac(wwwAttributes.ts, credentials);
                if (tsm !== wwwAttributes.tsm) ***REMOVED***
                    return false;
                ***REMOVED***

                hawk.utils.setNtpSecOffset(wwwAttributes.ts - Math.floor(Date.now() / 1000));      // Keep offset at 1 second precision
            ***REMOVED***
        ***REMOVED***

        // Parse HTTP Server-Authorization header

        const serverAuthorization = getHeader('server-authorization');
        if (!serverAuthorization &&
            !options.required) ***REMOVED***

            return true;
        ***REMOVED***

        const attributes = hawk.utils.parseAuthorizationHeader(serverAuthorization, ['mac', 'ext', 'hash']);
        if (!attributes) ***REMOVED***
            return false;
        ***REMOVED***

        const modArtifacts = ***REMOVED***
            ts: artifacts.ts,
            nonce: artifacts.nonce,
            method: artifacts.method,
            resource: artifacts.resource,
            host: artifacts.host,
            port: artifacts.port,
            hash: attributes.hash,
            ext: attributes.ext,
            app: artifacts.app,
            dlg: artifacts.dlg
        ***REMOVED***;

        const mac = hawk.crypto.calculateMac('response', credentials, modArtifacts);
        if (mac !== attributes.mac) ***REMOVED***
            return false;
        ***REMOVED***

        if (!options.payload &&
            options.payload !== '') ***REMOVED***

            return true;
        ***REMOVED***

        if (!attributes.hash) ***REMOVED***
            return false;
        ***REMOVED***

        const calculatedHash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, getHeader('content-type'));
        return (calculatedHash === attributes.hash);
    ***REMOVED***,

    message: function (host, port, message, options) ***REMOVED***

        // Validate inputs

        if (!host || typeof host !== 'string' ||
            !port || typeof port !== 'number' ||
            message === null || message === undefined || typeof message !== 'string' ||
            !options || typeof options !== 'object') ***REMOVED***

            return null;
        ***REMOVED***

        // Application time

        const timestamp = options.timestamp || hawk.utils.nowSec(options.localtimeOffsetMsec);

        // Validate credentials

        const credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) ***REMOVED***

            // Invalid credential object
            return null;
        ***REMOVED***

        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) ***REMOVED***
            return null;
        ***REMOVED***

        // Calculate signature

        const artifacts = ***REMOVED***
            ts: timestamp,
            nonce: options.nonce || hawk.utils.randomString(6),
            host,
            port,
            hash: hawk.crypto.calculatePayloadHash(message, credentials.algorithm)
        ***REMOVED***;

        // Construct authorization

        const result = ***REMOVED***
            id: credentials.id,
            ts: artifacts.ts,
            nonce: artifacts.nonce,
            hash: artifacts.hash,
            mac: hawk.crypto.calculateMac('message', credentials, artifacts)
        ***REMOVED***;

        return result;
    ***REMOVED***,

    authenticateTimestamp: function (message, credentials, updateClock) ***REMOVED***               // updateClock defaults to true

        const tsm = hawk.crypto.calculateTsMac(message.ts, credentials);
        if (tsm !== message.tsm) ***REMOVED***
            return false;
        ***REMOVED***

        if (updateClock !== false) ***REMOVED***
            hawk.utils.setNtpSecOffset(message.ts - Math.floor(Date.now() / 1000));     // Keep offset at 1 second precision
        ***REMOVED***

        return true;
    ***REMOVED***
***REMOVED***;


hawk.crypto = ***REMOVED***

    headerVersion: '1',

    algorithms: ['sha1', 'sha256'],

    calculateMac: function (type, credentials, options) ***REMOVED***

        const normalized = hawk.crypto.generateNormalizedString(type, options);

        const hmac = CryptoJS['Hmac' + credentials.algorithm.toUpperCase()](normalized, credentials.key);
        return hmac.toString(CryptoJS.enc.Base64);
    ***REMOVED***,

    generateNormalizedString: function (type, options) ***REMOVED***

        let normalized = 'hawk.' + hawk.crypto.headerVersion + '.' + type + '\n' +
                         options.ts + '\n' +
                         options.nonce + '\n' +
                         (options.method || '').toUpperCase() + '\n' +
                         (options.resource || '') + '\n' +
                         options.host.toLowerCase() + '\n' +
                         options.port + '\n' +
                         (options.hash || '') + '\n';

        if (options.ext) ***REMOVED***
            normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
        ***REMOVED***

        normalized += '\n';

        if (options.app) ***REMOVED***
            normalized += options.app + '\n' +
                          (options.dlg || '') + '\n';
        ***REMOVED***

        return normalized;
    ***REMOVED***,

    calculatePayloadHash: function (payload, algorithm, contentType) ***REMOVED***

        const hash = CryptoJS.algo[algorithm.toUpperCase()].create();
        hash.update('hawk.' + hawk.crypto.headerVersion + '.payload\n');
        hash.update(hawk.utils.parseContentType(contentType) + '\n');
        hash.update(payload);
        hash.update('\n');
        return hash.finalize().toString(CryptoJS.enc.Base64);
    ***REMOVED***,

    calculateTsMac: function (ts, credentials) ***REMOVED***

        const hash = CryptoJS['Hmac' + credentials.algorithm.toUpperCase()]('hawk.' + hawk.crypto.headerVersion + '.ts\n' + ts + '\n', credentials.key);
        return hash.toString(CryptoJS.enc.Base64);
    ***REMOVED***
***REMOVED***;


// localStorage compatible interface

hawk.internals.LocalStorage = function () ***REMOVED***

    this._cache = ***REMOVED******REMOVED***;
    this.length = 0;

    this.getItem = function (key) ***REMOVED***

        return this._cache.hasOwnProperty(key) ? String(this._cache[key]) : null;
    ***REMOVED***;

    this.setItem = function (key, value) ***REMOVED***

        this._cache[key] = String(value);
        this.length = Object.keys(this._cache).length;
    ***REMOVED***;

    this.removeItem = function (key) ***REMOVED***

        delete this._cache[key];
        this.length = Object.keys(this._cache).length;
    ***REMOVED***;

    this.clear = function () ***REMOVED***

        this._cache = ***REMOVED******REMOVED***;
        this.length = 0;
    ***REMOVED***;

    this.key = function (i) ***REMOVED***

        return Object.keys(this._cache)[i || 0];
    ***REMOVED***;
***REMOVED***;


hawk.utils = ***REMOVED***

    storage: new hawk.internals.LocalStorage(),

    setStorage: function (storage) ***REMOVED***

        const ntpOffset = hawk.utils.storage.getItem('hawk_ntp_offset');
        hawk.utils.storage = storage;
        if (ntpOffset) ***REMOVED***
            hawk.utils.setNtpSecOffset(ntpOffset);
        ***REMOVED***
    ***REMOVED***,

    setNtpSecOffset: function (offset) ***REMOVED***

        try ***REMOVED***
            hawk.utils.storage.setItem('hawk_ntp_offset', offset);
        ***REMOVED***
        catch (err) ***REMOVED***
            console.error('[hawk] could not write to storage.');
            console.error(err);
        ***REMOVED***
    ***REMOVED***,

    getNtpSecOffset: function () ***REMOVED***

        const offset = hawk.utils.storage.getItem('hawk_ntp_offset');
        if (!offset) ***REMOVED***
            return 0;
        ***REMOVED***

        return parseInt(offset, 10);
    ***REMOVED***,

    now: function (localtimeOffsetMsec) ***REMOVED***

        return Date.now() + (localtimeOffsetMsec || 0) + (hawk.utils.getNtpSecOffset() * 1000);
    ***REMOVED***,

    nowSec: function (localtimeOffsetMsec) ***REMOVED***

        return Math.floor(hawk.utils.now(localtimeOffsetMsec) / 1000);
    ***REMOVED***,

    escapeHeaderAttribute: function (attribute) ***REMOVED***

        return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');
    ***REMOVED***,

    parseContentType: function (header) ***REMOVED***

        if (!header) ***REMOVED***
            return '';
        ***REMOVED***

        return header.split(';')[0].replace(/^\s+|\s+$/g, '').toLowerCase();
    ***REMOVED***,

    parseAuthorizationHeader: function (header, keys) ***REMOVED***

        if (!header) ***REMOVED***
            return null;
        ***REMOVED***

        const headerParts = header.match(/^(\w+)(?:\s+(.*))?$/);       // Header: scheme[ something]
        if (!headerParts) ***REMOVED***
            return null;
        ***REMOVED***

        const scheme = headerParts[1];
        if (scheme.toLowerCase() !== 'hawk') ***REMOVED***
            return null;
        ***REMOVED***

        const attributesString = headerParts[2];
        if (!attributesString) ***REMOVED***
            return null;
        ***REMOVED***

        const attributes = ***REMOVED******REMOVED***;
        const verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, ($0, $1, $2) => ***REMOVED***

            // Check valid attribute names

            if (keys.indexOf($1) === -1) ***REMOVED***
                return;
            ***REMOVED***

            // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`***REMOVED***|***REMOVED***~ and space, a-z, A-Z, 0-9

            if ($2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\***REMOVED***\|\***REMOVED***~]+$/) === null) ***REMOVED***
                return;
            ***REMOVED***

            // Check for duplicates

            if (attributes.hasOwnProperty($1)) ***REMOVED***
                return;
            ***REMOVED***

            attributes[$1] = $2;
            return '';
        ***REMOVED***);

        if (verify !== '') ***REMOVED***
            return null;
        ***REMOVED***

        return attributes;
    ***REMOVED***,

    randomString: function (size) ***REMOVED***

        const randomSource = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        const len = randomSource.length;

        const result = [];
        for (let i = 0; i < size; ++i) ***REMOVED***
            result[i] = randomSource[Math.floor(Math.random() * len)];
        ***REMOVED***

        return result.join('');
    ***REMOVED***,

    //          1                        2             3      4
    uriRegex: /^([^:]+)\:\/\/(?:[^@/]*@)?([^\/:]+)(?:\:(\d+))?([^#]*)(?:#.*)?$/,       // scheme://credentials@host:port/resource#fragment
    parseUri: function (input) ***REMOVED***

        const parts = input.match(hawk.utils.uriRegex);
        if (!parts) ***REMOVED***
            return ***REMOVED*** host: '', port: '', resource: '' ***REMOVED***;
        ***REMOVED***

        const scheme = parts[1].toLowerCase();
        const uri = ***REMOVED***
            host: parts[2],
            port: parts[3] || (scheme === 'http' ? '80' : (scheme === 'https' ? '443' : '')),
            resource: parts[4]
        ***REMOVED***;

        return uri;
    ***REMOVED***,

    base64urlEncode: function (value) ***REMOVED***

        const wordArray = CryptoJS.enc.Utf8.parse(value);
        const encoded = CryptoJS.enc.Base64.stringify(wordArray);
        return encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    ***REMOVED***
***REMOVED***;


// $lab:coverage:off$
/* eslint-disable */

// Based on: Crypto-JS v3.1.2
// Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
// http://code.google.com/p/crypto-js/
// http://code.google.com/p/crypto-js/wiki/License

var CryptoJS = CryptoJS || function (h, r) ***REMOVED*** var k = ***REMOVED******REMOVED***, l = k.lib = ***REMOVED******REMOVED***, n = function () ***REMOVED*** ***REMOVED***, f = l.Base = ***REMOVED*** extend: function (a) ***REMOVED*** n.prototype = this; var b = new n; a && b.mixIn(a); b.hasOwnProperty("init") || (b.init = function () ***REMOVED*** b.$super.init.apply(this, arguments) ***REMOVED***); b.init.prototype = b; b.$super = this; return b ***REMOVED***, create: function () ***REMOVED*** var a = this.extend(); a.init.apply(a, arguments); return a ***REMOVED***, init: function () ***REMOVED*** ***REMOVED***, mixIn: function (a) ***REMOVED*** for (let b in a) a.hasOwnProperty(b) && (this[b] = a[b]); a.hasOwnProperty("toString") && (this.toString = a.toString) ***REMOVED***, clone: function () ***REMOVED*** return this.init.prototype.extend(this) ***REMOVED*** ***REMOVED***, j = l.WordArray = f.extend(***REMOVED*** init: function (a, b) ***REMOVED*** a = this.words = a || []; this.sigBytes = b != r ? b : 4 * a.length ***REMOVED***, toString: function (a) ***REMOVED*** return (a || s).stringify(this) ***REMOVED***, concat: function (a) ***REMOVED*** var b = this.words, d = a.words, c = this.sigBytes; a = a.sigBytes; this.clamp(); if (c % 4) for (let e = 0; e < a; e++) b[c + e >>> 2] |= (d[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((c + e) % 4); else if (65535 < d.length) for (let e = 0; e < a; e += 4) b[c + e >>> 2] = d[e >>> 2]; else b.push.apply(b, d); this.sigBytes += a; return this ***REMOVED***, clamp: function () ***REMOVED*** var a = this.words, b = this.sigBytes; a[b >>> 2] &= 4294967295 << 32 - 8 * (b % 4); a.length = h.ceil(b / 4) ***REMOVED***, clone: function () ***REMOVED*** var a = f.clone.call(this); a.words = this.words.slice(0); return a ***REMOVED***, random: function (a) ***REMOVED*** for (let b = [], d = 0; d < a; d += 4) b.push(4294967296 * h.random() | 0); return new j.init(b, a) ***REMOVED*** ***REMOVED***), m = k.enc = ***REMOVED******REMOVED***, s = m.Hex = ***REMOVED*** stringify: function (a) ***REMOVED*** var b = a.words; a = a.sigBytes; for (var d = [], c = 0; c < a; c++) ***REMOVED*** var e = b[c >>> 2] >>> 24 - 8 * (c % 4) & 255; d.push((e >>> 4).toString(16)); d.push((e & 15).toString(16)) ***REMOVED*** return d.join("") ***REMOVED***, parse: function (a) ***REMOVED*** for (var b = a.length, d = [], c = 0; c < b; c += 2) d[c >>> 3] |= parseInt(a.substr(c, 2), 16) << 24 - 4 * (c % 8); return new j.init(d, b / 2) ***REMOVED*** ***REMOVED***, p = m.Latin1 = ***REMOVED*** stringify: function (a) ***REMOVED*** var b = a.words; a = a.sigBytes; for (var d = [], c = 0; c < a; c++) d.push(String.fromCharCode(b[c >>> 2] >>> 24 - 8 * (c % 4) & 255)); return d.join("") ***REMOVED***, parse: function (a) ***REMOVED*** for (var b = a.length, d = [], c = 0; c < b; c++) d[c >>> 2] |= (a.charCodeAt(c) & 255) << 24 - 8 * (c % 4); return new j.init(d, b) ***REMOVED*** ***REMOVED***, t = m.Utf8 = ***REMOVED*** stringify: function (a) ***REMOVED*** try ***REMOVED*** return decodeURIComponent(escape(p.stringify(a))) ***REMOVED*** catch (b) ***REMOVED*** throw Error("Malformed UTF-8 data"); ***REMOVED*** ***REMOVED***, parse: function (a) ***REMOVED*** return p.parse(unescape(encodeURIComponent(a))) ***REMOVED*** ***REMOVED***, q = l.BufferedBlockAlgorithm = f.extend(***REMOVED*** reset: function () ***REMOVED*** this._data = new j.init; this._nDataBytes = 0 ***REMOVED***, _append: function (a) ***REMOVED*** "string" == typeof a && (a = t.parse(a)); this._data.concat(a); this._nDataBytes += a.sigBytes ***REMOVED***, _process: function (a) ***REMOVED*** var b = this._data, d = b.words, c = b.sigBytes, e = this.blockSize, f = c / (4 * e), f = a ? h.ceil(f) : h.max((f | 0) - this._minBufferSize, 0); a = f * e; c = h.min(4 * a, c); if (a) ***REMOVED*** for (var g = 0; g < a; g += e) this._doProcessBlock(d, g); g = d.splice(0, a); b.sigBytes -= c ***REMOVED*** return new j.init(g, c) ***REMOVED***, clone: function () ***REMOVED*** var a = f.clone.call(this); a._data = this._data.clone(); return a ***REMOVED***, _minBufferSize: 0 ***REMOVED***); l.Hasher = q.extend(***REMOVED*** cfg: f.extend(), init: function (a) ***REMOVED*** this.cfg = this.cfg.extend(a); this.reset() ***REMOVED***, reset: function () ***REMOVED*** q.reset.call(this); this._doReset() ***REMOVED***, update: function (a) ***REMOVED*** this._append(a); this._process(); return this ***REMOVED***, finalize: function (a) ***REMOVED*** a && this._append(a); return this._doFinalize() ***REMOVED***, blockSize: 16, _createHelper: function (a) ***REMOVED*** return function (b, d) ***REMOVED*** return (new a.init(d)).finalize(b) ***REMOVED*** ***REMOVED***, _createHmacHelper: function (a) ***REMOVED*** return function (b, d) ***REMOVED*** return (new u.HMAC.init(a, d)).finalize(b) ***REMOVED*** ***REMOVED*** ***REMOVED***); var u = k.algo = ***REMOVED******REMOVED***; return k ***REMOVED***(Math);
(() => ***REMOVED*** var k = CryptoJS, b = k.lib, m = b.WordArray, l = b.Hasher, d = [], b = k.algo.SHA1 = l.extend(***REMOVED*** _doReset: function () ***REMOVED*** this._hash = new m.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) ***REMOVED***, _doProcessBlock: function (n, p) ***REMOVED*** for (var a = this._hash.words, e = a[0], f = a[1], h = a[2], j = a[3], b = a[4], c = 0; 80 > c; c++) ***REMOVED*** if (16 > c) d[c] = n[p + c] | 0; else ***REMOVED*** var g = d[c - 3] ^ d[c - 8] ^ d[c - 14] ^ d[c - 16]; d[c] = g << 1 | g >>> 31 ***REMOVED*** g = (e << 5 | e >>> 27) + b + d[c]; g = 20 > c ? g + ((f & h | ~f & j) + 1518500249) : 40 > c ? g + ((f ^ h ^ j) + 1859775393) : 60 > c ? g + ((f & h | f & j | h & j) - 1894007588) : g + ((f ^ h ^ j) - 899497514); b = j; j = h; h = f << 30 | f >>> 2; f = e; e = g ***REMOVED*** a[0] = a[0] + e | 0; a[1] = a[1] + f | 0; a[2] = a[2] + h | 0; a[3] = a[3] + j | 0; a[4] = a[4] + b | 0 ***REMOVED***, _doFinalize: function () ***REMOVED*** var b = this._data, d = b.words, a = 8 * this._nDataBytes, e = 8 * b.sigBytes; d[e >>> 5] |= 128 << 24 - e % 32; d[(e + 64 >>> 9 << 4) + 14] = Math.floor(a / 4294967296); d[(e + 64 >>> 9 << 4) + 15] = a; b.sigBytes = 4 * d.length; this._process(); return this._hash ***REMOVED***, clone: function () ***REMOVED*** var b = l.clone.call(this); b._hash = this._hash.clone(); return b ***REMOVED*** ***REMOVED***); k.SHA1 = l._createHelper(b); k.HmacSHA1 = l._createHmacHelper(b) ***REMOVED***)();
(function (k) ***REMOVED*** for (var g = CryptoJS, h = g.lib, v = h.WordArray, j = h.Hasher, h = g.algo, s = [], t = [], u = function (q) ***REMOVED*** return 4294967296 * (q - (q | 0)) | 0 ***REMOVED***, l = 2, b = 0; 64 > b;) ***REMOVED*** var d; a: ***REMOVED*** d = l; for (var w = k.sqrt(d), r = 2; r <= w; r++) if (!(d % r)) ***REMOVED*** d = !1; break a ***REMOVED*** d = !0 ***REMOVED*** d && (8 > b && (s[b] = u(k.pow(l, 0.5))), t[b] = u(k.pow(l, 1 / 3)), b++); l++ ***REMOVED*** var n = [], h = h.SHA256 = j.extend(***REMOVED*** _doReset: function () ***REMOVED*** this._hash = new v.init(s.slice(0)) ***REMOVED***, _doProcessBlock: function (q, h) ***REMOVED*** for (var a = this._hash.words, c = a[0], d = a[1], b = a[2], k = a[3], f = a[4], g = a[5], j = a[6], l = a[7], e = 0; 64 > e; e++) ***REMOVED*** if (16 > e) n[e] = q[h + e] | 0; else ***REMOVED*** var m = n[e - 15], p = n[e - 2]; n[e] = ((m << 25 | m >>> 7) ^ (m << 14 | m >>> 18) ^ m >>> 3) + n[e - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + n[e - 16] ***REMOVED*** m = l + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & g ^ ~f & j) + t[e] + n[e]; p = ((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + (c & d ^ c & b ^ d & b); l = j; j = g; g = f; f = k + m | 0; k = b; b = d; d = c; c = m + p | 0 ***REMOVED*** a[0] = a[0] + c | 0; a[1] = a[1] + d | 0; a[2] = a[2] + b | 0; a[3] = a[3] + k | 0; a[4] = a[4] + f | 0; a[5] = a[5] + g | 0; a[6] = a[6] + j | 0; a[7] = a[7] + l | 0 ***REMOVED***, _doFinalize: function () ***REMOVED*** var d = this._data, b = d.words, a = 8 * this._nDataBytes, c = 8 * d.sigBytes; b[c >>> 5] |= 128 << 24 - c % 32; b[(c + 64 >>> 9 << 4) + 14] = k.floor(a / 4294967296); b[(c + 64 >>> 9 << 4) + 15] = a; d.sigBytes = 4 * b.length; this._process(); return this._hash ***REMOVED***, clone: function () ***REMOVED*** var b = j.clone.call(this); b._hash = this._hash.clone(); return b ***REMOVED*** ***REMOVED***); g.SHA256 = j._createHelper(h); g.HmacSHA256 = j._createHmacHelper(h) ***REMOVED***)(Math);
(() => ***REMOVED*** var c = CryptoJS, k = c.enc.Utf8; c.algo.HMAC = c.lib.Base.extend(***REMOVED*** init: function (a, b) ***REMOVED*** a = this._hasher = new a.init; "string" == typeof b && (b = k.parse(b)); var c = a.blockSize, e = 4 * c; b.sigBytes > e && (b = a.finalize(b)); b.clamp(); for (var f = this._oKey = b.clone(), g = this._iKey = b.clone(), h = f.words, j = g.words, d = 0; d < c; d++) h[d] ^= 1549556828, j[d] ^= 909522486; f.sigBytes = g.sigBytes = e; this.reset() ***REMOVED***, reset: function () ***REMOVED*** var a = this._hasher; a.reset(); a.update(this._iKey) ***REMOVED***, update: function (a) ***REMOVED*** this._hasher.update(a); return this ***REMOVED***, finalize: function (a) ***REMOVED*** var b = this._hasher; a = b.finalize(a); b.reset(); return b.finalize(this._oKey.clone().concat(a)) ***REMOVED*** ***REMOVED***) ***REMOVED***)();
(() => ***REMOVED*** var h = CryptoJS, j = h.lib.WordArray; h.enc.Base64 = ***REMOVED*** stringify: function (b) ***REMOVED*** var e = b.words, f = b.sigBytes, c = this._map; b.clamp(); b = []; for (var a = 0; a < f; a += 3) for (var d = (e[a >>> 2] >>> 24 - 8 * (a % 4) & 255) << 16 | (e[a + 1 >>> 2] >>> 24 - 8 * ((a + 1) % 4) & 255) << 8 | e[a + 2 >>> 2] >>> 24 - 8 * ((a + 2) % 4) & 255, g = 0; 4 > g && a + 0.75 * g < f; g++) b.push(c.charAt(d >>> 6 * (3 - g) & 63)); if (e = c.charAt(64)) for (; b.length % 4;) b.push(e); return b.join("") ***REMOVED***, parse: function (b) ***REMOVED*** var e = b.length, f = this._map, c = f.charAt(64); c && (c = b.indexOf(c), -1 != c && (e = c)); for (var c = [], a = 0, d = 0; d < e; d++) if (d % 4) ***REMOVED*** var g = f.indexOf(b.charAt(d - 1)) << 2 * (d % 4), h = f.indexOf(b.charAt(d)) >>> 6 - 2 * (d % 4); c[a >>> 2] |= (g | h) << 24 - 8 * (a % 4); a++ ***REMOVED*** return j.create(c, a) ***REMOVED***, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" ***REMOVED*** ***REMOVED***)();


hawk.crypto.utils = CryptoJS;

// Export if used as a module

if (typeof module !== 'undefined' && module.exports) ***REMOVED***
    module.exports = hawk;
***REMOVED***

/* eslint-enable */
// $lab:coverage:on$
