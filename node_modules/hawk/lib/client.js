'use strict';

// Load modules

const Url = require('url');
const Hoek = require('hoek');
const Cryptiles = require('cryptiles');
const Crypto = require('./crypto');
const Utils = require('./utils');


// Declare internals

const internals = ***REMOVED******REMOVED***;


// Generate an Authorization header for a given request

/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse()
    method: HTTP verb (e.g. 'GET', 'POST')
    options: ***REMOVED***

        // Required

        credentials: ***REMOVED***
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                                 // 'sha1', 'sha256'
        ***REMOVED***,

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        timestamp: Date.now() / 1000,                       // A pre-calculated timestamp in seconds
        nonce: '2334f34f',                                  // A pre-generated nonce
        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
        payload: '***REMOVED***"some":"payload"***REMOVED***',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
        hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
        app: '24s23423f34dx',                               // Oz application id
        dlg: '234sz34tww3sd'                                // Oz delegated-by application id
    ***REMOVED***
*/

exports.header = function (uri, method, options) ***REMOVED***

    const result = ***REMOVED***
        field: '',
        artifacts: ***REMOVED******REMOVED***
    ***REMOVED***;

    // Validate inputs

    if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||
        !method || typeof method !== 'string' ||
        !options || typeof options !== 'object') ***REMOVED***

        result.err = 'Invalid argument type';
        return result;
    ***REMOVED***

    // Application time

    const timestamp = options.timestamp || Utils.nowSecs(options.localtimeOffsetMsec);

    // Validate credentials

    const credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) ***REMOVED***

        result.err = 'Invalid credential object';
        return result;
    ***REMOVED***

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) ***REMOVED***
        result.err = 'Unknown algorithm';
        return result;
    ***REMOVED***

    // Parse URI

    if (typeof uri === 'string') ***REMOVED***
        uri = Url.parse(uri);
    ***REMOVED***

    // Calculate signature

    const artifacts = ***REMOVED***
        ts: timestamp,
        nonce: options.nonce || Cryptiles.randomString(6),
        method,
        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
        hash: options.hash,
        ext: options.ext,
        app: options.app,
        dlg: options.dlg
    ***REMOVED***;

    result.artifacts = artifacts;

    // Calculate payload hash

    if (!artifacts.hash &&
        (options.payload || options.payload === '')) ***REMOVED***

        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
    ***REMOVED***

    const mac = Crypto.calculateMac('header', credentials, artifacts);

    // Construct header

    const hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
    let header = 'Hawk id="' + credentials.id +
                 '", ts="' + artifacts.ts +
                 '", nonce="' + artifacts.nonce +
                 (artifacts.hash ? '", hash="' + artifacts.hash : '') +
                 (hasExt ? '", ext="' + Hoek.escapeHeaderAttribute(artifacts.ext) : '') +
                 '", mac="' + mac + '"';

    if (artifacts.app) ***REMOVED***
        header = header + ', app="' + artifacts.app +
                  (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
    ***REMOVED***

    result.field = header;

    return result;
***REMOVED***;


// Validate server response

/*
    res:        node's response object
    artifacts:  object received from header().artifacts
    options: ***REMOVED***
        payload:    optional payload received
        required:   specifies if a Server-Authorization header is required. Defaults to 'false'
    ***REMOVED***
*/

exports.authenticate = function (res, credentials, artifacts, options, callback) ***REMOVED***

    artifacts = Hoek.clone(artifacts);
    options = options || ***REMOVED******REMOVED***;

    let wwwAttributes = null;
    let serverAuthAttributes = null;

    const finalize = function (err) ***REMOVED***

        if (callback) ***REMOVED***
            const headers = ***REMOVED***
                'www-authenticate': wwwAttributes,
                'server-authorization': serverAuthAttributes
            ***REMOVED***;

            return callback(err, headers);
        ***REMOVED***

        return !err;
    ***REMOVED***;

    if (res.headers['www-authenticate']) ***REMOVED***

        // Parse HTTP WWW-Authenticate header

        wwwAttributes = Utils.parseAuthorizationHeader(res.headers['www-authenticate'], ['ts', 'tsm', 'error']);
        if (wwwAttributes instanceof Error) ***REMOVED***
            wwwAttributes = null;
            return finalize(new Error('Invalid WWW-Authenticate header'));
        ***REMOVED***

        // Validate server timestamp (not used to update clock since it is done via the SNPT client)

        if (wwwAttributes.ts) ***REMOVED***
            const tsm = Crypto.calculateTsMac(wwwAttributes.ts, credentials);
            if (tsm !== wwwAttributes.tsm) ***REMOVED***
                return finalize(new Error('Invalid server timestamp hash'));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    // Parse HTTP Server-Authorization header

    if (!res.headers['server-authorization'] &&
        !options.required) ***REMOVED***

        return finalize();
    ***REMOVED***

    serverAuthAttributes = Utils.parseAuthorizationHeader(res.headers['server-authorization'], ['mac', 'ext', 'hash']);
    if (serverAuthAttributes instanceof Error) ***REMOVED***
        serverAuthAttributes = null;
        return finalize(new Error('Invalid Server-Authorization header'));
    ***REMOVED***

    artifacts.ext = serverAuthAttributes.ext;
    artifacts.hash = serverAuthAttributes.hash;

    const mac = Crypto.calculateMac('response', credentials, artifacts);
    if (mac !== serverAuthAttributes.mac) ***REMOVED***
        return finalize(new Error('Bad response mac'));
    ***REMOVED***

    if (!options.payload &&
        options.payload !== '') ***REMOVED***

        return finalize();
    ***REMOVED***

    if (!serverAuthAttributes.hash) ***REMOVED***
        return finalize(new Error('Missing response hash attribute'));
    ***REMOVED***

    const calculatedHash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, res.headers['content-type']);
    if (calculatedHash !== serverAuthAttributes.hash) ***REMOVED***
        return finalize(new Error('Bad response payload mac'));
    ***REMOVED***

    return finalize();
***REMOVED***;


// Generate a bewit value for a given URI

/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse()
    options: ***REMOVED***

        // Required

        credentials: ***REMOVED***
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
        ***REMOVED***,
        ttlSec: 60 * 60,                                    // TTL in seconds

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        localtimeOffsetMsec: 400                            // Time offset to sync with server time
    ***REMOVED***;
*/

exports.getBewit = function (uri, options) ***REMOVED***

    // Validate inputs

    if (!uri ||
        (typeof uri !== 'string' && typeof uri !== 'object') ||
        !options ||
        typeof options !== 'object' ||
        !options.ttlSec) ***REMOVED***

        return '';
    ***REMOVED***

    options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value

    // Application time

    const now = Utils.now(options.localtimeOffsetMsec);

    // Validate credentials

    const credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) ***REMOVED***

        return '';
    ***REMOVED***

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) ***REMOVED***
        return '';
    ***REMOVED***

    // Parse URI

    if (typeof uri === 'string') ***REMOVED***
        uri = Url.parse(uri);
    ***REMOVED***

    // Calculate signature

    const exp = Math.floor(now / 1000) + options.ttlSec;
    const mac = Crypto.calculateMac('bewit', credentials, ***REMOVED***
        ts: exp,
        nonce: '',
        method: 'GET',
        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
        ext: options.ext
    ***REMOVED***);

    // Construct bewit: id\exp\mac\ext

    const bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
    return Hoek.base64urlEncode(bewit);
***REMOVED***;


// Generate an authorization string for a message

/*
    host: 'example.com',
    port: 8000,
    message: '***REMOVED***"some":"payload"***REMOVED***',                          // UTF-8 encoded string for body hash generation
    options: ***REMOVED***

        // Required

        credentials: ***REMOVED***
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
        ***REMOVED***,

        // Optional

        timestamp: Date.now() / 1000,                       // A pre-calculated timestamp in seconds
        nonce: '2334f34f',                                  // A pre-generated nonce
        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
    ***REMOVED***
*/

exports.message = function (host, port, message, options) ***REMOVED***

    // Validate inputs

    if (!host || typeof host !== 'string' ||
        !port || typeof port !== 'number' ||
        message === null || message === undefined || typeof message !== 'string' ||
        !options || typeof options !== 'object') ***REMOVED***

        return null;
    ***REMOVED***

    // Application time

    const timestamp = options.timestamp || Utils.nowSecs(options.localtimeOffsetMsec);

    // Validate credentials

    const credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) ***REMOVED***

        // Invalid credential object
        return null;
    ***REMOVED***

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) ***REMOVED***
        return null;
    ***REMOVED***

    // Calculate signature

    const artifacts = ***REMOVED***
        ts: timestamp,
        nonce: options.nonce || Cryptiles.randomString(6),
        host,
        port,
        hash: Crypto.calculatePayloadHash(message, credentials.algorithm)
    ***REMOVED***;

    // Construct authorization

    const result = ***REMOVED***
        id: credentials.id,
        ts: artifacts.ts,
        nonce: artifacts.nonce,
        hash: artifacts.hash,
        mac: Crypto.calculateMac('message', credentials, artifacts)
    ***REMOVED***;

    return result;
***REMOVED***;



