'use strict';

// Load modules

const Sntp = require('sntp');
const Boom = require('boom');


// Declare internals

const internals = ***REMOVED******REMOVED***;


exports.version = function () ***REMOVED***

    return require('../package.json').version;
***REMOVED***;


exports.limits = ***REMOVED***
    maxMatchLength: 4096            // Limit the length of uris and headers to avoid a DoS attack on string matching
***REMOVED***;


// Extract host and port from request

//                                            $1                            $2
internals.hostHeaderRegex = /^(?:(?:\r\n)?\s)*((?:[^:]+)|(?:\[[^\]]+\]))(?::(\d+))?(?:(?:\r\n)?\s)*$/;              // (IPv4, hostname)|(IPv6)


exports.parseHost = function (req, hostHeaderName) ***REMOVED***

    hostHeaderName = (hostHeaderName ? hostHeaderName.toLowerCase() : 'host');
    const hostHeader = req.headers[hostHeaderName];
    if (!hostHeader) ***REMOVED***
        return null;
    ***REMOVED***

    if (hostHeader.length > exports.limits.maxMatchLength) ***REMOVED***
        return null;
    ***REMOVED***

    const hostParts = hostHeader.match(internals.hostHeaderRegex);
    if (!hostParts) ***REMOVED***
        return null;
    ***REMOVED***

    return ***REMOVED***
        name: hostParts[1],
        port: (hostParts[2] ? hostParts[2] : (req.connection && req.connection.encrypted ? 443 : 80))
    ***REMOVED***;
***REMOVED***;


// Parse Content-Type header content

exports.parseContentType = function (header) ***REMOVED***

    if (!header) ***REMOVED***
        return '';
    ***REMOVED***

    return header.split(';')[0].trim().toLowerCase();
***REMOVED***;


// Convert node's  to request configuration object

exports.parseRequest = function (req, options) ***REMOVED***

    if (!req.headers) ***REMOVED***
        return req;
    ***REMOVED***

    // Obtain host and port information

    let host;
    if (!options.host ||
        !options.port) ***REMOVED***

        host = exports.parseHost(req, options.hostHeaderName);
        if (!host) ***REMOVED***
            return new Error('Invalid Host header');
        ***REMOVED***
    ***REMOVED***

    const request = ***REMOVED***
        method: req.method,
        url: req.url,
        host: options.host || host.name,
        port: options.port || host.port,
        authorization: req.headers.authorization,
        contentType: req.headers['content-type'] || ''
    ***REMOVED***;

    return request;
***REMOVED***;


exports.now = function (localtimeOffsetMsec) ***REMOVED***

    return Sntp.now() + (localtimeOffsetMsec || 0);
***REMOVED***;


exports.nowSecs = function (localtimeOffsetMsec) ***REMOVED***

    return Math.floor(exports.now(localtimeOffsetMsec) / 1000);
***REMOVED***;


internals.authHeaderRegex = /^(\w+)(?:\s+(.*))?$/;                                      // Header: scheme[ something]
internals.attributeRegex = /^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\***REMOVED***\|\***REMOVED***~]+$/;   // !#$%&'()*+,-./:;<=>?@[]^_`***REMOVED***|***REMOVED***~ and space, a-z, A-Z, 0-9


// Parse Hawk HTTP Authorization header

exports.parseAuthorizationHeader = function (header, keys) ***REMOVED***

    keys = keys || ['id', 'ts', 'nonce', 'hash', 'ext', 'mac', 'app', 'dlg'];

    if (!header) ***REMOVED***
        return Boom.unauthorized(null, 'Hawk');
    ***REMOVED***

    if (header.length > exports.limits.maxMatchLength) ***REMOVED***
        return Boom.badRequest('Header length too long');
    ***REMOVED***

    const headerParts = header.match(internals.authHeaderRegex);
    if (!headerParts) ***REMOVED***
        return Boom.badRequest('Invalid header syntax');
    ***REMOVED***

    const scheme = headerParts[1];
    if (scheme.toLowerCase() !== 'hawk') ***REMOVED***
        return Boom.unauthorized(null, 'Hawk');
    ***REMOVED***

    const attributesString = headerParts[2];
    if (!attributesString) ***REMOVED***
        return Boom.badRequest('Invalid header syntax');
    ***REMOVED***

    const attributes = ***REMOVED******REMOVED***;
    let errorMessage = '';
    const verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, ($0, $1, $2) => ***REMOVED***

        // Check valid attribute names

        if (keys.indexOf($1) === -1) ***REMOVED***
            errorMessage = 'Unknown attribute: ' + $1;
            return;
        ***REMOVED***

        // Allowed attribute value characters

        if ($2.match(internals.attributeRegex) === null) ***REMOVED***
            errorMessage = 'Bad attribute value: ' + $1;
            return;
        ***REMOVED***

        // Check for duplicates

        if (attributes.hasOwnProperty($1)) ***REMOVED***
            errorMessage = 'Duplicate attribute: ' + $1;
            return;
        ***REMOVED***

        attributes[$1] = $2;
        return '';
    ***REMOVED***);

    if (verify !== '') ***REMOVED***
        return Boom.badRequest(errorMessage || 'Bad header format');
    ***REMOVED***

    return attributes;
***REMOVED***;


exports.unauthorized = function (message, attributes) ***REMOVED***

    return Boom.unauthorized(message || null, 'Hawk', attributes);
***REMOVED***;

