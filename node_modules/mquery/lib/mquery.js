'use strict';

/**
 * Dependencies
 */

var slice = require('sliced')
var assert = require('assert')
var util = require('util')
var utils = require('./utils')
var debug = require('debug')('mquery');

/**
 * Query constructor used for building queries.
 *
 * ####Example:
 *
 *     var query = new Query(***REMOVED*** name: 'mquery' ***REMOVED***);
 *     query.setOptions(***REMOVED*** collection: moduleCollection ***REMOVED***)
 *     query.where('age').gte(21).exec(callback);
 *
 * @param ***REMOVED***Object***REMOVED*** [criteria]
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @api public
 */

function Query (criteria, options) ***REMOVED***
  if (!(this instanceof Query))
    return new Query(criteria, options);

  var proto = this.constructor.prototype;

  this.op = proto.op || undefined;

  this.options = ***REMOVED******REMOVED***;
  this.setOptions(proto.options);

  this._conditions = proto._conditions
    ? utils.clone(proto._conditions)
    : ***REMOVED******REMOVED***;

  this._fields = proto._fields
    ? utils.clone(proto._fields)
    : undefined;

  this._update = proto._update
    ? utils.clone(proto._update)
    : undefined;

  this._path = proto._path || undefined;
  this._distinct = proto._distinct || undefined;
  this._collection = proto._collection || undefined;
  this._traceFunction = proto._traceFunction || undefined;

  if (options) ***REMOVED***
    this.setOptions(options);
  ***REMOVED***

  if (criteria) ***REMOVED***
    if (criteria.find && criteria.remove && criteria.update) ***REMOVED***
      // quack quack!
      this.collection(criteria);
    ***REMOVED*** else ***REMOVED***
      this.find(criteria);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * This is a parameter that the user can set which determines if mquery
 * uses $within or $geoWithin for queries. It defaults to true which
 * means $geoWithin will be used. If using MongoDB < 2.4 you should
 * set this to false.
 *
 * @api public
 * @property use$geoWithin
 */

var $withinCmd = '$geoWithin';
Object.defineProperty(Query, 'use$geoWithin', ***REMOVED***
    get: function ( ) ***REMOVED*** return $withinCmd == '$geoWithin' ***REMOVED***
  , set: function (v) ***REMOVED***
      if (true === v) ***REMOVED***
        // mongodb >= 2.4
        $withinCmd = '$geoWithin';
      ***REMOVED*** else ***REMOVED***
        $withinCmd = '$within';
      ***REMOVED***
    ***REMOVED***
***REMOVED***);

/**
 * Converts this query to a constructor function with all arguments and options retained.
 *
 * ####Example
 *
 *     // Create a query that will read documents with a "video" category from
 *     // `aCollection` on the primary node in the replica-set unless it is down,
 *     // in which case we'll read from a secondary node.
 *     var query = mquery(***REMOVED*** category: 'video' ***REMOVED***)
 *     query.setOptions(***REMOVED*** collection: aCollection, read: 'primaryPreferred' ***REMOVED***);
 *
 *     // create a constructor based off these settings
 *     var Video = query.toConstructor();
 *
 *     // Video is now a subclass of mquery() and works the same way but with the
 *     // default query parameters and options set.
 *
 *     // run a query with the previous settings but filter for movies with names
 *     // that start with "Life".
 *     Video().where(***REMOVED*** name: /^Life/ ***REMOVED***).exec(cb);
 *
 * @return ***REMOVED***Query***REMOVED*** new Query
 * @api public
 */

Query.prototype.toConstructor = function toConstructor () ***REMOVED***
  function CustomQuery (criteria, options) ***REMOVED***
    if (!(this instanceof CustomQuery))
      return new CustomQuery(criteria, options);
    Query.call(this, criteria, options);
  ***REMOVED***

  utils.inherits(CustomQuery, Query);

  // set inherited defaults
  var p = CustomQuery.prototype;

  p.options = ***REMOVED******REMOVED***;
  p.setOptions(this.options);

  p.op = this.op;
  p._conditions = utils.clone(this._conditions);
  p._fields = utils.clone(this._fields);
  p._update = utils.clone(this._update);
  p._path = this._path;
  p._distinct = this._distinct;
  p._collection = this._collection;
  p._traceFunction = this._traceFunction;

  return CustomQuery;
***REMOVED***

/**
 * Sets query options.
 *
 * ####Options:
 *
 * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *
 * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\)%7D%7D) *
 * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *
 * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *
 * - [maxScan](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan) *
 * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *
 * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *
 * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *
 * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *
 * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *
 * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *
 * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)
 * - collection the collection to query against
 *
 * _* denotes a query helper method is also available_
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api public
 */

Query.prototype.setOptions = function (options) ***REMOVED***
  if (!(options && utils.isObject(options)))
    return this;

  // set arbitrary options
  var methods = utils.keys(options)
    , method

  for (var i = 0; i < methods.length; ++i) ***REMOVED***
    method = methods[i];

    // use methods if exist (safer option manipulation)
    if ('function' == typeof this[method]) ***REMOVED***
      var args = utils.isArray(options[method])
        ? options[method]
        : [options[method]];
      this[method].apply(this, args)
    ***REMOVED*** else ***REMOVED***
      this.options[method] = options[method];
    ***REMOVED***
  ***REMOVED***

  return this;
***REMOVED***

/**
 * Sets this Querys collection.
 *
 * @param ***REMOVED***Collection***REMOVED*** coll
 * @return ***REMOVED***Query***REMOVED*** this
 */

Query.prototype.collection = function collection (coll) ***REMOVED***
  this._collection = new Query.Collection(coll);

  return this;
***REMOVED***

/**
 * Specifies a `$where` condition
 *
 * Use `$where` when you need to select documents using a JavaScript expression.
 *
 * ####Example
 *
 *     query.$where('this.comments.length > 10 || this.name.length > 5')
 *
 *     query.$where(function () ***REMOVED***
 *       return this.comments.length > 10 || this.name.length > 5;
 *     ***REMOVED***)
 *
 * @param ***REMOVED***String|Function***REMOVED*** js javascript string or function
 * @return ***REMOVED***Query***REMOVED*** this
 * @memberOf Query
 * @method $where
 * @api public
 */

Query.prototype.$where = function (js) ***REMOVED***
  this._conditions.$where = js;
  return this;
***REMOVED***

/**
 * Specifies a `path` for use with chaining.
 *
 * ####Example
 *
 *     // instead of writing:
 *     User.find(***REMOVED***age: ***REMOVED***$gte: 21, $lte: 65***REMOVED******REMOVED***, callback);
 *
 *     // we can instead write:
 *     User.where('age').gte(21).lte(65);
 *
 *     // passing query conditions is permitted
 *     User.find().where(***REMOVED*** name: 'vonderful' ***REMOVED***)
 *
 *     // chaining
 *     User
 *     .where('age').gte(21).lte(65)
 *     .where('name', /^vonderful/i)
 *     .where('friends').slice(10)
 *     .exec(callback)
 *
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Object***REMOVED*** [val]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.where = function () ***REMOVED***
  if (!arguments.length) return this;
  if (!this.op) this.op = 'find';

  var type = typeof arguments[0];

  if ('string' == type) ***REMOVED***
    this._path = arguments[0];

    if (2 === arguments.length) ***REMOVED***
      this._conditions[this._path] = arguments[1];
    ***REMOVED***

    return this;
  ***REMOVED***

  if ('object' == type && !Array.isArray(arguments[0])) ***REMOVED***
    return this.merge(arguments[0]);
  ***REMOVED***

  throw new TypeError('path must be a string or object');
***REMOVED***

/**
 * Specifies the complementary comparison value for paths specified with `where()`
 *
 * ####Example
 *
 *     User.where('age').equals(49);
 *
 *     // is the same as
 *
 *     User.where('age', 49);
 *
 * @param ***REMOVED***Object***REMOVED*** val
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.equals = function equals (val) ***REMOVED***
  this._ensurePath('equals');
  var path = this._path;
  this._conditions[path] = val;
  return this;
***REMOVED***

/**
 * Specifies the complementary comparison value for paths specified with `where()`
 * This is alias of `equals`
 *
 * ####Example
 *
 *     User.where('age').eq(49);
 *
 *     // is the same as
 *
 *     User.shere('age').equals(49);
 *
 *     // is the same as
 *
 *     User.where('age', 49);
 *
 * @param ***REMOVED***Object***REMOVED*** val
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.eq = function eq (val) ***REMOVED***
  this._ensurePath('eq');
  var path = this._path;
  this._conditions[path] = val;
  return this;
***REMOVED***

/**
 * Specifies arguments for an `$or` condition.
 *
 * ####Example
 *
 *     query.or([***REMOVED*** color: 'red' ***REMOVED***, ***REMOVED*** status: 'emergency' ***REMOVED***])
 *
 * @param ***REMOVED***Array***REMOVED*** array array of conditions
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.or = function or (array) ***REMOVED***
  var or = this._conditions.$or || (this._conditions.$or = []);
  if (!utils.isArray(array)) array = [array];
  or.push.apply(or, array);
  return this;
***REMOVED***

/**
 * Specifies arguments for a `$nor` condition.
 *
 * ####Example
 *
 *     query.nor([***REMOVED*** color: 'green' ***REMOVED***, ***REMOVED*** status: 'ok' ***REMOVED***])
 *
 * @param ***REMOVED***Array***REMOVED*** array array of conditions
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.nor = function nor (array) ***REMOVED***
  var nor = this._conditions.$nor || (this._conditions.$nor = []);
  if (!utils.isArray(array)) array = [array];
  nor.push.apply(nor, array);
  return this;
***REMOVED***

/**
 * Specifies arguments for a `$and` condition.
 *
 * ####Example
 *
 *     query.and([***REMOVED*** color: 'green' ***REMOVED***, ***REMOVED*** status: 'ok' ***REMOVED***])
 *
 * @see $and http://docs.mongodb.org/manual/reference/operator/and/
 * @param ***REMOVED***Array***REMOVED*** array array of conditions
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.and = function and (array) ***REMOVED***
  var and = this._conditions.$and || (this._conditions.$and = []);
  if (!Array.isArray(array)) array = [array];
  and.push.apply(and, array);
  return this;
***REMOVED***

/**
 * Specifies a $gt query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * ####Example
 *
 *     Thing.find().where('age').gt(21)
 *
 *     // or
 *     Thing.find().gt('age', 21)
 *
 * @method gt
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $gte query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method gte
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $lt query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method lt
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $lte query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method lte
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $ne query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method ne
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies an $in query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method in
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies an $nin query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method nin
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies an $all query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method all
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $size query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method size
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $regex query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method regex
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***String|RegExp***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $maxDistance query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method maxDistance
 * @memberOf Query
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @api public
 */

/*!
 * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
 *
 *     Thing.where('type').nin(array)
 */

'gt gte lt lte ne in nin all regex size maxDistance minDistance'.split(' ').forEach(function ($conditional) ***REMOVED***
  Query.prototype[$conditional] = function () ***REMOVED***
    var path, val;

    if (1 === arguments.length) ***REMOVED***
      this._ensurePath($conditional);
      val = arguments[0];
      path = this._path;
    ***REMOVED*** else ***REMOVED***
      val = arguments[1];
      path = arguments[0];
    ***REMOVED***

    var conds = this._conditions[path] === null || typeof this._conditions[path] === 'object' ?
      this._conditions[path] :
      (this._conditions[path] = ***REMOVED******REMOVED***);
    conds['$' + $conditional] = val;
    return this;
  ***REMOVED***;
***REMOVED***)

/**
 * Specifies a `$mod` condition
 *
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.mod = function () ***REMOVED***
  var val, path;

  if (1 === arguments.length) ***REMOVED***
    this._ensurePath('mod')
    val = arguments[0];
    path = this._path;
  ***REMOVED*** else if (2 === arguments.length && !utils.isArray(arguments[1])) ***REMOVED***
    this._ensurePath('mod')
    val = slice(arguments);
    path = this._path;
  ***REMOVED*** else if (3 === arguments.length) ***REMOVED***
    val = slice(arguments, 1);
    path = arguments[0];
  ***REMOVED*** else ***REMOVED***
    val = arguments[1];
    path = arguments[0];
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = ***REMOVED******REMOVED***);
  conds.$mod = val;
  return this;
***REMOVED***

/**
 * Specifies an `$exists` condition
 *
 * ####Example
 *
 *     // ***REMOVED*** name: ***REMOVED*** $exists: true ***REMOVED******REMOVED***
 *     Thing.where('name').exists()
 *     Thing.where('name').exists(true)
 *     Thing.find().exists('name')
 *
 *     // ***REMOVED*** name: ***REMOVED*** $exists: false ***REMOVED******REMOVED***
 *     Thing.where('name').exists(false);
 *     Thing.find().exists('name', false);
 *
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.exists = function () ***REMOVED***
  var path, val;

  if (0 === arguments.length) ***REMOVED***
    this._ensurePath('exists');
    path = this._path;
    val = true;
  ***REMOVED*** else if (1 === arguments.length) ***REMOVED***
    if ('boolean' === typeof arguments[0]) ***REMOVED***
      this._ensurePath('exists');
      path = this._path;
      val = arguments[0];
    ***REMOVED*** else ***REMOVED***
      path = arguments[0];
      val = true;
    ***REMOVED***
  ***REMOVED*** else if (2 === arguments.length) ***REMOVED***
    path = arguments[0];
    val = arguments[1];
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = ***REMOVED******REMOVED***);
  conds.$exists = val;
  return this;
***REMOVED***

/**
 * Specifies an `$elemMatch` condition
 *
 * ####Example
 *
 *     query.elemMatch('comment', ***REMOVED*** author: 'autobot', votes: ***REMOVED***$gte: 5***REMOVED******REMOVED***)
 *
 *     query.where('comment').elemMatch(***REMOVED*** author: 'autobot', votes: ***REMOVED***$gte: 5***REMOVED******REMOVED***)
 *
 *     query.elemMatch('comment', function (elem) ***REMOVED***
 *       elem.where('author').equals('autobot');
 *       elem.where('votes').gte(5);
 *     ***REMOVED***)
 *
 *     query.where('comment').elemMatch(function (elem) ***REMOVED***
 *       elem.where(***REMOVED*** author: 'autobot' ***REMOVED***);
 *       elem.where('votes').gte(5);
 *     ***REMOVED***)
 *
 * @param ***REMOVED***String|Object|Function***REMOVED*** path
 * @param ***REMOVED***Object|Function***REMOVED*** criteria
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.elemMatch = function () ***REMOVED***
  if (null == arguments[0])
    throw new TypeError("Invalid argument");

  var fn, path, criteria;

  if ('function' === typeof arguments[0]) ***REMOVED***
    this._ensurePath('elemMatch');
    path = this._path;
    fn = arguments[0];
  ***REMOVED*** else if (utils.isObject(arguments[0])) ***REMOVED***
    this._ensurePath('elemMatch');
    path = this._path;
    criteria = arguments[0];
  ***REMOVED*** else if ('function' === typeof arguments[1]) ***REMOVED***
    path = arguments[0];
    fn = arguments[1];
  ***REMOVED*** else if (arguments[1] && utils.isObject(arguments[1])) ***REMOVED***
    path = arguments[0];
    criteria = arguments[1];
  ***REMOVED*** else ***REMOVED***
    throw new TypeError("Invalid argument");
  ***REMOVED***

  if (fn) ***REMOVED***
    criteria = new Query;
    fn(criteria);
    criteria = criteria._conditions;
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = ***REMOVED******REMOVED***);
  conds.$elemMatch = criteria;
  return this;
***REMOVED***

// Spatial queries

/**
 * Sugar for geo-spatial queries.
 *
 * ####Example
 *
 *     query.within().box()
 *     query.within().circle()
 *     query.within().geometry()
 *
 *     query.where('loc').within(***REMOVED*** center: [50,50], radius: 10, unique: true, spherical: true ***REMOVED***);
 *     query.where('loc').within(***REMOVED*** box: [[40.73, -73.9], [40.7, -73.988]] ***REMOVED***);
 *     query.where('loc').within(***REMOVED*** polygon: [[],[],[],[]] ***REMOVED***);
 *
 *     query.where('loc').within([], [], []) // polygon
 *     query.where('loc').within([], []) // box
 *     query.where('loc').within(***REMOVED*** type: 'LineString', coordinates: [...] ***REMOVED***); // geometry
 *
 * ####NOTE:
 *
 * Must be used after `where()`.
 *
 * @memberOf Query
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.within = function within () ***REMOVED***
  // opinionated, must be used after where
  this._ensurePath('within');
  this._geoComparison = $withinCmd;

  if (0 === arguments.length) ***REMOVED***
    return this;
  ***REMOVED***

  if (2 === arguments.length) ***REMOVED***
    return this.box.apply(this, arguments);
  ***REMOVED*** else if (2 < arguments.length) ***REMOVED***
    return this.polygon.apply(this, arguments);
  ***REMOVED***

  var area = arguments[0];

  if (!area)
    throw new TypeError('Invalid argument');

  if (area.center)
    return this.circle(area);

  if (area.box)
    return this.box.apply(this, area.box);

  if (area.polygon)
    return this.polygon.apply(this, area.polygon);

  if (area.type && area.coordinates)
    return this.geometry(area);

  throw new TypeError('Invalid argument');
***REMOVED***

/**
 * Specifies a $box condition
 *
 * ####Example
 *
 *     var lowerLeft = [40.73083, -73.99756]
 *     var upperRight= [40.741404,  -73.988135]
 *
 *     query.where('loc').within().box(lowerLeft, upperRight)
 *     query.box('loc', lowerLeft, upperRight )
 *
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @see Query#within #query_Query-within
 * @param ***REMOVED***String***REMOVED*** path
 * @param ***REMOVED***Object***REMOVED*** val
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.box = function () ***REMOVED***
  var path, box;

  if (3 === arguments.length) ***REMOVED***
    // box('loc', [], [])
    path = arguments[0];
    box = [arguments[1], arguments[2]];
  ***REMOVED*** else if (2 === arguments.length) ***REMOVED***
    // box([], [])
    this._ensurePath('box');
    path = this._path;
    box = [arguments[0], arguments[1]];
  ***REMOVED*** else ***REMOVED***
    throw new TypeError("Invalid argument");
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = ***REMOVED******REMOVED***);
  conds[this._geoComparison || $withinCmd] = ***REMOVED*** '$box': box  ***REMOVED***;
  return this;
***REMOVED***

/**
 * Specifies a $polygon condition
 *
 * ####Example
 *
 *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])
 *     query.polygon('loc', [10,20], [13, 25], [7,15])
 *
 * @param ***REMOVED***String|Array***REMOVED*** [path]
 * @param ***REMOVED***Array|Object***REMOVED*** [val]
 * @return ***REMOVED***Query***REMOVED*** this
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */

Query.prototype.polygon = function () ***REMOVED***
  var val, path;

  if ('string' == typeof arguments[0]) ***REMOVED***
    // polygon('loc', [],[],[])
    path = arguments[0];
    val = slice(arguments, 1);
  ***REMOVED*** else ***REMOVED***
    // polygon([],[],[])
    this._ensurePath('polygon');
    path = this._path;
    val = slice(arguments);
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = ***REMOVED******REMOVED***);
  conds[this._geoComparison || $withinCmd] = ***REMOVED*** '$polygon': val ***REMOVED***;
  return this;
***REMOVED***

/**
 * Specifies a $center or $centerSphere condition.
 *
 * ####Example
 *
 *     var area = ***REMOVED*** center: [50, 50], radius: 10, unique: true ***REMOVED***
 *     query.where('loc').within().circle(area)
 *     query.center('loc', area);
 *
 *     // for spherical calculations
 *     var area = ***REMOVED*** center: [50, 50], radius: 10, unique: true, spherical: true ***REMOVED***
 *     query.where('loc').within().circle(area)
 *     query.center('loc', area);
 *
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Object***REMOVED*** area
 * @return ***REMOVED***Query***REMOVED*** this
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */

Query.prototype.circle = function () ***REMOVED***
  var path, val;

  if (1 === arguments.length) ***REMOVED***
    this._ensurePath('circle');
    path = this._path;
    val = arguments[0];
  ***REMOVED*** else if (2 === arguments.length) ***REMOVED***
    path = arguments[0];
    val = arguments[1];
  ***REMOVED*** else ***REMOVED***
    throw new TypeError("Invalid argument");
  ***REMOVED***

  if (!('radius' in val && val.center))
    throw new Error('center and radius are required');

  var conds = this._conditions[path] || (this._conditions[path] = ***REMOVED******REMOVED***);

  var type = val.spherical
    ? '$centerSphere'
    : '$center';

  var wKey = this._geoComparison || $withinCmd;
  conds[wKey] = ***REMOVED******REMOVED***;
  conds[wKey][type] = [val.center, val.radius];

  if ('unique' in val)
    conds[wKey].$uniqueDocs = !! val.unique;

  return this;
***REMOVED***

/**
 * Specifies a `$near` or `$nearSphere` condition
 *
 * These operators return documents sorted by distance.
 *
 * ####Example
 *
 *     query.where('loc').near(***REMOVED*** center: [10, 10] ***REMOVED***);
 *     query.where('loc').near(***REMOVED*** center: [10, 10], maxDistance: 5 ***REMOVED***);
 *     query.where('loc').near(***REMOVED*** center: [10, 10], maxDistance: 5, spherical: true ***REMOVED***);
 *     query.near('loc', ***REMOVED*** center: [10, 10], maxDistance: 5 ***REMOVED***);
 *     query.near(***REMOVED*** center: ***REMOVED*** type: 'Point', coordinates: [..] ***REMOVED******REMOVED***)
 *     query.near().geometry(***REMOVED*** type: 'Point', coordinates: [..] ***REMOVED***)
 *
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Object***REMOVED*** val
 * @return ***REMOVED***Query***REMOVED*** this
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */

Query.prototype.near = function near () ***REMOVED***
  var path, val;

  this._geoComparison = '$near';

  if (0 === arguments.length) ***REMOVED***
    return this;
  ***REMOVED*** else if (1 === arguments.length) ***REMOVED***
    this._ensurePath('near');
    path = this._path;
    val = arguments[0];
  ***REMOVED*** else if (2 === arguments.length) ***REMOVED***
    path = arguments[0];
    val = arguments[1];
  ***REMOVED*** else ***REMOVED***
    throw new TypeError("Invalid argument");
  ***REMOVED***

  if (!val.center) ***REMOVED***
    throw new Error('center is required');
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = ***REMOVED******REMOVED***);

  var type = val.spherical
    ? '$nearSphere'
    : '$near';

  // center could be a GeoJSON object or an Array
  if (Array.isArray(val.center)) ***REMOVED***
    conds[type] = val.center;

    var radius = 'maxDistance' in val
      ? val.maxDistance
      : null;

    if (null != radius) ***REMOVED***
      conds.$maxDistance = radius;
    ***REMOVED***
    if (null != val.minDistance) ***REMOVED***
      conds.$minDistance = val.minDistance;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    // GeoJSON?
    if (val.center.type != 'Point' || !Array.isArray(val.center.coordinates)) ***REMOVED***
      throw new Error(util.format("Invalid GeoJSON specified for %s", type));
    ***REMOVED***
    conds[type] = ***REMOVED*** $geometry : val.center ***REMOVED***;

    // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere
    if ('maxDistance' in val) ***REMOVED***
      conds[type]['$maxDistance'] = val.maxDistance;
    ***REMOVED***
    if ('minDistance' in val) ***REMOVED***
      conds[type]['$minDistance'] = val.minDistance;
    ***REMOVED***
  ***REMOVED***

  return this;
***REMOVED***

/**
 * Declares an intersects query for `geometry()`.
 *
 * ####Example
 *
 *     query.where('path').intersects().geometry(***REMOVED***
 *         type: 'LineString'
 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
 *     ***REMOVED***)
 *
 *     query.where('path').intersects(***REMOVED***
 *         type: 'LineString'
 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
 *     ***REMOVED***)
 *
 * @param ***REMOVED***Object***REMOVED*** [arg]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.intersects = function intersects () ***REMOVED***
  // opinionated, must be used after where
  this._ensurePath('intersects');

  this._geoComparison = '$geoIntersects';

  if (0 === arguments.length) ***REMOVED***
    return this;
  ***REMOVED***

  var area = arguments[0];

  if (null != area && area.type && area.coordinates)
    return this.geometry(area);

  throw new TypeError('Invalid argument');
***REMOVED***

/**
 * Specifies a `$geometry` condition
 *
 * ####Example
 *
 *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
 *     query.where('loc').within().geometry(***REMOVED*** type: 'Polygon', coordinates: polyA ***REMOVED***)
 *
 *     // or
 *     var polyB = [[ 0, 0 ], [ 1, 1 ]]
 *     query.where('loc').within().geometry(***REMOVED*** type: 'LineString', coordinates: polyB ***REMOVED***)
 *
 *     // or
 *     var polyC = [ 0, 0 ]
 *     query.where('loc').within().geometry(***REMOVED*** type: 'Point', coordinates: polyC ***REMOVED***)
 *
 *     // or
 *     query.where('loc').intersects().geometry(***REMOVED*** type: 'Point', coordinates: polyC ***REMOVED***)
 *
 * ####NOTE:
 *
 * `geometry()` **must** come after either `intersects()` or `within()`.
 *
 * The `object` argument must contain `type` and `coordinates` properties.
 * - type ***REMOVED***String***REMOVED***
 * - coordinates ***REMOVED***Array***REMOVED***
 *
 * The most recent path passed to `where()` is used.
 *
 * @param ***REMOVED***Object***REMOVED*** object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.
 * @return ***REMOVED***Query***REMOVED*** this
 * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
 * @api public
 */

Query.prototype.geometry = function geometry () ***REMOVED***
  if (!('$within' == this._geoComparison ||
        '$geoWithin' == this._geoComparison ||
        '$near' == this._geoComparison ||
        '$geoIntersects' == this._geoComparison)) ***REMOVED***
    throw new Error('geometry() must come after `within()`, `intersects()`, or `near()');
  ***REMOVED***

  var val, path;

  if (1 === arguments.length) ***REMOVED***
    this._ensurePath('geometry');
    path = this._path;
    val = arguments[0];
  ***REMOVED*** else ***REMOVED***
    throw new TypeError("Invalid argument");
  ***REMOVED***

  if (!(val.type && Array.isArray(val.coordinates))) ***REMOVED***
    throw new TypeError('Invalid argument');
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = ***REMOVED******REMOVED***);
  conds[this._geoComparison] = ***REMOVED*** $geometry: val ***REMOVED***;

  return this;
***REMOVED***

// end spatial

/**
 * Specifies which document fields to include or exclude
 *
 * ####String syntax
 *
 * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.
 *
 * ####Example
 *
 *     // include a and b, exclude c
 *     query.select('a b -c');
 *
 *     // or you may use object notation, useful when
 *     // you have keys already prefixed with a "-"
 *     query.select(***REMOVED***a: 1, b: 1, c: 0***REMOVED***);
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @param ***REMOVED***Object|String***REMOVED*** arg
 * @return ***REMOVED***Query***REMOVED*** this
 * @see SchemaType
 * @api public
 */

Query.prototype.select = function select () ***REMOVED***
  var arg = arguments[0];
  if (!arg) return this;

  if (arguments.length !== 1) ***REMOVED***
    throw new Error("Invalid select: select only takes 1 argument");
  ***REMOVED***

  this._validate('select');

  var fields = this._fields || (this._fields = ***REMOVED******REMOVED***);
  var type = typeof arg;

  if (('string' == type || utils.isArgumentsObject(arg)) &&
    'number' == typeof arg.length || Array.isArray(arg)) ***REMOVED***
    if ('string' == type)
      arg = arg.split(/\s+/);

    for (var i = 0, len = arg.length; i < len; ++i) ***REMOVED***
      var field = arg[i];
      if (!field) continue;
      var include = '-' == field[0] ? 0 : 1;
      if (include === 0) field = field.substring(1);
      fields[field] = include;
    ***REMOVED***

    return this;
  ***REMOVED***

  if (utils.isObject(arg)) ***REMOVED***
    var keys = utils.keys(arg);
    for (var i = 0; i < keys.length; ++i) ***REMOVED***
      fields[keys[i]] = arg[keys[i]];
    ***REMOVED***
    return this;
  ***REMOVED***

  throw new TypeError('Invalid select() argument. Must be string or object.');
***REMOVED***

/**
 * Specifies a $slice condition for a `path`
 *
 * ####Example
 *
 *     query.slice('comments', 5)
 *     query.slice('comments', -5)
 *     query.slice('comments', [10, 5])
 *     query.where('comments').slice(5)
 *     query.where('comments').slice([-10, 5])
 *
 * @param ***REMOVED***String***REMOVED*** [path]
 * @param ***REMOVED***Number***REMOVED*** val number/range of elements to slice
 * @return ***REMOVED***Query***REMOVED*** this
 * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements
 * @api public
 */

Query.prototype.slice = function () ***REMOVED***
  if (0 === arguments.length)
    return this;

  this._validate('slice');

  var path, val;

  if (1 === arguments.length) ***REMOVED***
    var arg = arguments[0];
    if (typeof arg === 'object' && !Array.isArray(arg)) ***REMOVED***
      var keys = Object.keys(arg);
      var numKeys = keys.length;
      for (var i = 0; i < numKeys; ++i) ***REMOVED***
        this.slice(keys[i], arg[keys[i]]);
      ***REMOVED***
      return this;
    ***REMOVED***
    this._ensurePath('slice');
    path = this._path;
    val = arguments[0];
  ***REMOVED*** else if (2 === arguments.length) ***REMOVED***
    if ('number' === typeof arguments[0]) ***REMOVED***
      this._ensurePath('slice');
      path = this._path;
      val = slice(arguments);
    ***REMOVED*** else ***REMOVED***
      path = arguments[0];
      val = arguments[1];
    ***REMOVED***
  ***REMOVED*** else if (3 === arguments.length) ***REMOVED***
    path = arguments[0];
    val = slice(arguments, 1);
  ***REMOVED***

  var myFields = this._fields || (this._fields = ***REMOVED******REMOVED***);
  myFields[path] = ***REMOVED*** '$slice': val ***REMOVED***;
  return this;
***REMOVED***

/**
 * Sets the sort order
 *
 * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.
 *
 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
 *
 * ####Example
 *
 *     // these are equivalent
 *     query.sort(***REMOVED*** field: 'asc', test: -1 ***REMOVED***);
 *     query.sort('field -test');
 *     query.sort([['field', 1], ['test', -1]]);
 *
 * ####Note
 *
 *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).
 *  - Cannot be used with `distinct()`
 *
 * @param ***REMOVED***Object|String|Array***REMOVED*** arg
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.sort = function (arg) ***REMOVED***
  if (!arg) return this;
  var len;

  this._validate('sort');

  var type = typeof arg;

  // .sort([['field', 1], ['test', -1]])
  if (Array.isArray(arg)) ***REMOVED***
    len = arg.length;
    for (var i = 0; i < arg.length; ++i) ***REMOVED***
      if (!Array.isArray(arg[i])) ***REMOVED***
        throw new Error('Invalid sort() argument, must be array of arrays');
      ***REMOVED***
      _pushArr(this.options, arg[i][0], arg[i][1]);
    ***REMOVED***
    return this;
  ***REMOVED***

  // .sort('field -test')
  if (1 === arguments.length && 'string' == type) ***REMOVED***
    arg = arg.split(/\s+/);
    len = arg.length;
    for (var i = 0; i < len; ++i) ***REMOVED***
      var field = arg[i];
      if (!field) continue;
      var ascend = '-' == field[0] ? -1 : 1;
      if (ascend === -1) field = field.substring(1);
      push(this.options, field, ascend);
    ***REMOVED***

    return this;
  ***REMOVED***

  // .sort(***REMOVED*** field: 1, test: -1 ***REMOVED***)
  if (utils.isObject(arg)) ***REMOVED***
    var keys = utils.keys(arg);
    for (var i = 0; i < keys.length; ++i) ***REMOVED***
      var field = keys[i];
      push(this.options, field, arg[field]);
    ***REMOVED***

    return this;
  ***REMOVED***

  if (typeof Map !== 'undefined' && arg instanceof Map) ***REMOVED***
    _pushMap(this.options, arg);
    return this;
  ***REMOVED***

  throw new TypeError('Invalid sort() argument. Must be a string, object, or array.');
***REMOVED***

/*!
 * @ignore
 */

function push (opts, field, value) ***REMOVED***
  if (Array.isArray(opts.sort)) ***REMOVED***
    throw new TypeError("Can't mix sort syntaxes. Use either array or object:" +
      "\n- `.sort([['field', 1], ['test', -1]])`" +
      "\n- `.sort(***REMOVED*** field: 1, test: -1 ***REMOVED***)`");
  ***REMOVED***

  if (value && value.$meta) ***REMOVED***
    var s = opts.sort || (opts.sort = ***REMOVED******REMOVED***);
    s[field] = ***REMOVED*** $meta : value.$meta ***REMOVED***;
    return;
  ***REMOVED***

  var val = String(value || 1).toLowerCase();
  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) ***REMOVED***
    if (utils.isArray(value)) value = '['+value+']';
    throw new TypeError('Invalid sort value: ***REMOVED***' + field + ': ' + value + ' ***REMOVED***');
  ***REMOVED***
  // store `sort` in a sane format
  var s = opts.sort || (opts.sort = ***REMOVED******REMOVED***);
  var valueStr = value.toString()
                  .replace("asc", "1")
                  .replace("ascending", "1")
                  .replace("desc", "-1")
                  .replace("descending", "-1");
  s[field] = parseInt(valueStr, 10);
***REMOVED***

function _pushArr (opts, field, value) ***REMOVED***
  opts.sort = opts.sort || [];
  if (!Array.isArray(opts.sort)) ***REMOVED***
    throw new TypeError("Can't mix sort syntaxes. Use either array or object:" +
      "\n- `.sort([['field', 1], ['test', -1]])`" +
      "\n- `.sort(***REMOVED*** field: 1, test: -1 ***REMOVED***)`");
  ***REMOVED***
  var valueStr = value.toString()
    .replace("asc", "1")
    .replace("ascending", "1")
    .replace("desc", "-1")
    .replace("descending", "-1");
  opts.sort.push([field, value]);
***REMOVED***

function _pushMap (opts, map) ***REMOVED***
  opts.sort = opts.sort || new Map();
  if (!(opts.sort instanceof Map)) ***REMOVED***
    throw new TypeError("Can't mix sort syntaxes. Use either array or " +
      "object or map consistently");
  ***REMOVED***
  map.forEach(function(value, key) ***REMOVED***
    var valueStr = value.toString()
      .replace("asc", "1")
      .replace("ascending", "1")
      .replace("desc", "-1")
      .replace("descending", "-1");
    opts.sort.set(key, valueStr);
  ***REMOVED***);
***REMOVED***

/**
 * Specifies the limit option.
 *
 * ####Example
 *
 *     query.limit(20)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method limit
 * @memberOf Query
 * @param ***REMOVED***Number***REMOVED*** val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D
 * @api public
 */
/**
 * Specifies the skip option.
 *
 * ####Example
 *
 *     query.skip(100).limit(20)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method skip
 * @memberOf Query
 * @param ***REMOVED***Number***REMOVED*** val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D
 * @api public
 */
/**
 * Specifies the maxScan option.
 *
 * ####Example
 *
 *     query.maxScan(100)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method maxScan
 * @memberOf Query
 * @param ***REMOVED***Number***REMOVED*** val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan
 * @api public
 */
/**
 * Specifies the batchSize option.
 *
 * ####Example
 *
 *     query.batchSize(100)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method batchSize
 * @memberOf Query
 * @param ***REMOVED***Number***REMOVED*** val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D
 * @api public
 */
/**
 * Specifies the `comment` option.
 *
 * ####Example
 *
 *     query.comment('login query')
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method comment
 * @memberOf Query
 * @param ***REMOVED***Number***REMOVED*** val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment
 * @api public
 */

/*!
 * limit, skip, maxScan, batchSize, comment
 *
 * Sets these associated options.
 *
 *     query.comment('feed query');
 */

;['limit', 'skip', 'maxScan', 'batchSize', 'comment'].forEach(function (method) ***REMOVED***
  Query.prototype[method] = function (v) ***REMOVED***
    this._validate(method);
    this.options[method] = v;
    return this;
  ***REMOVED***;
***REMOVED***)

/**
 * Specifies the maxTimeMS option.
 *
 * ####Example
 *
 *     query.maxTime(100)
 *
 * @method maxTime
 * @memberOf Query
 * @param ***REMOVED***Number***REMOVED*** val
 * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS
 * @api public
 */

Query.prototype.maxTime = function (v) ***REMOVED***
  this._validate('maxTime');
  this.options.maxTimeMS = v;
  return this;
***REMOVED***;

/**
 * Specifies this query as a `snapshot` query.
 *
 * ####Example
 *
 *     mquery().snapshot() // true
 *     mquery().snapshot(true)
 *     mquery().snapshot(false)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.snapshot = function () ***REMOVED***
  this._validate('snapshot');

  this.options.snapshot = arguments.length
    ? !! arguments[0]
    : true

  return this;
***REMOVED***

/**
 * Sets query hints.
 *
 * ####Example
 *
 *     query.hint(***REMOVED*** indexA: 1, indexB: -1***REMOVED***);
 *     query.hint('indexA_1_indexB_1');
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @param ***REMOVED***Object|string***REMOVED*** val a hint object or the index name
 * @return ***REMOVED***Query***REMOVED*** this
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint
 * @api public
 */

Query.prototype.hint = function () ***REMOVED***
  if (0 === arguments.length) return this;

  this._validate('hint');

  var arg = arguments[0];
  if (utils.isObject(arg)) ***REMOVED***
    var hint = this.options.hint || (this.options.hint = ***REMOVED******REMOVED***);

    // must keep object keys in order so don't use Object.keys()
    for (var k in arg) ***REMOVED***
      hint[k] = arg[k];
    ***REMOVED***

    return this;
  ***REMOVED***
  if (typeof arg === 'string') ***REMOVED***
    this.options.hint = arg;
    return this;
  ***REMOVED***

  throw new TypeError('Invalid hint. ' + arg);
***REMOVED***

/**
 * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.
 *
 * ####Example:
 *
 *     query.slaveOk() // true
 *     query.slaveOk(true)
 *     query.slaveOk(false)
 *
 * @deprecated use read() preferences instead if on mongodb >= 2.2
 * @param ***REMOVED***Boolean***REMOVED*** v defaults to true
 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
 * @see read()
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.slaveOk = function (v) ***REMOVED***
  this.options.slaveOk = arguments.length ? !!v : true;
  return this;
***REMOVED***

/**
 * Sets the readPreference option for the query.
 *
 * ####Example:
 *
 *     new Query().read('primary')
 *     new Query().read('p')  // same as primary
 *
 *     new Query().read('primaryPreferred')
 *     new Query().read('pp') // same as primaryPreferred
 *
 *     new Query().read('secondary')
 *     new Query().read('s')  // same as secondary
 *
 *     new Query().read('secondaryPreferred')
 *     new Query().read('sp') // same as secondaryPreferred
 *
 *     new Query().read('nearest')
 *     new Query().read('n')  // same as nearest
 *
 *     // you can also use mongodb.ReadPreference class to also specify tags
 *     new Query().read(mongodb.ReadPreference('secondary', [***REMOVED*** dc:'sf', s: 1 ***REMOVED***,***REMOVED*** dc:'ma', s: 2 ***REMOVED***]))
 *
 * ####Preferences:
 *
 *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
 *     secondary            Read from secondary if available, otherwise error.
 *     primaryPreferred     Read from primary if available, otherwise a secondary.
 *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
 *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
 *
 * Aliases
 *
 *     p   primary
 *     pp  primaryPreferred
 *     s   secondary
 *     sp  secondaryPreferred
 *     n   nearest
 *
 * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).
 *
 * @param ***REMOVED***String|ReadPreference***REMOVED*** pref one of the listed preference options or their aliases
 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.read = function (pref) ***REMOVED***
  if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) ***REMOVED***
    console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
    Query.prototype.read.deprecationWarningIssued = true;
  ***REMOVED***
  this.options.readPreference = utils.readPref(pref);
  return this;
***REMOVED***

/**
 * Sets tailable option.
 *
 * ####Example
 *
 *     query.tailable() <== true
 *     query.tailable(true)
 *     query.tailable(false)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @param ***REMOVED***Boolean***REMOVED*** v defaults to true
 * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors
 * @api public
 */

Query.prototype.tailable = function () ***REMOVED***
  this._validate('tailable');

  this.options.tailable = arguments.length
    ? !! arguments[0]
    : true;

  return this;
***REMOVED***

/**
 * Merges another Query or conditions object into this one.
 *
 * When a Query is passed, conditions, field selection and options are merged.
 *
 * @param ***REMOVED***Query|Object***REMOVED*** source
 * @return ***REMOVED***Query***REMOVED*** this
 */

Query.prototype.merge = function (source) ***REMOVED***
  if (!source)
    return this;

  if (!Query.canMerge(source))
    throw new TypeError('Invalid argument. Expected instanceof mquery or plain object');

  if (source instanceof Query) ***REMOVED***
    // if source has a feature, apply it to ourselves

    if (source._conditions) ***REMOVED***
      utils.merge(this._conditions, source._conditions);
    ***REMOVED***

    if (source._fields) ***REMOVED***
      this._fields || (this._fields = ***REMOVED******REMOVED***);
      utils.merge(this._fields, source._fields);
    ***REMOVED***

    if (source.options) ***REMOVED***
      this.options || (this.options = ***REMOVED******REMOVED***);
      utils.merge(this.options, source.options);
    ***REMOVED***

    if (source._update) ***REMOVED***
      this._update || (this._update = ***REMOVED******REMOVED***);
      utils.mergeClone(this._update, source._update);
    ***REMOVED***

    if (source._distinct) ***REMOVED***
      this._distinct = source._distinct;
    ***REMOVED***

    return this;
  ***REMOVED***

  // plain object
  utils.merge(this._conditions, source);

  return this;
***REMOVED***

/**
 * Finds documents.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     query.find()
 *     query.find(callback)
 *     query.find(***REMOVED*** name: 'Burning Lights' ***REMOVED***, callback)
 *
 * @param ***REMOVED***Object***REMOVED*** [criteria] mongodb selector
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.find = function (criteria, callback) ***REMOVED***
  this.op = 'find';

  if ('function' === typeof criteria) ***REMOVED***
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) ***REMOVED***
    this.merge(criteria);
  ***REMOVED***

  if (!callback) return this;

  var self = this
    , conds = this._conditions
    , options = this._optionsForExec()

  options.fields = this._fieldsForExec()

  debug('find', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('find', callback, ***REMOVED***
    conditions: conds
  , options: options
  ***REMOVED***);

  this._collection.find(conds, options, utils.tick(callback));
  return this;
***REMOVED***

/**
 * Returns the query cursor
 *
 * ####Examples
 *
 *     query.find().cursor();
 *     query.cursor(***REMOVED*** name: 'Burning Lights' ***REMOVED***);
 *
 * @param ***REMOVED***Object***REMOVED*** [criteria] mongodb selector
 * @return ***REMOVED***Object***REMOVED*** cursor
 * @api public
 */

Query.prototype.cursor = function cursor (criteria) ***REMOVED***
  if (this.op) ***REMOVED***
    if (this.op !== 'find') ***REMOVED***
      throw new TypeError(".cursor only support .find method");
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    this.find(criteria);
  ***REMOVED***

  var conds = this._conditions
    , options = this._optionsForExec()

  options.fields = this._fieldsForExec()

  debug('findCursor', this._collection.collectionName, conds, options);
  return this._collection.findCursor(conds, options);
***REMOVED***

/**
 * Executes the query as a findOne() operation.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     query.findOne().where('name', /^Burning/);
 *
 *     query.findOne(***REMOVED*** name: /^Burning/ ***REMOVED***)
 *
 *     query.findOne(***REMOVED*** name: /^Burning/ ***REMOVED***, callback); // executes
 *
 *     query.findOne(function (err, doc) ***REMOVED***
 *       if (err) return handleError(err);
 *       if (doc) ***REMOVED***
 *         // doc may be null if no document matched
 *
 *       ***REMOVED***
 *     ***REMOVED***);
 *
 * @param ***REMOVED***Object|Query***REMOVED*** [criteria] mongodb selector
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.findOne = function (criteria, callback) ***REMOVED***
  this.op = 'findOne';

  if ('function' === typeof criteria) ***REMOVED***
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) ***REMOVED***
    this.merge(criteria);
  ***REMOVED***

  if (!callback) return this;

  var self = this
    , conds = this._conditions
    , options = this._optionsForExec()

  options.fields = this._fieldsForExec();

  debug('findOne', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('findOne', callback, ***REMOVED***
    conditions: conds
  , options: options
  ***REMOVED***);

  this._collection.findOne(conds, options, utils.tick(callback));

  return this;
***REMOVED***

/**
 * Exectues the query as a count() operation.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     query.count().where('color', 'black').exec(callback);
 *
 *     query.count(***REMOVED*** color: 'black' ***REMOVED***).count(callback)
 *
 *     query.count(***REMOVED*** color: 'black' ***REMOVED***, callback)
 *
 *     query.where('color', 'black').count(function (err, count) ***REMOVED***
 *       if (err) return handleError(err);
 *       console.log('there are %d kittens', count);
 *     ***REMOVED***)
 *
 * @param ***REMOVED***Object***REMOVED*** [criteria] mongodb selector
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count
 * @api public
 */

Query.prototype.count = function (criteria, callback) ***REMOVED***
  this.op = 'count';
  this._validate();

  if ('function' === typeof criteria) ***REMOVED***
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) ***REMOVED***
    this.merge(criteria);
  ***REMOVED***

  if (!callback) return this;

  var conds = this._conditions
    , options = this._optionsForExec()

  debug('count', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('count', callback, ***REMOVED***
    conditions: conds
  , options: options
  ***REMOVED***);

  this._collection.count(conds, options, utils.tick(callback));
  return this;
***REMOVED***

/**
 * Declares or executes a distinct() operation.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     distinct(criteria, field, fn)
 *     distinct(criteria, field)
 *     distinct(field, fn)
 *     distinct(field)
 *     distinct(fn)
 *     distinct()
 *
 * @param ***REMOVED***Object|Query***REMOVED*** [criteria]
 * @param ***REMOVED***String***REMOVED*** [field]
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct
 * @api public
 */

Query.prototype.distinct = function (criteria, field, callback) ***REMOVED***
  this.op = 'distinct';
  this._validate();

  if (!callback) ***REMOVED***
    switch (typeof field) ***REMOVED***
      case 'function':
        callback = field;
        if ('string' == typeof criteria) ***REMOVED***
          field = criteria;
          criteria = undefined;
        ***REMOVED***
        break;
      case 'undefined':
      case 'string':
        break;
      default:
        throw new TypeError('Invalid `field` argument. Must be string or function')
        break;
    ***REMOVED***

    switch (typeof criteria) ***REMOVED***
      case 'function':
        callback = criteria;
        criteria = field = undefined;
        break;
      case 'string':
        field = criteria;
        criteria = undefined;
        break;
    ***REMOVED***
  ***REMOVED***

  if ('string' == typeof field) ***REMOVED***
    this._distinct = field;
  ***REMOVED***

  if (Query.canMerge(criteria)) ***REMOVED***
    this.merge(criteria);
  ***REMOVED***

  if (!callback) ***REMOVED***
    return this;
  ***REMOVED***

  if (!this._distinct) ***REMOVED***
    throw new Error('No value for `distinct` has been declared');
  ***REMOVED***

  var conds = this._conditions
    , options = this._optionsForExec()

  debug('distinct', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('distinct', callback, ***REMOVED***
    conditions: conds
  , options: options
  ***REMOVED***);

  this._collection.distinct(this._distinct, conds, options, utils.tick(callback));

  return this;
***REMOVED***

/**
 * Declare and/or execute this query as an update() operation. By default,
 * `update()` only modifies the _first_ document that matches `criteria`.
 *
 * _All paths passed that are not $atomic operations will become $set ops._
 *
 * ####Example
 *
 *     mquery(***REMOVED*** _id: id ***REMOVED***).update(***REMOVED*** title: 'words' ***REMOVED***, ...)
 *
 * becomes
 *
 *     collection.update(***REMOVED*** _id: id ***REMOVED***, ***REMOVED*** $set: ***REMOVED*** title: 'words' ***REMOVED******REMOVED***, ...)
 *
 * ####Note
 *
 * Passing an empty object `***REMOVED******REMOVED***` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.
 *
 * ####Note
 *
 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call update() and then execute it by using the `exec()` method.
 *
 *     var q = mquery(collection).where(***REMOVED*** _id: id ***REMOVED***);
 *     q.update(***REMOVED*** $set: ***REMOVED*** name: 'bob' ***REMOVED******REMOVED***).update(); // not executed
 *
 *     var q = mquery(collection).where(***REMOVED*** _id: id ***REMOVED***);
 *     q.update(***REMOVED*** $set: ***REMOVED*** name: 'bob' ***REMOVED******REMOVED***).exec(); // executed as unsafe
 *
 *     // keys that are not $atomic ops become $set.
 *     // this executes the same command as the previous example.
 *     q.update(***REMOVED*** name: 'bob' ***REMOVED***).where(***REMOVED*** _id: id ***REMOVED***).exec();
 *
 *     var q = mquery(collection).update(); // not executed
 *
 *     // overwriting with empty docs
 *     var q.where(***REMOVED*** _id: id ***REMOVED***).setOptions(***REMOVED*** overwrite: true ***REMOVED***)
 *     q.update(***REMOVED*** ***REMOVED***, callback); // executes
 *
 *     // multi update with overwrite to empty doc
 *     var q = mquery(collection).where(***REMOVED*** _id: id ***REMOVED***);
 *     q.setOptions(***REMOVED*** multi: true, overwrite: true ***REMOVED***)
 *     q.update(***REMOVED*** ***REMOVED***);
 *     q.update(callback); // executed
 *
 *     // multi updates
 *     mquery()
 *       .collection(coll)
 *       .update(***REMOVED*** name: /^match/ ***REMOVED***, ***REMOVED*** $set: ***REMOVED*** arr: [] ***REMOVED******REMOVED***, ***REMOVED*** multi: true ***REMOVED***, callback)
 *     // more multi updates
 *     mquery(***REMOVED*** ***REMOVED***)
 *       .collection(coll)
 *       .setOptions(***REMOVED*** multi: true ***REMOVED***)
 *       .update(***REMOVED*** $set: ***REMOVED*** arr: [] ***REMOVED******REMOVED***, callback)
 *
 *     // single update by default
 *     mquery(***REMOVED*** email: 'address@example.com' ***REMOVED***)
 *      .collection(coll)
 *      .update(***REMOVED*** $inc: ***REMOVED*** counter: 1 ***REMOVED******REMOVED***, callback)
 *
 *     // summary
 *     update(criteria, doc, opts, cb) // executes
 *     update(criteria, doc, opts)
 *     update(criteria, doc, cb) // executes
 *     update(criteria, doc)
 *     update(doc, cb) // executes
 *     update(doc)
 *     update(cb) // executes
 *     update(true) // executes (unsafe write)
 *     update()
 *
 * @param ***REMOVED***Object***REMOVED*** [criteria]
 * @param ***REMOVED***Object***REMOVED*** [doc] the update command
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.update = function update (criteria, doc, options, callback) ***REMOVED***
  var force;

  switch (arguments.length) ***REMOVED***
    case 3:
      if ('function' == typeof options) ***REMOVED***
        callback = options;
        options = undefined;
      ***REMOVED***
      break;
    case 2:
      if ('function' == typeof doc) ***REMOVED***
        callback = doc;
        doc = criteria;
        criteria = undefined;
      ***REMOVED***
      break;
    case 1:
      switch (typeof criteria) ***REMOVED***
        case 'function':
          callback = criteria;
          criteria = options = doc = undefined;
          break;
        case 'boolean':
          // execution with no callback (unsafe write)
          force = criteria;
          criteria = undefined;
          break;
        default:
          doc = criteria;
          criteria = options = undefined;
          break;
      ***REMOVED***
  ***REMOVED***

  return _update(this, 'update', criteria, doc, options, force, callback);
***REMOVED***

/**
 * Declare and/or execute this query as an `updateMany()` operation. Identical
 * to `update()` except `updateMany()` will update _all_ documents that match
 * `criteria`, rather than just the first one.
 *
 * _All paths passed that are not $atomic operations will become $set ops._
 *
 * ####Example
 *
 *     // Update every document whose `title` contains 'test'
 *     mquery().updateMany(***REMOVED*** title: /test/ ***REMOVED***, ***REMOVED*** year: 2017 ***REMOVED***)
 *
 * @param ***REMOVED***Object***REMOVED*** [criteria]
 * @param ***REMOVED***Object***REMOVED*** [doc] the update command
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.updateMany = function updateMany (criteria, doc, options, callback) ***REMOVED***
  var force;

  switch (arguments.length) ***REMOVED***
    case 3:
      if ('function' == typeof options) ***REMOVED***
        callback = options;
        options = undefined;
      ***REMOVED***
      break;
    case 2:
      if ('function' == typeof doc) ***REMOVED***
        callback = doc;
        doc = criteria;
        criteria = undefined;
      ***REMOVED***
      break;
    case 1:
      switch (typeof criteria) ***REMOVED***
        case 'function':
          callback = criteria;
          criteria = options = doc = undefined;
          break;
        case 'boolean':
          // execution with no callback (unsafe write)
          force = criteria;
          criteria = undefined;
          break;
        default:
          doc = criteria;
          criteria = options = undefined;
          break;
      ***REMOVED***
  ***REMOVED***

  return _update(this, 'updateMany', criteria, doc, options, force, callback);
***REMOVED***

/**
 * Declare and/or execute this query as an `updateOne()` operation. Identical
 * to `update()` except `updateOne()` will _always_ update just one document,
 * regardless of the `multi` option.
 *
 * _All paths passed that are not $atomic operations will become $set ops._
 *
 * ####Example
 *
 *     // Update the first document whose `title` contains 'test'
 *     mquery().updateMany(***REMOVED*** title: /test/ ***REMOVED***, ***REMOVED*** year: 2017 ***REMOVED***)
 *
 * @param ***REMOVED***Object***REMOVED*** [criteria]
 * @param ***REMOVED***Object***REMOVED*** [doc] the update command
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.updateOne = function updateOne (criteria, doc, options, callback) ***REMOVED***
  var force;

  switch (arguments.length) ***REMOVED***
    case 3:
      if ('function' == typeof options) ***REMOVED***
        callback = options;
        options = undefined;
      ***REMOVED***
      break;
    case 2:
      if ('function' == typeof doc) ***REMOVED***
        callback = doc;
        doc = criteria;
        criteria = undefined;
      ***REMOVED***
      break;
    case 1:
      switch (typeof criteria) ***REMOVED***
        case 'function':
          callback = criteria;
          criteria = options = doc = undefined;
          break;
        case 'boolean':
          // execution with no callback (unsafe write)
          force = criteria;
          criteria = undefined;
          break;
        default:
          doc = criteria;
          criteria = options = undefined;
          break;
      ***REMOVED***
  ***REMOVED***

  return _update(this, 'updateOne', criteria, doc, options, force, callback);
***REMOVED***

/**
 * Declare and/or execute this query as an `replaceOne()` operation. Similar
 * to `updateOne()`, except `replaceOne()` is not allowed to use atomic
 * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always
 * replace the existing doc.
 *
 * ####Example
 *
 *     // Replace the document with `_id` 1 with `***REMOVED*** _id: 1, year: 2017 ***REMOVED***`
 *     mquery().replaceOne(***REMOVED*** _id: 1 ***REMOVED***, ***REMOVED*** year: 2017 ***REMOVED***)
 *
 * @param ***REMOVED***Object***REMOVED*** [criteria]
 * @param ***REMOVED***Object***REMOVED*** [doc] the update command
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.replaceOne = function replaceOne (criteria, doc, options, callback) ***REMOVED***
  var force;

  switch (arguments.length) ***REMOVED***
    case 3:
      if ('function' == typeof options) ***REMOVED***
        callback = options;
        options = undefined;
      ***REMOVED***
      break;
    case 2:
      if ('function' == typeof doc) ***REMOVED***
        callback = doc;
        doc = criteria;
        criteria = undefined;
      ***REMOVED***
      break;
    case 1:
      switch (typeof criteria) ***REMOVED***
        case 'function':
          callback = criteria;
          criteria = options = doc = undefined;
          break;
        case 'boolean':
          // execution with no callback (unsafe write)
          force = criteria;
          criteria = undefined;
          break;
        default:
          doc = criteria;
          criteria = options = undefined;
          break;
      ***REMOVED***
  ***REMOVED***

  this.setOptions(***REMOVED*** overwrite: true ***REMOVED***);
  return _update(this, 'replaceOne', criteria, doc, options, force, callback);
***REMOVED***


/*!
 * Internal helper for update, updateMany, updateOne
 */

function _update (query, op, criteria, doc, options, force, callback) ***REMOVED***
  query.op = op;

  if (Query.canMerge(criteria)) ***REMOVED***
    query.merge(criteria);
  ***REMOVED***

  if (doc) ***REMOVED***
    query._mergeUpdate(doc);
  ***REMOVED***

  if (utils.isObject(options)) ***REMOVED***
    // ***REMOVED*** overwrite: true ***REMOVED***
    query.setOptions(options);
  ***REMOVED***

  // we are done if we don't have callback and they are
  // not forcing an unsafe write.
  if (!(force || callback)) ***REMOVED***
    return query;
  ***REMOVED***

  if (!query._update ||
      !query.options.overwrite && 0 === utils.keys(query._update).length) ***REMOVED***
    callback && utils.soon(callback.bind(null, null, 0));
    return query;
  ***REMOVED***

  options = query._optionsForExec();
  if (!callback) options.safe = false;

  var criteria = query._conditions;
  doc = query._updateForExec();

  debug('update', query._collection.collectionName, criteria, doc, options);
  callback = query._wrapCallback(op, callback, ***REMOVED***
    conditions: criteria
  , doc: doc
  , options: options
  ***REMOVED***);

  query._collection[op](criteria, doc, options, utils.tick(callback));

  return query;
***REMOVED***

/**
 * Declare and/or execute this query as a remove() operation.
 *
 * ####Example
 *
 *     mquery(collection).remove(***REMOVED*** artist: 'Anne Murray' ***REMOVED***, callback)
 *
 * ####Note
 *
 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call remove() and then execute it by using the `exec()` method.
 *
 *     // not executed
 *     var query = mquery(collection).remove(***REMOVED*** name: 'Anne Murray' ***REMOVED***)
 *
 *     // executed
 *     mquery(collection).remove(***REMOVED*** name: 'Anne Murray' ***REMOVED***, callback)
 *     mquery(collection).remove(***REMOVED*** name: 'Anne Murray' ***REMOVED***).remove(callback)
 *
 *     // executed without a callback (unsafe write)
 *     query.exec()
 *
 *     // summary
 *     query.remove(conds, fn); // executes
 *     query.remove(conds)
 *     query.remove(fn) // executes
 *     query.remove()
 *
 * @param ***REMOVED***Object|Query***REMOVED*** [criteria] mongodb selector
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.remove = function (criteria, callback) ***REMOVED***
  this.op = 'remove';
  var force;

  if ('function' === typeof criteria) ***REMOVED***
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) ***REMOVED***
    this.merge(criteria);
  ***REMOVED*** else if (true === criteria) ***REMOVED***
    force = criteria;
    criteria = undefined;
  ***REMOVED***

  if (!(force || callback))
    return this;

  var options = this._optionsForExec()
  if (!callback) options.safe = false;

  var conds = this._conditions;

  debug('remove', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('remove', callback, ***REMOVED***
    conditions: conds
  , options: options
  ***REMOVED***);

  this._collection.remove(conds, options, utils.tick(callback));

  return this;
***REMOVED***

/**
 * Declare and/or execute this query as a `deleteOne()` operation. Behaves like
 * `remove()`, except for ignores the `justOne` option and always deletes at
 * most one document.
 *
 * ####Example
 *
 *     mquery(collection).deleteOne(***REMOVED*** artist: 'Anne Murray' ***REMOVED***, callback)
 *
 * @param ***REMOVED***Object|Query***REMOVED*** [criteria] mongodb selector
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.deleteOne = function (criteria, callback) ***REMOVED***
  this.op = 'deleteOne';
  var force;

  if ('function' === typeof criteria) ***REMOVED***
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) ***REMOVED***
    this.merge(criteria);
  ***REMOVED*** else if (true === criteria) ***REMOVED***
    force = criteria;
    criteria = undefined;
  ***REMOVED***

  if (!(force || callback))
    return this;

  var options = this._optionsForExec()
  if (!callback) options.safe = false;
  delete options.justOne;

  var conds = this._conditions;

  debug('deleteOne', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('deleteOne', callback, ***REMOVED***
    conditions: conds
  , options: options
  ***REMOVED***);

  this._collection.deleteOne(conds, options, utils.tick(callback));

  return this;
***REMOVED***

/**
 * Declare and/or execute this query as a `deleteMany()` operation. Behaves like
 * `remove()`, except for ignores the `justOne` option and always deletes
 * _every_ document that matches `criteria`.
 *
 * ####Example
 *
 *     mquery(collection).deleteMany(***REMOVED*** artist: 'Anne Murray' ***REMOVED***, callback)
 *
 * @param ***REMOVED***Object|Query***REMOVED*** [criteria] mongodb selector
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.deleteMany = function (criteria, callback) ***REMOVED***
  this.op = 'deleteMany';
  var force;

  if ('function' === typeof criteria) ***REMOVED***
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) ***REMOVED***
    this.merge(criteria);
  ***REMOVED*** else if (true === criteria) ***REMOVED***
    force = criteria;
    criteria = undefined;
  ***REMOVED***

  if (!(force || callback))
    return this;

  var options = this._optionsForExec()
  if (!callback) options.safe = false;
  delete options.justOne;

  var conds = this._conditions;

  debug('deleteOne', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('deleteOne', callback, ***REMOVED***
    conditions: conds
  , options: options
  ***REMOVED***);

  this._collection.deleteMany(conds, options, utils.tick(callback));

  return this;
***REMOVED***

/**
 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.
 *
 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.
 *
 * ####Available options
 *
 * - `new`: bool - true to return the modified document rather than the original. defaults to true
 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 *
 * ####Examples
 *
 *     query.findOneAndUpdate(conditions, update, options, callback) // executes
 *     query.findOneAndUpdate(conditions, update, options)  // returns Query
 *     query.findOneAndUpdate(conditions, update, callback) // executes
 *     query.findOneAndUpdate(conditions, update)           // returns Query
 *     query.findOneAndUpdate(update, callback)             // returns Query
 *     query.findOneAndUpdate(update)                       // returns Query
 *     query.findOneAndUpdate(callback)                     // executes
 *     query.findOneAndUpdate()                             // returns Query
 *
 * @param ***REMOVED***Object|Query***REMOVED*** [query]
 * @param ***REMOVED***Object***REMOVED*** [doc]
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */

Query.prototype.findOneAndUpdate = function (criteria, doc, options, callback) ***REMOVED***
  this.op = 'findOneAndUpdate';
  this._validate();

  switch (arguments.length) ***REMOVED***
    case 3:
      if ('function' == typeof options) ***REMOVED***
        callback = options;
        options = ***REMOVED******REMOVED***;
      ***REMOVED***
      break;
    case 2:
      if ('function' == typeof doc) ***REMOVED***
        callback = doc;
        doc = criteria;
        criteria = undefined;
      ***REMOVED***
      options = undefined;
      break;
    case 1:
      if ('function' == typeof criteria) ***REMOVED***
        callback = criteria;
        criteria = options = doc = undefined;
      ***REMOVED*** else ***REMOVED***
        doc = criteria;
        criteria = options = undefined;
      ***REMOVED***
  ***REMOVED***

  if (Query.canMerge(criteria)) ***REMOVED***
    this.merge(criteria);
  ***REMOVED***

  // apply doc
  if (doc) ***REMOVED***
    this._mergeUpdate(doc);
  ***REMOVED***

  options && this.setOptions(options);

  if (!callback) return this;
  return this._findAndModify('update', callback);
***REMOVED***

/**
 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.
 *
 * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.
 *
 * ####Available options
 *
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 *
 * ####Examples
 *
 *     A.where().findOneAndRemove(conditions, options, callback) // executes
 *     A.where().findOneAndRemove(conditions, options)  // return Query
 *     A.where().findOneAndRemove(conditions, callback) // executes
 *     A.where().findOneAndRemove(conditions) // returns Query
 *     A.where().findOneAndRemove(callback)   // executes
 *     A.where().findOneAndRemove()           // returns Query
 *
 * @param ***REMOVED***Object***REMOVED*** [conditions]
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Query***REMOVED*** this
 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
 * @api public
 */

Query.prototype.findOneAndRemove = function (conditions, options, callback) ***REMOVED***
  this.op = 'findOneAndRemove';
  this._validate();

  if ('function' == typeof options) ***REMOVED***
    callback = options;
    options = undefined;
  ***REMOVED*** else if ('function' == typeof conditions) ***REMOVED***
    callback = conditions;
    conditions = undefined;
  ***REMOVED***

  // apply conditions
  if (Query.canMerge(conditions)) ***REMOVED***
    this.merge(conditions);
  ***REMOVED***

  // apply options
  options && this.setOptions(options);

  if (!callback) return this;

  return this._findAndModify('remove', callback);
***REMOVED***

/**
 * _findAndModify
 *
 * @param ***REMOVED***String***REMOVED*** type - either "remove" or "update"
 * @param ***REMOVED***Function***REMOVED*** callback
 * @api private
 */

Query.prototype._findAndModify = function (type, callback) ***REMOVED***
  assert.equal('function', typeof callback);

  var opts = this._optionsForExec()
    , self = this
    , fields
    , sort
    , doc

  if ('remove' == type) ***REMOVED***
    opts.remove = true;
  ***REMOVED*** else ***REMOVED***
    if (!('new' in opts)) opts.new = true;
    if (!('upsert' in opts)) opts.upsert = false;

    doc = this._updateForExec()
    if (!doc) ***REMOVED***
      if (opts.upsert) ***REMOVED***
        // still need to do the upsert to empty doc
        doc = ***REMOVED*** $set: ***REMOVED******REMOVED*** ***REMOVED***;
      ***REMOVED*** else ***REMOVED***
        return this.findOne(callback);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  var fields = this._fieldsForExec();
  if (fields) ***REMOVED***
    opts.fields = fields;
  ***REMOVED***

  var conds = this._conditions;

  debug('findAndModify', this._collection.collectionName, conds, doc, opts);
  callback = this._wrapCallback('findAndModify', callback, ***REMOVED***
    conditions: conds
  , doc: doc
  , options: opts
  ***REMOVED***);

  this._collection
  .findAndModify(conds, doc, opts, utils.tick(callback));

  return this;
***REMOVED***

/**
 * Wrap callback to add tracing
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @param ***REMOVED***Object***REMOVED*** [queryInfo]
 * @api private
 */
Query.prototype._wrapCallback = function (method, callback, queryInfo) ***REMOVED***
  var traceFunction = this._traceFunction || Query.traceFunction;

  if (traceFunction) ***REMOVED***
    queryInfo.collectionName = this._collection.collectionName;

    var traceCallback = traceFunction &&
      traceFunction.call(null, method, queryInfo, this);

    var startTime = new Date().getTime();

    return function wrapperCallback (err, result) ***REMOVED***
      if (traceCallback) ***REMOVED***
        var millis = new Date().getTime() - startTime;
        traceCallback.call(null, err, result, millis);
      ***REMOVED***

      if (callback) ***REMOVED***
        callback.apply(null, arguments);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***

  return callback;
***REMOVED***

/**
 * Add trace function that gets called when the query is executed.
 * The function will be called with (method, queryInfo, query) and
 * should return a callback function which will be called
 * with (err, result, millis) when the query is complete.
 *
 * queryInfo is an object containing: ***REMOVED***
 *   collectionName: <name of the collection>,
 *   conditions: <query criteria>,
 *   options: <comment, fields, readPreference, etc>,
 *   doc: [document to update, if applicable]
 * ***REMOVED***
 *
 * NOTE: Does not trace stream queries.
 *
 * @param ***REMOVED***Function***REMOVED*** traceFunction
 * @return ***REMOVED***Query***REMOVED*** this
 * @api public
 */
Query.prototype.setTraceFunction = function (traceFunction) ***REMOVED***
  this._traceFunction = traceFunction;
  return this;
***REMOVED***

/**
 * Executes the query
 *
 * ####Examples
 *
 *     query.exec();
 *     query.exec(callback);
 *     query.exec('update');
 *     query.exec('find', callback);
 *
 * @param ***REMOVED***String|Function***REMOVED*** [operation]
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @api public
 */

Query.prototype.exec = function exec (op, callback) ***REMOVED***
  switch (typeof op) ***REMOVED***
    case 'function':
      callback = op;
      op = null;
      break;
    case 'string':
      this.op = op;
      break;
  ***REMOVED***

  assert.ok(this.op, "Missing query type: (find, update, etc)");

  if ('update' == this.op || 'remove' == this.op) ***REMOVED***
    callback || (callback = true);
  ***REMOVED***

  var self = this;

  if ('function' == typeof callback) ***REMOVED***
    this[this.op](callback);
  ***REMOVED*** else ***REMOVED***
    return new Query.Promise(function(success, error) ***REMOVED***
      self[self.op](function(err, val) ***REMOVED***
        if (err) error(err);
        else success(val);
        self = success = error = null;
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Returns a thunk which when called runs this.exec()
 *
 * The thunk receives a callback function which will be
 * passed to `this.exec()`
 *
 * @return ***REMOVED***Function***REMOVED***
 * @api public
 */

Query.prototype.thunk = function() ***REMOVED***
  var self = this;
  return function(cb) ***REMOVED***
    self.exec(cb);
  ***REMOVED***
***REMOVED***

/**
 * Executes the query returning a `Promise` which will be
 * resolved with either the doc(s) or rejected with the error.
 *
 * @param ***REMOVED***Function***REMOVED*** [resolve]
 * @param ***REMOVED***Function***REMOVED*** [reject]
 * @return ***REMOVED***Promise***REMOVED***
 * @api public
 */

Query.prototype.then = function(resolve, reject) ***REMOVED***
  var self = this;
  var promise = new Query.Promise(function(success, error) ***REMOVED***
    self.exec(function(err, val) ***REMOVED***
      if (err) error(err);
      else success(val);
      self = success = error = null;
    ***REMOVED***);
  ***REMOVED***);
  return promise.then(resolve, reject);
***REMOVED***

/**
 * Returns a stream for the given find query.
 *
 * @throws Error if operation is not a find
 * @returns ***REMOVED***Stream***REMOVED*** Node 0.8 style
 */

Query.prototype.stream = function(streamOptions) ***REMOVED***
  if ('find' != this.op)
    throw new Error('stream() is only available for find');

  var conds = this._conditions;

  var options = this._optionsForExec()
  options.fields = this._fieldsForExec()

  debug('stream', this._collection.collectionName, conds, options, streamOptions);

  return this._collection.findStream(conds, options, streamOptions);
***REMOVED***

/**
 * Determines if field selection has been made.
 *
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

Query.prototype.selected = function selected () ***REMOVED***
  return !! (this._fields && Object.keys(this._fields).length > 0);
***REMOVED***

/**
 * Determines if inclusive field selection has been made.
 *
 *     query.selectedInclusively() // false
 *     query.select('name')
 *     query.selectedInclusively() // true
 *     query.selectedExlusively() // false
 *
 * @returns ***REMOVED***Boolean***REMOVED***
 */

Query.prototype.selectedInclusively = function selectedInclusively () ***REMOVED***
  if (!this._fields) return false;

  var keys = Object.keys(this._fields);
  if (0 === keys.length) return false;

  for (var i = 0; i < keys.length; ++i) ***REMOVED***
    var key = keys[i];
    if (0 === this._fields[key]) return false;
    if (this._fields[key] &&
        typeof this._fields[key] === 'object' &&
        this._fields[key].$meta) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***

/**
 * Determines if exclusive field selection has been made.
 *
 *     query.selectedExlusively() // false
 *     query.select('-name')
 *     query.selectedExlusively() // true
 *     query.selectedInclusively() // false
 *
 * @returns ***REMOVED***Boolean***REMOVED***
 */

Query.prototype.selectedExclusively = function selectedExclusively () ***REMOVED***
  if (!this._fields) return false;

  var keys = Object.keys(this._fields);
  if (0 === keys.length) return false;

  for (var i = 0; i < keys.length; ++i) ***REMOVED***
    var key = keys[i];
    if (0 === this._fields[key]) return true;
  ***REMOVED***

  return false;
***REMOVED***

/**
 * Merges `doc` with the current update object.
 *
 * @param ***REMOVED***Object***REMOVED*** doc
 */

Query.prototype._mergeUpdate = function (doc) ***REMOVED***
  if (!this._update) this._update = ***REMOVED******REMOVED***;
  if (doc instanceof Query) ***REMOVED***
    if (doc._update) ***REMOVED***
      utils.mergeClone(this._update, doc._update);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    utils.mergeClone(this._update, doc);
  ***REMOVED***
***REMOVED***

/**
 * Returns default options.
 *
 * @return ***REMOVED***Object***REMOVED***
 * @api private
 */

Query.prototype._optionsForExec = function () ***REMOVED***
  var options = utils.clone(this.options);
  return options;
***REMOVED***

/**
 * Returns fields selection for this query.
 *
 * @return ***REMOVED***Object***REMOVED***
 * @api private
 */

Query.prototype._fieldsForExec = function () ***REMOVED***
  return utils.clone(this._fields);
***REMOVED***

/**
 * Return an update document with corrected $set operations.
 *
 * @api private
 */

Query.prototype._updateForExec = function () ***REMOVED***
  var update = utils.clone(this._update)
    , ops = utils.keys(update)
    , i = ops.length
    , ret = ***REMOVED******REMOVED***
    , hasKeys
    , val

  while (i--) ***REMOVED***
    var op = ops[i];

    if (this.options.overwrite) ***REMOVED***
      ret[op] = update[op];
      continue;
    ***REMOVED***

    if ('$' !== op[0]) ***REMOVED***
      // fix up $set sugar
      if (!ret.$set) ***REMOVED***
        if (update.$set) ***REMOVED***
          ret.$set = update.$set;
        ***REMOVED*** else ***REMOVED***
          ret.$set = ***REMOVED******REMOVED***;
        ***REMOVED***
      ***REMOVED***
      ret.$set[op] = update[op];
      ops.splice(i, 1);
      if (!~ops.indexOf('$set')) ops.push('$set');
    ***REMOVED*** else if ('$set' === op) ***REMOVED***
      if (!ret.$set) ***REMOVED***
        ret[op] = update[op];
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      ret[op] = update[op];
    ***REMOVED***
  ***REMOVED***

  this._compiledUpdate = ret;
  return ret;
***REMOVED***

/**
 * Make sure _path is set.
 *
 * @parmam ***REMOVED***String***REMOVED*** method
 */

Query.prototype._ensurePath = function (method) ***REMOVED***
  if (!this._path) ***REMOVED***
    var msg = method + '() must be used after where() '
                     + 'when called with these arguments'
    throw new Error(msg);
  ***REMOVED***
***REMOVED***

/*!
 * Permissions
 */

Query.permissions = require('./permissions');

Query._isPermitted = function (a, b) ***REMOVED***
  var denied = Query.permissions[b];
  if (!denied) return true;
  return true !== denied[a];
***REMOVED***

Query.prototype._validate = function (action) ***REMOVED***
  var fail;
  var validator;

  if (undefined === action) ***REMOVED***

    validator = Query.permissions[this.op];
    if ('function' != typeof validator) return true;

    fail = validator(this);

  ***REMOVED*** else if (!Query._isPermitted(action, this.op)) ***REMOVED***
    fail = action;
  ***REMOVED***

  if (fail) ***REMOVED***
    throw new Error(fail + ' cannot be used with ' + this.op);
  ***REMOVED***
***REMOVED***

/**
 * Determines if `conds` can be merged using `mquery().merge()`
 *
 * @param ***REMOVED***Object***REMOVED*** conds
 * @return ***REMOVED***Boolean***REMOVED***
 */

Query.canMerge = function (conds) ***REMOVED***
  return conds instanceof Query || utils.isObject(conds);
***REMOVED***

/**
 * Set a trace function that will get called whenever a
 * query is executed.
 *
 * See `setTraceFunction()` for details.
 *
 * @param ***REMOVED***Object***REMOVED*** conds
 * @return ***REMOVED***Boolean***REMOVED***
 */
Query.setGlobalTraceFunction = function (traceFunction) ***REMOVED***
  Query.traceFunction = traceFunction;
***REMOVED***

/*!
 * Exports.
 */

Query.utils = utils;
Query.env = require('./env')
Query.Collection = require('./collection');
Query.BaseCollection = require('./collection/collection');
Query.Promise = require('bluebird');
module.exports = exports = Query;

// TODO
// test utils
