"use strict";
module.exports = function(Promise, PromiseArray, apiRejection, debug) ***REMOVED***
var util = require("./util");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

Promise.prototype["break"] = Promise.prototype.cancel = function() ***REMOVED***
    if (!debug.cancellation()) return this._warn("cancellation is disabled");

    var promise = this;
    var child = promise;
    while (promise._isCancellable()) ***REMOVED***
        if (!promise._cancelBy(child)) ***REMOVED***
            if (child._isFollowing()) ***REMOVED***
                child._followee().cancel();
            ***REMOVED*** else ***REMOVED***
                child._cancelBranched();
            ***REMOVED***
            break;
        ***REMOVED***

        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) ***REMOVED***
            if (promise._isFollowing()) ***REMOVED***
                promise._followee().cancel();
            ***REMOVED*** else ***REMOVED***
                promise._cancelBranched();
            ***REMOVED***
            break;
        ***REMOVED*** else ***REMOVED***
            if (promise._isFollowing()) promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
        ***REMOVED***
    ***REMOVED***
***REMOVED***;

Promise.prototype._branchHasCancelled = function() ***REMOVED***
    this._branchesRemainingToCancel--;
***REMOVED***;

Promise.prototype._enoughBranchesHaveCancelled = function() ***REMOVED***
    return this._branchesRemainingToCancel === undefined ||
           this._branchesRemainingToCancel <= 0;
***REMOVED***;

Promise.prototype._cancelBy = function(canceller) ***REMOVED***
    if (canceller === this) ***REMOVED***
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
    ***REMOVED*** else ***REMOVED***
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) ***REMOVED***
            this._invokeOnCancel();
            return true;
        ***REMOVED***
    ***REMOVED***
    return false;
***REMOVED***;

Promise.prototype._cancelBranched = function() ***REMOVED***
    if (this._enoughBranchesHaveCancelled()) ***REMOVED***
        this._cancel();
    ***REMOVED***
***REMOVED***;

Promise.prototype._cancel = function() ***REMOVED***
    if (!this._isCancellable()) return;
    this._setCancelled();
    async.invoke(this._cancelPromises, this, undefined);
***REMOVED***;

Promise.prototype._cancelPromises = function() ***REMOVED***
    if (this._length() > 0) this._settlePromises();
***REMOVED***;

Promise.prototype._unsetOnCancel = function() ***REMOVED***
    this._onCancelField = undefined;
***REMOVED***;

Promise.prototype._isCancellable = function() ***REMOVED***
    return this.isPending() && !this._isCancelled();
***REMOVED***;

Promise.prototype.isCancellable = function() ***REMOVED***
    return this.isPending() && !this.isCancelled();
***REMOVED***;

Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) ***REMOVED***
    if (util.isArray(onCancelCallback)) ***REMOVED***
        for (var i = 0; i < onCancelCallback.length; ++i) ***REMOVED***
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        ***REMOVED***
    ***REMOVED*** else if (onCancelCallback !== undefined) ***REMOVED***
        if (typeof onCancelCallback === "function") ***REMOVED***
            if (!internalOnly) ***REMOVED***
                var e = tryCatch(onCancelCallback).call(this._boundValue());
                if (e === errorObj) ***REMOVED***
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            onCancelCallback._resultCancelled(this);
        ***REMOVED***
    ***REMOVED***
***REMOVED***;

Promise.prototype._invokeOnCancel = function() ***REMOVED***
    var onCancelCallback = this._onCancel();
    this._unsetOnCancel();
    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
***REMOVED***;

Promise.prototype._invokeInternalOnCancel = function() ***REMOVED***
    if (this._isCancellable()) ***REMOVED***
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
    ***REMOVED***
***REMOVED***;

Promise.prototype._resultCancelled = function() ***REMOVED***
    this.cancel();
***REMOVED***;

***REMOVED***;
