"use strict";
module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) ***REMOVED***
var util = require("./util");
var CancellationError = Promise.CancellationError;
var errorObj = util.errorObj;
var catchFilter = require("./catch_filter")(NEXT_FILTER);

function PassThroughHandlerContext(promise, type, handler) ***REMOVED***
    this.promise = promise;
    this.type = type;
    this.handler = handler;
    this.called = false;
    this.cancelPromise = null;
***REMOVED***

PassThroughHandlerContext.prototype.isFinallyHandler = function() ***REMOVED***
    return this.type === 0;
***REMOVED***;

function FinallyHandlerCancelReaction(finallyHandler) ***REMOVED***
    this.finallyHandler = finallyHandler;
***REMOVED***

FinallyHandlerCancelReaction.prototype._resultCancelled = function() ***REMOVED***
    checkCancel(this.finallyHandler);
***REMOVED***;

function checkCancel(ctx, reason) ***REMOVED***
    if (ctx.cancelPromise != null) ***REMOVED***
        if (arguments.length > 1) ***REMOVED***
            ctx.cancelPromise._reject(reason);
        ***REMOVED*** else ***REMOVED***
            ctx.cancelPromise._cancel();
        ***REMOVED***
        ctx.cancelPromise = null;
        return true;
    ***REMOVED***
    return false;
***REMOVED***

function succeed() ***REMOVED***
    return finallyHandler.call(this, this.promise._target()._settledValue());
***REMOVED***
function fail(reason) ***REMOVED***
    if (checkCancel(this, reason)) return;
    errorObj.e = reason;
    return errorObj;
***REMOVED***
function finallyHandler(reasonOrValue) ***REMOVED***
    var promise = this.promise;
    var handler = this.handler;

    if (!this.called) ***REMOVED***
        this.called = true;
        var ret = this.isFinallyHandler()
            ? handler.call(promise._boundValue())
            : handler.call(promise._boundValue(), reasonOrValue);
        if (ret === NEXT_FILTER) ***REMOVED***
            return ret;
        ***REMOVED*** else if (ret !== undefined) ***REMOVED***
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) ***REMOVED***
                if (this.cancelPromise != null) ***REMOVED***
                    if (maybePromise._isCancelled()) ***REMOVED***
                        var reason =
                            new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                    ***REMOVED*** else if (maybePromise.isPending()) ***REMOVED***
                        maybePromise._attachCancellationCallback(
                            new FinallyHandlerCancelReaction(this));
                    ***REMOVED***
                ***REMOVED***
                return maybePromise._then(
                    succeed, fail, undefined, this, undefined);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    if (promise.isRejected()) ***REMOVED***
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
    ***REMOVED*** else ***REMOVED***
        checkCancel(this);
        return reasonOrValue;
    ***REMOVED***
***REMOVED***

Promise.prototype._passThrough = function(handler, type, success, fail) ***REMOVED***
    if (typeof handler !== "function") return this.then();
    return this._then(success,
                      fail,
                      undefined,
                      new PassThroughHandlerContext(this, type, handler),
                      undefined);
***REMOVED***;

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) ***REMOVED***
    return this._passThrough(handler,
                             0,
                             finallyHandler,
                             finallyHandler);
***REMOVED***;


Promise.prototype.tap = function (handler) ***REMOVED***
    return this._passThrough(handler, 1, finallyHandler);
***REMOVED***;

Promise.prototype.tapCatch = function (handlerOrPredicate) ***REMOVED***
    var len = arguments.length;
    if(len === 1) ***REMOVED***
        return this._passThrough(handlerOrPredicate,
                                 1,
                                 undefined,
                                 finallyHandler);
    ***REMOVED*** else ***REMOVED***
         var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) ***REMOVED***
            var item = arguments[i];
            if (util.isObject(item)) ***REMOVED***
                catchInstances[j++] = item;
            ***REMOVED*** else ***REMOVED***
                return Promise.reject(new TypeError(
                    "tapCatch statement predicate: "
                    + "expecting an object but got " + util.classString(item)
                ));
            ***REMOVED***
        ***REMOVED***
        catchInstances.length = j;
        var handler = arguments[i];
        return this._passThrough(catchFilter(catchInstances, handler, this),
                                 1,
                                 undefined,
                                 finallyHandler);
    ***REMOVED***

***REMOVED***;

return PassThroughHandlerContext;
***REMOVED***;
