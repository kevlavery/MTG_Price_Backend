"use strict";
var cr = Object.create;
if (cr) ***REMOVED***
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
***REMOVED***

module.exports = function(Promise) ***REMOVED***
var util = require("./util");
var canEvaluate = util.canEvaluate;
var isIdentifier = util.isIdentifier;

var getMethodCaller;
var getGetter;
if (!false) ***REMOVED***
var makeMethodCaller = function (methodName) ***REMOVED***
    return new Function("ensureMethod", "                                    \n\
        return function(obj) ***REMOVED***                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) ***REMOVED***                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            ***REMOVED***                                                                \n\
        ***REMOVED***;                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
***REMOVED***;

var makeGetter = function (propertyName) ***REMOVED***
    return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
***REMOVED***;

var getCompiled = function(name, compiler, cache) ***REMOVED***
    var ret = cache[name];
    if (typeof ret !== "function") ***REMOVED***
        if (!isIdentifier(name)) ***REMOVED***
            return null;
        ***REMOVED***
        ret = compiler(name);
        cache[name] = ret;
        cache[" size"]++;
        if (cache[" size"] > 512) ***REMOVED***
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
        ***REMOVED***
    ***REMOVED***
    return ret;
***REMOVED***;

getMethodCaller = function(name) ***REMOVED***
    return getCompiled(name, makeMethodCaller, callerCache);
***REMOVED***;

getGetter = function(name) ***REMOVED***
    return getCompiled(name, makeGetter, getterCache);
***REMOVED***;
***REMOVED***

function ensureMethod(obj, methodName) ***REMOVED***
    var fn;
    if (obj != null) fn = obj[methodName];
    if (typeof fn !== "function") ***REMOVED***
        var message = "Object " + util.classString(obj) + " has no method '" +
            util.toString(methodName) + "'";
        throw new Promise.TypeError(message);
    ***REMOVED***
    return fn;
***REMOVED***

function caller(obj) ***REMOVED***
    var methodName = this.pop();
    var fn = ensureMethod(obj, methodName);
    return fn.apply(obj, this);
***REMOVED***
Promise.prototype.call = function (methodName) ***REMOVED***
    var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) ***REMOVED***args[$_i - 1] = arguments[$_i];***REMOVED***;
    if (!false) ***REMOVED***
        if (canEvaluate) ***REMOVED***
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) ***REMOVED***
                return this._then(
                    maybeCaller, undefined, undefined, args, undefined);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    args.push(methodName);
    return this._then(caller, undefined, undefined, args, undefined);
***REMOVED***;

function namedGetter(obj) ***REMOVED***
    return obj[this];
***REMOVED***
function indexedGetter(obj) ***REMOVED***
    var index = +this;
    if (index < 0) index = Math.max(0, index + obj.length);
    return obj[index];
***REMOVED***
Promise.prototype.get = function (propertyName) ***REMOVED***
    var isIndex = (typeof propertyName === "number");
    var getter;
    if (!isIndex) ***REMOVED***
        if (canEvaluate) ***REMOVED***
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
        ***REMOVED*** else ***REMOVED***
            getter = namedGetter;
        ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        getter = indexedGetter;
    ***REMOVED***
    return this._then(getter, undefined, undefined, propertyName, undefined);
***REMOVED***;
***REMOVED***;
