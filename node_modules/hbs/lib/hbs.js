var fs = require('fs');
var path = require('path');
var walk = require('walk').walk;

var async = require('./async');

function Instance(handlebars) ***REMOVED***
  if (!(this instanceof Instance)) ***REMOVED***
    return new Instance(handlebars);
  ***REMOVED***

  // expose handlebars, allows users to use their versions
  // by overriding this early in their apps
  var self = this;

  self.handlebars = handlebars || require('handlebars').create();

  // cache for templates, express 3.x doesn't do this for us
  self.cache = ***REMOVED******REMOVED***;

  self.__express = middleware.bind(this);

  // DEPRECATED, kept for backwards compatibility
  self.SafeString = this.handlebars.SafeString;
  self.Utils = this.handlebars.Utils;
***REMOVED***;

// express 3.x template engine compliance
function middleware(filename, options, cb) ***REMOVED***
  var self = this;
  var cache = self.cache;
  var handlebars = self.handlebars;

  self.async = async();

  // grab extension from filename
  // if we need a layout, we will look for one matching out extension
  var extension = path.extname(filename);

  // If passing the locals as data, create the handlebars options object now
  var handlebarsOpts = (self.__localsAsData) ? ***REMOVED*** data: options._locals ***REMOVED*** : undefined;

  // render the original file
  // cb(err, str)
  function render_file(locals, cb) ***REMOVED***
    // cached?
    var template = cache[filename];
    if (template) ***REMOVED***
      return cb(null, template(locals, handlebarsOpts));
    ***REMOVED***

    fs.readFile(filename, 'utf8', function(err, str)***REMOVED***
      if (err) ***REMOVED***
        return cb(err);
      ***REMOVED***

      var template = handlebars.compile(str);
      if (locals.cache) ***REMOVED***
        cache[filename] = template;
      ***REMOVED***

      try ***REMOVED***
        var res = template(locals, handlebarsOpts);
        self.async.done(function(values) ***REMOVED***
          Object.keys(values).forEach(function(id) ***REMOVED***
            res = res.replace(id, values[id]);
          ***REMOVED***);

          cb(null, res);
        ***REMOVED***);
      ***REMOVED*** catch (err) ***REMOVED***
        err.message = filename + ': ' + err.message;
        cb(err);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  // render with a layout
  function render_with_layout(template, locals, cb) ***REMOVED***
    render_file(locals, function(err, str) ***REMOVED***
      if (err) ***REMOVED***
        return cb(err);
      ***REMOVED***

      locals.body = str;

      var res = template(locals, handlebarsOpts);
      self.async.done(function(values) ***REMOVED***
        Object.keys(values).forEach(function(id) ***REMOVED***
          res = res.replace(id, values[id]);
        ***REMOVED***);

        cb(null, res);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  var layout = options.layout;

  // user did not specify a layout in the locals
  // check global layout state
  if (layout === undefined && options.settings && options.settings['view options']) ***REMOVED***
    layout = options.settings['view options'].layout;
  ***REMOVED***

  // user explicitly request no layout
  // either by specifying false for layout: false in locals
  // or by settings the false view options
  if (layout !== undefined && !layout) ***REMOVED***
    return render_file(options, cb);
  ***REMOVED***

  var view_dirs = options.settings.views;

  var layout_filename = [].concat(view_dirs).map(function (view_dir) ***REMOVED***
    var view_path = path.join(view_dir, layout || 'layout');

    if (!path.extname(view_path)) ***REMOVED***
      view_path += extension;
    ***REMOVED***

    return view_path;
  ***REMOVED***);

  var layout_template = layout_filename.reduce(function (cached, filename) ***REMOVED***
    if (cached) ***REMOVED***
      return cached;
    ***REMOVED***

    var cached_file = cache[filename];

    if (cached_file) ***REMOVED***
      return cache[filename];
    ***REMOVED***

    return undefined;
  ***REMOVED***, undefined);

  if (layout_template) ***REMOVED***
    return render_with_layout(layout_template, options, cb);
  ***REMOVED***

  // TODO check if layout path has .hbs extension

  function cacheAndCompile(filename, str) ***REMOVED***
    var layout_template = handlebars.compile(str);
    if (options.cache) ***REMOVED***
      cache[filename] = layout_template;
    ***REMOVED***

    render_with_layout(layout_template, options, cb);
  ***REMOVED***

  function tryReadFileAndCache(templates) ***REMOVED***
    var template = templates.shift();

    fs.readFile(template, 'utf8', function(err, str) ***REMOVED***
      if (err) ***REMOVED***
        if (layout && templates.length === 0) ***REMOVED***
          // Only return error if user explicitly asked for layout.
          return cb(err);
        ***REMOVED***

        if (templates.length > 0) ***REMOVED***
          return tryReadFileAndCache(templates);
        ***REMOVED***

        return render_file(options, cb);
      ***REMOVED***

      cacheAndCompile(template, str);
    ***REMOVED***);
  ***REMOVED***

  tryReadFileAndCache(layout_filename);
***REMOVED***

// express 2.x template engine compliance
Instance.prototype.compile = function (str) ***REMOVED***
  if (typeof str !== 'string') ***REMOVED***
    return str;
  ***REMOVED***

  var template = this.handlebars.compile(str);
  return function (locals) ***REMOVED***
    return template(locals, ***REMOVED***
      helpers: locals.blockHelpers,
      partials: null,
      data: null
    ***REMOVED***);
  ***REMOVED***;
***REMOVED***;

Instance.prototype.registerHelper = function () ***REMOVED***
  this.handlebars.registerHelper.apply(this.handlebars, arguments);
***REMOVED***;

Instance.prototype.registerPartial = function () ***REMOVED***
  this.handlebars.registerPartial.apply(this.handlebars, arguments);
***REMOVED***;

Instance.prototype.registerPartials = function (directory, done) ***REMOVED***
  var handlebars = this.handlebars;

  var register = function(filepath, done) ***REMOVED***
    var isValidTemplate = /\.(html|hbs)$/.test(filepath);

    if (!isValidTemplate) ***REMOVED***
      return done(null);
    ***REMOVED***

    fs.readFile(filepath, 'utf8', function(err, data) ***REMOVED***
      if (!err) ***REMOVED***
        var ext = path.extname(filepath);
        var templateName = path.relative(directory, filepath)
          .slice(0, -(ext.length)).replace(/[ -]/g, '_').replace('\\', '/');
        handlebars.registerPartial(templateName, data);
      ***REMOVED***

      done(err);
    ***REMOVED***);
  ***REMOVED***;

  walk(directory).on('file', function(root, stat, next) ***REMOVED***
    register(path.join(root, stat.name), next);
  ***REMOVED***).on('end', done || function() ***REMOVED******REMOVED***);

***REMOVED***;

Instance.prototype.registerAsyncHelper = function(name, fn) ***REMOVED***
  var self = this;
  self.handlebars.registerHelper(name, function() ***REMOVED***
    return self.async.resolve(fn, arguments);
  ***REMOVED***);
***REMOVED***;

Instance.prototype.localsAsTemplateData = function(app) ***REMOVED***
  // Set a flag to indicate we should pass locals as data
  this.__localsAsData = true;

  app.render = (function(render) ***REMOVED***
    return function(view, options, callback) ***REMOVED***
      if (typeof options === "function") ***REMOVED***
        callback = options;
        options = ***REMOVED******REMOVED***;
      ***REMOVED***

      // Mix response.locals (options._locals) with app.locals (this.locals)
      options._locals = options._locals || ***REMOVED******REMOVED***;
      for (var key in this.locals) ***REMOVED***
        options._locals[key] = this.locals[key];
      ***REMOVED***

      return render.call(this, view, options, callback);
    ***REMOVED***;
  ***REMOVED***)(app.render);
***REMOVED***;

module.exports = new Instance();
module.exports.create = function(handlebars) ***REMOVED***
  return new Instance(handlebars);
***REMOVED***;
