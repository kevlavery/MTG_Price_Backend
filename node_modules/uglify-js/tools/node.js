// workaround for tty output truncation upon process.exit()
[process.stdout, process.stderr].forEach(function(stream)***REMOVED***
    if (stream._handle && stream._handle.setBlocking)
        stream._handle.setBlocking(true);
***REMOVED***);

var path = require("path");
var fs = require("fs");

var UglifyJS = exports;
var FILES = UglifyJS.FILES = [
    "../lib/utils.js",
    "../lib/ast.js",
    "../lib/parse.js",
    "../lib/transform.js",
    "../lib/scope.js",
    "../lib/output.js",
    "../lib/compress.js",
    "../lib/sourcemap.js",
    "../lib/mozilla-ast.js",
    "../lib/propmangle.js",
    "./exports.js",
].map(function(file)***REMOVED***
    return require.resolve(file);
***REMOVED***);

new Function("MOZ_SourceMap", "exports", FILES.map(function(file)***REMOVED***
    return fs.readFileSync(file, "utf8");
***REMOVED***).join("\n\n"))(
    require("source-map"),
    UglifyJS
);

UglifyJS.AST_Node.warn_function = function(txt) ***REMOVED***
    console.error("WARN: %s", txt);
***REMOVED***;

function read_source_map(code) ***REMOVED***
    var match = /\n\/\/# sourceMappingURL=data:application\/json(;.*?)?;base64,(.*)/.exec(code);
    if (!match) ***REMOVED***
        UglifyJS.AST_Node.warn("inline source map not found");
        return null;
    ***REMOVED***
    return JSON.parse(new Buffer(match[2], "base64"));
***REMOVED***

UglifyJS.minify = function(files, options) ***REMOVED***
    options = UglifyJS.defaults(options, ***REMOVED***
        compress         : ***REMOVED******REMOVED***,
        fromString       : false,
        inSourceMap      : null,
        mangle           : ***REMOVED******REMOVED***,
        mangleProperties : false,
        nameCache        : null,
        outFileName      : null,
        output           : null,
        outSourceMap     : null,
        parse            : ***REMOVED******REMOVED***,
        sourceMapInline  : false,
        sourceMapUrl     : null,
        sourceRoot       : null,
        spidermonkey     : false,
        warnings         : false,
    ***REMOVED***);
    UglifyJS.base54.reset();

    var inMap = options.inSourceMap;
    if (typeof inMap == "string" && inMap != "inline") ***REMOVED***
        inMap = JSON.parse(fs.readFileSync(inMap, "utf8"));
    ***REMOVED***

    // 1. parse
    var toplevel = null,
        sourcesContent = ***REMOVED******REMOVED***;

    if (options.spidermonkey) ***REMOVED***
        if (inMap == "inline") ***REMOVED***
            throw new Error("inline source map only works with built-in parser");
        ***REMOVED***
        toplevel = UglifyJS.AST_Node.from_mozilla_ast(files);
    ***REMOVED*** else ***REMOVED***
        function addFile(file, fileUrl) ***REMOVED***
            var code = options.fromString
                ? file
                : fs.readFileSync(file, "utf8");
            if (inMap == "inline") ***REMOVED***
                inMap = read_source_map(code);
            ***REMOVED***
            sourcesContent[fileUrl] = code;
            toplevel = UglifyJS.parse(code, ***REMOVED***
                filename: fileUrl,
                toplevel: toplevel,
                bare_returns: options.parse ? options.parse.bare_returns : undefined
            ***REMOVED***);
        ***REMOVED***
        if (!options.fromString) ***REMOVED***
            files = UglifyJS.simple_glob(files);
            if (inMap == "inline" && files.length > 1) ***REMOVED***
                throw new Error("inline source map only works with singular input");
            ***REMOVED***
        ***REMOVED***
        [].concat(files).forEach(function (files, i) ***REMOVED***
            if (typeof files === 'string') ***REMOVED***
                addFile(files, options.fromString ? i : files);
            ***REMOVED*** else ***REMOVED***
                for (var fileUrl in files) ***REMOVED***
                    addFile(files[fileUrl], fileUrl);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
    if (options.wrap) ***REMOVED***
      toplevel = toplevel.wrap_commonjs(options.wrap, options.exportAll);
    ***REMOVED***

    // 2. compress
    if (options.compress) ***REMOVED***
        var compress = ***REMOVED*** warnings: options.warnings ***REMOVED***;
        UglifyJS.merge(compress, options.compress);
        toplevel.figure_out_scope(options.mangle);
        var sq = UglifyJS.Compressor(compress);
        toplevel = sq.compress(toplevel);
    ***REMOVED***

    // 3. mangle properties
    if (options.mangleProperties || options.nameCache) ***REMOVED***
        options.mangleProperties.cache = UglifyJS.readNameCache(options.nameCache, "props");
        toplevel = UglifyJS.mangle_properties(toplevel, options.mangleProperties);
        UglifyJS.writeNameCache(options.nameCache, "props", options.mangleProperties.cache);
    ***REMOVED***

    // 4. mangle
    if (options.mangle) ***REMOVED***
        toplevel.figure_out_scope(options.mangle);
        toplevel.compute_char_frequency(options.mangle);
        toplevel.mangle_names(options.mangle);
    ***REMOVED***

    // 5. output
    var output = ***REMOVED*** max_line_len: 32000 ***REMOVED***;
    if (options.outSourceMap || options.sourceMapInline) ***REMOVED***
        output.source_map = UglifyJS.SourceMap(***REMOVED***
            // prefer outFileName, otherwise use outSourceMap without .map suffix
            file: options.outFileName || (typeof options.outSourceMap === 'string' ? options.outSourceMap.replace(/\.map$/i, '') : null),
            orig: inMap,
            root: options.sourceRoot
        ***REMOVED***);
        if (options.sourceMapIncludeSources) ***REMOVED***
            for (var file in sourcesContent) ***REMOVED***
                if (sourcesContent.hasOwnProperty(file)) ***REMOVED***
                    output.source_map.get().setSourceContent(file, sourcesContent[file]);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

    ***REMOVED***
    if (options.output) ***REMOVED***
        UglifyJS.merge(output, options.output);
    ***REMOVED***
    var stream = UglifyJS.OutputStream(output);
    toplevel.print(stream);


    var source_map = output.source_map;
    if (source_map) ***REMOVED***
        source_map = source_map + "";
    ***REMOVED***

    var mappingUrlPrefix = "\n//# sourceMappingURL=";
    if (options.sourceMapInline) ***REMOVED***
        stream += mappingUrlPrefix + "data:application/json;charset=utf-8;base64," + new Buffer(source_map).toString("base64");
    ***REMOVED*** else if (options.outSourceMap && typeof options.outSourceMap === "string" && options.sourceMapUrl !== false) ***REMOVED***
        stream += mappingUrlPrefix + (typeof options.sourceMapUrl === "string" ? options.sourceMapUrl : options.outSourceMap);
    ***REMOVED***

    return ***REMOVED***
        code : stream + "",
        map  : source_map
    ***REMOVED***;
***REMOVED***;

// UglifyJS.describe_ast = function() ***REMOVED***
//     function doitem(ctor) ***REMOVED***
//         var sub = ***REMOVED******REMOVED***;
//         ctor.SUBCLASSES.forEach(function(ctor)***REMOVED***
//             sub[ctor.TYPE] = doitem(ctor);
//         ***REMOVED***);
//         var ret = ***REMOVED******REMOVED***;
//         if (ctor.SELF_PROPS.length > 0) ret.props = ctor.SELF_PROPS;
//         if (ctor.SUBCLASSES.length > 0) ret.sub = sub;
//         return ret;
//     ***REMOVED***
//     return doitem(UglifyJS.AST_Node).sub;
// ***REMOVED***

UglifyJS.describe_ast = function() ***REMOVED***
    var out = UglifyJS.OutputStream(***REMOVED*** beautify: true ***REMOVED***);
    function doitem(ctor) ***REMOVED***
        out.print("AST_" + ctor.TYPE);
        var props = ctor.SELF_PROPS.filter(function(prop)***REMOVED***
            return !/^\$/.test(prop);
        ***REMOVED***);
        if (props.length > 0) ***REMOVED***
            out.space();
            out.with_parens(function()***REMOVED***
                props.forEach(function(prop, i)***REMOVED***
                    if (i) out.space();
                    out.print(prop);
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***
        if (ctor.documentation) ***REMOVED***
            out.space();
            out.print_string(ctor.documentation);
        ***REMOVED***
        if (ctor.SUBCLASSES.length > 0) ***REMOVED***
            out.space();
            out.with_block(function()***REMOVED***
                ctor.SUBCLASSES.forEach(function(ctor, i)***REMOVED***
                    out.indent();
                    doitem(ctor);
                    out.newline();
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***;
    doitem(UglifyJS.AST_Node);
    return out + "";
***REMOVED***;

function readReservedFile(filename, reserved) ***REMOVED***
    if (!reserved) ***REMOVED***
        reserved = ***REMOVED*** vars: [], props: [] ***REMOVED***;
    ***REMOVED***
    var data = fs.readFileSync(filename, "utf8");
    data = JSON.parse(data);
    if (data.vars) ***REMOVED***
        data.vars.forEach(function(name)***REMOVED***
            UglifyJS.push_uniq(reserved.vars, name);
        ***REMOVED***);
    ***REMOVED***
    if (data.props) ***REMOVED***
        data.props.forEach(function(name)***REMOVED***
            UglifyJS.push_uniq(reserved.props, name);
        ***REMOVED***);
    ***REMOVED***
    return reserved;
***REMOVED***

UglifyJS.readReservedFile = readReservedFile;

UglifyJS.readDefaultReservedFile = function(reserved) ***REMOVED***
    return readReservedFile(require.resolve("./domprops.json"), reserved);
***REMOVED***;

UglifyJS.readNameCache = function(filename, key) ***REMOVED***
    var cache = null;
    if (filename) ***REMOVED***
        try ***REMOVED***
            var cache = fs.readFileSync(filename, "utf8");
            cache = JSON.parse(cache)[key];
            if (!cache) throw "init";
            cache.props = UglifyJS.Dictionary.fromObject(cache.props);
        ***REMOVED*** catch(ex) ***REMOVED***
            cache = ***REMOVED***
                cname: -1,
                props: new UglifyJS.Dictionary()
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***
    return cache;
***REMOVED***;

UglifyJS.writeNameCache = function(filename, key, cache) ***REMOVED***
    if (filename) ***REMOVED***
        var data;
        try ***REMOVED***
            data = fs.readFileSync(filename, "utf8");
            data = JSON.parse(data);
        ***REMOVED*** catch(ex) ***REMOVED***
            data = ***REMOVED******REMOVED***;
        ***REMOVED***
        data[key] = ***REMOVED***
            cname: cache.cname,
            props: cache.props.toObject()
        ***REMOVED***;
        fs.writeFileSync(filename, JSON.stringify(data, null, 2), "utf8");
    ***REMOVED***
***REMOVED***;

// A file glob function that only supports "*" and "?" wildcards in the basename.
// Example: "foo/bar/*baz??.*.js"
// Argument `glob` may be a string or an array of strings.
// Returns an array of strings. Garbage in, garbage out.
UglifyJS.simple_glob = function simple_glob(glob) ***REMOVED***
    if (Array.isArray(glob)) ***REMOVED***
        return [].concat.apply([], glob.map(simple_glob));
    ***REMOVED***
    if (glob.match(/\*|\?/)) ***REMOVED***
        var dir = path.dirname(glob);
        try ***REMOVED***
            var entries = fs.readdirSync(dir);
        ***REMOVED*** catch (ex) ***REMOVED******REMOVED***
        if (entries) ***REMOVED***
            var pattern = "^" + path.basename(glob)
                .replace(/[.+^$[\]\\()***REMOVED******REMOVED***]/g, "\\$&")
                .replace(/\*/g, "[^/\\\\]*")
                .replace(/\?/g, "[^/\\\\]") + "$";
            var mod = process.platform === "win32" ? "i" : "";
            var rx = new RegExp(pattern, mod);
            var results = entries.filter(function(name) ***REMOVED***
                return rx.test(name);
            ***REMOVED***).map(function(name) ***REMOVED***
                return path.join(dir, name);
            ***REMOVED***);
            if (results.length) return results;
        ***REMOVED***
    ***REMOVED***
    return [ glob ];
***REMOVED***;
