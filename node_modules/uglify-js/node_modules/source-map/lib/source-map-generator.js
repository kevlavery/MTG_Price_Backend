/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) ***REMOVED***
  if (!aArgs) ***REMOVED***
    aArgs = ***REMOVED******REMOVED***;
  ***REMOVED***
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
***REMOVED***

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) ***REMOVED***
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(***REMOVED***
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    ***REMOVED***);
    aSourceMapConsumer.eachMapping(function (mapping) ***REMOVED***
      var newMapping = ***REMOVED***
        generated: ***REMOVED***
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        ***REMOVED***
      ***REMOVED***;

      if (mapping.source != null) ***REMOVED***
        newMapping.source = mapping.source;
        if (sourceRoot != null) ***REMOVED***
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        ***REMOVED***

        newMapping.original = ***REMOVED***
          line: mapping.originalLine,
          column: mapping.originalColumn
        ***REMOVED***;

        if (mapping.name != null) ***REMOVED***
          newMapping.name = mapping.name;
        ***REMOVED***
      ***REMOVED***

      generator.addMapping(newMapping);
    ***REMOVED***);
    aSourceMapConsumer.sources.forEach(function (sourceFile) ***REMOVED***
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) ***REMOVED***
        generator.setSourceContent(sourceFile, content);
      ***REMOVED***
    ***REMOVED***);
    return generator;
  ***REMOVED***;

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) ***REMOVED***
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) ***REMOVED***
      this._validateMapping(generated, original, source, name);
    ***REMOVED***

    if (source != null) ***REMOVED***
      source = String(source);
      if (!this._sources.has(source)) ***REMOVED***
        this._sources.add(source);
      ***REMOVED***
    ***REMOVED***

    if (name != null) ***REMOVED***
      name = String(name);
      if (!this._names.has(name)) ***REMOVED***
        this._names.add(name);
      ***REMOVED***
    ***REMOVED***

    this._mappings.add(***REMOVED***
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    ***REMOVED***);
  ***REMOVED***;

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) ***REMOVED***
    var source = aSourceFile;
    if (this._sourceRoot != null) ***REMOVED***
      source = util.relative(this._sourceRoot, source);
    ***REMOVED***

    if (aSourceContent != null) ***REMOVED***
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) ***REMOVED***
        this._sourcesContents = Object.create(null);
      ***REMOVED***
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    ***REMOVED*** else if (this._sourcesContents) ***REMOVED***
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) ***REMOVED***
        this._sourcesContents = null;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) ***REMOVED***
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) ***REMOVED***
      if (aSourceMapConsumer.file == null) ***REMOVED***
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      ***REMOVED***
      sourceFile = aSourceMapConsumer.file;
    ***REMOVED***
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) ***REMOVED***
      sourceFile = util.relative(sourceRoot, sourceFile);
    ***REMOVED***
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) ***REMOVED***
      if (mapping.source === sourceFile && mapping.originalLine != null) ***REMOVED***
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor(***REMOVED***
          line: mapping.originalLine,
          column: mapping.originalColumn
        ***REMOVED***);
        if (original.source != null) ***REMOVED***
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) ***REMOVED***
            mapping.source = util.join(aSourceMapPath, mapping.source)
          ***REMOVED***
          if (sourceRoot != null) ***REMOVED***
            mapping.source = util.relative(sourceRoot, mapping.source);
          ***REMOVED***
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) ***REMOVED***
            mapping.name = original.name;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      var source = mapping.source;
      if (source != null && !newSources.has(source)) ***REMOVED***
        newSources.add(source);
      ***REMOVED***

      var name = mapping.name;
      if (name != null && !newNames.has(name)) ***REMOVED***
        newNames.add(name);
      ***REMOVED***

    ***REMOVED***, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) ***REMOVED***
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) ***REMOVED***
        if (aSourceMapPath != null) ***REMOVED***
          sourceFile = util.join(aSourceMapPath, sourceFile);
        ***REMOVED***
        if (sourceRoot != null) ***REMOVED***
          sourceFile = util.relative(sourceRoot, sourceFile);
        ***REMOVED***
        this.setSourceContent(sourceFile, content);
      ***REMOVED***
    ***REMOVED***, this);
  ***REMOVED***;

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) ***REMOVED***
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') ***REMOVED***
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    ***REMOVED***

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) ***REMOVED***
      // Case 1.
      return;
    ***REMOVED***
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) ***REMOVED***
      // Cases 2 and 3.
      return;
    ***REMOVED***
    else ***REMOVED***
      throw new Error('Invalid mapping: ' + JSON.stringify(***REMOVED***
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      ***REMOVED***));
    ***REMOVED***
  ***REMOVED***;

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() ***REMOVED***
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) ***REMOVED***
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) ***REMOVED***
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) ***REMOVED***
          next += ';';
          previousGeneratedLine++;
        ***REMOVED***
      ***REMOVED***
      else ***REMOVED***
        if (i > 0) ***REMOVED***
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) ***REMOVED***
            continue;
          ***REMOVED***
          next += ',';
        ***REMOVED***
      ***REMOVED***

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) ***REMOVED***
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) ***REMOVED***
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        ***REMOVED***
      ***REMOVED***

      result += next;
    ***REMOVED***

    return result;
  ***REMOVED***;

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) ***REMOVED***
    return aSources.map(function (source) ***REMOVED***
      if (!this._sourcesContents) ***REMOVED***
        return null;
      ***REMOVED***
      if (aSourceRoot != null) ***REMOVED***
        source = util.relative(aSourceRoot, source);
      ***REMOVED***
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    ***REMOVED***, this);
  ***REMOVED***;

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() ***REMOVED***
    var map = ***REMOVED***
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    ***REMOVED***;
    if (this._file != null) ***REMOVED***
      map.file = this._file;
    ***REMOVED***
    if (this._sourceRoot != null) ***REMOVED***
      map.sourceRoot = this._sourceRoot;
    ***REMOVED***
    if (this._sourcesContents) ***REMOVED***
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    ***REMOVED***

    return map;
  ***REMOVED***;

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() ***REMOVED***
    return JSON.stringify(this.toJSON());
  ***REMOVED***;

exports.SourceMapGenerator = SourceMapGenerator;
