/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) ***REMOVED***
  this.children = [];
  this.sourceContents = ***REMOVED******REMOVED***;
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
***REMOVED***

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) ***REMOVED***
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() ***REMOVED***
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() ***REMOVED***
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      ***REMOVED***
    ***REMOVED***;

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) ***REMOVED***
      if (lastMapping !== null) ***REMOVED***
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) ***REMOVED***
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        ***REMOVED*** else ***REMOVED***
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        ***REMOVED***
      ***REMOVED***
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) ***REMOVED***
        node.add(shiftNextLine());
        lastGeneratedLine++;
      ***REMOVED***
      if (lastGeneratedColumn < mapping.generatedColumn) ***REMOVED***
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      ***REMOVED***
      lastMapping = mapping;
    ***REMOVED***, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) ***REMOVED***
      if (lastMapping) ***REMOVED***
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      ***REMOVED***
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    ***REMOVED***

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) ***REMOVED***
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) ***REMOVED***
        if (aRelativePath != null) ***REMOVED***
          sourceFile = util.join(aRelativePath, sourceFile);
        ***REMOVED***
        node.setSourceContent(sourceFile, content);
      ***REMOVED***
    ***REMOVED***);

    return node;

    function addMappingWithCode(mapping, code) ***REMOVED***
      if (mapping === null || mapping.source === undefined) ***REMOVED***
        node.add(code);
      ***REMOVED*** else ***REMOVED***
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) ***REMOVED***
  if (Array.isArray(aChunk)) ***REMOVED***
    aChunk.forEach(function (chunk) ***REMOVED***
      this.add(chunk);
    ***REMOVED***, this);
  ***REMOVED***
  else if (aChunk[isSourceNode] || typeof aChunk === "string") ***REMOVED***
    if (aChunk) ***REMOVED***
      this.children.push(aChunk);
    ***REMOVED***
  ***REMOVED***
  else ***REMOVED***
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  ***REMOVED***
  return this;
***REMOVED***;

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) ***REMOVED***
  if (Array.isArray(aChunk)) ***REMOVED***
    for (var i = aChunk.length-1; i >= 0; i--) ***REMOVED***
      this.prepend(aChunk[i]);
    ***REMOVED***
  ***REMOVED***
  else if (aChunk[isSourceNode] || typeof aChunk === "string") ***REMOVED***
    this.children.unshift(aChunk);
  ***REMOVED***
  else ***REMOVED***
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  ***REMOVED***
  return this;
***REMOVED***;

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) ***REMOVED***
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) ***REMOVED***
    chunk = this.children[i];
    if (chunk[isSourceNode]) ***REMOVED***
      chunk.walk(aFn);
    ***REMOVED***
    else ***REMOVED***
      if (chunk !== '') ***REMOVED***
        aFn(chunk, ***REMOVED*** source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) ***REMOVED***
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) ***REMOVED***
    newChildren = [];
    for (i = 0; i < len-1; i++) ***REMOVED***
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    ***REMOVED***
    newChildren.push(this.children[i]);
    this.children = newChildren;
  ***REMOVED***
  return this;
***REMOVED***;

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) ***REMOVED***
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) ***REMOVED***
    lastChild.replaceRight(aPattern, aReplacement);
  ***REMOVED***
  else if (typeof lastChild === 'string') ***REMOVED***
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  ***REMOVED***
  else ***REMOVED***
    this.children.push(''.replace(aPattern, aReplacement));
  ***REMOVED***
  return this;
***REMOVED***;

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) ***REMOVED***
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  ***REMOVED***;

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) ***REMOVED***
    for (var i = 0, len = this.children.length; i < len; i++) ***REMOVED***
      if (this.children[i][isSourceNode]) ***REMOVED***
        this.children[i].walkSourceContents(aFn);
      ***REMOVED***
    ***REMOVED***

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) ***REMOVED***
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    ***REMOVED***
  ***REMOVED***;

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() ***REMOVED***
  var str = "";
  this.walk(function (chunk) ***REMOVED***
    str += chunk;
  ***REMOVED***);
  return str;
***REMOVED***;

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) ***REMOVED***
  var generated = ***REMOVED***
    code: "",
    line: 1,
    column: 0
  ***REMOVED***;
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) ***REMOVED***
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) ***REMOVED***
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) ***REMOVED***
        map.addMapping(***REMOVED***
          source: original.source,
          original: ***REMOVED***
            line: original.line,
            column: original.column
          ***REMOVED***,
          generated: ***REMOVED***
            line: generated.line,
            column: generated.column
          ***REMOVED***,
          name: original.name
        ***REMOVED***);
      ***REMOVED***
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    ***REMOVED*** else if (sourceMappingActive) ***REMOVED***
      map.addMapping(***REMOVED***
        generated: ***REMOVED***
          line: generated.line,
          column: generated.column
        ***REMOVED***
      ***REMOVED***);
      lastOriginalSource = null;
      sourceMappingActive = false;
    ***REMOVED***
    for (var idx = 0, length = chunk.length; idx < length; idx++) ***REMOVED***
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) ***REMOVED***
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) ***REMOVED***
          lastOriginalSource = null;
          sourceMappingActive = false;
        ***REMOVED*** else if (sourceMappingActive) ***REMOVED***
          map.addMapping(***REMOVED***
            source: original.source,
            original: ***REMOVED***
              line: original.line,
              column: original.column
            ***REMOVED***,
            generated: ***REMOVED***
              line: generated.line,
              column: generated.column
            ***REMOVED***,
            name: original.name
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        generated.column++;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
  this.walkSourceContents(function (sourceFile, sourceContent) ***REMOVED***
    map.setSourceContent(sourceFile, sourceContent);
  ***REMOVED***);

  return ***REMOVED*** code: generated.code, map: map ***REMOVED***;
***REMOVED***;

exports.SourceNode = SourceNode;
