"use strict";
var firstLineError;
try ***REMOVED***throw new Error(); ***REMOVED*** catch (e) ***REMOVED***firstLineError = e;***REMOVED***
var schedule = require("./schedule");
var Queue = require("./queue");
var util = require("./util");

function Async() ***REMOVED***
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () ***REMOVED***
        self._drainQueues();
    ***REMOVED***;
    this._schedule = schedule;
***REMOVED***

Async.prototype.setScheduler = function(fn) ***REMOVED***
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
***REMOVED***;

Async.prototype.hasCustomScheduler = function() ***REMOVED***
    return this._customScheduler;
***REMOVED***;

Async.prototype.enableTrampoline = function() ***REMOVED***
    this._trampolineEnabled = true;
***REMOVED***;

Async.prototype.disableTrampolineIfNecessary = function() ***REMOVED***
    if (util.hasDevTools) ***REMOVED***
        this._trampolineEnabled = false;
    ***REMOVED***
***REMOVED***;

Async.prototype.haveItemsQueued = function () ***REMOVED***
    return this._isTickUsed || this._haveDrainedQueues;
***REMOVED***;


Async.prototype.fatalError = function(e, isNode) ***REMOVED***
    if (isNode) ***REMOVED***
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
            "\n");
        process.exit(2);
    ***REMOVED*** else ***REMOVED***
        this.throwLater(e);
    ***REMOVED***
***REMOVED***;

Async.prototype.throwLater = function(fn, arg) ***REMOVED***
    if (arguments.length === 1) ***REMOVED***
        arg = fn;
        fn = function () ***REMOVED*** throw arg; ***REMOVED***;
    ***REMOVED***
    if (typeof setTimeout !== "undefined") ***REMOVED***
        setTimeout(function() ***REMOVED***
            fn(arg);
        ***REMOVED***, 0);
    ***REMOVED*** else try ***REMOVED***
        this._schedule(function() ***REMOVED***
            fn(arg);
        ***REMOVED***);
    ***REMOVED*** catch (e) ***REMOVED***
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    ***REMOVED***
***REMOVED***;

function AsyncInvokeLater(fn, receiver, arg) ***REMOVED***
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
***REMOVED***

function AsyncInvoke(fn, receiver, arg) ***REMOVED***
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
***REMOVED***

function AsyncSettlePromises(promise) ***REMOVED***
    this._normalQueue._pushOne(promise);
    this._queueTick();
***REMOVED***

if (!util.hasDevTools) ***REMOVED***
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
***REMOVED*** else ***REMOVED***
    Async.prototype.invokeLater = function (fn, receiver, arg) ***REMOVED***
        if (this._trampolineEnabled) ***REMOVED***
            AsyncInvokeLater.call(this, fn, receiver, arg);
        ***REMOVED*** else ***REMOVED***
            this._schedule(function() ***REMOVED***
                setTimeout(function() ***REMOVED***
                    fn.call(receiver, arg);
                ***REMOVED***, 100);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***;

    Async.prototype.invoke = function (fn, receiver, arg) ***REMOVED***
        if (this._trampolineEnabled) ***REMOVED***
            AsyncInvoke.call(this, fn, receiver, arg);
        ***REMOVED*** else ***REMOVED***
            this._schedule(function() ***REMOVED***
                fn.call(receiver, arg);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***;

    Async.prototype.settlePromises = function(promise) ***REMOVED***
        if (this._trampolineEnabled) ***REMOVED***
            AsyncSettlePromises.call(this, promise);
        ***REMOVED*** else ***REMOVED***
            this._schedule(function() ***REMOVED***
                promise._settlePromises();
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***;
***REMOVED***

Async.prototype._drainQueue = function(queue) ***REMOVED***
    while (queue.length() > 0) ***REMOVED***
        var fn = queue.shift();
        if (typeof fn !== "function") ***REMOVED***
            fn._settlePromises();
            continue;
        ***REMOVED***
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    ***REMOVED***
***REMOVED***;

Async.prototype._drainQueues = function () ***REMOVED***
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
***REMOVED***;

Async.prototype._queueTick = function () ***REMOVED***
    if (!this._isTickUsed) ***REMOVED***
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    ***REMOVED***
***REMOVED***;

Async.prototype._reset = function () ***REMOVED***
    this._isTickUsed = false;
***REMOVED***;

module.exports = Async;
module.exports.firstLineError = firstLineError;
