"use strict";
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) ***REMOVED***
var util = require("./util");
var tryCatch = util.tryCatch;

Promise.method = function (fn) ***REMOVED***
    if (typeof fn !== "function") ***REMOVED***
        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
    ***REMOVED***
    return function () ***REMOVED***
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
            value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    ***REMOVED***;
***REMOVED***;

Promise.attempt = Promise["try"] = function (fn) ***REMOVED***
    if (typeof fn !== "function") ***REMOVED***
        return apiRejection("expecting a function but got " + util.classString(fn));
    ***REMOVED***
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value;
    if (arguments.length > 1) ***REMOVED***
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
                                  : tryCatch(fn).call(ctx, arg);
    ***REMOVED*** else ***REMOVED***
        value = tryCatch(fn)();
    ***REMOVED***
    var promiseCreated = ret._popContext();
    debug.checkForgottenReturns(
        value, promiseCreated, "Promise.try", ret);
    ret._resolveFromSyncValue(value);
    return ret;
***REMOVED***;

Promise.prototype._resolveFromSyncValue = function (value) ***REMOVED***
    if (value === util.errorObj) ***REMOVED***
        this._rejectCallback(value.e, false);
    ***REMOVED*** else ***REMOVED***
        this._resolveCallback(value, true);
    ***REMOVED***
***REMOVED***;
***REMOVED***;
