"use strict";
module.exports = function(Promise, INTERNAL, debug) ***REMOVED***
var util = require("./util");
var TimeoutError = Promise.TimeoutError;

function HandleWrapper(handle)  ***REMOVED***
    this.handle = handle;
***REMOVED***

HandleWrapper.prototype._resultCancelled = function() ***REMOVED***
    clearTimeout(this.handle);
***REMOVED***;

var afterValue = function(value) ***REMOVED*** return delay(+this).thenReturn(value); ***REMOVED***;
var delay = Promise.delay = function (ms, value) ***REMOVED***
    var ret;
    var handle;
    if (value !== undefined) ***REMOVED***
        ret = Promise.resolve(value)
                ._then(afterValue, null, null, ms, undefined);
        if (debug.cancellation() && value instanceof Promise) ***REMOVED***
            ret._setOnCancel(value);
        ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        ret = new Promise(INTERNAL);
        handle = setTimeout(function() ***REMOVED*** ret._fulfill(); ***REMOVED***, +ms);
        if (debug.cancellation()) ***REMOVED***
            ret._setOnCancel(new HandleWrapper(handle));
        ***REMOVED***
        ret._captureStackTrace();
    ***REMOVED***
    ret._setAsyncGuaranteed();
    return ret;
***REMOVED***;

Promise.prototype.delay = function (ms) ***REMOVED***
    return delay(ms, this);
***REMOVED***;

var afterTimeout = function (promise, message, parent) ***REMOVED***
    var err;
    if (typeof message !== "string") ***REMOVED***
        if (message instanceof Error) ***REMOVED***
            err = message;
        ***REMOVED*** else ***REMOVED***
            err = new TimeoutError("operation timed out");
        ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        err = new TimeoutError(message);
    ***REMOVED***
    util.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._reject(err);

    if (parent != null) ***REMOVED***
        parent.cancel();
    ***REMOVED***
***REMOVED***;

function successClear(value) ***REMOVED***
    clearTimeout(this.handle);
    return value;
***REMOVED***

function failureClear(reason) ***REMOVED***
    clearTimeout(this.handle);
    throw reason;
***REMOVED***

Promise.prototype.timeout = function (ms, message) ***REMOVED***
    ms = +ms;
    var ret, parent;

    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() ***REMOVED***
        if (ret.isPending()) ***REMOVED***
            afterTimeout(ret, message, parent);
        ***REMOVED***
    ***REMOVED***, ms));

    if (debug.cancellation()) ***REMOVED***
        parent = this.then();
        ret = parent._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
        ret._setOnCancel(handleWrapper);
    ***REMOVED*** else ***REMOVED***
        ret = this._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
    ***REMOVED***

    return ret;
***REMOVED***;

***REMOVED***;
