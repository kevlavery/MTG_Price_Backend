/**
 * Machine id.
 *
 * Create a random 3-byte value (i.e. unique for this
 * process). Other drivers use a md5 of the machine id here, but
 * that would mean an asyc call to gethostname, so we don't bother.
 * @ignore
 */
var MACHINE_ID = parseInt(Math.random() * 0xffffff, 10);

// Regular expression that checks for hex value
var checkForHexRegExp = new RegExp('^[0-9a-fA-F]***REMOVED***24***REMOVED***$');

// Check if buffer exists
try ***REMOVED***
  if (Buffer && Buffer.from) var hasBufferType = true;
***REMOVED*** catch (err) ***REMOVED***
  hasBufferType = false;
***REMOVED***

/**
* Create a new ObjectID instance
*
* @class
* @param ***REMOVED***(string|number)***REMOVED*** id Can be a 24 byte hex string, 12 byte binary string or a Number.
* @property ***REMOVED***number***REMOVED*** generationTime The generation time of this ObjectId instance
* @return ***REMOVED***ObjectID***REMOVED*** instance of ObjectID.
*/
var ObjectID = function ObjectID(id) ***REMOVED***
  // Duck-typing to support ObjectId from different npm packages
  if (id instanceof ObjectID) return id;
  if (!(this instanceof ObjectID)) return new ObjectID(id);

  this._bsontype = 'ObjectID';

  // The most common usecase (blank id, new objectId instance)
  if (id == null || typeof id === 'number') ***REMOVED***
    // Generate a new id
    this.id = this.generate(id);
    // If we are caching the hex string
    if (ObjectID.cacheHexString) this.__id = this.toString('hex');
    // Return the object
    return;
  ***REMOVED***

  // Check if the passed in id is valid
  var valid = ObjectID.isValid(id);

  // Throw an error if it's not a valid setup
  if (!valid && id != null) ***REMOVED***
    throw new Error(
      'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'
    );
  ***REMOVED*** else if (valid && typeof id === 'string' && id.length === 24 && hasBufferType) ***REMOVED***
    return new ObjectID(new Buffer(id, 'hex'));
  ***REMOVED*** else if (valid && typeof id === 'string' && id.length === 24) ***REMOVED***
    return ObjectID.createFromHexString(id);
  ***REMOVED*** else if (id != null && id.length === 12) ***REMOVED***
    // assume 12 byte string
    this.id = id;
  ***REMOVED*** else if (id != null && id.toHexString) ***REMOVED***
    // Duck-typing to support ObjectId from different npm packages
    return id;
  ***REMOVED*** else ***REMOVED***
    throw new Error(
      'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'
    );
  ***REMOVED***

  if (ObjectID.cacheHexString) this.__id = this.toString('hex');
***REMOVED***;

// Allow usage of ObjectId as well as ObjectID
// var ObjectId = ObjectID;

// Precomputed hex table enables speedy hex string conversion
var hexTable = [];
for (var i = 0; i < 256; i++) ***REMOVED***
  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);
***REMOVED***

/**
* Return the ObjectID id as a 24 byte hex string representation
*
* @method
* @return ***REMOVED***string***REMOVED*** return the 24 byte hex string representation.
*/
ObjectID.prototype.toHexString = function() ***REMOVED***
  if (ObjectID.cacheHexString && this.__id) return this.__id;

  var hexString = '';
  if (!this.id || !this.id.length) ***REMOVED***
    throw new Error(
      'invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' +
        JSON.stringify(this.id) +
        ']'
    );
  ***REMOVED***

  if (this.id instanceof _Buffer) ***REMOVED***
    hexString = convertToHex(this.id);
    if (ObjectID.cacheHexString) this.__id = hexString;
    return hexString;
  ***REMOVED***

  for (var i = 0; i < this.id.length; i++) ***REMOVED***
    hexString += hexTable[this.id.charCodeAt(i)];
  ***REMOVED***

  if (ObjectID.cacheHexString) this.__id = hexString;
  return hexString;
***REMOVED***;

/**
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @method
* @return ***REMOVED***number***REMOVED*** returns next index value.
* @ignore
*/
ObjectID.prototype.get_inc = function() ***REMOVED***
  return (ObjectID.index = (ObjectID.index + 1) % 0xffffff);
***REMOVED***;

/**
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @method
* @return ***REMOVED***number***REMOVED*** returns next index value.
* @ignore
*/
ObjectID.prototype.getInc = function() ***REMOVED***
  return this.get_inc();
***REMOVED***;

/**
* Generate a 12 byte id buffer used in ObjectID's
*
* @method
* @param ***REMOVED***number***REMOVED*** [time] optional parameter allowing to pass in a second based timestamp.
* @return ***REMOVED***Buffer***REMOVED*** return the 12 byte id buffer string.
*/
ObjectID.prototype.generate = function(time) ***REMOVED***
  if ('number' !== typeof time) ***REMOVED***
    time = ~~(Date.now() / 1000);
  ***REMOVED***

  // Use pid
  var pid =
    (typeof process === 'undefined' || process.pid === 1
      ? Math.floor(Math.random() * 100000)
      : process.pid) % 0xffff;
  var inc = this.get_inc();
  // Buffer used
  var buffer = new Buffer(12);
  // Encode time
  buffer[3] = time & 0xff;
  buffer[2] = (time >> 8) & 0xff;
  buffer[1] = (time >> 16) & 0xff;
  buffer[0] = (time >> 24) & 0xff;
  // Encode machine
  buffer[6] = MACHINE_ID & 0xff;
  buffer[5] = (MACHINE_ID >> 8) & 0xff;
  buffer[4] = (MACHINE_ID >> 16) & 0xff;
  // Encode pid
  buffer[8] = pid & 0xff;
  buffer[7] = (pid >> 8) & 0xff;
  // Encode index
  buffer[11] = inc & 0xff;
  buffer[10] = (inc >> 8) & 0xff;
  buffer[9] = (inc >> 16) & 0xff;
  // Return the buffer
  return buffer;
***REMOVED***;

/**
* Converts the id into a 24 byte hex string for printing
*
* @param ***REMOVED***String***REMOVED*** format The Buffer toString format parameter.
* @return ***REMOVED***String***REMOVED*** return the 24 byte hex string representation.
* @ignore
*/
ObjectID.prototype.toString = function(format) ***REMOVED***
  // Is the id a buffer then use the buffer toString method to return the format
  if (this.id && this.id.copy) ***REMOVED***
    return this.id.toString(typeof format === 'string' ? format : 'hex');
  ***REMOVED***

  // if(this.buffer )
  return this.toHexString();
***REMOVED***;

/**
* Converts to a string representation of this Id.
*
* @return ***REMOVED***String***REMOVED*** return the 24 byte hex string representation.
* @ignore
*/
ObjectID.prototype.inspect = ObjectID.prototype.toString;

/**
* Converts to its JSON representation.
*
* @return ***REMOVED***String***REMOVED*** return the 24 byte hex string representation.
* @ignore
*/
ObjectID.prototype.toJSON = function() ***REMOVED***
  return this.toHexString();
***REMOVED***;

/**
* Compares the equality of this ObjectID with `otherID`.
*
* @method
* @param ***REMOVED***object***REMOVED*** otherID ObjectID instance to compare against.
* @return ***REMOVED***boolean***REMOVED*** the result of comparing two ObjectID's
*/
ObjectID.prototype.equals = function equals(otherId) ***REMOVED***
  // var id;

  if (otherId instanceof ObjectID) ***REMOVED***
    return this.toString() === otherId.toString();
  ***REMOVED*** else if (
    typeof otherId === 'string' &&
    ObjectID.isValid(otherId) &&
    otherId.length === 12 &&
    this.id instanceof _Buffer
  ) ***REMOVED***
    return otherId === this.id.toString('binary');
  ***REMOVED*** else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 24) ***REMOVED***
    return otherId.toLowerCase() === this.toHexString();
  ***REMOVED*** else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12) ***REMOVED***
    return otherId === this.id;
  ***REMOVED*** else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) ***REMOVED***
    return otherId.toHexString() === this.toHexString();
  ***REMOVED*** else ***REMOVED***
    return false;
  ***REMOVED***
***REMOVED***;

/**
* Returns the generation date (accurate up to the second) that this ID was generated.
*
* @method
* @return ***REMOVED***date***REMOVED*** the generation date
*/
ObjectID.prototype.getTimestamp = function() ***REMOVED***
  var timestamp = new Date();
  var time = this.id[3] | (this.id[2] << 8) | (this.id[1] << 16) | (this.id[0] << 24);
  timestamp.setTime(Math.floor(time) * 1000);
  return timestamp;
***REMOVED***;

/**
* @ignore
*/
ObjectID.index = ~~(Math.random() * 0xffffff);

/**
* @ignore
*/
ObjectID.createPk = function createPk() ***REMOVED***
  return new ObjectID();
***REMOVED***;

/**
* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
*
* @method
* @param ***REMOVED***number***REMOVED*** time an integer number representing a number of seconds.
* @return ***REMOVED***ObjectID***REMOVED*** return the created ObjectID
*/
ObjectID.createFromTime = function createFromTime(time) ***REMOVED***
  var buffer = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  // Encode time into first 4 bytes
  buffer[3] = time & 0xff;
  buffer[2] = (time >> 8) & 0xff;
  buffer[1] = (time >> 16) & 0xff;
  buffer[0] = (time >> 24) & 0xff;
  // Return the new objectId
  return new ObjectID(buffer);
***REMOVED***;

// Lookup tables
//var encodeLookup = '0123456789abcdef'.split('');
var decodeLookup = [];
i = 0;
while (i < 10) decodeLookup[0x30 + i] = i++;
while (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;

var _Buffer = Buffer;
var convertToHex = function(bytes) ***REMOVED***
  return bytes.toString('hex');
***REMOVED***;

/**
* Creates an ObjectID from a hex string representation of an ObjectID.
*
* @method
* @param ***REMOVED***string***REMOVED*** hexString create a ObjectID from a passed in 24 byte hexstring.
* @return ***REMOVED***ObjectID***REMOVED*** return the created ObjectID
*/
ObjectID.createFromHexString = function createFromHexString(string) ***REMOVED***
  // Throw an error if it's not a valid setup
  if (typeof string === 'undefined' || (string != null && string.length !== 24)) ***REMOVED***
    throw new Error(
      'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'
    );
  ***REMOVED***

  // Use Buffer.from method if available
  if (hasBufferType) return new ObjectID(new Buffer(string, 'hex'));

  // Calculate lengths
  var array = new _Buffer(12);
  var n = 0;
  var i = 0;

  while (i < 24) ***REMOVED***
    array[n++] = (decodeLookup[string.charCodeAt(i++)] << 4) | decodeLookup[string.charCodeAt(i++)];
  ***REMOVED***

  return new ObjectID(array);
***REMOVED***;

/**
* Checks if a value is a valid bson ObjectId
*
* @method
* @return ***REMOVED***boolean***REMOVED*** return true if the value is a valid bson ObjectId, return false otherwise.
*/
ObjectID.isValid = function isValid(id) ***REMOVED***
  if (id == null) return false;

  if (typeof id === 'number') ***REMOVED***
    return true;
  ***REMOVED***

  if (typeof id === 'string') ***REMOVED***
    return id.length === 12 || (id.length === 24 && checkForHexRegExp.test(id));
  ***REMOVED***

  if (id instanceof ObjectID) ***REMOVED***
    return true;
  ***REMOVED***

  if (id instanceof _Buffer) ***REMOVED***
    return true;
  ***REMOVED***

  // Duck-Typing detection of ObjectId like objects
  if (id.toHexString) ***REMOVED***
    return id.id.length === 12 || (id.id.length === 24 && checkForHexRegExp.test(id.id));
  ***REMOVED***

  return false;
***REMOVED***;

/**
* @ignore
*/
Object.defineProperty(ObjectID.prototype, 'generationTime', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.id[3] | (this.id[2] << 8) | (this.id[1] << 16) | (this.id[0] << 24);
  ***REMOVED***,
  set: function(value) ***REMOVED***
    // Encode time into first 4 bytes
    this.id[3] = value & 0xff;
    this.id[2] = (value >> 8) & 0xff;
    this.id[1] = (value >> 16) & 0xff;
    this.id[0] = (value >> 24) & 0xff;
  ***REMOVED***
***REMOVED***);

/**
 * Expose.
 */
module.exports = ObjectID;
module.exports.ObjectID = ObjectID;
module.exports.ObjectId = ObjectID;
