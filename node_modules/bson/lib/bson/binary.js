/**
 * Module dependencies.
 * @ignore
 */

// Test if we're in Node via presence of "global" not absence of "window"
// to support hybrid environments like Electron
if (typeof global !== 'undefined') ***REMOVED***
  var Buffer = require('buffer').Buffer; // TODO just use global Buffer
***REMOVED***

/**
 * A class representation of the BSON Binary type.
 *
 * Sub types
 *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.
 *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.
 *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.
 *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.
 *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.
 *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.
 *
 * @class
 * @param ***REMOVED***Buffer***REMOVED*** buffer a buffer object containing the binary data.
 * @param ***REMOVED***Number***REMOVED*** [subType] the option binary type.
 * @return ***REMOVED***Binary***REMOVED***
 */
function Binary(buffer, subType) ***REMOVED***
  if (!(this instanceof Binary)) return new Binary(buffer, subType);

  if (
    buffer != null &&
    !(typeof buffer === 'string') &&
    !Buffer.isBuffer(buffer) &&
    !(buffer instanceof Uint8Array) &&
    !Array.isArray(buffer)
  ) ***REMOVED***
    throw new Error('only String, Buffer, Uint8Array or Array accepted');
  ***REMOVED***

  this._bsontype = 'Binary';

  if (buffer instanceof Number) ***REMOVED***
    this.sub_type = buffer;
    this.position = 0;
  ***REMOVED*** else ***REMOVED***
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  ***REMOVED***

  if (buffer != null && !(buffer instanceof Number)) ***REMOVED***
    // Only accept Buffer, Uint8Array or Arrays
    if (typeof buffer === 'string') ***REMOVED***
      // Different ways of writing the length of the string for the different types
      if (typeof Buffer !== 'undefined') ***REMOVED***
        this.buffer = new Buffer(buffer);
      ***REMOVED*** else if (
        typeof Uint8Array !== 'undefined' ||
        Object.prototype.toString.call(buffer) === '[object Array]'
      ) ***REMOVED***
        this.buffer = writeStringToArray(buffer);
      ***REMOVED*** else ***REMOVED***
        throw new Error('only String, Buffer, Uint8Array or Array accepted');
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      this.buffer = buffer;
    ***REMOVED***
    this.position = buffer.length;
  ***REMOVED*** else ***REMOVED***
    if (typeof Buffer !== 'undefined') ***REMOVED***
      this.buffer = new Buffer(Binary.BUFFER_SIZE);
    ***REMOVED*** else if (typeof Uint8Array !== 'undefined') ***REMOVED***
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    ***REMOVED*** else ***REMOVED***
      this.buffer = new Array(Binary.BUFFER_SIZE);
    ***REMOVED***
    // Set position to start of buffer
    this.position = 0;
  ***REMOVED***
***REMOVED***

/**
 * Updates this binary with byte_value.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** byte_value a single byte we wish to write.
 */
Binary.prototype.put = function put(byte_value) ***REMOVED***
  // If it's a string and a has more than one character throw an error
  if (byte_value['length'] != null && typeof byte_value !== 'number' && byte_value.length !== 1)
    throw new Error('only accepts single character String, Uint8Array or Array');
  if ((typeof byte_value !== 'number' && byte_value < 0) || byte_value > 255)
    throw new Error('only accepts number in a valid unsigned byte range 0-255');

  // Decode the byte value once
  var decoded_byte = null;
  if (typeof byte_value === 'string') ***REMOVED***
    decoded_byte = byte_value.charCodeAt(0);
  ***REMOVED*** else if (byte_value['length'] != null) ***REMOVED***
    decoded_byte = byte_value[0];
  ***REMOVED*** else ***REMOVED***
    decoded_byte = byte_value;
  ***REMOVED***

  if (this.buffer.length > this.position) ***REMOVED***
    this.buffer[this.position++] = decoded_byte;
  ***REMOVED*** else ***REMOVED***
    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) ***REMOVED***
      // Create additional overflow buffer
      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);
      // Combine the two buffers together
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
      this.buffer = buffer;
      this.buffer[this.position++] = decoded_byte;
    ***REMOVED*** else ***REMOVED***
      buffer = null;
      // Create a new buffer (typed or normal array)
      if (Object.prototype.toString.call(this.buffer) === '[object Uint8Array]') ***REMOVED***
        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
      ***REMOVED*** else ***REMOVED***
        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
      ***REMOVED***

      // We need to copy all the content to the new array
      for (var i = 0; i < this.buffer.length; i++) ***REMOVED***
        buffer[i] = this.buffer[i];
      ***REMOVED***

      // Reassign the buffer
      this.buffer = buffer;
      // Write the byte
      this.buffer[this.position++] = decoded_byte;
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Writes a buffer or string to the binary.
 *
 * @method
 * @param ***REMOVED***(Buffer|string)***REMOVED*** string a string or buffer to be written to the Binary BSON object.
 * @param ***REMOVED***number***REMOVED*** offset specify the binary of where to write the content.
 * @return ***REMOVED***null***REMOVED***
 */
Binary.prototype.write = function write(string, offset) ***REMOVED***
  offset = typeof offset === 'number' ? offset : this.position;

  // If the buffer is to small let's extend the buffer
  if (this.buffer.length < offset + string.length) ***REMOVED***
    var buffer = null;
    // If we are in node.js
    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) ***REMOVED***
      buffer = new Buffer(this.buffer.length + string.length);
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
    ***REMOVED*** else if (Object.prototype.toString.call(this.buffer) === '[object Uint8Array]') ***REMOVED***
      // Create a new buffer
      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));
      // Copy the content
      for (var i = 0; i < this.position; i++) ***REMOVED***
        buffer[i] = this.buffer[i];
      ***REMOVED***
    ***REMOVED***

    // Assign the new buffer
    this.buffer = buffer;
  ***REMOVED***

  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) ***REMOVED***
    string.copy(this.buffer, offset, 0, string.length);
    this.position = offset + string.length > this.position ? offset + string.length : this.position;
    // offset = string.length
  ***REMOVED*** else if (
    typeof Buffer !== 'undefined' &&
    typeof string === 'string' &&
    Buffer.isBuffer(this.buffer)
  ) ***REMOVED***
    this.buffer.write(string, offset, 'binary');
    this.position = offset + string.length > this.position ? offset + string.length : this.position;
    // offset = string.length;
  ***REMOVED*** else if (
    Object.prototype.toString.call(string) === '[object Uint8Array]' ||
    (Object.prototype.toString.call(string) === '[object Array]' && typeof string !== 'string')
  ) ***REMOVED***
    for (i = 0; i < string.length; i++) ***REMOVED***
      this.buffer[offset++] = string[i];
    ***REMOVED***

    this.position = offset > this.position ? offset : this.position;
  ***REMOVED*** else if (typeof string === 'string') ***REMOVED***
    for (i = 0; i < string.length; i++) ***REMOVED***
      this.buffer[offset++] = string.charCodeAt(i);
    ***REMOVED***

    this.position = offset > this.position ? offset : this.position;
  ***REMOVED***
***REMOVED***;

/**
 * Reads **length** bytes starting at **position**.
 *
 * @method
 * @param ***REMOVED***number***REMOVED*** position read from the given position in the Binary.
 * @param ***REMOVED***number***REMOVED*** length the number of bytes to read.
 * @return ***REMOVED***Buffer***REMOVED***
 */
Binary.prototype.read = function read(position, length) ***REMOVED***
  length = length && length > 0 ? length : this.position;

  // Let's return the data based on the type we have
  if (this.buffer['slice']) ***REMOVED***
    return this.buffer.slice(position, position + length);
  ***REMOVED*** else ***REMOVED***
    // Create a buffer to keep the result
    var buffer =
      typeof Uint8Array !== 'undefined'
        ? new Uint8Array(new ArrayBuffer(length))
        : new Array(length);
    for (var i = 0; i < length; i++) ***REMOVED***
      buffer[i] = this.buffer[position++];
    ***REMOVED***
  ***REMOVED***
  // Return the buffer
  return buffer;
***REMOVED***;

/**
 * Returns the value of this binary as a string.
 *
 * @method
 * @return ***REMOVED***string***REMOVED***
 */
Binary.prototype.value = function value(asRaw) ***REMOVED***
  asRaw = asRaw == null ? false : asRaw;

  // Optimize to serialize for the situation where the data == size of buffer
  if (
    asRaw &&
    typeof Buffer !== 'undefined' &&
    Buffer.isBuffer(this.buffer) &&
    this.buffer.length === this.position
  )
    return this.buffer;

  // If it's a node.js buffer object
  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) ***REMOVED***
    return asRaw
      ? this.buffer.slice(0, this.position)
      : this.buffer.toString('binary', 0, this.position);
  ***REMOVED*** else ***REMOVED***
    if (asRaw) ***REMOVED***
      // we support the slice command use it
      if (this.buffer['slice'] != null) ***REMOVED***
        return this.buffer.slice(0, this.position);
      ***REMOVED*** else ***REMOVED***
        // Create a new buffer to copy content to
        var newBuffer =
          Object.prototype.toString.call(this.buffer) === '[object Uint8Array]'
            ? new Uint8Array(new ArrayBuffer(this.position))
            : new Array(this.position);
        // Copy content
        for (var i = 0; i < this.position; i++) ***REMOVED***
          newBuffer[i] = this.buffer[i];
        ***REMOVED***
        // Return the buffer
        return newBuffer;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Length.
 *
 * @method
 * @return ***REMOVED***number***REMOVED*** the length of the binary.
 */
Binary.prototype.length = function length() ***REMOVED***
  return this.position;
***REMOVED***;

/**
 * @ignore
 */
Binary.prototype.toJSON = function() ***REMOVED***
  return this.buffer != null ? this.buffer.toString('base64') : '';
***REMOVED***;

/**
 * @ignore
 */
Binary.prototype.toString = function(format) ***REMOVED***
  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
***REMOVED***;

/**
 * Binary default subtype
 * @ignore
 */
var BSON_BINARY_SUBTYPE_DEFAULT = 0;

/**
 * @ignore
 */
var writeStringToArray = function(data) ***REMOVED***
  // Create a buffer
  var buffer =
    typeof Uint8Array !== 'undefined'
      ? new Uint8Array(new ArrayBuffer(data.length))
      : new Array(data.length);
  // Write the content to the buffer
  for (var i = 0; i < data.length; i++) ***REMOVED***
    buffer[i] = data.charCodeAt(i);
  ***REMOVED***
  // Write the string to the buffer
  return buffer;
***REMOVED***;

/**
 * Convert Array ot Uint8Array to Binary String
 *
 * @ignore
 */
var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) ***REMOVED***
  var result = '';
  for (var i = startIndex; i < endIndex; i++) ***REMOVED***
    result = result + String.fromCharCode(byteArray[i]);
  ***REMOVED***
  return result;
***REMOVED***;

Binary.BUFFER_SIZE = 256;

/**
 * Default BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_DEFAULT = 0;
/**
 * Function BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_FUNCTION = 1;
/**
 * Byte Array BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_BYTE_ARRAY = 2;
/**
 * OLD UUID BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_UUID_OLD = 3;
/**
 * UUID BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_UUID = 4;
/**
 * MD5 BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_MD5 = 5;
/**
 * User BSON type
 *
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_USER_DEFINED = 128;

/**
 * Expose.
 */
module.exports = Binary;
module.exports.Binary = Binary;
