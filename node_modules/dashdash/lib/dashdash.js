/**
 * dashdash - A light, featureful and explicit option parsing library for
 * node.js.
 */
// vim: set ts=4 sts=4 sw=4 et:

var assert = require('assert-plus');
var format = require('util').format;
var fs = require('fs');
var path = require('path');


var DEBUG = true;
if (DEBUG) ***REMOVED***
    var debug = console.warn;
***REMOVED*** else ***REMOVED***
    var debug = function () ***REMOVED******REMOVED***;
***REMOVED***



// ---- internal support stuff

// Replace ***REMOVED******REMOVED***variable***REMOVED******REMOVED*** in `s` with the template data in `d`.
function renderTemplate(s, d) ***REMOVED***
    return s.replace(/***REMOVED******REMOVED***([a-zA-Z]+)***REMOVED******REMOVED***/g, function (match, key) ***REMOVED***
        return d.hasOwnProperty(key) ? d[key] : match;
    ***REMOVED***);
***REMOVED***

/**
 * Return a shallow copy of the given object;
 */
function shallowCopy(obj) ***REMOVED***
    if (!obj) ***REMOVED***
        return (obj);
    ***REMOVED***
    var copy = ***REMOVED******REMOVED***;
    Object.keys(obj).forEach(function (k) ***REMOVED***
        copy[k] = obj[k];
    ***REMOVED***);
    return (copy);
***REMOVED***


function space(n) ***REMOVED***
    var s = '';
    for (var i = 0; i < n; i++) ***REMOVED***
        s += ' ';
    ***REMOVED***
    return s;
***REMOVED***


function makeIndent(arg, deflen, name) ***REMOVED***
    if (arg === null || arg === undefined)
        return space(deflen);
    else if (typeof (arg) === 'number')
        return space(arg);
    else if (typeof (arg) === 'string')
        return arg;
    else
        assert.fail('invalid "' + name + '": not a string or number: ' + arg);
***REMOVED***


/**
 * Return an array of lines wrapping the given text to the given width.
 * This splits on whitespace. Single tokens longer than `width` are not
 * broken up.
 */
function textwrap(s, width) ***REMOVED***
    var words = s.trim().split(/\s+/);
    var lines = [];
    var line = '';
    words.forEach(function (w) ***REMOVED***
        var newLength = line.length + w.length;
        if (line.length > 0)
            newLength += 1;
        if (newLength > width) ***REMOVED***
            lines.push(line);
            line = '';
        ***REMOVED***
        if (line.length > 0)
            line += ' ';
        line += w;
    ***REMOVED***);
    lines.push(line);
    return lines;
***REMOVED***


/**
 * Transform an option name to a "key" that is used as the field
 * on the `opts` object returned from `<parser>.parse()`.
 *
 * Transformations:
 * - '-' -> '_': This allow one to use hyphen in option names (common)
 *   but not have to do silly things like `opt["dry-run"]` to access the
 *   parsed results.
 */
function optionKeyFromName(name) ***REMOVED***
    return name.replace(/-/g, '_');
***REMOVED***



// ---- Option types

function parseBool(option, optstr, arg) ***REMOVED***
    return Boolean(arg);
***REMOVED***

function parseString(option, optstr, arg) ***REMOVED***
    assert.string(arg, 'arg');
    return arg;
***REMOVED***

function parseNumber(option, optstr, arg) ***REMOVED***
    assert.string(arg, 'arg');
    var num = Number(arg);
    if (isNaN(num)) ***REMOVED***
        throw new Error(format('arg for "%s" is not a number: "%s"',
            optstr, arg));
    ***REMOVED***
    return num;
***REMOVED***

function parseInteger(option, optstr, arg) ***REMOVED***
    assert.string(arg, 'arg');
    var num = Number(arg);
    if (!/^[0-9-]+$/.test(arg) || isNaN(num)) ***REMOVED***
        throw new Error(format('arg for "%s" is not an integer: "%s"',
            optstr, arg));
    ***REMOVED***
    return num;
***REMOVED***

function parsePositiveInteger(option, optstr, arg) ***REMOVED***
    assert.string(arg, 'arg');
    var num = Number(arg);
    if (!/^[0-9]+$/.test(arg) || isNaN(num) || num === 0) ***REMOVED***
        throw new Error(format('arg for "%s" is not a positive integer: "%s"',
            optstr, arg));
    ***REMOVED***
    return num;
***REMOVED***

/**
 * Supported date args:
 * - epoch second times (e.g. 1396031701)
 * - ISO 8601 format: YYYY-MM-DD[THH:MM:SS[.sss][Z]]
 *      2014-03-28T18:35:01.489Z
 *      2014-03-28T18:35:01.489
 *      2014-03-28T18:35:01Z
 *      2014-03-28T18:35:01
 *      2014-03-28
 */
function parseDate(option, optstr, arg) ***REMOVED***
    assert.string(arg, 'arg');
    var date;
    if (/^\d+$/.test(arg)) ***REMOVED***
        // epoch seconds
        date = new Date(Number(arg) * 1000);
    /* JSSTYLED */
    ***REMOVED*** else if (/^\d***REMOVED***4***REMOVED***-\d***REMOVED***2***REMOVED***-\d***REMOVED***2***REMOVED***(T\d***REMOVED***2***REMOVED***:\d***REMOVED***2***REMOVED***:\d***REMOVED***2***REMOVED***(\.\d+)?Z?)?$/i.test(arg)) ***REMOVED***
        // ISO 8601 format
        date = new Date(arg);
    ***REMOVED*** else ***REMOVED***
        throw new Error(format('arg for "%s" is not a valid date format: "%s"',
            optstr, arg));
    ***REMOVED***
    if (date.toString() === 'Invalid Date') ***REMOVED***
        throw new Error(format('arg for "%s" is an invalid date: "%s"',
            optstr, arg));
    ***REMOVED***
    return date;
***REMOVED***

var optionTypes = ***REMOVED***
    bool: ***REMOVED***
        takesArg: false,
        parseArg: parseBool
    ***REMOVED***,
    string: ***REMOVED***
        takesArg: true,
        helpArg: 'ARG',
        parseArg: parseString
    ***REMOVED***,
    number: ***REMOVED***
        takesArg: true,
        helpArg: 'NUM',
        parseArg: parseNumber
    ***REMOVED***,
    integer: ***REMOVED***
        takesArg: true,
        helpArg: 'INT',
        parseArg: parseInteger
    ***REMOVED***,
    positiveInteger: ***REMOVED***
        takesArg: true,
        helpArg: 'INT',
        parseArg: parsePositiveInteger
    ***REMOVED***,
    date: ***REMOVED***
        takesArg: true,
        helpArg: 'DATE',
        parseArg: parseDate
    ***REMOVED***,
    arrayOfBool: ***REMOVED***
        takesArg: false,
        array: true,
        parseArg: parseBool
    ***REMOVED***,
    arrayOfString: ***REMOVED***
        takesArg: true,
        helpArg: 'ARG',
        array: true,
        parseArg: parseString
    ***REMOVED***,
    arrayOfNumber: ***REMOVED***
        takesArg: true,
        helpArg: 'NUM',
        array: true,
        parseArg: parseNumber
    ***REMOVED***,
    arrayOfInteger: ***REMOVED***
        takesArg: true,
        helpArg: 'INT',
        array: true,
        parseArg: parseInteger
    ***REMOVED***,
    arrayOfPositiveInteger: ***REMOVED***
        takesArg: true,
        helpArg: 'INT',
        array: true,
        parseArg: parsePositiveInteger
    ***REMOVED***,
    arrayOfDate: ***REMOVED***
        takesArg: true,
        helpArg: 'INT',
        array: true,
        parseArg: parseDate
    ***REMOVED***,
***REMOVED***;



// ---- Parser

/**
 * Parser constructor.
 *
 * @param config ***REMOVED***Object***REMOVED*** The parser configuration
 *      - options ***REMOVED***Array***REMOVED*** Array of option specs. See the README for how to
 *        specify each option spec.
 *      - allowUnknown ***REMOVED***Boolean***REMOVED*** Default false. Whether to throw on unknown
 *        options. If false, then unknown args are included in the _args array.
 *      - interspersed ***REMOVED***Boolean***REMOVED*** Default true. Whether to allow interspersed
 *        arguments (non-options) and options. E.g.:
 *              node tool.js arg1 arg2 -v
 *        '-v' is after some args here. If `interspersed: false` then '-v'
 *        would not be parsed out. Note that regardless of `interspersed`
 *        the presence of '--' will stop option parsing, as all good
 *        option parsers should.
 */
function Parser(config) ***REMOVED***
    assert.object(config, 'config');
    assert.arrayOfObject(config.options, 'config.options');
    assert.optionalBool(config.interspersed, 'config.interspersed');
    var self = this;

    // Allow interspersed arguments (true by default).
    this.interspersed = (config.interspersed !== undefined
        ? config.interspersed : true);

    // Don't allow unknown flags (true by default).
    this.allowUnknown = (config.allowUnknown !== undefined
        ? config.allowUnknown : false);

    this.options = config.options.map(function (o) ***REMOVED*** return shallowCopy(o); ***REMOVED***);
    this.optionFromName = ***REMOVED******REMOVED***;
    this.optionFromEnv = ***REMOVED******REMOVED***;
    for (var i = 0; i < this.options.length; i++) ***REMOVED***
        var o = this.options[i];
        if (o.group !== undefined && o.group !== null) ***REMOVED***
            assert.optionalString(o.group,
                format('config.options.%d.group', i));
            continue;
        ***REMOVED***
        assert.ok(optionTypes[o.type],
            format('invalid config.options.%d.type: "%s" in %j',
                   i, o.type, o));
        assert.optionalString(o.name, format('config.options.%d.name', i));
        assert.optionalArrayOfString(o.names,
            format('config.options.%d.names', i));
        assert.ok((o.name || o.names) && !(o.name && o.names),
            format('exactly one of "name" or "names" required: %j', o));
        assert.optionalString(o.help, format('config.options.%d.help', i));
        var env = o.env || [];
        if (typeof (env) === 'string') ***REMOVED***
            env = [env];
        ***REMOVED***
        assert.optionalArrayOfString(env, format('config.options.%d.env', i));
        assert.optionalString(o.helpGroup,
            format('config.options.%d.helpGroup', i));
        assert.optionalBool(o.helpWrap,
            format('config.options.%d.helpWrap', i));
        assert.optionalBool(o.hidden, format('config.options.%d.hidden', i));

        if (o.name) ***REMOVED***
            o.names = [o.name];
        ***REMOVED*** else ***REMOVED***
            assert.string(o.names[0],
                format('config.options.%d.names is empty', i));
        ***REMOVED***
        o.key = optionKeyFromName(o.names[0]);
        o.names.forEach(function (n) ***REMOVED***
            if (self.optionFromName[n]) ***REMOVED***
                throw new Error(format(
                    'option name collision: "%s" used in %j and %j',
                    n, self.optionFromName[n], o));
            ***REMOVED***
            self.optionFromName[n] = o;
        ***REMOVED***);
        env.forEach(function (n) ***REMOVED***
            if (self.optionFromEnv[n]) ***REMOVED***
                throw new Error(format(
                    'option env collision: "%s" used in %j and %j',
                    n, self.optionFromEnv[n], o));
            ***REMOVED***
            self.optionFromEnv[n] = o;
        ***REMOVED***);
    ***REMOVED***
***REMOVED***

Parser.prototype.optionTakesArg = function optionTakesArg(option) ***REMOVED***
    return optionTypes[option.type].takesArg;
***REMOVED***;

/**
 * Parse options from the given argv.
 *
 * @param inputs ***REMOVED***Object***REMOVED*** Optional.
 *      - argv ***REMOVED***Array***REMOVED*** Optional. The argv to parse. Defaults to
 *        `process.argv`.
 *      - slice ***REMOVED***Number***REMOVED*** The index into argv at which options/args begin.
 *        Default is 2, as appropriate for `process.argv`.
 *      - env ***REMOVED***Object***REMOVED*** Optional. The env to use for 'env' entries in the
 *        option specs. Defaults to `process.env`.
 * @returns ***REMOVED***Object***REMOVED*** Parsed `opts`. It has special keys `_args` (the
 *      remaining args from `argv`) and `_order` (gives the order that
 *      options were specified).
 */
Parser.prototype.parse = function parse(inputs) ***REMOVED***
    var self = this;

    // Old API was `parse([argv, [slice]])`
    if (Array.isArray(arguments[0])) ***REMOVED***
        inputs = ***REMOVED***argv: arguments[0], slice: arguments[1]***REMOVED***;
    ***REMOVED***

    assert.optionalObject(inputs, 'inputs');
    if (!inputs) ***REMOVED***
        inputs = ***REMOVED******REMOVED***;
    ***REMOVED***
    assert.optionalArrayOfString(inputs.argv, 'inputs.argv');
    //assert.optionalNumber(slice, 'slice');
    var argv = inputs.argv || process.argv;
    var slice = inputs.slice !== undefined ? inputs.slice : 2;
    var args = argv.slice(slice);
    var env = inputs.env || process.env;
    var opts = ***REMOVED******REMOVED***;
    var _order = [];

    function addOpt(option, optstr, key, val, from) ***REMOVED***
        var type = optionTypes[option.type];
        var parsedVal = type.parseArg(option, optstr, val);
        if (type.array) ***REMOVED***
            if (!opts[key]) ***REMOVED***
                opts[key] = [];
            ***REMOVED***
            if (type.arrayFlatten && Array.isArray(parsedVal)) ***REMOVED***
                for (var i = 0; i < parsedVal.length; i++) ***REMOVED***
                    opts[key].push(parsedVal[i]);
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                opts[key].push(parsedVal);
            ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            opts[key] = parsedVal;
        ***REMOVED***
        var item = ***REMOVED*** key: key, value: parsedVal, from: from ***REMOVED***;
        _order.push(item);
    ***REMOVED***

    // Parse args.
    var _args = [];
    var i = 0;
    outer: while (i < args.length) ***REMOVED***
        var arg = args[i];

        // End of options marker.
        if (arg === '--') ***REMOVED***
            i++;
            break;

        // Long option
        ***REMOVED*** else if (arg.slice(0, 2) === '--') ***REMOVED***
            var name = arg.slice(2);
            var val = null;
            var idx = name.indexOf('=');
            if (idx !== -1) ***REMOVED***
                val = name.slice(idx + 1);
                name = name.slice(0, idx);
            ***REMOVED***
            var option = this.optionFromName[name];
            if (!option) ***REMOVED***
                if (!this.allowUnknown)
                    throw new Error(format('unknown option: "--%s"', name));
                else if (this.interspersed)
                    _args.push(arg);
                else
                    break outer;
            ***REMOVED*** else ***REMOVED***
                var takesArg = this.optionTakesArg(option);
                if (val !== null && !takesArg) ***REMOVED***
                    throw new Error(format('argument given to "--%s" option '
                        + 'that does not take one: "%s"', name, arg));
                ***REMOVED***
                if (!takesArg) ***REMOVED***
                    addOpt(option, '--'+name, option.key, true, 'argv');
                ***REMOVED*** else if (val !== null) ***REMOVED***
                    addOpt(option, '--'+name, option.key, val, 'argv');
                ***REMOVED*** else if (i + 1 >= args.length) ***REMOVED***
                    throw new Error(format('do not have enough args for "--%s" '
                        + 'option', name));
                ***REMOVED*** else ***REMOVED***
                    addOpt(option, '--'+name, option.key, args[i + 1], 'argv');
                    i++;
                ***REMOVED***
            ***REMOVED***

        // Short option
        ***REMOVED*** else if (arg[0] === '-' && arg.length > 1) ***REMOVED***
            var j = 1;
            var allFound = true;
            while (j < arg.length) ***REMOVED***
                var name = arg[j];
                var option = this.optionFromName[name];
                if (!option) ***REMOVED***
                    allFound = false;
                    if (this.allowUnknown) ***REMOVED***
                        if (this.interspersed) ***REMOVED***
                            _args.push(arg);
                            break;
                        ***REMOVED*** else
                            break outer;
                    ***REMOVED*** else if (arg.length > 2) ***REMOVED***
                        throw new Error(format(
                            'unknown option: "-%s" in "%s" group',
                            name, arg));
                    ***REMOVED*** else ***REMOVED***
                        throw new Error(format('unknown option: "-%s"', name));
                    ***REMOVED***
                ***REMOVED*** else if (this.optionTakesArg(option)) ***REMOVED***
                    break;
                ***REMOVED***
                j++;
            ***REMOVED***

            j = 1;
            while (allFound && j < arg.length) ***REMOVED***
                var name = arg[j];
                var val = arg.slice(j + 1);  // option val if it takes an arg
                var option = this.optionFromName[name];
                var takesArg = this.optionTakesArg(option);
                if (!takesArg) ***REMOVED***
                    addOpt(option, '-'+name, option.key, true, 'argv');
                ***REMOVED*** else if (val) ***REMOVED***
                    addOpt(option, '-'+name, option.key, val, 'argv');
                    break;
                ***REMOVED*** else ***REMOVED***
                    if (i + 1 >= args.length) ***REMOVED***
                        throw new Error(format('do not have enough args '
                            + 'for "-%s" option', name));
                    ***REMOVED***
                    addOpt(option, '-'+name, option.key, args[i + 1], 'argv');
                    i++;
                    break;
                ***REMOVED***
                j++;
            ***REMOVED***

        // An interspersed arg
        ***REMOVED*** else if (this.interspersed) ***REMOVED***
            _args.push(arg);

        // An arg and interspersed args are not allowed, so done options.
        ***REMOVED*** else ***REMOVED***
            break outer;
        ***REMOVED***
        i++;
    ***REMOVED***
    _args = _args.concat(args.slice(i));

    // Parse environment.
    Object.keys(this.optionFromEnv).forEach(function (envname) ***REMOVED***
        var val = env[envname];
        if (val === undefined)
            return;
        var option = self.optionFromEnv[envname];
        if (opts[option.key] !== undefined)
            return;
        var takesArg = self.optionTakesArg(option);
        if (takesArg) ***REMOVED***
            addOpt(option, envname, option.key, val, 'env');
        ***REMOVED*** else if (val !== '') ***REMOVED***
            // Boolean envvar handling:
            // - VAR=<empty-string>     not set (as if the VAR was not set)
            // - VAR=0                  false
            // - anything else          true
            addOpt(option, envname, option.key, (val !== '0'), 'env');
        ***REMOVED***
    ***REMOVED***);

    // Apply default values.
    this.options.forEach(function (o) ***REMOVED***
        if (opts[o.key] === undefined) ***REMOVED***
            if (o.default !== undefined) ***REMOVED***
                opts[o.key] = o.default;
            ***REMOVED*** else if (o.type && optionTypes[o.type].default !== undefined) ***REMOVED***
                opts[o.key] = optionTypes[o.type].default;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***);

    opts._order = _order;
    opts._args = _args;
    return opts;
***REMOVED***;


/**
 * Return help output for the current options.
 *
 * E.g.: if the current options are:
 *      [***REMOVED***names: ['help', 'h'], type: 'bool', help: 'Show help and exit.'***REMOVED***]
 * then this would return:
 *      '  -h, --help     Show help and exit.\n'
 *
 * @param config ***REMOVED***Object***REMOVED*** Config for controlling the option help output.
 *      - indent ***REMOVED***Number|String***REMOVED*** Default 4. An indent/prefix to use for
 *        each option line.
 *      - nameSort ***REMOVED***String***REMOVED*** Default is 'length'. By default the names are
 *        sorted to put the short opts first (i.e. '-h, --help' preferred
 *        to '--help, -h'). Set to 'none' to not do this sorting.
 *      - maxCol ***REMOVED***Number***REMOVED*** Default 80. Note that long tokens in a help string
 *        can go past this.
 *      - helpCol ***REMOVED***Number***REMOVED*** Set to specify a specific column at which
 *        option help will be aligned. By default this is determined
 *        automatically.
 *      - minHelpCol ***REMOVED***Number***REMOVED*** Default 20.
 *      - maxHelpCol ***REMOVED***Number***REMOVED*** Default 40.
 *      - includeEnv ***REMOVED***Boolean***REMOVED*** Default false. If true, a note stating the `env`
 *        envvar (if specified for this option) will be appended to the help
 *        output.
 *      - includeDefault ***REMOVED***Boolean***REMOVED*** Default false. If true, a note stating
 *        the `default` for this option, if any, will be appended to the help
 *        output.
 *      - helpWrap ***REMOVED***Boolean***REMOVED*** Default true. Wrap help text in helpCol..maxCol
 *        bounds.
 * @returns ***REMOVED***String***REMOVED***
 */
Parser.prototype.help = function help(config) ***REMOVED***
    config = config || ***REMOVED******REMOVED***;
    assert.object(config, 'config');

    var indent = makeIndent(config.indent, 4, 'config.indent');
    var headingIndent = makeIndent(config.headingIndent,
        Math.round(indent.length / 2), 'config.headingIndent');

    assert.optionalString(config.nameSort, 'config.nameSort');
    var nameSort = config.nameSort || 'length';
    assert.ok(~['length', 'none'].indexOf(nameSort),
        'invalid "config.nameSort"');
    assert.optionalNumber(config.maxCol, 'config.maxCol');
    assert.optionalNumber(config.maxHelpCol, 'config.maxHelpCol');
    assert.optionalNumber(config.minHelpCol, 'config.minHelpCol');
    assert.optionalNumber(config.helpCol, 'config.helpCol');
    assert.optionalBool(config.includeEnv, 'config.includeEnv');
    assert.optionalBool(config.includeDefault, 'config.includeDefault');
    assert.optionalBool(config.helpWrap, 'config.helpWrap');
    var maxCol = config.maxCol || 80;
    var minHelpCol = config.minHelpCol || 20;
    var maxHelpCol = config.maxHelpCol || 40;

    var lines = [];
    var maxWidth = 0;
    this.options.forEach(function (o) ***REMOVED***
        if (o.hidden) ***REMOVED***
            return;
        ***REMOVED***
        if (o.group !== undefined && o.group !== null) ***REMOVED***
            // We deal with groups in the next pass
            lines.push(null);
            return;
        ***REMOVED***
        var type = optionTypes[o.type];
        var arg = o.helpArg || type.helpArg || 'ARG';
        var line = '';
        var names = o.names.slice();
        if (nameSort === 'length') ***REMOVED***
            names.sort(function (a, b) ***REMOVED***
                if (a.length < b.length)
                    return -1;
                else if (b.length < a.length)
                    return 1;
                else
                    return 0;
            ***REMOVED***)
        ***REMOVED***
        names.forEach(function (name, i) ***REMOVED***
            if (i > 0)
                line += ', ';
            if (name.length === 1) ***REMOVED***
                line += '-' + name
                if (type.takesArg)
                    line += ' ' + arg;
            ***REMOVED*** else ***REMOVED***
                line += '--' + name
                if (type.takesArg)
                    line += '=' + arg;
            ***REMOVED***
        ***REMOVED***);
        maxWidth = Math.max(maxWidth, line.length);
        lines.push(line);
    ***REMOVED***);

    // Add help strings.
    var helpCol = config.helpCol;
    if (!helpCol) ***REMOVED***
        helpCol = maxWidth + indent.length + 2;
        helpCol = Math.min(Math.max(helpCol, minHelpCol), maxHelpCol);
    ***REMOVED***
    var i = -1;
    this.options.forEach(function (o) ***REMOVED***
        if (o.hidden) ***REMOVED***
            return;
        ***REMOVED***
        i++;

        if (o.group !== undefined && o.group !== null) ***REMOVED***
            if (o.group === '') ***REMOVED***
                // Support a empty string "group" to have a blank line between
                // sets of options.
                lines[i] = '';
            ***REMOVED*** else ***REMOVED***
                // Render the group heading with the heading-specific indent.
                lines[i] = (i === 0 ? '' : '\n') + headingIndent +
                    o.group + ':';
            ***REMOVED***
            return;
        ***REMOVED***

        var helpDefault;
        if (config.includeDefault) ***REMOVED***
            if (o.default !== undefined) ***REMOVED***
                helpDefault = format('Default: %j', o.default);
            ***REMOVED*** else if (o.type && optionTypes[o.type].default !== undefined) ***REMOVED***
                helpDefault = format('Default: %j',
                    optionTypes[o.type].default);
            ***REMOVED***
        ***REMOVED***

        var line = lines[i] = indent + lines[i];
        if (!o.help && !(config.includeEnv && o.env) && !helpDefault) ***REMOVED***
            return;
        ***REMOVED***
        var n = helpCol - line.length;
        if (n >= 0) ***REMOVED***
            line += space(n);
        ***REMOVED*** else ***REMOVED***
            line += '\n' + space(helpCol);
        ***REMOVED***

        var helpEnv = '';
        if (o.env && o.env.length && config.includeEnv) ***REMOVED***
            helpEnv += 'Environment: ';
            var type = optionTypes[o.type];
            var arg = o.helpArg || type.helpArg || 'ARG';
            var envs = (Array.isArray(o.env) ? o.env : [o.env]).map(
                function (e) ***REMOVED***
                    if (type.takesArg) ***REMOVED***
                        return e + '=' + arg;
                    ***REMOVED*** else ***REMOVED***
                        return e + '=1';
                    ***REMOVED***
                ***REMOVED***
            );
            helpEnv += envs.join(', ');
        ***REMOVED***
        var help = (o.help || '').trim();
        if (o.helpWrap !== false && config.helpWrap !== false) ***REMOVED***
            // Wrap help description normally.
            if (help.length && !~'.!?"\''.indexOf(help.slice(-1))) ***REMOVED***
                help += '.';
            ***REMOVED***
            if (help.length) ***REMOVED***
                help += ' ';
            ***REMOVED***
            help += helpEnv;
            if (helpDefault) ***REMOVED***
                if (helpEnv) ***REMOVED***
                    help += '. ';
                ***REMOVED***
                help += helpDefault;
            ***REMOVED***
            line += textwrap(help, maxCol - helpCol).join(
                '\n' + space(helpCol));
        ***REMOVED*** else ***REMOVED***
            // Do not wrap help description, but indent newlines appropriately.
            var helpLines = help.split('\n').filter(
                    function (ln) ***REMOVED*** return ln.length ***REMOVED***);
            if (helpEnv !== '') ***REMOVED***
                helpLines.push(helpEnv);
            ***REMOVED***
            if (helpDefault) ***REMOVED***
                helpLines.push(helpDefault);
            ***REMOVED***
            line += helpLines.join('\n' + space(helpCol));
        ***REMOVED***

        lines[i] = line;
    ***REMOVED***);

    var rv = '';
    if (lines.length > 0) ***REMOVED***
        rv = lines.join('\n') + '\n';
    ***REMOVED***
    return rv;
***REMOVED***;


/**
 * Return a string suitable for a Bash completion file for this tool.
 *
 * @param args.name ***REMOVED***String***REMOVED*** The tool name.
 * @param args.specExtra ***REMOVED***String***REMOVED*** Optional. Extra Bash code content to add
 *      to the end of the "spec". Typically this is used to append Bash
 *      "complete_TYPE" functions for custom option types. See
 *      "examples/ddcompletion.js" for an example.
 * @param args.argtypes ***REMOVED***Array***REMOVED*** Optional. Array of completion types for
 *      positional args (i.e. non-options). E.g.
 *          argtypes = ['fruit', 'veggie', 'file']
 *      will result in completion of fruits for the first arg, veggies for the
 *      second, and filenames for the third and subsequent positional args.
 *      If not given, positional args will use Bash's 'default' completion.
 *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
 *      `complete_fruit` and `complete_veggie` in this example.
 */
Parser.prototype.bashCompletion = function bashCompletion(args) ***REMOVED***
    assert.object(args, 'args');
    assert.string(args.name, 'args.name');
    assert.optionalString(args.specExtra, 'args.specExtra');
    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');

    return bashCompletionFromOptions(***REMOVED***
        name: args.name,
        specExtra: args.specExtra,
        argtypes: args.argtypes,
        options: this.options
    ***REMOVED***);
***REMOVED***;


// ---- Bash completion

const BASH_COMPLETION_TEMPLATE_PATH = path.join(
    __dirname, '../etc/dashdash.bash_completion.in');

/**
 * Return the Bash completion "spec" (the string value for the "***REMOVED******REMOVED***spec***REMOVED******REMOVED***"
 * var in the "dashdash.bash_completion.in" template) for this tool.
 *
 * The "spec" is Bash code that defines the CLI options and subcmds for
 * the template's completion code. It looks something like this:
 *
 *      local cmd_shortopts="-J ..."
 *      local cmd_longopts="--help ..."
 *      local cmd_optargs="-p=tritonprofile ..."
 *
 * @param args.options ***REMOVED***Array***REMOVED*** The array of dashdash option specs.
 * @param args.context ***REMOVED***String***REMOVED*** Optional. A context string for the "local cmd*"
 *      vars in the spec. By default it is the empty string. When used to
 *      scope for completion on a *sub-command* (e.g. for "git log" on a "git"
 *      tool), then it would have a value (e.g. "__log"). See
 *      <http://github.com/trentm/node-cmdln> Bash completion for details.
 * @param opts.includeHidden ***REMOVED***Boolean***REMOVED*** Optional. Default false. By default
 *      hidden options and subcmds are "excluded". Here excluded means they
 *      won't be offered as a completion, but if used, their argument type
 *      will be completed. "Hidden" options and subcmds are ones with the
 *      `hidden: true` attribute to exclude them from default help output.
 * @param args.argtypes ***REMOVED***Array***REMOVED*** Optional. Array of completion types for
 *      positional args (i.e. non-options). E.g.
 *          argtypes = ['fruit', 'veggie', 'file']
 *      will result in completion of fruits for the first arg, veggies for the
 *      second, and filenames for the third and subsequent positional args.
 *      If not given, positional args will use Bash's 'default' completion.
 *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
 *      `complete_fruit` and `complete_veggie` in this example.
 */
function bashCompletionSpecFromOptions(args) ***REMOVED***
    assert.object(args, 'args');
    assert.object(args.options, 'args.options');
    assert.optionalString(args.context, 'args.context');
    assert.optionalBool(args.includeHidden, 'args.includeHidden');
    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');

    var context = args.context || '';
    var includeHidden = (args.includeHidden === undefined
        ? false : args.includeHidden);

    var spec = [];
    var shortopts = [];
    var longopts = [];
    var optargs = [];
    (args.options || []).forEach(function (o) ***REMOVED***
        if (o.group !== undefined && o.group !== null) ***REMOVED***
            // Skip group headers.
            return;
        ***REMOVED***

        var optNames = o.names || [o.name];
        var optType = getOptionType(o.type);
        if (optType.takesArg) ***REMOVED***
            var completionType = o.completionType ||
                optType.completionType || o.type;
            optNames.forEach(function (optName) ***REMOVED***
                if (optName.length === 1) ***REMOVED***
                    if (includeHidden || !o.hidden) ***REMOVED***
                        shortopts.push('-' + optName);
                    ***REMOVED***
                    // Include even hidden options in `optargs` so that bash
                    // completion of its arg still works.
                    optargs.push('-' + optName + '=' + completionType);
                ***REMOVED*** else ***REMOVED***
                    if (includeHidden || !o.hidden) ***REMOVED***
                        longopts.push('--' + optName);
                    ***REMOVED***
                    optargs.push('--' + optName + '=' + completionType);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED*** else ***REMOVED***
            optNames.forEach(function (optName) ***REMOVED***
                if (includeHidden || !o.hidden) ***REMOVED***
                    if (optName.length === 1) ***REMOVED***
                        shortopts.push('-' + optName);
                    ***REMOVED*** else ***REMOVED***
                        longopts.push('--' + optName);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***);

    spec.push(format('local cmd%s_shortopts="%s"',
        context, shortopts.sort().join(' ')));
    spec.push(format('local cmd%s_longopts="%s"',
        context, longopts.sort().join(' ')));
    spec.push(format('local cmd%s_optargs="%s"',
        context, optargs.sort().join(' ')));
    if (args.argtypes) ***REMOVED***
        spec.push(format('local cmd%s_argtypes="%s"',
            context, args.argtypes.join(' ')));
    ***REMOVED***
    return spec.join('\n');
***REMOVED***


/**
 * Return a string suitable for a Bash completion file for this tool.
 *
 * @param args.name ***REMOVED***String***REMOVED*** The tool name.
 * @param args.options ***REMOVED***Array***REMOVED*** The array of dashdash option specs.
 * @param args.specExtra ***REMOVED***String***REMOVED*** Optional. Extra Bash code content to add
 *      to the end of the "spec". Typically this is used to append Bash
 *      "complete_TYPE" functions for custom option types. See
 *      "examples/ddcompletion.js" for an example.
 * @param args.argtypes ***REMOVED***Array***REMOVED*** Optional. Array of completion types for
 *      positional args (i.e. non-options). E.g.
 *          argtypes = ['fruit', 'veggie', 'file']
 *      will result in completion of fruits for the first arg, veggies for the
 *      second, and filenames for the third and subsequent positional args.
 *      If not given, positional args will use Bash's 'default' completion.
 *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
 *      `complete_fruit` and `complete_veggie` in this example.
 */
function bashCompletionFromOptions(args) ***REMOVED***
    assert.object(args, 'args');
    assert.object(args.options, 'args.options');
    assert.string(args.name, 'args.name');
    assert.optionalString(args.specExtra, 'args.specExtra');
    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');

    // Gather template data.
    var data = ***REMOVED***
        name: args.name,
        date: new Date(),
        spec: bashCompletionSpecFromOptions(***REMOVED***
            options: args.options,
            argtypes: args.argtypes
        ***REMOVED***),
    ***REMOVED***;
    if (args.specExtra) ***REMOVED***
        data.spec += '\n\n' + args.specExtra;
    ***REMOVED***

    // Render template.
    var template = fs.readFileSync(BASH_COMPLETION_TEMPLATE_PATH, 'utf8');
    return renderTemplate(template, data);
***REMOVED***



// ---- exports

function createParser(config) ***REMOVED***
    return new Parser(config);
***REMOVED***

/**
 * Parse argv with the given options.
 *
 * @param config ***REMOVED***Object***REMOVED*** A merge of all the available fields from
 *      `dashdash.Parser` and `dashdash.Parser.parse`: options, interspersed,
 *      argv, env, slice.
 */
function parse(config) ***REMOVED***
    assert.object(config, 'config');
    assert.optionalArrayOfString(config.argv, 'config.argv');
    assert.optionalObject(config.env, 'config.env');
    var config = shallowCopy(config);
    var argv = config.argv;
    delete config.argv;
    var env = config.env;
    delete config.env;

    var parser = new Parser(config);
    return parser.parse(***REMOVED***argv: argv, env: env***REMOVED***);
***REMOVED***


/**
 * Add a new option type.
 *
 * @params optionType ***REMOVED***Object***REMOVED***:
 *      - name ***REMOVED***String***REMOVED*** Required.
 *      - takesArg ***REMOVED***Boolean***REMOVED*** Required. Whether this type of option takes an
 *        argument on process.argv. Typically this is true for all but the
 *        "bool" type.
 *      - helpArg ***REMOVED***String***REMOVED*** Required iff `takesArg === true`. The string to
 *        show in generated help for options of this type.
 *      - parseArg ***REMOVED***Function***REMOVED*** Require. `function (option, optstr, arg)` parser
 *        that takes a string argument and returns an instance of the
 *        appropriate type, or throws an error if the arg is invalid.
 *      - array ***REMOVED***Boolean***REMOVED*** Optional. Set to true if this is an 'arrayOf' type
 *        that collects multiple usages of the option in process.argv and
 *        puts results in an array.
 *      - arrayFlatten ***REMOVED***Boolean***REMOVED*** Optional. XXX
 *      - default Optional. Default value for options of this type, if no
 *        default is specified in the option type usage.
 */
function addOptionType(optionType) ***REMOVED***
    assert.object(optionType, 'optionType');
    assert.string(optionType.name, 'optionType.name');
    assert.bool(optionType.takesArg, 'optionType.takesArg');
    if (optionType.takesArg) ***REMOVED***
        assert.string(optionType.helpArg, 'optionType.helpArg');
    ***REMOVED***
    assert.func(optionType.parseArg, 'optionType.parseArg');
    assert.optionalBool(optionType.array, 'optionType.array');
    assert.optionalBool(optionType.arrayFlatten, 'optionType.arrayFlatten');

    optionTypes[optionType.name] = ***REMOVED***
        takesArg: optionType.takesArg,
        helpArg: optionType.helpArg,
        parseArg: optionType.parseArg,
        array: optionType.array,
        arrayFlatten: optionType.arrayFlatten,
        default: optionType.default
    ***REMOVED***
***REMOVED***


function getOptionType(name) ***REMOVED***
    assert.string(name, 'name');
    return optionTypes[name];
***REMOVED***


/**
 * Return a synopsis string for the given option spec.
 *
 * Examples:
 *      > synopsisFromOpt(***REMOVED***names: ['help', 'h'], type: 'bool'***REMOVED***);
 *      '[ --help | -h ]'
 *      > synopsisFromOpt(***REMOVED***name: 'file', type: 'string', helpArg: 'FILE'***REMOVED***);
 *      '[ --file=FILE ]'
 */
function synopsisFromOpt(o) ***REMOVED***
    assert.object(o, 'o');

    if (o.hasOwnProperty('group')) ***REMOVED***
        return null;
    ***REMOVED***
    var names = o.names || [o.name];
    // `type` here could be undefined if, for example, the command has a
    // dashdash option spec with a bogus 'type'.
    var type = getOptionType(o.type);
    var helpArg = o.helpArg || (type && type.helpArg) || 'ARG';
    var parts = [];
    names.forEach(function (name) ***REMOVED***
        var part = (name.length === 1 ? '-' : '--') + name;
        if (type && type.takesArg) ***REMOVED***
            part += (name.length === 1 ? ' ' + helpArg : '=' + helpArg);
        ***REMOVED***
        parts.push(part);
    ***REMOVED***);
    return ('[ ' + parts.join(' | ') + ' ]');
***REMOVED***;


module.exports = ***REMOVED***
    createParser: createParser,
    Parser: Parser,
    parse: parse,
    addOptionType: addOptionType,
    getOptionType: getOptionType,
    synopsisFromOpt: synopsisFromOpt,

    // Bash completion-related exports
    BASH_COMPLETION_TEMPLATE_PATH: BASH_COMPLETION_TEMPLATE_PATH,
    bashCompletionFromOptions: bashCompletionFromOptions,
    bashCompletionSpecFromOptions: bashCompletionSpecFromOptions,

    // Export the parseFoo parsers because they might be useful as primitives
    // for custom option types.
    parseBool: parseBool,
    parseString: parseString,
    parseNumber: parseNumber,
    parseInteger: parseInteger,
    parsePositiveInteger: parsePositiveInteger,
    parseDate: parseDate
***REMOVED***;
