var async = require('./async.js');

// API
module.exports = ***REMOVED***
  iterator: wrapIterator,
  callback: wrapCallback
***REMOVED***;

/**
 * Wraps iterators with long signature
 *
 * @this    ReadableAsyncKit#
 * @param   ***REMOVED***function***REMOVED*** iterator - function to wrap
 * @returns ***REMOVED***function***REMOVED*** - wrapped function
 */
function wrapIterator(iterator)
***REMOVED***
  var stream = this;

  return function(item, key, cb)
  ***REMOVED***
    var aborter
      , wrappedCb = async(wrapIteratorCallback.call(stream, cb, key))
      ;

    stream.jobs[key] = wrappedCb;

    // it's either shortcut (item, cb)
    if (iterator.length == 2)
    ***REMOVED***
      aborter = iterator(item, wrappedCb);
    ***REMOVED***
    // or long format (item, key, cb)
    else
    ***REMOVED***
      aborter = iterator(item, key, wrappedCb);
    ***REMOVED***

    return aborter;
  ***REMOVED***;
***REMOVED***

/**
 * Wraps provided callback function
 * allowing to execute snitch function before
 * real callback
 *
 * @this    ReadableAsyncKit#
 * @param   ***REMOVED***function***REMOVED*** callback - function to wrap
 * @returns ***REMOVED***function***REMOVED*** - wrapped function
 */
function wrapCallback(callback)
***REMOVED***
  var stream = this;

  var wrapped = function(error, result)
  ***REMOVED***
    return finisher.call(stream, error, result, callback);
  ***REMOVED***;

  return wrapped;
***REMOVED***

/**
 * Wraps provided iterator callback function
 * makes sure snitch only called once,
 * but passes secondary calls to the original callback
 *
 * @this    ReadableAsyncKit#
 * @param   ***REMOVED***function***REMOVED*** callback - callback to wrap
 * @param   ***REMOVED***number|string***REMOVED*** key - iteration key
 * @returns ***REMOVED***function***REMOVED*** wrapped callback
 */
function wrapIteratorCallback(callback, key)
***REMOVED***
  var stream = this;

  return function(error, output)
  ***REMOVED***
    // don't repeat yourself
    if (!(key in stream.jobs))
    ***REMOVED***
      callback(error, output);
      return;
    ***REMOVED***

    // clean up jobs
    delete stream.jobs[key];

    return streamer.call(stream, error, ***REMOVED***key: key, value: output***REMOVED***, callback);
  ***REMOVED***;
***REMOVED***

/**
 * Stream wrapper for iterator callback
 *
 * @this  ReadableAsyncKit#
 * @param ***REMOVED***mixed***REMOVED*** error - error response
 * @param ***REMOVED***mixed***REMOVED*** output - iterator output
 * @param ***REMOVED***function***REMOVED*** callback - callback that expects iterator results
 */
function streamer(error, output, callback)
***REMOVED***
  if (error && !this.error)
  ***REMOVED***
    this.error = error;
    this.pause();
    this.emit('error', error);
    // send back value only, as expected
    callback(error, output && output.value);
    return;
  ***REMOVED***

  // stream stuff
  this.push(output);

  // back to original track
  // send back value only, as expected
  callback(error, output && output.value);
***REMOVED***

/**
 * Stream wrapper for finishing callback
 *
 * @this  ReadableAsyncKit#
 * @param ***REMOVED***mixed***REMOVED*** error - error response
 * @param ***REMOVED***mixed***REMOVED*** output - iterator output
 * @param ***REMOVED***function***REMOVED*** callback - callback that expects final results
 */
function finisher(error, output, callback)
***REMOVED***
  // signal end of the stream
  // only for successfully finished streams
  if (!error)
  ***REMOVED***
    this.push(null);
  ***REMOVED***

  // back to original track
  callback(error, output);
***REMOVED***
