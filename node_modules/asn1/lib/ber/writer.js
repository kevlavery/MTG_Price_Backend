// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('assert');
var ASN1 = require('./types');
var errors = require('./errors');


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;

var DEFAULT_OPTS = ***REMOVED***
  size: 1024,
  growthFactor: 8
***REMOVED***;


///--- Helpers

function merge(from, to) ***REMOVED***
  assert.ok(from);
  assert.equal(typeof(from), 'object');
  assert.ok(to);
  assert.equal(typeof(to), 'object');

  var keys = Object.getOwnPropertyNames(from);
  keys.forEach(function(key) ***REMOVED***
    if (to[key])
      return;

    var value = Object.getOwnPropertyDescriptor(from, key);
    Object.defineProperty(to, key, value);
  ***REMOVED***);

  return to;
***REMOVED***



///--- API

function Writer(options) ***REMOVED***
  options = merge(DEFAULT_OPTS, options || ***REMOVED******REMOVED***);

  this._buf = new Buffer(options.size || 1024);
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;

  // A list of offsets in the buffer where we need to insert
  // sequence tag/len pairs.
  this._seq = [];
***REMOVED***

Object.defineProperty(Writer.prototype, 'buffer', ***REMOVED***
  get: function () ***REMOVED***
    if (this._seq.length)
      throw new InvalidAsn1Error(this._seq.length + ' unended sequence(s)');

    return (this._buf.slice(0, this._offset));
  ***REMOVED***
***REMOVED***);

Writer.prototype.writeByte = function(b) ***REMOVED***
  if (typeof(b) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(1);
  this._buf[this._offset++] = b;
***REMOVED***;


Writer.prototype.writeInt = function(i, tag) ***REMOVED***
  if (typeof(i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof(tag) !== 'number')
    tag = ASN1.Integer;

  var sz = 4;

  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&
         (sz > 1)) ***REMOVED***
    sz--;
    i <<= 8;
  ***REMOVED***

  if (sz > 4)
    throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');

  this._ensure(2 + sz);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;

  while (sz-- > 0) ***REMOVED***
    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);
    i <<= 8;
  ***REMOVED***

***REMOVED***;


Writer.prototype.writeNull = function() ***REMOVED***
  this.writeByte(ASN1.Null);
  this.writeByte(0x00);
***REMOVED***;


Writer.prototype.writeEnumeration = function(i, tag) ***REMOVED***
  if (typeof(i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof(tag) !== 'number')
    tag = ASN1.Enumeration;

  return this.writeInt(i, tag);
***REMOVED***;


Writer.prototype.writeBoolean = function(b, tag) ***REMOVED***
  if (typeof(b) !== 'boolean')
    throw new TypeError('argument must be a Boolean');
  if (typeof(tag) !== 'number')
    tag = ASN1.Boolean;

  this._ensure(3);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 0x01;
  this._buf[this._offset++] = b ? 0xff : 0x00;
***REMOVED***;


Writer.prototype.writeString = function(s, tag) ***REMOVED***
  if (typeof(s) !== 'string')
    throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
  if (typeof(tag) !== 'number')
    tag = ASN1.OctetString;

  var len = Buffer.byteLength(s);
  this.writeByte(tag);
  this.writeLength(len);
  if (len) ***REMOVED***
    this._ensure(len);
    this._buf.write(s, this._offset);
    this._offset += len;
  ***REMOVED***
***REMOVED***;


Writer.prototype.writeBuffer = function(buf, tag) ***REMOVED***
  if (typeof(tag) !== 'number')
    throw new TypeError('tag must be a number');
  if (!Buffer.isBuffer(buf))
    throw new TypeError('argument must be a buffer');

  this.writeByte(tag);
  this.writeLength(buf.length);
  this._ensure(buf.length);
  buf.copy(this._buf, this._offset, 0, buf.length);
  this._offset += buf.length;
***REMOVED***;


Writer.prototype.writeStringArray = function(strings) ***REMOVED***
  if ((!strings instanceof Array))
    throw new TypeError('argument must be an Array[String]');

  var self = this;
  strings.forEach(function(s) ***REMOVED***
    self.writeString(s);
  ***REMOVED***);
***REMOVED***;

// This is really to solve DER cases, but whatever for now
Writer.prototype.writeOID = function(s, tag) ***REMOVED***
  if (typeof(s) !== 'string')
    throw new TypeError('argument must be a string');
  if (typeof(tag) !== 'number')
    tag = ASN1.OID;

  if (!/^([0-9]+\.)***REMOVED***3,***REMOVED***[0-9]+$/.test(s))
    throw new Error('argument is not a valid OID string');

  function encodeOctet(bytes, octet) ***REMOVED***
    if (octet < 128) ***REMOVED***
        bytes.push(octet);
    ***REMOVED*** else if (octet < 16384) ***REMOVED***
        bytes.push((octet >>> 7) | 0x80);
        bytes.push(octet & 0x7F);
    ***REMOVED*** else if (octet < 2097152) ***REMOVED***
      bytes.push((octet >>> 14) | 0x80);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    ***REMOVED*** else if (octet < 268435456) ***REMOVED***
      bytes.push((octet >>> 21) | 0x80);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    ***REMOVED*** else ***REMOVED***
      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    ***REMOVED***
  ***REMOVED***

  var tmp = s.split('.');
  var bytes = [];
  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
  tmp.slice(2).forEach(function(b) ***REMOVED***
    encodeOctet(bytes, parseInt(b, 10));
  ***REMOVED***);

  var self = this;
  this._ensure(2 + bytes.length);
  this.writeByte(tag);
  this.writeLength(bytes.length);
  bytes.forEach(function(b) ***REMOVED***
    self.writeByte(b);
  ***REMOVED***);
***REMOVED***;


Writer.prototype.writeLength = function(len) ***REMOVED***
  if (typeof(len) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(4);

  if (len <= 0x7f) ***REMOVED***
    this._buf[this._offset++] = len;
  ***REMOVED*** else if (len <= 0xff) ***REMOVED***
    this._buf[this._offset++] = 0x81;
    this._buf[this._offset++] = len;
  ***REMOVED*** else if (len <= 0xffff) ***REMOVED***
    this._buf[this._offset++] = 0x82;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  ***REMOVED*** else if (len <= 0xffffff) ***REMOVED***
    this._buf[this._offset++] = 0x83;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  ***REMOVED*** else ***REMOVED***
    throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
  ***REMOVED***
***REMOVED***;

Writer.prototype.startSequence = function(tag) ***REMOVED***
  if (typeof(tag) !== 'number')
    tag = ASN1.Sequence | ASN1.Constructor;

  this.writeByte(tag);
  this._seq.push(this._offset);
  this._ensure(3);
  this._offset += 3;
***REMOVED***;


Writer.prototype.endSequence = function() ***REMOVED***
  var seq = this._seq.pop();
  var start = seq + 3;
  var len = this._offset - start;

  if (len <= 0x7f) ***REMOVED***
    this._shift(start, len, -2);
    this._buf[seq] = len;
  ***REMOVED*** else if (len <= 0xff) ***REMOVED***
    this._shift(start, len, -1);
    this._buf[seq] = 0x81;
    this._buf[seq + 1] = len;
  ***REMOVED*** else if (len <= 0xffff) ***REMOVED***
    this._buf[seq] = 0x82;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
  ***REMOVED*** else if (len <= 0xffffff) ***REMOVED***
    this._shift(start, len, 1);
    this._buf[seq] = 0x83;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
  ***REMOVED*** else ***REMOVED***
    throw new InvalidAsn1Error('Sequence too long');
  ***REMOVED***
***REMOVED***;


Writer.prototype._shift = function(start, len, shift) ***REMOVED***
  assert.ok(start !== undefined);
  assert.ok(len !== undefined);
  assert.ok(shift);

  this._buf.copy(this._buf, start + shift, start, start + len);
  this._offset += shift;
***REMOVED***;

Writer.prototype._ensure = function(len) ***REMOVED***
  assert.ok(len);

  if (this._size - this._offset < len) ***REMOVED***
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len)
      sz += len;

    var buf = new Buffer(sz);

    this._buf.copy(buf, 0, 0, this._offset);
    this._buf = buf;
    this._size = sz;
  ***REMOVED***
***REMOVED***;



///--- Exported API

module.exports = Writer;
