'use strict';

var errors = require('./errors.js'),
    isFunction = require('lodash/isFunction'),
    isObjectLike = require('lodash/isObjectLike'),
    isString = require('lodash/isString'),
    isUndefined = require('lodash/isUndefined');


module.exports = function (options) ***REMOVED***

    var errorText = 'Please verify options'; // For better minification because this string is repeating

    if (!isObjectLike(options)) ***REMOVED***
        throw new TypeError(errorText);
    ***REMOVED***

    if (!isFunction(options.PromiseImpl)) ***REMOVED***
        throw new TypeError(errorText + '.PromiseImpl');
    ***REMOVED***

    if (!isUndefined(options.constructorMixin) && !isFunction(options.constructorMixin)) ***REMOVED***
        throw new TypeError(errorText + '.PromiseImpl');
    ***REMOVED***

    var PromiseImpl = options.PromiseImpl;
    var constructorMixin = options.constructorMixin;


    var plumbing = ***REMOVED******REMOVED***;

    plumbing.init = function (requestOptions) ***REMOVED***

        var self = this;

        self._rp_promise = new PromiseImpl(function (resolve, reject) ***REMOVED***
            self._rp_resolve = resolve;
            self._rp_reject = reject;
            if (constructorMixin) ***REMOVED***
                constructorMixin.apply(self, arguments); // Using arguments since specific Promise libraries may pass additional parameters
            ***REMOVED***
        ***REMOVED***);

        self._rp_callbackOrig = requestOptions.callback;
        requestOptions.callback = self.callback = function RP$callback(err, response, body) ***REMOVED***
            plumbing.callback.call(self, err, response, body);
        ***REMOVED***;

        if (isString(requestOptions.method)) ***REMOVED***
            requestOptions.method = requestOptions.method.toUpperCase();
        ***REMOVED***

        requestOptions.transform = requestOptions.transform || plumbing.defaultTransformations[requestOptions.method];

        self._rp_options = requestOptions;
        self._rp_options.simple = requestOptions.simple !== false;
        self._rp_options.resolveWithFullResponse = requestOptions.resolveWithFullResponse === true;
        self._rp_options.transform2xxOnly = requestOptions.transform2xxOnly === true;

    ***REMOVED***;

    plumbing.defaultTransformations = ***REMOVED***
        HEAD: function (body, response, resolveWithFullResponse) ***REMOVED***
            return resolveWithFullResponse ? response : response.headers;
        ***REMOVED***
    ***REMOVED***;

    plumbing.callback = function (err, response, body) ***REMOVED***

        var self = this;

        var origCallbackThrewException = false, thrownException = null;

        if (isFunction(self._rp_callbackOrig)) ***REMOVED***
            try ***REMOVED***
                self._rp_callbackOrig.apply(self, arguments); // TODO: Apply to self mimics behavior of request@2. Is that also right for request@next?
            ***REMOVED*** catch (e) ***REMOVED***
                origCallbackThrewException = true;
                thrownException = e;
            ***REMOVED***
        ***REMOVED***

        var is2xx = !err && /^2/.test('' + response.statusCode);

        if (err) ***REMOVED***

            self._rp_reject(new errors.RequestError(err, self._rp_options, response));

        ***REMOVED*** else if (self._rp_options.simple && !is2xx) ***REMOVED***

            if (isFunction(self._rp_options.transform) && self._rp_options.transform2xxOnly === false) ***REMOVED***

                (new PromiseImpl(function (resolve) ***REMOVED***
                    resolve(self._rp_options.transform(body, response, self._rp_options.resolveWithFullResponse)); // transform may return a Promise
                ***REMOVED***))
                    .then(function (transformedResponse) ***REMOVED***
                        self._rp_reject(new errors.StatusCodeError(response.statusCode, body, self._rp_options, transformedResponse));
                    ***REMOVED***)
                    .catch(function (transformErr) ***REMOVED***
                        self._rp_reject(new errors.TransformError(transformErr, self._rp_options, response));
                    ***REMOVED***);

            ***REMOVED*** else ***REMOVED***
                self._rp_reject(new errors.StatusCodeError(response.statusCode, body, self._rp_options, response));
            ***REMOVED***

        ***REMOVED*** else ***REMOVED***

            if (isFunction(self._rp_options.transform) && (is2xx || self._rp_options.transform2xxOnly === false)) ***REMOVED***

                (new PromiseImpl(function (resolve) ***REMOVED***
                    resolve(self._rp_options.transform(body, response, self._rp_options.resolveWithFullResponse)); // transform may return a Promise
                ***REMOVED***))
                    .then(function (transformedResponse) ***REMOVED***
                        self._rp_resolve(transformedResponse);
                    ***REMOVED***)
                    .catch(function (transformErr) ***REMOVED***
                        self._rp_reject(new errors.TransformError(transformErr, self._rp_options, response));
                    ***REMOVED***);

            ***REMOVED*** else if (self._rp_options.resolveWithFullResponse) ***REMOVED***
                self._rp_resolve(response);
            ***REMOVED*** else ***REMOVED***
                self._rp_resolve(body);
            ***REMOVED***

        ***REMOVED***

        if (origCallbackThrewException) ***REMOVED***
            throw thrownException;
        ***REMOVED***

    ***REMOVED***;

    plumbing.exposePromiseMethod = function (exposeTo, bindTo, promisePropertyKey, methodToExpose, exposeAs) ***REMOVED***

        exposeAs = exposeAs || methodToExpose;

        if (exposeAs in exposeTo) ***REMOVED***
            throw new Error('Unable to expose method "' + exposeAs + '"');
        ***REMOVED***

        exposeTo[exposeAs] = function RP$exposed() ***REMOVED***
            var self = bindTo || this;
            return self[promisePropertyKey][methodToExpose].apply(self[promisePropertyKey], arguments);
        ***REMOVED***;

    ***REMOVED***;

    plumbing.exposePromise = function (exposeTo, bindTo, promisePropertyKey, exposeAs) ***REMOVED***

        exposeAs = exposeAs || 'promise';

        if (exposeAs in exposeTo) ***REMOVED***
            throw new Error('Unable to expose method "' + exposeAs + '"');
        ***REMOVED***

        exposeTo[exposeAs] = function RP$promise() ***REMOVED***
            var self = bindTo || this;
            return self[promisePropertyKey];
        ***REMOVED***;

    ***REMOVED***;

    return plumbing;

***REMOVED***;
