(function() ***REMOVED***
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;

  ipaddr = ***REMOVED******REMOVED***;

  root = this;

  if ((typeof module !== "undefined" && module !== null) && module.exports) ***REMOVED***
    module.exports = ipaddr;
  ***REMOVED*** else ***REMOVED***
    root['ipaddr'] = ipaddr;
  ***REMOVED***

  matchCIDR = function(first, second, partSize, cidrBits) ***REMOVED***
    var part, shift;
    if (first.length !== second.length) ***REMOVED***
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    ***REMOVED***
    part = 0;
    while (cidrBits > 0) ***REMOVED***
      shift = partSize - cidrBits;
      if (shift < 0) ***REMOVED***
        shift = 0;
      ***REMOVED***
      if (first[part] >> shift !== second[part] >> shift) ***REMOVED***
        return false;
      ***REMOVED***
      cidrBits -= partSize;
      part += 1;
    ***REMOVED***
    return true;
  ***REMOVED***;

  ipaddr.subnetMatch = function(address, rangeList, defaultName) ***REMOVED***
    var k, len, rangeName, rangeSubnets, subnet;
    if (defaultName == null) ***REMOVED***
      defaultName = 'unicast';
    ***REMOVED***
    for (rangeName in rangeList) ***REMOVED***
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) ***REMOVED***
        rangeSubnets = [rangeSubnets];
      ***REMOVED***
      for (k = 0, len = rangeSubnets.length; k < len; k++) ***REMOVED***
        subnet = rangeSubnets[k];
        if (address.kind() === subnet[0].kind()) ***REMOVED***
          if (address.match.apply(address, subnet)) ***REMOVED***
            return rangeName;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    return defaultName;
  ***REMOVED***;

  ipaddr.IPv4 = (function() ***REMOVED***
    function IPv4(octets) ***REMOVED***
      var k, len, octet;
      if (octets.length !== 4) ***REMOVED***
        throw new Error("ipaddr: ipv4 octet count should be 4");
      ***REMOVED***
      for (k = 0, len = octets.length; k < len; k++) ***REMOVED***
        octet = octets[k];
        if (!((0 <= octet && octet <= 255))) ***REMOVED***
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        ***REMOVED***
      ***REMOVED***
      this.octets = octets;
    ***REMOVED***

    IPv4.prototype.kind = function() ***REMOVED***
      return 'ipv4';
    ***REMOVED***;

    IPv4.prototype.toString = function() ***REMOVED***
      return this.octets.join(".");
    ***REMOVED***;

    IPv4.prototype.toNormalizedString = function() ***REMOVED***
      return this.toString();
    ***REMOVED***;

    IPv4.prototype.toByteArray = function() ***REMOVED***
      return this.octets.slice(0);
    ***REMOVED***;

    IPv4.prototype.match = function(other, cidrRange) ***REMOVED***
      var ref;
      if (cidrRange === void 0) ***REMOVED***
        ref = other, other = ref[0], cidrRange = ref[1];
      ***REMOVED***
      if (other.kind() !== 'ipv4') ***REMOVED***
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      ***REMOVED***
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    ***REMOVED***;

    IPv4.prototype.SpecialRanges = ***REMOVED***
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    ***REMOVED***;

    IPv4.prototype.range = function() ***REMOVED***
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    ***REMOVED***;

    IPv4.prototype.toIPv4MappedAddress = function() ***REMOVED***
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    ***REMOVED***;

    IPv4.prototype.prefixLengthFromSubnetMask = function() ***REMOVED***
      var cidr, i, k, octet, stop, zeros, zerotable;
      zerotable = ***REMOVED***
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      ***REMOVED***;
      cidr = 0;
      stop = false;
      for (i = k = 3; k >= 0; i = k += -1) ***REMOVED***
        octet = this.octets[i];
        if (octet in zerotable) ***REMOVED***
          zeros = zerotable[octet];
          if (stop && zeros !== 0) ***REMOVED***
            return null;
          ***REMOVED***
          if (zeros !== 8) ***REMOVED***
            stop = true;
          ***REMOVED***
          cidr += zeros;
        ***REMOVED*** else ***REMOVED***
          return null;
        ***REMOVED***
      ***REMOVED***
      return 32 - cidr;
    ***REMOVED***;

    return IPv4;

  ***REMOVED***)();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = ***REMOVED***
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  ***REMOVED***;

  ipaddr.IPv4.parser = function(string) ***REMOVED***
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) ***REMOVED***
      if (string[0] === "0" && string[1] !== "x") ***REMOVED***
        return parseInt(string, 8);
      ***REMOVED*** else ***REMOVED***
        return parseInt(string);
      ***REMOVED***
    ***REMOVED***;
    if (match = string.match(ipv4Regexes.fourOctet)) ***REMOVED***
      return (function() ***REMOVED***
        var k, len, ref, results;
        ref = match.slice(1, 6);
        results = [];
        for (k = 0, len = ref.length; k < len; k++) ***REMOVED***
          part = ref[k];
          results.push(parseIntAuto(part));
        ***REMOVED***
        return results;
      ***REMOVED***)();
    ***REMOVED*** else if (match = string.match(ipv4Regexes.longValue)) ***REMOVED***
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) ***REMOVED***
        throw new Error("ipaddr: address outside defined range");
      ***REMOVED***
      return ((function() ***REMOVED***
        var k, results;
        results = [];
        for (shift = k = 0; k <= 24; shift = k += 8) ***REMOVED***
          results.push((value >> shift) & 0xff);
        ***REMOVED***
        return results;
      ***REMOVED***)()).reverse();
    ***REMOVED*** else ***REMOVED***
      return null;
    ***REMOVED***
  ***REMOVED***;

  ipaddr.IPv6 = (function() ***REMOVED***
    function IPv6(parts, zoneId) ***REMOVED***
      var i, k, l, len, part, ref;
      if (parts.length === 16) ***REMOVED***
        this.parts = [];
        for (i = k = 0; k <= 14; i = k += 2) ***REMOVED***
          this.parts.push((parts[i] << 8) | parts[i + 1]);
        ***REMOVED***
      ***REMOVED*** else if (parts.length === 8) ***REMOVED***
        this.parts = parts;
      ***REMOVED*** else ***REMOVED***
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      ***REMOVED***
      ref = this.parts;
      for (l = 0, len = ref.length; l < len; l++) ***REMOVED***
        part = ref[l];
        if (!((0 <= part && part <= 0xffff))) ***REMOVED***
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        ***REMOVED***
      ***REMOVED***
      if (zoneId) ***REMOVED***
        this.zoneId = zoneId;
      ***REMOVED***
    ***REMOVED***

    IPv6.prototype.kind = function() ***REMOVED***
      return 'ipv6';
    ***REMOVED***;

    IPv6.prototype.toString = function() ***REMOVED***
      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
    ***REMOVED***;

    IPv6.prototype.toByteArray = function() ***REMOVED***
      var bytes, k, len, part, ref;
      bytes = [];
      ref = this.parts;
      for (k = 0, len = ref.length; k < len; k++) ***REMOVED***
        part = ref[k];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      ***REMOVED***
      return bytes;
    ***REMOVED***;

    IPv6.prototype.toNormalizedString = function() ***REMOVED***
      var addr, part, suffix;
      addr = ((function() ***REMOVED***
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) ***REMOVED***
          part = ref[k];
          results.push(part.toString(16));
        ***REMOVED***
        return results;
      ***REMOVED***).call(this)).join(":");
      suffix = '';
      if (this.zoneId) ***REMOVED***
        suffix = '%' + this.zoneId;
      ***REMOVED***
      return addr + suffix;
    ***REMOVED***;

    IPv6.prototype.match = function(other, cidrRange) ***REMOVED***
      var ref;
      if (cidrRange === void 0) ***REMOVED***
        ref = other, other = ref[0], cidrRange = ref[1];
      ***REMOVED***
      if (other.kind() !== 'ipv6') ***REMOVED***
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      ***REMOVED***
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    ***REMOVED***;

    IPv6.prototype.SpecialRanges = ***REMOVED***
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    ***REMOVED***;

    IPv6.prototype.range = function() ***REMOVED***
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    ***REMOVED***;

    IPv6.prototype.isIPv4MappedAddress = function() ***REMOVED***
      return this.range() === 'ipv4Mapped';
    ***REMOVED***;

    IPv6.prototype.toIPv4Address = function() ***REMOVED***
      var high, low, ref;
      if (!this.isIPv4MappedAddress()) ***REMOVED***
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      ***REMOVED***
      ref = this.parts.slice(-2), high = ref[0], low = ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    ***REMOVED***;

    IPv6.prototype.prefixLengthFromSubnetMask = function() ***REMOVED***
      var cidr, i, k, part, stop, zeros, zerotable;
      zerotable = ***REMOVED***
        0: 16,
        32768: 15,
        49152: 14,
        57344: 13,
        61440: 12,
        63488: 11,
        64512: 10,
        65024: 9,
        65280: 8,
        65408: 7,
        65472: 6,
        65504: 5,
        65520: 4,
        65528: 3,
        65532: 2,
        65534: 1,
        65535: 0
      ***REMOVED***;
      cidr = 0;
      stop = false;
      for (i = k = 7; k >= 0; i = k += -1) ***REMOVED***
        part = this.parts[i];
        if (part in zerotable) ***REMOVED***
          zeros = zerotable[part];
          if (stop && zeros !== 0) ***REMOVED***
            return null;
          ***REMOVED***
          if (zeros !== 16) ***REMOVED***
            stop = true;
          ***REMOVED***
          cidr += zeros;
        ***REMOVED*** else ***REMOVED***
          return null;
        ***REMOVED***
      ***REMOVED***
      return 128 - cidr;
    ***REMOVED***;

    return IPv6;

  ***REMOVED***)();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  zoneIndex = "%[0-9a-z]***REMOVED***1,***REMOVED***";

  ipv6Regexes = ***REMOVED***
    zoneIndex: new RegExp(zoneIndex, 'i'),
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
  ***REMOVED***;

  expandIPv6 = function(string, parts) ***REMOVED***
    var colonCount, lastColon, part, replacement, replacementCount, zoneId;
    if (string.indexOf('::') !== string.lastIndexOf('::')) ***REMOVED***
      return null;
    ***REMOVED***
    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
    if (zoneId) ***REMOVED***
      zoneId = zoneId.substring(1);
      string = string.replace(/%.+$/, '');
    ***REMOVED***
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) ***REMOVED***
      colonCount++;
    ***REMOVED***
    if (string.substr(0, 2) === '::') ***REMOVED***
      colonCount--;
    ***REMOVED***
    if (string.substr(-2, 2) === '::') ***REMOVED***
      colonCount--;
    ***REMOVED***
    if (colonCount > parts) ***REMOVED***
      return null;
    ***REMOVED***
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) ***REMOVED***
      replacement += '0:';
    ***REMOVED***
    string = string.replace('::', replacement);
    if (string[0] === ':') ***REMOVED***
      string = string.slice(1);
    ***REMOVED***
    if (string[string.length - 1] === ':') ***REMOVED***
      string = string.slice(0, -1);
    ***REMOVED***
    parts = (function() ***REMOVED***
      var k, len, ref, results;
      ref = string.split(":");
      results = [];
      for (k = 0, len = ref.length; k < len; k++) ***REMOVED***
        part = ref[k];
        results.push(parseInt(part, 16));
      ***REMOVED***
      return results;
    ***REMOVED***)();
    return ***REMOVED***
      parts: parts,
      zoneId: zoneId
    ***REMOVED***;
  ***REMOVED***;

  ipaddr.IPv6.parser = function(string) ***REMOVED***
    var addr, k, len, match, octet, octets, zoneId;
    if (ipv6Regexes['native'].test(string)) ***REMOVED***
      return expandIPv6(string, 8);
    ***REMOVED*** else if (match = string.match(ipv6Regexes['transitional'])) ***REMOVED***
      zoneId = match[6] || '';
      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
      if (addr.parts) ***REMOVED***
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (k = 0, len = octets.length; k < len; k++) ***REMOVED***
          octet = octets[k];
          if (!((0 <= octet && octet <= 255))) ***REMOVED***
            return null;
          ***REMOVED***
        ***REMOVED***
        addr.parts.push(octets[0] << 8 | octets[1]);
        addr.parts.push(octets[2] << 8 | octets[3]);
        return ***REMOVED***
          parts: addr.parts,
          zoneId: addr.zoneId
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***
    return null;
  ***REMOVED***;

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) ***REMOVED***
    return this.parser(string) !== null;
  ***REMOVED***;

  ipaddr.IPv4.isValid = function(string) ***REMOVED***
    var e;
    try ***REMOVED***
      new this(this.parser(string));
      return true;
    ***REMOVED*** catch (error1) ***REMOVED***
      e = error1;
      return false;
    ***REMOVED***
  ***REMOVED***;

  ipaddr.IPv4.isValidFourPartDecimal = function(string) ***REMOVED***
    if (ipaddr.IPv4.isValid(string) && string.match(/^\d+(\.\d+)***REMOVED***3***REMOVED***$/)) ***REMOVED***
      return true;
    ***REMOVED*** else ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***;

  ipaddr.IPv6.isValid = function(string) ***REMOVED***
    var addr, e;
    if (typeof string === "string" && string.indexOf(":") === -1) ***REMOVED***
      return false;
    ***REMOVED***
    try ***REMOVED***
      addr = this.parser(string);
      new this(addr.parts, addr.zoneId);
      return true;
    ***REMOVED*** catch (error1) ***REMOVED***
      e = error1;
      return false;
    ***REMOVED***
  ***REMOVED***;

  ipaddr.IPv4.parse = function(string) ***REMOVED***
    var parts;
    parts = this.parser(string);
    if (parts === null) ***REMOVED***
      throw new Error("ipaddr: string is not formatted like ip address");
    ***REMOVED***
    return new this(parts);
  ***REMOVED***;

  ipaddr.IPv6.parse = function(string) ***REMOVED***
    var addr;
    addr = this.parser(string);
    if (addr.parts === null) ***REMOVED***
      throw new Error("ipaddr: string is not formatted like ip address");
    ***REMOVED***
    return new this(addr.parts, addr.zoneId);
  ***REMOVED***;

  ipaddr.IPv4.parseCIDR = function(string) ***REMOVED***
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) ***REMOVED***
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) ***REMOVED***
        return [this.parse(match[1]), maskLength];
      ***REMOVED***
    ***REMOVED***
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  ***REMOVED***;

  ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) ***REMOVED***
    var filledOctetCount, j, octets;
    prefix = parseInt(prefix);
    if (prefix < 0 || prefix > 32) ***REMOVED***
      throw new Error('ipaddr: invalid IPv4 prefix length');
    ***REMOVED***
    octets = [0, 0, 0, 0];
    j = 0;
    filledOctetCount = Math.floor(prefix / 8);
    while (j < filledOctetCount) ***REMOVED***
      octets[j] = 255;
      j++;
    ***REMOVED***
    if (filledOctetCount < 4) ***REMOVED***
      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
    ***REMOVED***
    return new this(octets);
  ***REMOVED***;

  ipaddr.IPv4.broadcastAddressFromCIDR = function(string) ***REMOVED***
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try ***REMOVED***
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) ***REMOVED***
        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
        i++;
      ***REMOVED***
      return new this(octets);
    ***REMOVED*** catch (error1) ***REMOVED***
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    ***REMOVED***
  ***REMOVED***;

  ipaddr.IPv4.networkAddressFromCIDR = function(string) ***REMOVED***
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try ***REMOVED***
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) ***REMOVED***
        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
        i++;
      ***REMOVED***
      return new this(octets);
    ***REMOVED*** catch (error1) ***REMOVED***
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    ***REMOVED***
  ***REMOVED***;

  ipaddr.IPv6.parseCIDR = function(string) ***REMOVED***
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) ***REMOVED***
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) ***REMOVED***
        return [this.parse(match[1]), maskLength];
      ***REMOVED***
    ***REMOVED***
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  ***REMOVED***;

  ipaddr.isValid = function(string) ***REMOVED***
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  ***REMOVED***;

  ipaddr.parse = function(string) ***REMOVED***
    if (ipaddr.IPv6.isValid(string)) ***REMOVED***
      return ipaddr.IPv6.parse(string);
    ***REMOVED*** else if (ipaddr.IPv4.isValid(string)) ***REMOVED***
      return ipaddr.IPv4.parse(string);
    ***REMOVED*** else ***REMOVED***
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    ***REMOVED***
  ***REMOVED***;

  ipaddr.parseCIDR = function(string) ***REMOVED***
    var e;
    try ***REMOVED***
      return ipaddr.IPv6.parseCIDR(string);
    ***REMOVED*** catch (error1) ***REMOVED***
      e = error1;
      try ***REMOVED***
        return ipaddr.IPv4.parseCIDR(string);
      ***REMOVED*** catch (error1) ***REMOVED***
        e = error1;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  ipaddr.fromByteArray = function(bytes) ***REMOVED***
    var length;
    length = bytes.length;
    if (length === 4) ***REMOVED***
      return new ipaddr.IPv4(bytes);
    ***REMOVED*** else if (length === 16) ***REMOVED***
      return new ipaddr.IPv6(bytes);
    ***REMOVED*** else ***REMOVED***
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    ***REMOVED***
  ***REMOVED***;

  ipaddr.process = function(string) ***REMOVED***
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) ***REMOVED***
      return addr.toIPv4Address();
    ***REMOVED*** else ***REMOVED***
      return addr;
    ***REMOVED***
  ***REMOVED***;

***REMOVED***).call(this);
