'use strict'

var caseless = require('caseless')
var uuid = require('uuid')
var helpers = require('./helpers')

var md5 = helpers.md5
var toBase64 = helpers.toBase64

function Auth (request) ***REMOVED***
  // define all public properties here
  this.request = request
  this.hasAuth = false
  this.sentAuth = false
  this.bearerToken = null
  this.user = null
  this.pass = null
***REMOVED***

Auth.prototype.basic = function (user, pass, sendImmediately) ***REMOVED***
  var self = this
  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) ***REMOVED***
    self.request.emit('error', new Error('auth() received invalid user or password'))
  ***REMOVED***
  self.user = user
  self.pass = pass
  self.hasAuth = true
  var header = user + ':' + (pass || '')
  if (sendImmediately || typeof sendImmediately === 'undefined') ***REMOVED***
    var authHeader = 'Basic ' + toBase64(header)
    self.sentAuth = true
    return authHeader
  ***REMOVED***
***REMOVED***

Auth.prototype.bearer = function (bearer, sendImmediately) ***REMOVED***
  var self = this
  self.bearerToken = bearer
  self.hasAuth = true
  if (sendImmediately || typeof sendImmediately === 'undefined') ***REMOVED***
    if (typeof bearer === 'function') ***REMOVED***
      bearer = bearer()
    ***REMOVED***
    var authHeader = 'Bearer ' + (bearer || '')
    self.sentAuth = true
    return authHeader
  ***REMOVED***
***REMOVED***

Auth.prototype.digest = function (method, path, authHeader) ***REMOVED***
  // TODO: More complete implementation of RFC 2617.
  //   - handle challenge.domain
  //   - support qop="auth-int" only
  //   - handle Authentication-Info (not necessarily?)
  //   - check challenge.stale (not necessarily?)
  //   - increase nc (not necessarily?)
  // For reference:
  // http://tools.ietf.org/html/rfc2617#section-3
  // https://github.com/bagder/curl/blob/master/lib/http_digest.c

  var self = this

  var challenge = ***REMOVED******REMOVED***
  var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi
  for (;;) ***REMOVED***
    var match = re.exec(authHeader)
    if (!match) ***REMOVED***
      break
    ***REMOVED***
    challenge[match[1]] = match[2] || match[3]
  ***REMOVED***

  /**
   * RFC 2617: handle both MD5 and MD5-sess algorithms.
   *
   * If the algorithm directive's value is "MD5" or unspecified, then HA1 is
   *   HA1=MD5(username:realm:password)
   * If the algorithm directive's value is "MD5-sess", then HA1 is
   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)
   */
  var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) ***REMOVED***
    var ha1 = md5(user + ':' + realm + ':' + pass)
    if (algorithm && algorithm.toLowerCase() === 'md5-sess') ***REMOVED***
      return md5(ha1 + ':' + nonce + ':' + cnonce)
    ***REMOVED*** else ***REMOVED***
      return ha1
    ***REMOVED***
  ***REMOVED***

  var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth'
  var nc = qop && '00000001'
  var cnonce = qop && uuid().replace(/-/g, '')
  var ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce)
  var ha2 = md5(method + ':' + path)
  var digestResponse = qop
    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)
    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)
  var authValues = ***REMOVED***
    username: self.user,
    realm: challenge.realm,
    nonce: challenge.nonce,
    uri: path,
    qop: qop,
    response: digestResponse,
    nc: nc,
    cnonce: cnonce,
    algorithm: challenge.algorithm,
    opaque: challenge.opaque
  ***REMOVED***

  authHeader = []
  for (var k in authValues) ***REMOVED***
    if (authValues[k]) ***REMOVED***
      if (k === 'qop' || k === 'nc' || k === 'algorithm') ***REMOVED***
        authHeader.push(k + '=' + authValues[k])
      ***REMOVED*** else ***REMOVED***
        authHeader.push(k + '="' + authValues[k] + '"')
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  authHeader = 'Digest ' + authHeader.join(', ')
  self.sentAuth = true
  return authHeader
***REMOVED***

Auth.prototype.onRequest = function (user, pass, sendImmediately, bearer) ***REMOVED***
  var self = this
  var request = self.request

  var authHeader
  if (bearer === undefined && user === undefined) ***REMOVED***
    self.request.emit('error', new Error('no auth mechanism defined'))
  ***REMOVED*** else if (bearer !== undefined) ***REMOVED***
    authHeader = self.bearer(bearer, sendImmediately)
  ***REMOVED*** else ***REMOVED***
    authHeader = self.basic(user, pass, sendImmediately)
  ***REMOVED***
  if (authHeader) ***REMOVED***
    request.setHeader('authorization', authHeader)
  ***REMOVED***
***REMOVED***

Auth.prototype.onResponse = function (response) ***REMOVED***
  var self = this
  var request = self.request

  if (!self.hasAuth || self.sentAuth) ***REMOVED*** return null ***REMOVED***

  var c = caseless(response.headers)

  var authHeader = c.get('www-authenticate')
  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()
  request.debug('reauth', authVerb)

  switch (authVerb) ***REMOVED***
    case 'basic':
      return self.basic(self.user, self.pass, true)

    case 'bearer':
      return self.bearer(self.bearerToken, true)

    case 'digest':
      return self.digest(request.method, request.path, authHeader)
  ***REMOVED***
***REMOVED***

exports.Auth = Auth
