'use strict';

// Load modules

const Dgram = require('dgram');
const Dns = require('dns');

const Hoek = require('hoek');


// Declare internals

const internals = ***REMOVED******REMOVED***;


exports.time = function (options, callback) ***REMOVED***

    if (arguments.length !== 2) ***REMOVED***
        callback = arguments[0];
        options = ***REMOVED******REMOVED***;
    ***REMOVED***

    const settings = Hoek.clone(options);
    settings.host = settings.host || 'time.google.com';
    settings.port = settings.port || 123;
    settings.resolveReference = settings.resolveReference || false;

    // Declare variables used by callback

    let timeoutId = null;
    let sent = 0;

    // Ensure callback is only called once

    const finish = Hoek.once((err, result) => ***REMOVED***

        clearTimeout(timeoutId);

        socket.removeAllListeners();
        socket.once('error', Hoek.ignore);

        try ***REMOVED***
            socket.close();
        ***REMOVED***
        catch (ignoreErr) ***REMOVED*** ***REMOVED***       // Ignore errors if the socket is already closed

        return callback(err, result);
    ***REMOVED***);

    // Set timeout

    if (settings.timeout) ***REMOVED***
        timeoutId = setTimeout(() => ***REMOVED***

            return finish(new Error('Timeout'));
        ***REMOVED***, settings.timeout);
    ***REMOVED***

    // Create UDP socket

    const socket = Dgram.createSocket('udp4');

    socket.once('error', (err) => finish(err));

    // Listen to incoming messages

    socket.on('message', (buffer, rinfo) => ***REMOVED***

        const received = Date.now();

        const message = new internals.NtpMessage(buffer);
        if (!message.isValid) ***REMOVED***
            return finish(new Error('Invalid server response'), message);
        ***REMOVED***

        if (message.originateTimestamp !== sent) ***REMOVED***
            return finish(new Error('Wrong originate timestamp'), message);
        ***REMOVED***

        // Timestamp Name          ID   When Generated
        // ------------------------------------------------------------
        // Originate Timestamp     T1   time request sent by client
        // Receive Timestamp       T2   time request received by server
        // Transmit Timestamp      T3   time reply sent by server
        // Destination Timestamp   T4   time reply received by client
        //
        // The roundtrip delay d and system clock offset t are defined as:
        //
        // d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2

        const T1 = message.originateTimestamp;
        const T2 = message.receiveTimestamp;
        const T3 = message.transmitTimestamp;
        const T4 = received;

        message.d = (T4 - T1) - (T3 - T2);
        message.t = ((T2 - T1) + (T3 - T4)) / 2;
        message.receivedLocally = received;

        if (!settings.resolveReference ||
            message.stratum !== 'secondary') ***REMOVED***

            return finish(null, message);
        ***REMOVED***

        // Resolve reference IP address

        Dns.reverse(message.referenceId, (err, domains) => ***REMOVED***

            if (/* $lab:coverage:off$ */ !err /* $lab:coverage:on$ */) ***REMOVED***
                message.referenceHost = domains[0];
            ***REMOVED***

            return finish(null, message);
        ***REMOVED***);
    ***REMOVED***);

    // Construct NTP message

    const message = new Buffer(48);
    for (let i = 0; i < 48; ++i) ***REMOVED***                      // Zero message
        message[i] = 0;
    ***REMOVED***

    message[0] = (0 << 6) + (4 << 3) + (3 << 0);        // Set version number to 4 and Mode to 3 (client)
    sent = Date.now();
    internals.fromMsecs(sent, message, 40);             // Set transmit timestamp (returns as originate)

    // Send NTP request

    socket.send(message, 0, message.length, settings.port, settings.host, (err, bytes) => ***REMOVED***

        if (err ||
            bytes !== 48) ***REMOVED***

            return finish(err || new Error('Could not send entire message'));
        ***REMOVED***
    ***REMOVED***);
***REMOVED***;


internals.NtpMessage = function (buffer) ***REMOVED***

    this.isValid = false;

    // Validate

    if (buffer.length !== 48) ***REMOVED***
        return;
    ***REMOVED***

    // Leap indicator

    const li = (buffer[0] >> 6);
    switch (li) ***REMOVED***
        case 0: this.leapIndicator = 'no-warning'; break;
        case 1: this.leapIndicator = 'last-minute-61'; break;
        case 2: this.leapIndicator = 'last-minute-59'; break;
        case 3: this.leapIndicator = 'alarm'; break;
    ***REMOVED***

    // Version

    const vn = ((buffer[0] & 0x38) >> 3);
    this.version = vn;

    // Mode

    const mode = (buffer[0] & 0x7);
    switch (mode) ***REMOVED***
        case 1: this.mode = 'symmetric-active'; break;
        case 2: this.mode = 'symmetric-passive'; break;
        case 3: this.mode = 'client'; break;
        case 4: this.mode = 'server'; break;
        case 5: this.mode = 'broadcast'; break;
        case 0:
        case 6:
        case 7: this.mode = 'reserved'; break;
    ***REMOVED***

    // Stratum

    const stratum = buffer[1];
    if (stratum === 0) ***REMOVED***
        this.stratum = 'death';
    ***REMOVED***
    else if (stratum === 1) ***REMOVED***
        this.stratum = 'primary';
    ***REMOVED***
    else if (stratum <= 15) ***REMOVED***
        this.stratum = 'secondary';
    ***REMOVED***
    else ***REMOVED***
        this.stratum = 'reserved';
    ***REMOVED***

    // Poll interval (msec)

    this.pollInterval = Math.round(Math.pow(2, buffer[2])) * 1000;

    // Precision (msecs)

    this.precision = Math.pow(2, buffer[3]) * 1000;

    // Root delay (msecs)

    const rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]) + buffer[6]) + buffer[7];
    this.rootDelay = 1000 * (rootDelay / 0x10000);

    // Root dispersion (msecs)

    this.rootDispersion = ((buffer[8] << 8) + buffer[9] + ((buffer[10] << 8) + buffer[11]) / Math.pow(2, 16)) * 1000;

    // Reference identifier

    this.referenceId = '';
    switch (this.stratum) ***REMOVED***
        case 'death':
        case 'primary':
            this.referenceId = String.fromCharCode(buffer[12]) + String.fromCharCode(buffer[13]) + String.fromCharCode(buffer[14]) + String.fromCharCode(buffer[15]);
            break;
        case 'secondary':
            this.referenceId = '' + buffer[12] + '.' + buffer[13] + '.' + buffer[14] + '.' + buffer[15];
            break;
    ***REMOVED***

    // Reference timestamp

    this.referenceTimestamp = internals.toMsecs(buffer, 16);

    // Originate timestamp

    this.originateTimestamp = internals.toMsecs(buffer, 24);

    // Receive timestamp

    this.receiveTimestamp = internals.toMsecs(buffer, 32);

    // Transmit timestamp

    this.transmitTimestamp = internals.toMsecs(buffer, 40);

    // Validate

    if (this.version === 4 &&
        this.stratum !== 'reserved' &&
        this.mode === 'server' &&
        this.originateTimestamp &&
        this.receiveTimestamp &&
        this.transmitTimestamp) ***REMOVED***

        this.isValid = true;
    ***REMOVED***

    return this;
***REMOVED***;


internals.toMsecs = function (buffer, offset) ***REMOVED***

    let seconds = 0;
    let fraction = 0;

    for (let i = 0; i < 4; ++i) ***REMOVED***
        seconds = (seconds * 256) + buffer[offset + i];
    ***REMOVED***

    for (let i = 4; i < 8; ++i) ***REMOVED***
        fraction = (fraction * 256) + buffer[offset + i];
    ***REMOVED***

    return ((seconds - 2208988800 + (fraction / Math.pow(2, 32))) * 1000);
***REMOVED***;


internals.fromMsecs = function (ts, buffer, offset) ***REMOVED***

    const seconds = Math.floor(ts / 1000) + 2208988800;
    const fraction = Math.round((ts % 1000) / 1000 * Math.pow(2, 32));

    buffer[offset + 0] = (seconds & 0xFF000000) >> 24;
    buffer[offset + 1] = (seconds & 0x00FF0000) >> 16;
    buffer[offset + 2] = (seconds & 0x0000FF00) >> 8;
    buffer[offset + 3] = (seconds & 0x000000FF);

    buffer[offset + 4] = (fraction & 0xFF000000) >> 24;
    buffer[offset + 5] = (fraction & 0x00FF0000) >> 16;
    buffer[offset + 6] = (fraction & 0x0000FF00) >> 8;
    buffer[offset + 7] = (fraction & 0x000000FF);
***REMOVED***;


// Offset singleton

internals.last = ***REMOVED***
    offset: 0,
    expires: 0,
    host: '',
    port: 0
***REMOVED***;


exports.offset = function (options, callback) ***REMOVED***

    if (arguments.length !== 2) ***REMOVED***
        callback = arguments[0];
        options = ***REMOVED******REMOVED***;
    ***REMOVED***

    const now = Date.now();
    const clockSyncRefresh = options.clockSyncRefresh || 24 * 60 * 60 * 1000;                    // Daily

    if (internals.last.offset &&
        internals.last.host === options.host &&
        internals.last.port === options.port &&
        now < internals.last.expires) ***REMOVED***

        process.nextTick(() => callback(null, internals.last.offset));
        return;
    ***REMOVED***

    exports.time(options, (err, time) => ***REMOVED***

        if (err) ***REMOVED***
            return callback(err, 0);
        ***REMOVED***

        internals.last = ***REMOVED***
            offset: Math.round(time.t),
            expires: now + clockSyncRefresh,
            host: options.host,
            port: options.port
        ***REMOVED***;

        return callback(null, internals.last.offset);
    ***REMOVED***);
***REMOVED***;


// Now singleton

internals.now = ***REMOVED***
    started: false,
    intervalId: null
***REMOVED***;


exports.start = function (options, callback) ***REMOVED***

    if (arguments.length !== 2) ***REMOVED***
        callback = arguments[0];
        options = ***REMOVED******REMOVED***;
    ***REMOVED***

    if (internals.now.started) ***REMOVED***
        process.nextTick(() => callback());
        return;
    ***REMOVED***

    const report = (err) => ***REMOVED***

        if (err &&
            options.onError) ***REMOVED***

            options.onError(err);
        ***REMOVED***
    ***REMOVED***;

    internals.now.started = true;
    exports.offset(options, (err, offset) => ***REMOVED***

        report(err);

        internals.now.intervalId = setInterval(() => ***REMOVED***

            exports.offset(options, report);
        ***REMOVED***, options.clockSyncRefresh || 24 * 60 * 60 * 1000);                                // Daily

        return callback();
    ***REMOVED***);
***REMOVED***;


exports.stop = function () ***REMOVED***

    if (!internals.now.started) ***REMOVED***
        return;
    ***REMOVED***

    clearInterval(internals.now.intervalId);
    internals.now.started = false;
    internals.now.intervalId = null;
***REMOVED***;


exports.isLive = function () ***REMOVED***

    return internals.now.started;
***REMOVED***;


exports.now = function () ***REMOVED***

    const now = Date.now();
    if (!exports.isLive() ||
        now >= internals.last.expires) ***REMOVED***

        return now;
    ***REMOVED***

    return now + internals.last.offset;
***REMOVED***;
