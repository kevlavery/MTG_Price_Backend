/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 1.0.1 Copyright (c) 2011-2016, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param ***REMOVED***Object***REMOVED*** module the "module" object that is defined by Node for the
 * current module.
 * @param ***REMOVED***Function***REMOVED*** [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns ***REMOVED***Function***REMOVED*** a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) ***REMOVED***
    'use strict';
    var defineCache = ***REMOVED******REMOVED***,
        loaderCache = ***REMOVED******REMOVED***,
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param ***REMOVED***Array***REMOVED*** ary the array of path segments.
     */
    function trimDots(ary) ***REMOVED***
        var i, part;
        for (i = 0; ary[i]; i+= 1) ***REMOVED***
            part = ary[i];
            if (part === '.') ***REMOVED***
                ary.splice(i, 1);
                i -= 1;
            ***REMOVED*** else if (part === '..') ***REMOVED***
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) ***REMOVED***
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                ***REMOVED*** else if (i > 0) ***REMOVED***
                    ary.splice(i - 1, 2);
                    i -= 2;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    function normalize(name, baseName) ***REMOVED***
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') ***REMOVED***
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) ***REMOVED***
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            ***REMOVED***
        ***REMOVED***

        return name;
    ***REMOVED***

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) ***REMOVED***
        return function (name) ***REMOVED***
            return normalize(name, relName);
        ***REMOVED***;
    ***REMOVED***

    function makeLoad(id) ***REMOVED***
        function load(value) ***REMOVED***
            loaderCache[id] = value;
        ***REMOVED***

        load.fromText = function (id, text) ***REMOVED***
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        ***REMOVED***;

        return load;
    ***REMOVED***

    makeRequire = function (systemRequire, exports, module, relId) ***REMOVED***
        function amdRequire(deps, callback) ***REMOVED***
            if (typeof deps === 'string') ***REMOVED***
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            ***REMOVED*** else ***REMOVED***
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) ***REMOVED***
                    return stringRequire(systemRequire, exports, module, depName, relId);
                ***REMOVED***);

                //Wait for next tick to call back the require call.
                if (callback) ***REMOVED***
                    process.nextTick(function () ***REMOVED***
                        callback.apply(null, deps);
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        amdRequire.toUrl = function (filePath) ***REMOVED***
            if (filePath.indexOf('.') === 0) ***REMOVED***
                return normalize(filePath, path.dirname(module.filename));
            ***REMOVED*** else ***REMOVED***
                return filePath;
            ***REMOVED***
        ***REMOVED***;

        return amdRequire;
    ***REMOVED***;

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() ***REMOVED***
        return module.require.apply(module, arguments);
    ***REMOVED***;

    function runFactory(id, deps, factory) ***REMOVED***
        var r, e, m, result;

        if (id) ***REMOVED***
            e = loaderCache[id] = ***REMOVED******REMOVED***;
            m = ***REMOVED***
                id: id,
                uri: __filename,
                exports: e
            ***REMOVED***;
            r = makeRequire(requireFn, e, m, id);
        ***REMOVED*** else ***REMOVED***
            //Only support one define call per file
            if (alreadyCalled) ***REMOVED***
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            ***REMOVED***
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        ***REMOVED***

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) ***REMOVED***
            deps = deps.map(function (depName) ***REMOVED***
                return r(depName);
            ***REMOVED***);
        ***REMOVED***

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') ***REMOVED***
            result = factory.apply(m.exports, deps);
        ***REMOVED*** else ***REMOVED***
            result = factory;
        ***REMOVED***

        if (result !== undefined) ***REMOVED***
            m.exports = result;
            if (id) ***REMOVED***
                loaderCache[id] = m.exports;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    stringRequire = function (systemRequire, exports, module, id, relId) ***REMOVED***
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) ***REMOVED***
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') ***REMOVED***
                return makeRequire(systemRequire, exports, module, relId);
            ***REMOVED*** else if (id === 'exports') ***REMOVED***
                return exports;
            ***REMOVED*** else if (id === 'module') ***REMOVED***
                return module;
            ***REMOVED*** else if (loaderCache.hasOwnProperty(id)) ***REMOVED***
                return loaderCache[id];
            ***REMOVED*** else if (defineCache[id]) ***REMOVED***
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            ***REMOVED*** else ***REMOVED***
                if(systemRequire) ***REMOVED***
                    return systemRequire(originalId);
                ***REMOVED*** else ***REMOVED***
                    throw new Error('No module with ID: ' + id);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) ***REMOVED***
                id = plugin.normalize(id, makeNormalize(relId));
            ***REMOVED*** else ***REMOVED***
                //Normalize the ID normally.
                id = normalize(id, relId);
            ***REMOVED***

            if (loaderCache[id]) ***REMOVED***
                return loaderCache[id];
            ***REMOVED*** else ***REMOVED***
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), ***REMOVED******REMOVED***);

                return loaderCache[id];
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) ***REMOVED***
        if (Array.isArray(id)) ***REMOVED***
            factory = deps;
            deps = id;
            id = undefined;
        ***REMOVED*** else if (typeof id !== 'string') ***REMOVED***
            factory = id;
            id = deps = undefined;
        ***REMOVED***

        if (deps && !Array.isArray(deps)) ***REMOVED***
            factory = deps;
            deps = undefined;
        ***REMOVED***

        if (!deps) ***REMOVED***
            deps = ['require', 'exports', 'module'];
        ***REMOVED***

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) ***REMOVED***
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        ***REMOVED*** else ***REMOVED***
            runFactory(id, deps, factory);
        ***REMOVED***
    ***REMOVED***

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) ***REMOVED***
        if (loaderCache[id]) ***REMOVED***
            return loaderCache[id];
        ***REMOVED***

        if (defineCache[id]) ***REMOVED***
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        ***REMOVED***
    ***REMOVED***;

    define.amd = ***REMOVED******REMOVED***;

    return define;
***REMOVED***

module.exports = amdefine;
