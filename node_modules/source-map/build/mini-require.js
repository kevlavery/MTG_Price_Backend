/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * Define a module along with a payload.
 * @param ***REMOVED***string***REMOVED*** moduleName Name for the payload
 * @param ***REMOVED***ignored***REMOVED*** deps Ignored. For compatibility with CommonJS AMD Spec
 * @param ***REMOVED***function***REMOVED*** payload Function with (require, exports, module) params
 */
function define(moduleName, deps, payload) ***REMOVED***
  if (typeof moduleName != "string") ***REMOVED***
    throw new TypeError('Expected string, got: ' + moduleName);
  ***REMOVED***

  if (arguments.length == 2) ***REMOVED***
    payload = deps;
  ***REMOVED***

  if (moduleName in define.modules) ***REMOVED***
    throw new Error("Module already defined: " + moduleName);
  ***REMOVED***
  define.modules[moduleName] = payload;
***REMOVED***;

/**
 * The global store of un-instantiated modules
 */
define.modules = ***REMOVED******REMOVED***;


/**
 * We invoke require() in the context of a Domain so we can have multiple
 * sets of modules running separate from each other.
 * This contrasts with JSMs which are singletons, Domains allows us to
 * optionally load a CommonJS module twice with separate data each time.
 * Perhaps you want 2 command lines with a different set of commands in each,
 * for example.
 */
function Domain() ***REMOVED***
  this.modules = ***REMOVED******REMOVED***;
  this._currentModule = null;
***REMOVED***

(function () ***REMOVED***

  /**
   * Lookup module names and resolve them by calling the definition function if
   * needed.
   * There are 2 ways to call this, either with an array of dependencies and a
   * callback to call when the dependencies are found (which can happen
   * asynchronously in an in-page context) or with a single string an no callback
   * where the dependency is resolved synchronously and returned.
   * The API is designed to be compatible with the CommonJS AMD spec and
   * RequireJS.
   * @param ***REMOVED***string[]|string***REMOVED*** deps A name, or names for the payload
   * @param ***REMOVED***function|undefined***REMOVED*** callback Function to call when the dependencies
   * are resolved
   * @return ***REMOVED***undefined|object***REMOVED*** The module required or undefined for
   * array/callback method
   */
  Domain.prototype.require = function(deps, callback) ***REMOVED***
    if (Array.isArray(deps)) ***REMOVED***
      var params = deps.map(function(dep) ***REMOVED***
        return this.lookup(dep);
      ***REMOVED***, this);
      if (callback) ***REMOVED***
        callback.apply(null, params);
      ***REMOVED***
      return undefined;
    ***REMOVED***
    else ***REMOVED***
      return this.lookup(deps);
    ***REMOVED***
  ***REMOVED***;

  function normalize(path) ***REMOVED***
    var bits = path.split('/');
    var i = 1;
    while (i < bits.length) ***REMOVED***
      if (bits[i] === '..') ***REMOVED***
        bits.splice(i-1, 1);
      ***REMOVED*** else if (bits[i] === '.') ***REMOVED***
        bits.splice(i, 1);
      ***REMOVED*** else ***REMOVED***
        i++;
      ***REMOVED***
    ***REMOVED***
    return bits.join('/');
  ***REMOVED***

  function join(a, b) ***REMOVED***
    a = a.trim();
    b = b.trim();
    if (/^\//.test(b)) ***REMOVED***
      return b;
    ***REMOVED*** else ***REMOVED***
      return a.replace(/\/*$/, '/') + b;
    ***REMOVED***
  ***REMOVED***

  function dirname(path) ***REMOVED***
    var bits = path.split('/');
    bits.pop();
    return bits.join('/');
  ***REMOVED***

  /**
   * Lookup module names and resolve them by calling the definition function if
   * needed.
   * @param ***REMOVED***string***REMOVED*** moduleName A name for the payload to lookup
   * @return ***REMOVED***object***REMOVED*** The module specified by aModuleName or null if not found.
   */
  Domain.prototype.lookup = function(moduleName) ***REMOVED***
    if (/^\./.test(moduleName)) ***REMOVED***
      moduleName = normalize(join(dirname(this._currentModule), moduleName));
    ***REMOVED***

    if (moduleName in this.modules) ***REMOVED***
      var module = this.modules[moduleName];
      return module;
    ***REMOVED***

    if (!(moduleName in define.modules)) ***REMOVED***
      throw new Error("Module not defined: " + moduleName);
    ***REMOVED***

    var module = define.modules[moduleName];

    if (typeof module == "function") ***REMOVED***
      var exports = ***REMOVED******REMOVED***;
      var previousModule = this._currentModule;
      this._currentModule = moduleName;
      module(this.require.bind(this), exports, ***REMOVED*** id: moduleName, uri: "" ***REMOVED***);
      this._currentModule = previousModule;
      module = exports;
    ***REMOVED***

    // cache the resulting module object for next time
    this.modules[moduleName] = module;

    return module;
  ***REMOVED***;

***REMOVED***());

define.Domain = Domain;
define.globalDomain = new Domain();
var require = define.globalDomain.require.bind(define.globalDomain);
