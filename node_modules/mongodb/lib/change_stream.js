'use strict';

var EventEmitter = require('events'),
  inherits = require('util').inherits,
  MongoNetworkError = require('mongodb-core').MongoNetworkError;

var cursorOptionNames = ['maxAwaitTimeMS', 'collation', 'readPreference'];

/**
 * Creates a new Change Stream instance. Normally created using ***REMOVED***@link Collection#watch|Collection.watch()***REMOVED***.
 * @class ChangeStream
 * @since 3.0.0
 * @param ***REMOVED***(Db|Collection)***REMOVED*** changeDomain The collection against which to create the change stream
 * @param ***REMOVED***Array***REMOVED*** pipeline An array of ***REMOVED***@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages***REMOVED*** through which to pass change stream documents
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings
 * @param ***REMOVED***string***REMOVED*** [options.fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.
 * @param ***REMOVED***number***REMOVED*** [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query
 * @param ***REMOVED***object***REMOVED*** [options.resumeAfter=null] Specifies the logical starting point for the new change stream. This should be the _id field from a previously returned change stream document.
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=null] The number of documents to return per batch. See ***REMOVED***@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation***REMOVED***.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation settings for operation. See ***REMOVED***@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation***REMOVED***.
 * @param ***REMOVED***ReadPreference***REMOVED*** [options.readPreference=null] The read preference. Defaults to the read preference of the database or collection. See ***REMOVED***@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation***REMOVED***.
 * @fires ChangeStream#close
 * @fires ChangeStream#change
 * @fires ChangeStream#end
 * @fires ChangeStream#error
 * @return ***REMOVED***ChangeStream***REMOVED*** a ChangeStream instance.
 */
var ChangeStream = function(collection, pipeline, options) ***REMOVED***
  var Collection = require('./collection');

  // Ensure the provided collection is actually a collection
  if (!(collection instanceof Collection)) ***REMOVED***
    throw new Error(
      'collection provided to ChangeStream constructor is not an instance of Collection'
    );
  ***REMOVED***

  var self = this;
  self.pipeline = pipeline || [];
  self.options = options || ***REMOVED******REMOVED***;
  self.promiseLibrary = collection.s.promiseLibrary;

  // Extract namespace and serverConfig from the collection
  self.namespace = ***REMOVED***
    collection: collection.collectionName,
    database: collection.s.db.databaseName
  ***REMOVED***;

  self.serverConfig = collection.s.db.serverConfig;

  // Determine correct read preference
  self.options.readPreference = self.options.readPreference || collection.s.readPreference;

  // Create contained Change Stream cursor
  self.cursor = createChangeStreamCursor(self);

  // Listen for any `change` listeners being added to ChangeStream
  self.on('newListener', function(eventName) ***REMOVED***
    if (eventName === 'change' && self.cursor && self.cursor.listenerCount('change') === 0) ***REMOVED***
      self.cursor.on('data', function(change) ***REMOVED***
        processNewChange(self, null, change);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***);

  // Listen for all `change` listeners being removed from ChangeStream
  self.on('removeListener', function(eventName) ***REMOVED***
    if (eventName === 'change' && self.listenerCount('change') === 0 && self.cursor) ***REMOVED***
      self.cursor.removeAllListeners('data');
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

inherits(ChangeStream, EventEmitter);

// Create a new change stream cursor based on self's configuration
var createChangeStreamCursor = function(self) ***REMOVED***
  if (self.resumeToken) ***REMOVED***
    self.options.resumeAfter = self.resumeToken;
  ***REMOVED***

  var changeStreamCursor = buildChangeStreamAggregationCommand(
    self.serverConfig,
    self.namespace,
    self.pipeline,
    self.resumeToken,
    self.options
  );

  /**
   * Fired for each new matching change in the specified namespace. Attaching a `change` event listener to a Change Stream will switch the stream into flowing mode. Data will then be passed as soon as it is available.
   *
   * @event ChangeStream#change
   * @type ***REMOVED***object***REMOVED***
   */
  if (self.listenerCount('change') > 0) ***REMOVED***
    changeStreamCursor.on('data', function(change) ***REMOVED***
      processNewChange(self, null, change);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Change stream close event
   *
   * @event ChangeStream#close
   * @type ***REMOVED***null***REMOVED***
   */
  changeStreamCursor.on('close', function() ***REMOVED***
    self.emit('close');
  ***REMOVED***);

  /**
   * Change stream end event
   *
   * @event ChangeStream#end
   * @type ***REMOVED***null***REMOVED***
   */
  changeStreamCursor.on('end', function() ***REMOVED***
    self.emit('end');
  ***REMOVED***);

  /**
   * Fired when the stream encounters an error.
   *
   * @event ChangeStream#error
   * @type ***REMOVED***Error***REMOVED***
   */
  changeStreamCursor.on('error', function(error) ***REMOVED***
    self.emit('error', error);
  ***REMOVED***);

  return changeStreamCursor;
***REMOVED***;

var buildChangeStreamAggregationCommand = function(
  serverConfig,
  namespace,
  pipeline,
  resumeToken,
  options
) ***REMOVED***
  var changeStreamStageOptions = ***REMOVED******REMOVED***;
  if (options.fullDocument) ***REMOVED***
    changeStreamStageOptions.fullDocument = options.fullDocument;
  ***REMOVED***

  if (resumeToken || options.resumeAfter) ***REMOVED***
    changeStreamStageOptions.resumeAfter = resumeToken || options.resumeAfter;
  ***REMOVED***

  // Map cursor options
  var cursorOptions = ***REMOVED******REMOVED***;
  cursorOptionNames.forEach(function(optionName) ***REMOVED***
    if (options[optionName]) ***REMOVED***
      cursorOptions[optionName] = options[optionName];
    ***REMOVED***
  ***REMOVED***);

  var changeStreamPipeline = [***REMOVED*** $changeStream: changeStreamStageOptions ***REMOVED***];

  changeStreamPipeline = changeStreamPipeline.concat(pipeline);

  var command = ***REMOVED***
    aggregate: namespace.collection,
    pipeline: changeStreamPipeline,
    readConcern: ***REMOVED*** level: 'majority' ***REMOVED***,
    cursor: ***REMOVED***
      batchSize: options.batchSize || 1
    ***REMOVED***
  ***REMOVED***;

  // Create and return the cursor
  return serverConfig.cursor(
    namespace.database + '.' + namespace.collection,
    command,
    cursorOptions
  );
***REMOVED***;

/**
 * Check if there is any document still available in the Change Stream
 * @function ChangeStream.prototype.hasNext
 * @param ***REMOVED***ChangeStream~resultCallback***REMOVED*** [callback] The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
ChangeStream.prototype.hasNext = function(callback) ***REMOVED***
  return this.cursor.hasNext(callback);
***REMOVED***;

/**
 * Get the next available document from the Change Stream, returns null if no more documents are available.
 * @function ChangeStream.prototype.next
 * @param ***REMOVED***ChangeStream~resultCallback***REMOVED*** [callback] The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
ChangeStream.prototype.next = function(callback) ***REMOVED***
  var self = this;
  if (this.isClosed()) ***REMOVED***
    if (callback) return callback(new Error('Change Stream is not open.'), null);
    return self.promiseLibrary.reject(new Error('Change Stream is not open.'));
  ***REMOVED***
  return this.cursor
    .next()
    .then(function(change) ***REMOVED***
      return processNewChange(self, null, change, callback);
    ***REMOVED***)
    .catch(function(err) ***REMOVED***
      return processNewChange(self, err, null, callback);
    ***REMOVED***);
***REMOVED***;

/**
 * Is the cursor closed
 * @method ChangeStream.prototype.isClosed
 * @return ***REMOVED***boolean***REMOVED***
 */
ChangeStream.prototype.isClosed = function() ***REMOVED***
  if (this.cursor) ***REMOVED***
    return this.cursor.isClosed();
  ***REMOVED***
  return true;
***REMOVED***;

/**
 * Close the Change Stream
 * @method ChangeStream.prototype.close
 * @param ***REMOVED***ChangeStream~resultCallback***REMOVED*** [callback] The result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
ChangeStream.prototype.close = function(callback) ***REMOVED***
  if (!this.cursor) ***REMOVED***
    if (callback) return callback();
    return this.promiseLibrary.resolve();
  ***REMOVED***

  // Tidy up the existing cursor
  var cursor = this.cursor;
  delete this.cursor;
  return cursor.close(callback);
***REMOVED***;

/**
 * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
 * @method
 * @param ***REMOVED***Writable***REMOVED*** destination The destination for writing data
 * @param ***REMOVED***object***REMOVED*** [options] ***REMOVED***@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options***REMOVED***
 * @return ***REMOVED***null***REMOVED***
 */
ChangeStream.prototype.pipe = function(destination, options) ***REMOVED***
  if (!this.pipeDestinations) ***REMOVED***
    this.pipeDestinations = [];
  ***REMOVED***
  this.pipeDestinations.push(destination);
  return this.cursor.pipe(destination, options);
***REMOVED***;

/**
 * This method will remove the hooks set up for a previous pipe() call.
 * @param ***REMOVED***Writable***REMOVED*** [destination] The destination for writing data
 * @return ***REMOVED***null***REMOVED***
 */
ChangeStream.prototype.unpipe = function(destination) ***REMOVED***
  if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) ***REMOVED***
    this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
  ***REMOVED***
  return this.cursor.unpipe(destination);
***REMOVED***;

/**
 * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
 * @return ***REMOVED***null***REMOVED***
 */
ChangeStream.prototype.pause = function() ***REMOVED***
  return this.cursor.pause();
***REMOVED***;

/**
 * This method will cause the readable stream to resume emitting data events.
 * @return ***REMOVED***null***REMOVED***
 */
ChangeStream.prototype.resume = function() ***REMOVED***
  return this.cursor.resume();
***REMOVED***;

/**
 * Return a modified Readable stream including a possible transform method.
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***function***REMOVED*** [options.transform=null] A transformation method applied to each document emitted by the stream.
 * @return ***REMOVED***Cursor***REMOVED***
 */
ChangeStream.prototype.stream = function(options) ***REMOVED***
  this.streamOptions = options;
  return this.cursor.stream(options);
***REMOVED***;

// Handle new change events. This method brings together the routes from the callback, event emitter, and promise ways of using ChangeStream.
var processNewChange = function(self, err, change, callback) ***REMOVED***
  // Handle errors
  if (err) ***REMOVED***
    // Handle resumable MongoNetworkErrors
    if (err instanceof MongoNetworkError && !self.attemptingResume) ***REMOVED***
      self.attemptingResume = true;
      return self.cursor.close(function(closeErr) ***REMOVED***
        if (closeErr) ***REMOVED***
          if (callback) return callback(err, null);
          return self.promiseLibrary.reject(err);
        ***REMOVED***

        // Establish a new cursor
        self.cursor = createChangeStreamCursor(self);

        // Attempt to reconfigure piping
        if (self.pipeDestinations) ***REMOVED***
          var cursorStream = self.cursor.stream(self.streamOptions);
          for (var pipeDestination in self.pipeDestinations) ***REMOVED***
            cursorStream.pipe(pipeDestination);
          ***REMOVED***
        ***REMOVED***

        // Attempt the next() operation again
        if (callback) return self.next(callback);
        return self.next();
      ***REMOVED***);
    ***REMOVED***

    if (typeof callback === 'function') return callback(err, null);
    if (self.listenerCount('error')) return self.emit('error', err);
    return self.promiseLibrary.reject(err);
  ***REMOVED***
  self.attemptingResume = false;

  // Cache the resume token if it is present. If it is not present return an error.
  if (!change || !change._id) ***REMOVED***
    var noResumeTokenError = new Error(
      'A change stream document has been received that lacks a resume token (_id).'
    );
    if (typeof callback === 'function') return callback(noResumeTokenError, null);
    if (self.listenerCount('error')) return self.emit('error', noResumeTokenError);
    return self.promiseLibrary.reject(noResumeTokenError);
  ***REMOVED***
  self.resumeToken = change._id;

  // Return the change
  if (typeof callback === 'function') return callback(err, change);
  if (self.listenerCount('change')) return self.emit('change', change);
  return self.promiseLibrary.resolve(change);
***REMOVED***;

/**
 * The callback format for results
 * @callback ChangeStream~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***(object|null)***REMOVED*** result The result object if the command was executed successfully.
 */

module.exports = ChangeStream;
