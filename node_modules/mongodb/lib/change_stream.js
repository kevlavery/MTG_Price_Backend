'use strict';

const EventEmitter = require('events');
const isResumableError = require('./error').isResumableError;
const MongoError = require('mongodb-core').MongoError;

var cursorOptionNames = ['maxAwaitTimeMS', 'collation', 'readPreference'];

const CHANGE_DOMAIN_TYPES = ***REMOVED***
  COLLECTION: Symbol('Collection'),
  DATABASE: Symbol('Database'),
  CLUSTER: Symbol('Cluster')
***REMOVED***;

/**
 * Creates a new Change Stream instance. Normally created using ***REMOVED***@link Collection#watch|Collection.watch()***REMOVED***.
 * @class ChangeStream
 * @since 3.0.0
 * @param ***REMOVED***(MongoClient|Db|Collection)***REMOVED*** changeDomain The domain against which to create the change stream
 * @param ***REMOVED***Array***REMOVED*** pipeline An array of ***REMOVED***@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages***REMOVED*** through which to pass change stream documents
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***string***REMOVED*** [options.fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.
 * @param ***REMOVED***number***REMOVED*** [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query
 * @param ***REMOVED***object***REMOVED*** [options.resumeAfter] Specifies the logical starting point for the new change stream. This should be the _id field from a previously returned change stream document.
 * @param ***REMOVED***number***REMOVED*** [options.batchSize] The number of documents to return per batch. See ***REMOVED***@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation***REMOVED***.
 * @param ***REMOVED***object***REMOVED*** [options.collation] Specify collation settings for operation. See ***REMOVED***@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation***REMOVED***.
 * @param ***REMOVED***ReadPreference***REMOVED*** [options.readPreference] The read preference. Defaults to the read preference of the database or collection. See ***REMOVED***@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation***REMOVED***.
 * @fires ChangeStream#close
 * @fires ChangeStream#change
 * @fires ChangeStream#end
 * @fires ChangeStream#error
 * @return ***REMOVED***ChangeStream***REMOVED*** a ChangeStream instance.
 */

class ChangeStream extends EventEmitter ***REMOVED***
  constructor(changeDomain, pipeline, options) ***REMOVED***
    super();
    const Collection = require('./collection');
    const Db = require('./db');
    const MongoClient = require('./mongo_client');

    this.pipeline = pipeline || [];
    this.options = options || ***REMOVED******REMOVED***;
    this.cursorNamespace = undefined;
    this.namespace = ***REMOVED******REMOVED***;

    if (changeDomain instanceof Collection) ***REMOVED***
      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
      this.serverConfig = changeDomain.s.db.serverConfig;

      this.namespace = ***REMOVED***
        collection: changeDomain.collectionName,
        database: changeDomain.s.db.databaseName
      ***REMOVED***;

      this.cursorNamespace = `$***REMOVED***this.namespace.database***REMOVED***.$***REMOVED***this.namespace.collection***REMOVED***`;
    ***REMOVED*** else if (changeDomain instanceof Db) ***REMOVED***
      this.type = CHANGE_DOMAIN_TYPES.DATABASE;
      this.namespace = ***REMOVED*** collection: '', database: changeDomain.databaseName ***REMOVED***;
      this.cursorNamespace = this.namespace.database;
      this.serverConfig = changeDomain.serverConfig;
    ***REMOVED*** else if (changeDomain instanceof MongoClient) ***REMOVED***
      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
      this.namespace = ***REMOVED*** collection: '', database: 'admin' ***REMOVED***;
      this.cursorNamespace = this.namespace.database;
      this.serverConfig = changeDomain.topology;
    ***REMOVED*** else ***REMOVED***
      throw new TypeError(
        'changeDomain provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient'
      );
    ***REMOVED***

    this.promiseLibrary = changeDomain.s.promiseLibrary;
    if (!this.options.readPreference && changeDomain.s.readPreference) ***REMOVED***
      this.options.readPreference = changeDomain.s.readPreference;
    ***REMOVED***

    // We need to get the operationTime as early as possible
    const isMaster = this.serverConfig.lastIsMaster();
    if (!isMaster) ***REMOVED***
      throw new MongoError('ServerConfig does not have an ismaster yet.');
    ***REMOVED***

    this.operationTime = isMaster.operationTime;

    // Create contained Change Stream cursor
    this.cursor = createChangeStreamCursor(this);

    // Listen for any `change` listeners being added to ChangeStream
    this.on('newListener', eventName => ***REMOVED***
      if (eventName === 'change' && this.cursor && this.cursor.listenerCount('change') === 0) ***REMOVED***
        this.cursor.on('data', change => processNewChange(this, null, change));
      ***REMOVED***
    ***REMOVED***);

    // Listen for all `change` listeners being removed from ChangeStream
    this.on('removeListener', eventName => ***REMOVED***
      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) ***REMOVED***
        this.cursor.removeAllListeners('data');
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  /**
   * Check if there is any document still available in the Change Stream
   * @function ChangeStream.prototype.hasNext
   * @param ***REMOVED***ChangeStream~resultCallback***REMOVED*** [callback] The result callback.
   * @throws ***REMOVED***MongoError***REMOVED***
   * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
   */
  hasNext(callback) ***REMOVED***
    return this.cursor.hasNext(callback);
  ***REMOVED***

  /**
   * Get the next available document from the Change Stream, returns null if no more documents are available.
   * @function ChangeStream.prototype.next
   * @param ***REMOVED***ChangeStream~resultCallback***REMOVED*** [callback] The result callback.
   * @throws ***REMOVED***MongoError***REMOVED***
   * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
   */
  next(callback) ***REMOVED***
    var self = this;
    if (this.isClosed()) ***REMOVED***
      if (callback) return callback(new Error('Change Stream is not open.'), null);
      return self.promiseLibrary.reject(new Error('Change Stream is not open.'));
    ***REMOVED***
    return this.cursor
      .next()
      .then(function(change) ***REMOVED***
        return processNewChange(self, null, change, callback);
      ***REMOVED***)
      .catch(function(err) ***REMOVED***
        return processNewChange(self, err, null, callback);
      ***REMOVED***);
  ***REMOVED***

  /**
   * Is the cursor closed
   * @method ChangeStream.prototype.isClosed
   * @return ***REMOVED***boolean***REMOVED***
   */
  isClosed() ***REMOVED***
    if (this.cursor) ***REMOVED***
      return this.cursor.isClosed();
    ***REMOVED***
    return true;
  ***REMOVED***

  /**
   * Close the Change Stream
   * @method ChangeStream.prototype.close
   * @param ***REMOVED***ChangeStream~resultCallback***REMOVED*** [callback] The result callback.
   * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
   */
  close(callback) ***REMOVED***
    if (!this.cursor) ***REMOVED***
      if (callback) return callback();
      return this.promiseLibrary.resolve();
    ***REMOVED***

    // Tidy up the existing cursor
    var cursor = this.cursor;
    delete this.cursor;
    return cursor.close(callback);
  ***REMOVED***

  /**
   * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
   * @method
   * @param ***REMOVED***Writable***REMOVED*** destination The destination for writing data
   * @param ***REMOVED***object***REMOVED*** [options] ***REMOVED***@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options***REMOVED***
   * @return ***REMOVED***null***REMOVED***
   */
  pipe(destination, options) ***REMOVED***
    if (!this.pipeDestinations) ***REMOVED***
      this.pipeDestinations = [];
    ***REMOVED***
    this.pipeDestinations.push(destination);
    return this.cursor.pipe(destination, options);
  ***REMOVED***

  /**
   * This method will remove the hooks set up for a previous pipe() call.
   * @param ***REMOVED***Writable***REMOVED*** [destination] The destination for writing data
   * @return ***REMOVED***null***REMOVED***
   */
  unpipe(destination) ***REMOVED***
    if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) ***REMOVED***
      this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
    ***REMOVED***
    return this.cursor.unpipe(destination);
  ***REMOVED***

  /**
   * Return a modified Readable stream including a possible transform method.
   * @method
   * @param ***REMOVED***object***REMOVED*** [options] Optional settings.
   * @param ***REMOVED***function***REMOVED*** [options.transform] A transformation method applied to each document emitted by the stream.
   * @return ***REMOVED***Cursor***REMOVED***
   */
  stream(options) ***REMOVED***
    this.streamOptions = options;
    return this.cursor.stream(options);
  ***REMOVED***

  /**
   * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
   * @return ***REMOVED***null***REMOVED***
   */
  pause() ***REMOVED***
    return this.cursor.pause();
  ***REMOVED***

  /**
   * This method will cause the readable stream to resume emitting data events.
   * @return ***REMOVED***null***REMOVED***
   */
  resume() ***REMOVED***
    return this.cursor.resume();
  ***REMOVED***
***REMOVED***

// Create a new change stream cursor based on self's configuration
var createChangeStreamCursor = function(self) ***REMOVED***
  if (self.resumeToken) ***REMOVED***
    self.options.resumeAfter = self.resumeToken;
  ***REMOVED***

  var changeStreamCursor = buildChangeStreamAggregationCommand(self);

  /**
   * Fired for each new matching change in the specified namespace. Attaching a `change` event listener to a Change Stream will switch the stream into flowing mode. Data will then be passed as soon as it is available.
   *
   * @event ChangeStream#change
   * @type ***REMOVED***object***REMOVED***
   */
  if (self.listenerCount('change') > 0) ***REMOVED***
    changeStreamCursor.on('data', function(change) ***REMOVED***
      processNewChange(self, null, change);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Change stream close event
   *
   * @event ChangeStream#close
   * @type ***REMOVED***null***REMOVED***
   */
  changeStreamCursor.on('close', function() ***REMOVED***
    self.emit('close');
  ***REMOVED***);

  /**
   * Change stream end event
   *
   * @event ChangeStream#end
   * @type ***REMOVED***null***REMOVED***
   */
  changeStreamCursor.on('end', function() ***REMOVED***
    self.emit('end');
  ***REMOVED***);

  /**
   * Fired when the stream encounters an error.
   *
   * @event ChangeStream#error
   * @type ***REMOVED***Error***REMOVED***
   */
  changeStreamCursor.on('error', function(error) ***REMOVED***
    self.emit('error', error);
  ***REMOVED***);

  if (self.pipeDestinations) ***REMOVED***
    const cursorStream = changeStreamCursor.stream(self.streamOptions);
    for (let pipeDestination in self.pipeDestinations) ***REMOVED***
      cursorStream.pipe(pipeDestination);
    ***REMOVED***
  ***REMOVED***

  return changeStreamCursor;
***REMOVED***;

function getResumeToken(self) ***REMOVED***
  return self.resumeToken || self.options.resumeAfter;
***REMOVED***

function getStartAtOperationTime(self) ***REMOVED***
  const isMaster = self.serverConfig.lastIsMaster() || ***REMOVED******REMOVED***;
  return (
    isMaster.maxWireVersion && isMaster.maxWireVersion >= 7 && self.options.startAtOperationTime
  );
***REMOVED***

var buildChangeStreamAggregationCommand = function(self) ***REMOVED***
  const serverConfig = self.serverConfig;
  const namespace = self.namespace;
  const pipeline = self.pipeline;
  const options = self.options;
  const cursorNamespace = self.cursorNamespace;

  var changeStreamStageOptions = ***REMOVED***
    fullDocument: options.fullDocument || 'default'
  ***REMOVED***;

  const resumeToken = getResumeToken(self);
  const startAtOperationTime = getStartAtOperationTime(self);
  if (resumeToken) ***REMOVED***
    changeStreamStageOptions.resumeAfter = resumeToken;
  ***REMOVED***

  if (startAtOperationTime) ***REMOVED***
    changeStreamStageOptions.startAtOperationTime = startAtOperationTime;
  ***REMOVED***

  // Map cursor options
  var cursorOptions = ***REMOVED******REMOVED***;
  cursorOptionNames.forEach(function(optionName) ***REMOVED***
    if (options[optionName]) ***REMOVED***
      cursorOptions[optionName] = options[optionName];
    ***REMOVED***
  ***REMOVED***);

  if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) ***REMOVED***
    changeStreamStageOptions.allChangesForCluster = true;
  ***REMOVED***

  var changeStreamPipeline = [***REMOVED*** $changeStream: changeStreamStageOptions ***REMOVED***];

  changeStreamPipeline = changeStreamPipeline.concat(pipeline);

  var command = ***REMOVED***
    aggregate: self.type === CHANGE_DOMAIN_TYPES.COLLECTION ? namespace.collection : 1,
    pipeline: changeStreamPipeline,
    readConcern: ***REMOVED*** level: 'majority' ***REMOVED***,
    cursor: ***REMOVED***
      batchSize: options.batchSize || 1
    ***REMOVED***
  ***REMOVED***;

  // Create and return the cursor
  return serverConfig.cursor(cursorNamespace, command, cursorOptions);
***REMOVED***;

// Handle new change events. This method brings together the routes from the callback, event emitter, and promise ways of using ChangeStream.
var processNewChange = function(self, err, change, callback) ***REMOVED***
  // Handle errors
  if (err) ***REMOVED***
    // Handle resumable MongoNetworkErrors
    if (isResumableError(err) && !self.attemptingResume) ***REMOVED***
      self.attemptingResume = true;

      if (!(getResumeToken(self) || getStartAtOperationTime(self))) ***REMOVED***
        const startAtOperationTime = self.cursor.cursorState.operationTime;
        self.options = Object.assign(***REMOVED*** startAtOperationTime ***REMOVED***, self.options);
      ***REMOVED***

      if (callback) ***REMOVED***
        return self.cursor.close(function(closeErr) ***REMOVED***
          if (closeErr) ***REMOVED***
            return callback(err, null);
          ***REMOVED***

          self.cursor = createChangeStreamCursor(self);

          return self.next(callback);
        ***REMOVED***);
      ***REMOVED***

      return self.cursor
        .close()
        .then(() => (self.cursor = createChangeStreamCursor(self)))
        .then(() => self.next());
    ***REMOVED***

    if (typeof callback === 'function') return callback(err, null);
    if (self.listenerCount('error')) return self.emit('error', err);
    return self.promiseLibrary.reject(err);
  ***REMOVED***
  self.attemptingResume = false;

  // Cache the resume token if it is present. If it is not present return an error.
  if (!change || !change._id) ***REMOVED***
    var noResumeTokenError = new Error(
      'A change stream document has been received that lacks a resume token (_id).'
    );
    if (typeof callback === 'function') return callback(noResumeTokenError, null);
    if (self.listenerCount('error')) return self.emit('error', noResumeTokenError);
    return self.promiseLibrary.reject(noResumeTokenError);
  ***REMOVED***
  self.resumeToken = change._id;

  // Return the change
  if (typeof callback === 'function') return callback(err, change);
  if (self.listenerCount('change')) return self.emit('change', change);
  return self.promiseLibrary.resolve(change);
***REMOVED***;

/**
 * The callback format for results
 * @callback ChangeStream~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***(object|null)***REMOVED*** result The result object if the command was executed successfully.
 */

module.exports = ChangeStream;
