'use strict';

const checkCollectionName = require('./utils').checkCollectionName;
const ObjectID = require('mongodb-core').BSON.ObjectID;
const Long = require('mongodb-core').BSON.Long;
const Code = require('mongodb-core').BSON.Code;
const f = require('util').format;
const AggregationCursor = require('./aggregation_cursor');
const MongoError = require('mongodb-core').MongoError;
const shallowClone = require('./utils').shallowClone;
const isObject = require('./utils').isObject;
const toError = require('./utils').toError;
const normalizeHintField = require('./utils').normalizeHintField;
const handleCallback = require('./utils').handleCallback;
const decorateCommand = require('./utils').decorateCommand;
const formattedOrderClause = require('./utils').formattedOrderClause;
const ReadPreference = require('mongodb-core').ReadPreference;
const CommandCursor = require('./command_cursor');
const unordered = require('./bulk/unordered');
const ordered = require('./bulk/ordered');
const ChangeStream = require('./change_stream');
const executeOperation = require('./utils').executeOperation;
const applyWriteConcern = require('./utils').applyWriteConcern;

/**
 * @fileOverview The **Collection** class is an internal class that embodies a MongoDB collection
 * allowing for insert/update/remove/find and other command operation on that MongoDB collection.
 *
 * **COLLECTION Cannot directly be instantiated**
 * @example
 * const MongoClient = require('mongodb').MongoClient;
 * const test = require('assert');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) ***REMOVED***
 *   // Create a collection we want to drop later
 *   const col = client.db(dbName).collection('createIndexExample1');
 *   // Show that duplicate records got dropped
 *   col.find(***REMOVED******REMOVED***).toArray(function(err, items) ***REMOVED***
 *     test.equal(null, err);
 *     test.equal(4, items.length);
 *     client.close();
 *   ***REMOVED***);
 * ***REMOVED***);
 */

var mergeKeys = ['readPreference', 'ignoreUndefined'];

/**
 * Create a new Collection instance (INTERNAL TYPE, do not instantiate directly)
 * @class
 * @property ***REMOVED***string***REMOVED*** collectionName Get the collection name.
 * @property ***REMOVED***string***REMOVED*** namespace Get the full collection namespace.
 * @property ***REMOVED***object***REMOVED*** writeConcern The current write concern values.
 * @property ***REMOVED***object***REMOVED*** readConcern The current read concern values.
 * @property ***REMOVED***object***REMOVED*** hint Get current index hint for collection.
 * @return ***REMOVED***Collection***REMOVED*** a Collection instance.
 */
var Collection = function(db, topology, dbName, name, pkFactory, options) ***REMOVED***
  checkCollectionName(name);

  // Unpack variables
  var internalHint = null;
  var slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
  var serializeFunctions =
    options == null || options.serializeFunctions == null
      ? db.s.options.serializeFunctions
      : options.serializeFunctions;
  var raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
  var promoteLongs =
    options == null || options.promoteLongs == null
      ? db.s.options.promoteLongs
      : options.promoteLongs;
  var promoteValues =
    options == null || options.promoteValues == null
      ? db.s.options.promoteValues
      : options.promoteValues;
  var promoteBuffers =
    options == null || options.promoteBuffers == null
      ? db.s.options.promoteBuffers
      : options.promoteBuffers;
  var readPreference = null;
  var collectionHint = null;
  var namespace = f('%s.%s', dbName, name);

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary || Promise;

  // Assign the right collection level readPreference
  if (options && options.readPreference) ***REMOVED***
    readPreference = options.readPreference;
  ***REMOVED*** else if (db.options.readPreference) ***REMOVED***
    readPreference = db.options.readPreference;
  ***REMOVED***

  // Set custom primary key factory if provided
  pkFactory = pkFactory == null ? ObjectID : pkFactory;

  // Internal state
  this.s = ***REMOVED***
    // Set custom primary key factory if provided
    pkFactory: pkFactory,
    // Db
    db: db,
    // Topology
    topology: topology,
    // dbName
    dbName: dbName,
    // Options
    options: options,
    // Namespace
    namespace: namespace,
    // Read preference
    readPreference: readPreference,
    // SlaveOK
    slaveOk: slaveOk,
    // Serialize functions
    serializeFunctions: serializeFunctions,
    // Raw
    raw: raw,
    // promoteLongs
    promoteLongs: promoteLongs,
    // promoteValues
    promoteValues: promoteValues,
    // promoteBuffers
    promoteBuffers: promoteBuffers,
    // internalHint
    internalHint: internalHint,
    // collectionHint
    collectionHint: collectionHint,
    // Name
    name: name,
    // Promise library
    promiseLibrary: promiseLibrary,
    // Read Concern
    readConcern: options.readConcern
  ***REMOVED***;
***REMOVED***;

Object.defineProperty(Collection.prototype, 'dbName', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.dbName;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'collectionName', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.name;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'namespace', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.namespace;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'readConcern', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.readConcern || ***REMOVED*** level: 'local' ***REMOVED***;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'writeConcern', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    var ops = ***REMOVED******REMOVED***;
    if (this.s.options.w != null) ops.w = this.s.options.w;
    if (this.s.options.j != null) ops.j = this.s.options.j;
    if (this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
    if (this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
    return ops;
  ***REMOVED***
***REMOVED***);

/**
 * @ignore
 */
Object.defineProperty(Collection.prototype, 'hint', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.collectionHint;
  ***REMOVED***,
  set: function(v) ***REMOVED***
    this.s.collectionHint = normalizeHintField(v);
  ***REMOVED***
***REMOVED***);

/**
 * Creates a cursor for a query that can be used to iterate over results from MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** [query=***REMOVED******REMOVED***] The cursor query object.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.limit=0] Sets the limit of documents returned in the query.
 * @param ***REMOVED***(array|object)***REMOVED*** [options.sort=null] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
 * @param ***REMOVED***object***REMOVED*** [options.projection=null] The fields to return in the query. Object of fields to include or exclude (not both), ***REMOVED***'a':1***REMOVED***
 * @param ***REMOVED***object***REMOVED*** [options.fields=null] **Deprecated** Use `options.projection` instead
 * @param ***REMOVED***number***REMOVED*** [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).
 * @param ***REMOVED***Object***REMOVED*** [options.hint=null] Tell the query to use specific indexes in the query. Object of indexes to use, ***REMOVED***'_id':1***REMOVED***
 * @param ***REMOVED***boolean***REMOVED*** [options.explain=false] Explain the query instead of returning the data.
 * @param ***REMOVED***boolean***REMOVED*** [options.snapshot=false] Snapshot query.
 * @param ***REMOVED***boolean***REMOVED*** [options.timeout=false] Specify if the cursor can timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.tailable=false] Specify if the cursor is tailable.
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param ***REMOVED***boolean***REMOVED*** [options.returnKey=false] Only return the index key.
 * @param ***REMOVED***number***REMOVED*** [options.maxScan=null] Limit the number of items to scan.
 * @param ***REMOVED***number***REMOVED*** [options.min=null] Set index bounds.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] Set index bounds.
 * @param ***REMOVED***boolean***REMOVED*** [options.showDiskLoc=false] Show disk location of results.
 * @param ***REMOVED***string***REMOVED*** [options.comment=null] You can put a $comment field on a query to make looking in the profiler logs simpler.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***boolean***REMOVED*** [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Cursor***REMOVED***
 */
Collection.prototype.find = function(query, options, callback) ***REMOVED***
  let selector = query;
  // figuring out arguments
  if (typeof callback !== 'function') ***REMOVED***
    if (typeof options === 'function') ***REMOVED***
      callback = options;
      options = undefined;
    ***REMOVED*** else if (options == null) ***REMOVED***
      callback = typeof selector === 'function' ? selector : undefined;
      selector = typeof selector === 'object' ? selector : undefined;
    ***REMOVED***
  ***REMOVED***

  // Ensure selector is not null
  selector = selector == null ? ***REMOVED******REMOVED*** : selector;
  // Validate correctness off the selector
  var object = selector;
  if (Buffer.isBuffer(object)) ***REMOVED***
    var object_size = object[0] | (object[1] << 8) | (object[2] << 16) | (object[3] << 24);
    if (object_size !== object.length) ***REMOVED***
      var error = new Error(
        'query selector raw message size does not match message header size [' +
          object.length +
          '] != [' +
          object_size +
          ']'
      );
      error.name = 'MongoError';
      throw error;
    ***REMOVED***
  ***REMOVED***

  // Check special case where we are using an objectId
  if (selector != null && selector._bsontype === 'ObjectID') ***REMOVED***
    selector = ***REMOVED*** _id: selector ***REMOVED***;
  ***REMOVED***

  if (!options) options = ***REMOVED******REMOVED***;

  let projection = options.projection || options.fields;

  if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) ***REMOVED***
    projection = projection.length
      ? projection.reduce((result, field) => ***REMOVED***
          result[field] = 1;
          return result;
        ***REMOVED***, ***REMOVED******REMOVED***)
      : ***REMOVED*** _id: 1 ***REMOVED***;
  ***REMOVED***

  var newOptions = ***REMOVED******REMOVED***;

  // Make a shallow copy of the collection options
  for (var key in this.s.options) ***REMOVED***
    if (mergeKeys.indexOf(key) !== -1) ***REMOVED***
      newOptions[key] = this.s.options[key];
    ***REMOVED***
  ***REMOVED***

  // Make a shallow copy of options
  for (var optKey in options) ***REMOVED***
    newOptions[optKey] = options[optKey];
  ***REMOVED***

  // Unpack options
  newOptions.skip = options.skip ? options.skip : 0;
  newOptions.limit = options.limit ? options.limit : 0;
  newOptions.raw = typeof options.raw === 'boolean' ? options.raw : this.s.raw;
  newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
  newOptions.timeout = typeof options.timeout === 'undefined' ? undefined : options.timeout;
  // // If we have overridden slaveOk otherwise use the default db setting
  newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;

  // Add read preference if needed
  newOptions = getReadPreference(this, newOptions, this.s.db);

  // Set slave ok to true if read preference different from primary
  if (
    newOptions.readPreference != null &&
    (newOptions.readPreference !== 'primary' || newOptions.readPreference.mode !== 'primary')
  ) ***REMOVED***
    newOptions.slaveOk = true;
  ***REMOVED***

  // Ensure the query is an object
  if (selector != null && typeof selector !== 'object') ***REMOVED***
    throw MongoError.create(***REMOVED*** message: 'query selector must be an object', driver: true ***REMOVED***);
  ***REMOVED***

  // Build the find command
  var findCommand = ***REMOVED***
    find: this.s.namespace,
    limit: newOptions.limit,
    skip: newOptions.skip,
    query: selector
  ***REMOVED***;

  // Ensure we use the right await data option
  if (typeof newOptions.awaitdata === 'boolean') ***REMOVED***
    newOptions.awaitData = newOptions.awaitdata;
  ***REMOVED***

  // Translate to new command option noCursorTimeout
  if (typeof newOptions.timeout === 'boolean') newOptions.noCursorTimeout = newOptions.timeout;

  // Merge in options to command
  for (var name in newOptions) ***REMOVED***
    if (newOptions[name] != null && name !== 'session') ***REMOVED***
      findCommand[name] = newOptions[name];
    ***REMOVED***
  ***REMOVED***

  if (projection) findCommand.fields = projection;

  // Add db object to the new options
  newOptions.db = this.s.db;

  // Add the promise library
  newOptions.promiseLibrary = this.s.promiseLibrary;

  // Set raw if available at collection level
  if (newOptions.raw == null && typeof this.s.raw === 'boolean') newOptions.raw = this.s.raw;
  // Set promoteLongs if available at collection level
  if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === 'boolean')
    newOptions.promoteLongs = this.s.promoteLongs;
  if (newOptions.promoteValues == null && typeof this.s.promoteValues === 'boolean')
    newOptions.promoteValues = this.s.promoteValues;
  if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === 'boolean')
    newOptions.promoteBuffers = this.s.promoteBuffers;

  // Sort options
  if (findCommand.sort) ***REMOVED***
    findCommand.sort = formattedOrderClause(findCommand.sort);
  ***REMOVED***

  // Set the readConcern
  decorateWithReadConcern(findCommand, this, options);

  // Decorate find command with collation options
  decorateWithCollation(findCommand, this, options);

  // Create the cursor
  if (typeof callback === 'function')
    return handleCallback(
      callback,
      null,
      this.s.topology.cursor(this.s.namespace, findCommand, newOptions)
    );
  return this.s.topology.cursor(this.s.namespace, findCommand, newOptions);
***REMOVED***;

/**
 * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** doc Document to insert.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~insertOneWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.insertOne = function(doc, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, insertOne, [this, doc, options, callback]);
***REMOVED***;

var insertOne = function(self, doc, options, callback) ***REMOVED***
  if (Array.isArray(doc)) ***REMOVED***
    return callback(
      MongoError.create(***REMOVED*** message: 'doc parameter must be an object', driver: true ***REMOVED***)
    );
  ***REMOVED***

  insertDocuments(self, [doc], options, function(err, r) ***REMOVED***
    if (callback == null) return;
    if (err && callback) return callback(err);
    // Workaround for pre 2.6 servers
    if (r == null) return callback(null, ***REMOVED*** result: ***REMOVED*** ok: 1 ***REMOVED*** ***REMOVED***);
    // Add values to top level to ensure crud spec compatibility
    r.insertedCount = r.result.n;
    r.insertedId = doc._id;
    if (callback) callback(null, r);
  ***REMOVED***);
***REMOVED***;

var mapInserManyResults = function(docs, r) ***REMOVED***
  var finalResult = ***REMOVED***
    result: ***REMOVED*** ok: 1, n: r.insertedCount ***REMOVED***,
    ops: docs,
    insertedCount: r.insertedCount,
    insertedIds: r.insertedIds
  ***REMOVED***;

  if (r.getLastOp()) ***REMOVED***
    finalResult.result.opTime = r.getLastOp();
  ***REMOVED***

  return finalResult;
***REMOVED***;

/**
 * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param ***REMOVED***object[]***REMOVED*** docs Documents to insert.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] If true, when an insert fails, don't execute the remaining writes. If false, continue with remaining inserts when one fails.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~insertWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.insertMany = function(docs, options, callback) ***REMOVED***
  var self = this;
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options ? shallowClone(options) : ***REMOVED*** ordered: true ***REMOVED***;
  if (!Array.isArray(docs) && typeof callback === 'function') ***REMOVED***
    return callback(
      MongoError.create(***REMOVED*** message: 'docs parameter must be an array of documents', driver: true ***REMOVED***)
    );
  ***REMOVED*** else if (!Array.isArray(docs)) ***REMOVED***
    return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
      reject(
        MongoError.create(***REMOVED*** message: 'docs parameter must be an array of documents', driver: true ***REMOVED***)
      );
    ***REMOVED***);
  ***REMOVED***

  // If keep going set unordered
  options['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;

  // Set up the force server object id
  var forceServerObjectId =
    typeof options.forceServerObjectId === 'boolean'
      ? options.forceServerObjectId
      : self.s.db.options.forceServerObjectId;

  // Do we want to force the server to assign the _id key
  if (forceServerObjectId !== true) ***REMOVED***
    // Add _id if not specified
    for (var i = 0; i < docs.length; i++) ***REMOVED***
      if (docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();
    ***REMOVED***
  ***REMOVED***

  // Generate the bulk write operations
  var operations = [
    ***REMOVED***
      insertMany: docs
    ***REMOVED***
  ];

  return executeOperation(this.s.topology, bulkWrite, [this, operations, options, callback], ***REMOVED***
    resultMutator: result => mapInserManyResults(docs, result)
  ***REMOVED***);
***REMOVED***;

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~BulkWriteOpResult
 * @property ***REMOVED***number***REMOVED*** insertedCount Number of documents inserted.
 * @property ***REMOVED***number***REMOVED*** matchedCount Number of documents matched for update.
 * @property ***REMOVED***number***REMOVED*** modifiedCount Number of documents modified.
 * @property ***REMOVED***number***REMOVED*** deletedCount Number of documents deleted.
 * @property ***REMOVED***number***REMOVED*** upsertedCount Number of documents upserted.
 * @property ***REMOVED***object***REMOVED*** insertedIds Inserted document generated Id's, hash key is the index of the originating operation
 * @property ***REMOVED***object***REMOVED*** upsertedIds Upserted document generated Id's, hash key is the index of the originating operation
 * @property ***REMOVED***object***REMOVED*** result The command result object.
 */

/**
 * The callback format for inserts
 * @callback Collection~bulkWriteOpCallback
 * @param ***REMOVED***BulkWriteError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~BulkWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Perform a bulkWrite operation without a fluent API
 *
 * Legal operation types are
 *
 *  ***REMOVED*** insertOne: ***REMOVED*** document: ***REMOVED*** a: 1 ***REMOVED*** ***REMOVED*** ***REMOVED***
 *
 *  ***REMOVED*** updateOne: ***REMOVED*** filter: ***REMOVED***a:2***REMOVED***, update: ***REMOVED***$set: ***REMOVED***a:2***REMOVED******REMOVED***, upsert:true ***REMOVED*** ***REMOVED***
 *
 *  ***REMOVED*** updateMany: ***REMOVED*** filter: ***REMOVED***a:2***REMOVED***, update: ***REMOVED***$set: ***REMOVED***a:2***REMOVED******REMOVED***, upsert:true ***REMOVED*** ***REMOVED***
 *
 *  ***REMOVED*** deleteOne: ***REMOVED*** filter: ***REMOVED***c:1***REMOVED*** ***REMOVED*** ***REMOVED***
 *
 *  ***REMOVED*** deleteMany: ***REMOVED*** filter: ***REMOVED***c:1***REMOVED*** ***REMOVED*** ***REMOVED***
 *
 *  ***REMOVED*** replaceOne: ***REMOVED*** filter: ***REMOVED***c:3***REMOVED***, replacement: ***REMOVED***c:4***REMOVED***, upsert:true***REMOVED******REMOVED***
 *
 * If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param ***REMOVED***object[]***REMOVED*** operations Bulk operations to perform.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute write operation in ordered or unordered fashion.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~bulkWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.bulkWrite = function(operations, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED*** ordered: true ***REMOVED***;

  if (!Array.isArray(operations)) ***REMOVED***
    throw MongoError.create(***REMOVED*** message: 'operations must be an array of documents', driver: true ***REMOVED***);
  ***REMOVED***

  return executeOperation(this.s.topology, bulkWrite, [this, operations, options, callback]);
***REMOVED***;

var bulkWrite = function(self, operations, options, callback) ***REMOVED***
  // Add ignoreUndfined
  if (self.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = self.s.options.ignoreUndefined;
  ***REMOVED***

  // Create the bulk operation
  var bulk =
    options.ordered === true || options.ordered == null
      ? self.initializeOrderedBulkOp(options)
      : self.initializeUnorderedBulkOp(options);

  // Do we have a collation
  var collation = false;

  // for each op go through and add to the bulk
  try ***REMOVED***
    for (var i = 0; i < operations.length; i++) ***REMOVED***
      // Get the operation type
      var key = Object.keys(operations[i])[0];
      // Check if we have a collation
      if (operations[i][key].collation) ***REMOVED***
        collation = true;
      ***REMOVED***

      // Pass to the raw bulk
      bulk.raw(operations[i]);
    ***REMOVED***
  ***REMOVED*** catch (err) ***REMOVED***
    return callback(err, null);
  ***REMOVED***

  // Final options for write concern
  var finalOptions = applyWriteConcern(
    shallowClone(options),
    ***REMOVED*** db: self.s.db, collection: self ***REMOVED***,
    options
  );

  var writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : ***REMOVED******REMOVED***;
  var capabilities = self.s.topology.capabilities();

  // Did the user pass in a collation, check if our write server supports it
  if (collation && capabilities && !capabilities.commandsTakeCollation) ***REMOVED***
    return callback(new MongoError(f('server/primary/mongos does not support collation')));
  ***REMOVED***

  // Execute the bulk
  bulk.execute(writeCon, finalOptions, function(err, r) ***REMOVED***
    // We have connection level error
    if (!r && err) ***REMOVED***
      return callback(err, null);
    ***REMOVED***

    r.insertedCount = r.nInserted;
    r.matchedCount = r.nMatched;
    r.modifiedCount = r.nModified || 0;
    r.deletedCount = r.nRemoved;
    r.upsertedCount = r.getUpsertedIds().length;
    r.upsertedIds = ***REMOVED******REMOVED***;
    r.insertedIds = ***REMOVED******REMOVED***;

    // Update the n
    r.n = r.insertedCount;

    // Inserted documents
    var inserted = r.getInsertedIds();
    // Map inserted ids
    for (var i = 0; i < inserted.length; i++) ***REMOVED***
      r.insertedIds[inserted[i].index] = inserted[i]._id;
    ***REMOVED***

    // Upserted documents
    var upserted = r.getUpsertedIds();
    // Map upserted ids
    for (i = 0; i < upserted.length; i++) ***REMOVED***
      r.upsertedIds[upserted[i].index] = upserted[i]._id;
    ***REMOVED***

    // Return the results
    callback(null, r);
  ***REMOVED***);
***REMOVED***;

var insertDocuments = function(self, docs, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;
  // Ensure we are operating on an array op docs
  docs = Array.isArray(docs) ? docs : [docs];

  // Get the write concern options
  var finalOptions = applyWriteConcern(
    shallowClone(options),
    ***REMOVED*** db: self.s.db, collection: self ***REMOVED***,
    options
  );

  // If keep going set unordered
  if (finalOptions.keepGoing === true) finalOptions.ordered = false;
  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;

  // Set up the force server object id
  var forceServerObjectId =
    typeof options.forceServerObjectId === 'boolean'
      ? options.forceServerObjectId
      : self.s.db.options.forceServerObjectId;

  // Add _id if not specified
  if (forceServerObjectId !== true) ***REMOVED***
    for (var i = 0; i < docs.length; i++) ***REMOVED***
      if (docs[i]._id === void 0) docs[i]._id = self.s.pkFactory.createPk();
    ***REMOVED***
  ***REMOVED***

  // File inserts
  self.s.topology.insert(self.s.namespace, docs, finalOptions, function(err, result) ***REMOVED***
    if (callback == null) return;
    if (err) return handleCallback(callback, err);
    if (result == null) return handleCallback(callback, null, null);
    if (result.result.code) return handleCallback(callback, toError(result.result));
    if (result.result.writeErrors)
      return handleCallback(callback, toError(result.result.writeErrors[0]));
    // Add docs to the list
    result.ops = docs;
    // Return the results
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***;

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~WriteOpResult
 * @property ***REMOVED***object[]***REMOVED*** ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
 * @property ***REMOVED***object***REMOVED*** connection The connection object used for the operation.
 * @property ***REMOVED***object***REMOVED*** result The command result object.
 */

/**
 * The callback format for inserts
 * @callback Collection~writeOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~WriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~insertWriteOpResult
 * @property ***REMOVED***Number***REMOVED*** insertedCount The total amount of documents inserted.
 * @property ***REMOVED***object[]***REMOVED*** ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
 * @property ***REMOVED***Object.<Number, ObjectId>***REMOVED*** insertedIds Map of the index of the inserted document to the id of the inserted document.
 * @property ***REMOVED***object***REMOVED*** connection The connection object used for the operation.
 * @property ***REMOVED***object***REMOVED*** result The raw command result object returned from MongoDB (content might vary by server version).
 * @property ***REMOVED***Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property ***REMOVED***Number***REMOVED*** result.n The total count of documents inserted.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~insertOneWriteOpResult
 * @property ***REMOVED***Number***REMOVED*** insertedCount The total amount of documents inserted.
 * @property ***REMOVED***object[]***REMOVED*** ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
 * @property ***REMOVED***ObjectId***REMOVED*** insertedId The driver generated ObjectId for the insert operation.
 * @property ***REMOVED***object***REMOVED*** connection The connection object used for the operation.
 * @property ***REMOVED***object***REMOVED*** result The raw command result object returned from MongoDB (content might vary by server version).
 * @property ***REMOVED***Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property ***REMOVED***Number***REMOVED*** result.n The total count of documents inserted.
 */

/**
 * The callback format for inserts
 * @callback Collection~insertWriteOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~insertWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * The callback format for inserts
 * @callback Collection~insertOneWriteOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~insertOneWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param ***REMOVED***(object|object[])***REMOVED*** docs Documents to insert.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~insertWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use insertOne, insertMany or bulkWrite
 */
Collection.prototype.insert = function(docs, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED*** ordered: false ***REMOVED***;
  docs = !Array.isArray(docs) ? [docs] : docs;

  if (options.keepGoing === true) ***REMOVED***
    options.ordered = false;
  ***REMOVED***

  return this.insertMany(docs, options, callback);
***REMOVED***;

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~updateWriteOpResult
 * @property ***REMOVED***Object***REMOVED*** result The raw result returned from MongoDB, field will vary depending on server version.
 * @property ***REMOVED***Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property ***REMOVED***Number***REMOVED*** result.n The total count of documents scanned.
 * @property ***REMOVED***Number***REMOVED*** result.nModified The total count of documents modified.
 * @property ***REMOVED***Object***REMOVED*** connection The connection object used for the operation.
 * @property ***REMOVED***Number***REMOVED*** matchedCount The number of documents that matched the filter.
 * @property ***REMOVED***Number***REMOVED*** modifiedCount The number of documents that were modified.
 * @property ***REMOVED***Number***REMOVED*** upsertedCount The number of documents upserted.
 * @property ***REMOVED***Object***REMOVED*** upsertedId The upserted id.
 * @property ***REMOVED***ObjectId***REMOVED*** upsertedId._id The upserted _id returned from the server.
 */

/**
 * The callback format for inserts
 * @callback Collection~updateWriteOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~updateWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Update a single document on MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the document to update
 * @param ***REMOVED***object***REMOVED*** update The update operations to be applied to the document
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***Array***REMOVED*** [options.arrayFilters=null] optional list of array filters referenced in filtered positional operators
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.updateOne = function(filter, update, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  var err = checkForAtomicOperators(update);
  if (err) ***REMOVED***
    if (typeof callback === 'function') return callback(err);
    return this.s.promiseLibrary.reject(err);
  ***REMOVED***

  options = shallowClone(options);

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, updateOne, [this, filter, update, options, callback]);
***REMOVED***;

var checkForAtomicOperators = function(update) ***REMOVED***
  var keys = Object.keys(update);

  // same errors as the server would give for update doc lacking atomic operators
  if (keys.length === 0) ***REMOVED***
    return toError('The update operation document must contain at least one atomic operator.');
  ***REMOVED***

  if (keys[0][0] !== '$') ***REMOVED***
    return toError('the update operation document must contain atomic operators.');
  ***REMOVED***
***REMOVED***;

var updateOne = function(self, filter, update, options, callback) ***REMOVED***
  // Set single document update
  options.multi = false;
  // Execute update
  updateDocuments(self, filter, update, options, function(err, r) ***REMOVED***
    if (callback == null) return;
    if (err && callback) return callback(err);
    if (r == null) return callback(null, ***REMOVED*** result: ***REMOVED*** ok: 1 ***REMOVED*** ***REMOVED***);
    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId =
      Array.isArray(r.result.upserted) && r.result.upserted.length > 0
        ? r.result.upserted[0]
        : null;
    r.upsertedCount =
      Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount =
      Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    if (callback) callback(null, r);
  ***REMOVED***);
***REMOVED***;

/**
 * Replace a document on MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the document to update
 * @param ***REMOVED***object***REMOVED*** doc The Document that replaces the matching document
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.replaceOne = function(filter, doc, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = shallowClone(options);

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, replaceOne, [this, filter, doc, options, callback]);
***REMOVED***;

var replaceOne = function(self, filter, doc, options, callback) ***REMOVED***
  // Set single document update
  options.multi = false;

  // Execute update
  updateDocuments(self, filter, doc, options, function(err, r) ***REMOVED***
    if (callback == null) return;
    if (err && callback) return callback(err);
    if (r == null) return callback(null, ***REMOVED*** result: ***REMOVED*** ok: 1 ***REMOVED*** ***REMOVED***);

    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId =
      Array.isArray(r.result.upserted) && r.result.upserted.length > 0
        ? r.result.upserted[0]
        : null;
    r.upsertedCount =
      Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount =
      Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    r.ops = [doc];
    if (callback) callback(null, r);
  ***REMOVED***);
***REMOVED***;

/**
 * Update multiple documents on MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the documents to update
 * @param ***REMOVED***object***REMOVED*** update The update operations to be applied to the document
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***Array***REMOVED*** [options.arrayFilters=null] optional list of array filters referenced in filtered positional operators
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.updateMany = function(filter, update, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  var err = checkForAtomicOperators(update);
  if (err) ***REMOVED***
    if (typeof callback === 'function') return callback(err);
    return this.s.promiseLibrary.reject(err);
  ***REMOVED***

  options = shallowClone(options);

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, updateMany, [this, filter, update, options, callback]);
***REMOVED***;

var updateMany = function(self, filter, update, options, callback) ***REMOVED***
  // Set single document update
  options.multi = true;
  // Execute update
  updateDocuments(self, filter, update, options, function(err, r) ***REMOVED***
    if (callback == null) return;
    if (err && callback) return callback(err);
    if (r == null) return callback(null, ***REMOVED*** result: ***REMOVED*** ok: 1 ***REMOVED*** ***REMOVED***);
    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId =
      Array.isArray(r.result.upserted) && r.result.upserted.length > 0
        ? r.result.upserted[0]
        : null;
    r.upsertedCount =
      Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount =
      Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    if (callback) callback(null, r);
  ***REMOVED***);
***REMOVED***;

var updateDocuments = function(self, selector, document, options, callback) ***REMOVED***
  if ('function' === typeof options) (callback = options), (options = null);
  if (options == null) options = ***REMOVED******REMOVED***;
  if (!('function' === typeof callback)) callback = null;

  // If we are not providing a selector or document throw
  if (selector == null || typeof selector !== 'object')
    return callback(toError('selector must be a valid JavaScript object'));
  if (document == null || typeof document !== 'object')
    return callback(toError('document must be a valid JavaScript object'));

  // Get the write concern options
  var finalOptions = applyWriteConcern(
    shallowClone(options),
    ***REMOVED*** db: self.s.db, collection: self ***REMOVED***,
    options
  );

  // Do we return the actual result document
  // Either use override on the function, or go back to default on either the collection
  // level or db
  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;

  // Execute the operation
  var op = ***REMOVED*** q: selector, u: document ***REMOVED***;
  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;
  op.multi = options.multi !== void 0 ? !!options.multi : false;

  if (finalOptions.arrayFilters) ***REMOVED***
    op.arrayFilters = finalOptions.arrayFilters;
    delete finalOptions.arrayFilters;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(finalOptions, self, options);

  // Update options
  self.s.topology.update(self.s.namespace, [op], finalOptions, function(err, result) ***REMOVED***
    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    if (result == null) return handleCallback(callback, null, null);
    if (result.result.code) return handleCallback(callback, toError(result.result));
    if (result.result.writeErrors)
      return handleCallback(callback, toError(result.result.writeErrors[0]));
    // Return the results
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***;

/**
 * Updates documents.
 * @method
 * @param ***REMOVED***object***REMOVED*** selector The selector for the update operation.
 * @param ***REMOVED***object***REMOVED*** document The update document.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param ***REMOVED***boolean***REMOVED*** [options.multi=false] Update one/all documents with operation.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***Array***REMOVED*** [options.arrayFilters=null] optional list of array filters referenced in filtered positional operators
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~writeOpCallback***REMOVED*** [callback] The command result callback
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use updateOne, updateMany or bulkWrite
 */
Collection.prototype.update = function(selector, document, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, updateDocuments, [
    this,
    selector,
    document,
    options,
    callback
  ]);
***REMOVED***;

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~deleteWriteOpResult
 * @property ***REMOVED***Object***REMOVED*** result The raw result returned from MongoDB, field will vary depending on server version.
 * @property ***REMOVED***Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property ***REMOVED***Number***REMOVED*** result.n The total count of documents deleted.
 * @property ***REMOVED***Object***REMOVED*** connection The connection object used for the operation.
 * @property ***REMOVED***Number***REMOVED*** deletedCount The number of documents deleted.
 */

/**
 * The callback format for inserts
 * @callback Collection~deleteWriteOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~deleteWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Delete a document on MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the document to remove
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~deleteWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.deleteOne = function(filter, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = shallowClone(options);

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, deleteOne, [this, filter, options, callback]);
***REMOVED***;

var deleteOne = function(self, filter, options, callback) ***REMOVED***
  options.single = true;
  removeDocuments(self, filter, options, function(err, r) ***REMOVED***
    if (callback == null) return;
    if (err && callback) return callback(err);
    if (r == null) return callback(null, ***REMOVED*** result: ***REMOVED*** ok: 1 ***REMOVED*** ***REMOVED***);
    r.deletedCount = r.result.n;
    if (callback) callback(null, r);
  ***REMOVED***);
***REMOVED***;

Collection.prototype.removeOne = Collection.prototype.deleteOne;

/**
 * Delete multiple documents on MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the documents to remove
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~deleteWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.deleteMany = function(filter, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = shallowClone(options);

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, deleteMany, [this, filter, options, callback]);
***REMOVED***;

var deleteMany = function(self, filter, options, callback) ***REMOVED***
  options.single = false;

  removeDocuments(self, filter, options, function(err, r) ***REMOVED***
    if (callback == null) return;
    if (err && callback) return callback(err);
    if (r == null) return callback(null, ***REMOVED*** result: ***REMOVED*** ok: 1 ***REMOVED*** ***REMOVED***);
    r.deletedCount = r.result.n;
    if (callback) callback(null, r);
  ***REMOVED***);
***REMOVED***;

var removeDocuments = function(self, selector, options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    (callback = options), (options = ***REMOVED******REMOVED***);
  ***REMOVED*** else if (typeof selector === 'function') ***REMOVED***
    callback = selector;
    options = ***REMOVED******REMOVED***;
    selector = ***REMOVED******REMOVED***;
  ***REMOVED***

  // Create an empty options object if the provided one is null
  options = options || ***REMOVED******REMOVED***;

  // Get the write concern options
  var finalOptions = applyWriteConcern(
    shallowClone(options),
    ***REMOVED*** db: self.s.db, collection: self ***REMOVED***,
    options
  );

  // If selector is null set empty
  if (selector == null) selector = ***REMOVED******REMOVED***;

  // Build the op
  var op = ***REMOVED*** q: selector, limit: 0 ***REMOVED***;
  if (options.single) op.limit = 1;

  // Have we specified collation
  decorateWithCollation(finalOptions, self, options);

  // Execute the remove
  self.s.topology.remove(self.s.namespace, [op], finalOptions, function(err, result) ***REMOVED***
    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    if (result == null) return handleCallback(callback, null, null);
    if (result.result.code) return handleCallback(callback, toError(result.result));
    if (result.result.writeErrors)
      return handleCallback(callback, toError(result.result.writeErrors[0]));
    // Return the results
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***;

Collection.prototype.removeMany = Collection.prototype.deleteMany;

/**
 * Remove documents.
 * @method
 * @param ***REMOVED***object***REMOVED*** selector The selector for the update operation.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.single=false] Removes the first document found.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~writeOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use deleteOne, deleteMany or bulkWrite
 */
Collection.prototype.remove = function(selector, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, removeDocuments, [this, selector, options, callback]);
***REMOVED***;

/**
 * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic
 * operators and update instead for more efficient operations.
 * @method
 * @param ***REMOVED***object***REMOVED*** doc Document to save
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~writeOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use insertOne, insertMany, updateOne or updateMany
 */
Collection.prototype.save = function(doc, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, save, [this, doc, options, callback]);
***REMOVED***;

var save = function(self, doc, options, callback) ***REMOVED***
  // Get the write concern options
  var finalOptions = applyWriteConcern(
    shallowClone(options),
    ***REMOVED*** db: self.s.db, collection: self ***REMOVED***,
    options
  );
  // Establish if we need to perform an insert or update
  if (doc._id != null) ***REMOVED***
    finalOptions.upsert = true;
    return updateDocuments(self, ***REMOVED*** _id: doc._id ***REMOVED***, doc, finalOptions, callback);
  ***REMOVED***

  // Insert the document
  insertDocuments(self, [doc], finalOptions, function(err, r) ***REMOVED***
    if (callback == null) return;
    if (doc == null) return handleCallback(callback, null, null);
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, r);
  ***REMOVED***);
***REMOVED***;

/**
 * The callback format for results
 * @callback Collection~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***object***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * The callback format for an aggregation call
 * @callback Collection~aggregationCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***AggregationCursor***REMOVED*** cursor The cursor if the aggregation command was executed successfully.
 */

/**
 * Fetches the first document that matches the query
 * @method
 * @param ***REMOVED***object***REMOVED*** query Query for find Operation
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.limit=0] Sets the limit of documents returned in the query.
 * @param ***REMOVED***(array|object)***REMOVED*** [options.sort=null] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
 * @param ***REMOVED***object***REMOVED*** [options.projection=null] The fields to return in the query. Object of fields to include or exclude (not both), ***REMOVED***'a':1***REMOVED***
 * @param ***REMOVED***object***REMOVED*** [options.fields=null] **Deprecated** Use `options.projection` instead
 * @param ***REMOVED***number***REMOVED*** [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).
 * @param ***REMOVED***Object***REMOVED*** [options.hint=null] Tell the query to use specific indexes in the query. Object of indexes to use, ***REMOVED***'_id':1***REMOVED***
 * @param ***REMOVED***boolean***REMOVED*** [options.explain=false] Explain the query instead of returning the data.
 * @param ***REMOVED***boolean***REMOVED*** [options.snapshot=false] Snapshot query.
 * @param ***REMOVED***boolean***REMOVED*** [options.timeout=false] Specify if the cursor can timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.tailable=false] Specify if the cursor is tailable.
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param ***REMOVED***boolean***REMOVED*** [options.returnKey=false] Only return the index key.
 * @param ***REMOVED***number***REMOVED*** [options.maxScan=null] Limit the number of items to scan.
 * @param ***REMOVED***number***REMOVED*** [options.min=null] Set index bounds.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] Set index bounds.
 * @param ***REMOVED***boolean***REMOVED*** [options.showDiskLoc=false] Show disk location of results.
 * @param ***REMOVED***string***REMOVED*** [options.comment=null] You can put a $comment field on a query to make looking in the profiler logs simpler.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***boolean***REMOVED*** [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOne = function(query, options, callback) ***REMOVED***
  if (typeof query === 'function') (callback = query), (query = ***REMOVED******REMOVED***), (options = ***REMOVED******REMOVED***);
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  query = query || ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, findOne, [this, query, options, callback]);
***REMOVED***;

var findOne = function(self, query, options, callback) ***REMOVED***
  const cursor = self
    .find(query, options)
    .limit(-1)
    .batchSize(1);

  // Return the item
  cursor.next(function(err, item) ***REMOVED***
    if (err != null) return handleCallback(callback, toError(err), null);
    handleCallback(callback, null, item);
  ***REMOVED***);
***REMOVED***;

/**
 * The callback format for the collection method, must be used if strict is specified
 * @callback Collection~collectionResultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection***REMOVED*** collection The collection instance.
 */

/**
 * Rename the collection.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** newName New name of of the collection.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropTarget=false] Drop the target name collection if it previously exists.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~collectionResultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.rename = function(newName, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = Object.assign(***REMOVED******REMOVED***, options, ***REMOVED*** readPreference: ReadPreference.PRIMARY ***REMOVED***);

  return executeOperation(this.s.topology, rename, [this, newName, options, callback]);
***REMOVED***;

var rename = function(self, newName, options, callback) ***REMOVED***
  // Check the collection name
  checkCollectionName(newName);
  // Build the command
  var renameCollection = f('%s.%s', self.s.dbName, self.s.name);
  var toCollection = f('%s.%s', self.s.dbName, newName);
  var dropTarget = typeof options.dropTarget === 'boolean' ? options.dropTarget : false;
  var cmd = ***REMOVED*** renameCollection: renameCollection, to: toCollection, dropTarget: dropTarget ***REMOVED***;

  // Decorate command with writeConcern if supported
  applyWriteConcern(cmd, ***REMOVED*** db: self.s.db, collection: self ***REMOVED***, options);

  // Execute against admin
  self.s.db.admin().command(cmd, options, function(err, doc) ***REMOVED***
    if (err) return handleCallback(callback, err, null);
    // We have an error
    if (doc.errmsg) return handleCallback(callback, toError(doc), null);
    try ***REMOVED***
      return handleCallback(
        callback,
        null,
        new Collection(
          self.s.db,
          self.s.topology,
          self.s.dbName,
          newName,
          self.s.pkFactory,
          self.s.options
        )
      );
    ***REMOVED*** catch (err) ***REMOVED***
      return handleCallback(callback, toError(err), null);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.drop = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, this.s.db.dropCollection.bind(this.s.db), [
    this.s.name,
    options,
    callback
  ]);
***REMOVED***;

/**
 * Returns the options of the collection.
 *
 * @method
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.options = function(opts, callback) ***REMOVED***
  if (typeof opts === 'function') (callback = opts), (opts = ***REMOVED******REMOVED***);
  opts = opts || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, options, [this, opts, callback]);
***REMOVED***;

var options = function(self, opts, callback) ***REMOVED***
  self.s.db.listCollections(***REMOVED*** name: self.s.name ***REMOVED***, opts).toArray(function(err, collections) ***REMOVED***
    if (err) return handleCallback(callback, err);
    if (collections.length === 0) ***REMOVED***
      return handleCallback(
        callback,
        MongoError.create(***REMOVED*** message: f('collection %s not found', self.s.namespace), driver: true ***REMOVED***)
      );
    ***REMOVED***

    handleCallback(callback, err, collections[0].options || null);
  ***REMOVED***);
***REMOVED***;

/**
 * Returns if the collection is a capped collection
 *
 * @method
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.isCapped = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, isCapped, [this, options, callback]);
***REMOVED***;

var isCapped = function(self, options, callback) ***REMOVED***
  self.options(options, function(err, document) ***REMOVED***
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, document && document.capped);
  ***REMOVED***);
***REMOVED***;

/**
 * Creates an index on the db and collection collection.
 * @method
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.unique=false] Creates an unique index.
 * @param ***REMOVED***boolean***REMOVED*** [options.sparse=false] Creates a sparse index.
 * @param ***REMOVED***boolean***REMOVED*** [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param ***REMOVED***number***REMOVED*** [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.v=null] Specify the format version of the indexes.
 * @param ***REMOVED***number***REMOVED*** [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param ***REMOVED***string***REMOVED*** [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param ***REMOVED***object***REMOVED*** [options.partialFilterExpression=null] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.createIndex = function(fieldOrSpec, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, createIndex, [this, fieldOrSpec, options, callback]);
***REMOVED***;

var createIndex = function(self, fieldOrSpec, options, callback) ***REMOVED***
  self.s.db.createIndex(self.s.name, fieldOrSpec, options, callback);
***REMOVED***;

/**
 * Creates multiple indexes in the collection, this method is only supported for
 * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
 * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
 * @method
 * @param ***REMOVED***array***REMOVED*** indexSpecs An array of index specifications to be created
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.createIndexes = function(indexSpecs, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);

  options = options ? shallowClone(options) : ***REMOVED******REMOVED***;
  if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;

  return executeOperation(this.s.topology, createIndexes, [this, indexSpecs, options, callback]);
***REMOVED***;

var createIndexes = function(self, indexSpecs, options, callback) ***REMOVED***
  var capabilities = self.s.topology.capabilities();

  // Ensure we generate the correct name if the parameter is not set
  for (var i = 0; i < indexSpecs.length; i++) ***REMOVED***
    if (indexSpecs[i].name == null) ***REMOVED***
      var keys = [];

      // Did the user pass in a collation, check if our write server supports it
      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) ***REMOVED***
        return callback(new MongoError(f('server/primary/mongos does not support collation')));
      ***REMOVED***

      for (var name in indexSpecs[i].key) ***REMOVED***
        keys.push(f('%s_%s', name, indexSpecs[i].key[name]));
      ***REMOVED***

      // Set the name
      indexSpecs[i].name = keys.join('_');
    ***REMOVED***
  ***REMOVED***

  options = Object.assign(***REMOVED******REMOVED***, options, ***REMOVED*** readPreference: ReadPreference.PRIMARY ***REMOVED***);

  // Execute the index
  self.s.db.command(
    ***REMOVED***
      createIndexes: self.s.name,
      indexes: indexSpecs
    ***REMOVED***,
    options,
    callback
  );
***REMOVED***;

/**
 * Drops an index from this collection.
 * @method
 * @param ***REMOVED***string***REMOVED*** indexName Name of the index to drop.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS] Number of miliseconds to wait before aborting the query.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.dropIndex = function(indexName, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;

  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;
  // Run only against primary
  options.readPreference = ReadPreference.PRIMARY;

  return executeOperation(this.s.topology, dropIndex, [this, indexName, options, callback]);
***REMOVED***;

var dropIndex = function(self, indexName, options, callback) ***REMOVED***
  // Delete index command
  var cmd = ***REMOVED*** dropIndexes: self.s.name, index: indexName ***REMOVED***;

  // Decorate command with writeConcern if supported
  applyWriteConcern(cmd, ***REMOVED*** db: self.s.db, collection: self ***REMOVED***, options);

  // Execute command
  self.s.db.command(cmd, options, function(err, result) ***REMOVED***
    if (typeof callback !== 'function') return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***;

/**
 * Drops all indexes from this collection.
 * @method
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS] Number of miliseconds to wait before aborting the query.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.dropIndexes = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options ? shallowClone(options) : ***REMOVED******REMOVED***;

  if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;

  return executeOperation(this.s.topology, dropIndexes, [this, options, callback]);
***REMOVED***;

var dropIndexes = function(self, options, callback) ***REMOVED***
  self.dropIndex('*', options, function(err) ***REMOVED***
    if (err) return handleCallback(callback, err, false);
    handleCallback(callback, null, true);
  ***REMOVED***);
***REMOVED***;

/**
 * Drops all indexes from this collection.
 * @method
 * @deprecated use dropIndexes
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** callback The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no [callback] passed
 */
Collection.prototype.dropAllIndexes = Collection.prototype.dropIndexes;

/**
 * Reindex all indexes on the collection
 * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
 * @method
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.reIndex = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, reIndex, [this, options, callback]);
***REMOVED***;

var reIndex = function(self, options, callback) ***REMOVED***
  // Reindex
  var cmd = ***REMOVED*** reIndex: self.s.name ***REMOVED***;

  // Execute the command
  self.s.db.command(cmd, options, function(err, result) ***REMOVED***
    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  ***REMOVED***);
***REMOVED***;

/**
 * Get the list of all indexes information for the collection.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @return ***REMOVED***CommandCursor***REMOVED***
 */
Collection.prototype.listIndexes = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Clone the options
  options = shallowClone(options);
  // Determine the read preference in the options.
  options = getReadPreference(this, options, this.s.db, this);
  // Set the CommandCursor constructor
  options.cursorFactory = CommandCursor;
  // Set the promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  if (!this.s.topology.capabilities()) ***REMOVED***
    throw new MongoError('cannot connect to server');
  ***REMOVED***

  // We have a list collections command
  if (this.s.topology.capabilities().hasListIndexesCommand) ***REMOVED***
    // Cursor options
    var cursor = options.batchSize ? ***REMOVED*** batchSize: options.batchSize ***REMOVED*** : ***REMOVED******REMOVED***;
    // Build the command
    var command = ***REMOVED*** listIndexes: this.s.name, cursor: cursor ***REMOVED***;
    // Execute the cursor
    cursor = this.s.topology.cursor(f('%s.$cmd', this.s.dbName), command, options);
    // Do we have a readPreference, apply it
    if (options.readPreference) cursor.setReadPreference(options.readPreference);
    // Return the cursor
    return cursor;
  ***REMOVED***

  // Get the namespace
  var ns = f('%s.system.indexes', this.s.dbName);
  // Get the query
  cursor = this.s.topology.cursor(ns, ***REMOVED*** find: ns, query: ***REMOVED*** ns: this.s.namespace ***REMOVED*** ***REMOVED***, options);
  // Do we have a readPreference, apply it
  if (options.readPreference) cursor.setReadPreference(options.readPreference);
  // Set the passed in batch size if one was provided
  if (options.batchSize) cursor = cursor.batchSize(options.batchSize);
  // Return the cursor
  return cursor;
***REMOVED***;

/**
 * Ensures that an index exists, if it does not it creates it
 * @method
 * @deprecated use createIndexes instead
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.unique=false] Creates an unique index.
 * @param ***REMOVED***boolean***REMOVED*** [options.sparse=false] Creates a sparse index.
 * @param ***REMOVED***boolean***REMOVED*** [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param ***REMOVED***number***REMOVED*** [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.v=null] Specify the format version of the indexes.
 * @param ***REMOVED***number***REMOVED*** [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param ***REMOVED***number***REMOVED*** [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.ensureIndex = function(fieldOrSpec, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, ensureIndex, [this, fieldOrSpec, options, callback]);
***REMOVED***;

var ensureIndex = function(self, fieldOrSpec, options, callback) ***REMOVED***
  self.s.db.ensureIndex(self.s.name, fieldOrSpec, options, callback);
***REMOVED***;

/**
 * Checks if one or more indexes exist on the collection, fails on first non-existing index
 * @method
 * @param ***REMOVED***(string|array)***REMOVED*** indexes One or more index names to check.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.indexExists = function(indexes, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, indexExists, [this, indexes, options, callback]);
***REMOVED***;

var indexExists = function(self, indexes, options, callback) ***REMOVED***
  self.indexInformation(options, function(err, indexInformation) ***REMOVED***
    // If we have an error return
    if (err != null) return handleCallback(callback, err, null);
    // Let's check for the index names
    if (!Array.isArray(indexes))
      return handleCallback(callback, null, indexInformation[indexes] != null);
    // Check in list of indexes
    for (var i = 0; i < indexes.length; i++) ***REMOVED***
      if (indexInformation[indexes[i]] == null) ***REMOVED***
        return handleCallback(callback, null, false);
      ***REMOVED***
    ***REMOVED***

    // All keys found return true
    return handleCallback(callback, null, true);
  ***REMOVED***);
***REMOVED***;

/**
 * Retrieves this collections index info.
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.full=false] Returns the full raw index information.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.indexInformation = function(options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, indexInformation, [this, options, callback]);
***REMOVED***;

var indexInformation = function(self, options, callback) ***REMOVED***
  self.s.db.indexInformation(self.s.name, options, callback);
***REMOVED***;

/**
 * The callback format for results
 * @callback Collection~countCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***number***REMOVED*** result The count of documents that matched the query.
 */

/**
 * Count number of matching documents in the db to a query.
 * @method
 * @param ***REMOVED***object***REMOVED*** query The query for the count.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.limit=null] The limit of documents to count.
 * @param ***REMOVED***boolean***REMOVED*** [options.skip=null] The number of documents to skip for the count.
 * @param ***REMOVED***string***REMOVED*** [options.hint=null] An index name hint for the query.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~countCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.count = function(query, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  query = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, count, [this, query, options, callback]);
***REMOVED***;

var count = function(self, query, options, callback) ***REMOVED***
  var skip = options.skip;
  var limit = options.limit;
  var hint = options.hint;
  var maxTimeMS = options.maxTimeMS;

  // Final query
  var cmd = ***REMOVED***
    count: self.s.name,
    query: query
  ***REMOVED***;

  // Add limit, skip and maxTimeMS if defined
  if (typeof skip === 'number') cmd.skip = skip;
  if (typeof limit === 'number') cmd.limit = limit;
  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;
  if (hint) cmd.hint = hint;

  options = shallowClone(options);

  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db);

  // Do we have a readConcern specified
  decorateWithReadConcern(cmd, self, options);

  // Have we specified collation
  decorateWithCollation(cmd, self, options);

  // Execute command
  self.s.db.command(cmd, options, function(err, result) ***REMOVED***
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.n);
  ***REMOVED***);
***REMOVED***;

/**
 * The distinct command returns returns a list of distinct values for the given key across a collection.
 * @method
 * @param ***REMOVED***string***REMOVED*** key Field of the document to find distinct values for.
 * @param ***REMOVED***object***REMOVED*** query The query for filtering the set of documents to which we apply the distinct filter.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.distinct = function(key, query, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  var queryOption = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;
  var optionsOption = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, distinct, [
    this,
    key,
    queryOption,
    optionsOption,
    callback
  ]);
***REMOVED***;

var distinct = function(self, key, query, options, callback) ***REMOVED***
  // maxTimeMS option
  var maxTimeMS = options.maxTimeMS;

  // Distinct command
  var cmd = ***REMOVED***
    distinct: self.s.name,
    key: key,
    query: query
  ***REMOVED***;

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db, self);

  // Add maxTimeMS if defined
  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;

  // Do we have a readConcern specified
  decorateWithReadConcern(cmd, self, options);

  // Have we specified collation
  decorateWithCollation(cmd, self, options);

  // Execute the command
  self.s.db.command(cmd, options, function(err, result) ***REMOVED***
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.values);
  ***REMOVED***);
***REMOVED***;

/**
 * Retrieve all the indexes on the collection.
 * @method
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.indexes = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, indexes, [this, options, callback]);
***REMOVED***;

var indexes = function(self, options, callback) ***REMOVED***
  options = Object.assign(***REMOVED******REMOVED***, ***REMOVED*** full: true ***REMOVED***, options);
  self.s.db.indexInformation(self.s.name, options, callback);
***REMOVED***;

/**
 * Get all the collection statistics.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.scale=null] Divide the returned sizes by scale value.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.stats = function(options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, stats, [this, options, callback]);
***REMOVED***;

var stats = function(self, options, callback) ***REMOVED***
  // Build command object
  var commandObject = ***REMOVED***
    collStats: self.s.name
  ***REMOVED***;

  // Check if we have the scale value
  if (options['scale'] != null) commandObject['scale'] = options['scale'];

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db, self);

  // Execute the command
  self.s.db.command(commandObject, options, callback);
***REMOVED***;

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~findAndModifyWriteOpResult
 * @property ***REMOVED***object***REMOVED*** value Document returned from findAndModify command.
 * @property ***REMOVED***object***REMOVED*** lastErrorObject The raw lastErrorObject returned from the command.
 * @property ***REMOVED***Number***REMOVED*** ok Is 1 if the command executed correctly.
 */

/**
 * The callback format for inserts
 * @callback Collection~findAndModifyCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~findAndModifyWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** filter Document selection filter.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***object***REMOVED*** [options.projection=null] Limits the fields to return for all matching documents.
 * @param ***REMOVED***object***REMOVED*** [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOneAndDelete = function(filter, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Basic validation
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');

  return executeOperation(this.s.topology, findOneAndDelete, [this, filter, options, callback]);
***REMOVED***;

var findOneAndDelete = function(self, filter, options, callback) ***REMOVED***
  // Final options
  var finalOptions = shallowClone(options);
  finalOptions['fields'] = options.projection;
  finalOptions['remove'] = true;
  // Execute find and Modify
  self.findAndModify(filter, options.sort, null, finalOptions, callback);
***REMOVED***;

/**
 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** filter Document selection filter.
 * @param ***REMOVED***object***REMOVED*** replacement Document replacing the matching document.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***object***REMOVED*** [options.projection=null] Limits the fields to return for all matching documents.
 * @param ***REMOVED***object***REMOVED*** [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Upsert the document if it does not exist.
 * @param ***REMOVED***boolean***REMOVED*** [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOneAndReplace = function(filter, replacement, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Basic validation
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');
  if (replacement == null || typeof replacement !== 'object')
    throw toError('replacement parameter must be an object');

  return executeOperation(this.s.topology, findOneAndReplace, [
    this,
    filter,
    replacement,
    options,
    callback
  ]);
***REMOVED***;

var findOneAndReplace = function(self, filter, replacement, options, callback) ***REMOVED***
  // Final options
  var finalOptions = shallowClone(options);
  finalOptions['fields'] = options.projection;
  finalOptions['update'] = true;
  finalOptions['new'] = options.returnOriginal !== void 0 ? !options.returnOriginal : false;
  finalOptions['upsert'] = options.upsert !== void 0 ? !!options.upsert : false;

  // Execute findAndModify
  self.findAndModify(filter, options.sort, replacement, finalOptions, callback);
***REMOVED***;

/**
 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** filter Document selection filter.
 * @param ***REMOVED***object***REMOVED*** update Update operations to be performed on the document
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***object***REMOVED*** [options.projection=null] Limits the fields to return for all matching documents.
 * @param ***REMOVED***object***REMOVED*** [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Upsert the document if it does not exist.
 * @param ***REMOVED***boolean***REMOVED*** [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOneAndUpdate = function(filter, update, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Basic validation
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');
  if (update == null || typeof update !== 'object')
    throw toError('update parameter must be an object');

  return executeOperation(this.s.topology, findOneAndUpdate, [
    this,
    filter,
    update,
    options,
    callback
  ]);
***REMOVED***;

var findOneAndUpdate = function(self, filter, update, options, callback) ***REMOVED***
  // Final options
  var finalOptions = shallowClone(options);
  finalOptions['fields'] = options.projection;
  finalOptions['update'] = true;
  finalOptions['new'] =
    typeof options.returnOriginal === 'boolean' ? !options.returnOriginal : false;
  finalOptions['upsert'] = typeof options.upsert === 'boolean' ? options.upsert : false;

  // Execute findAndModify
  self.findAndModify(filter, options.sort, update, finalOptions, callback);
***REMOVED***;

/**
 * Find and update a document.
 * @method
 * @param ***REMOVED***object***REMOVED*** query Query object to locate the object to modify.
 * @param ***REMOVED***array***REMOVED*** sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param ***REMOVED***object***REMOVED*** doc The fields/vals to be updated.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.remove=false] Set to true to remove the object before returning.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Perform an upsert operation.
 * @param ***REMOVED***boolean***REMOVED*** [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.
 * @param ***REMOVED***object***REMOVED*** [options.projection=null] Object containing the field projection for the result returned from the operation.
 * @param ***REMOVED***object***REMOVED*** [options.fields=null] **Deprecated** Use `options.projection` instead
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead
 */
Collection.prototype.findAndModify = function(query, sort, doc, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  sort = args.length ? args.shift() || [] : [];
  doc = args.length ? args.shift() : null;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Clone options
  options = shallowClone(options);
  // Force read preference primary
  options.readPreference = ReadPreference.PRIMARY;

  return executeOperation(this.s.topology, findAndModify, [
    this,
    query,
    sort,
    doc,
    options,
    callback
  ]);
***REMOVED***;

var findAndModify = function(self, query, sort, doc, options, callback) ***REMOVED***
  // Create findAndModify command object
  var queryObject = ***REMOVED***
    findandmodify: self.s.name,
    query: query
  ***REMOVED***;

  sort = formattedOrderClause(sort);
  if (sort) ***REMOVED***
    queryObject.sort = sort;
  ***REMOVED***

  queryObject.new = options.new ? true : false;
  queryObject.remove = options.remove ? true : false;
  queryObject.upsert = options.upsert ? true : false;

  const projection = options.projection || options.fields;

  if (projection) ***REMOVED***
    queryObject.fields = projection;
  ***REMOVED***

  if (options.arrayFilters) ***REMOVED***
    queryObject.arrayFilters = options.arrayFilters;
    delete options.arrayFilters;
  ***REMOVED***

  if (doc && !options.remove) ***REMOVED***
    queryObject.update = doc;
  ***REMOVED***

  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS;

  // Either use override on the function, or go back to default on either the collection
  // level or db
  if (options['serializeFunctions'] != null) ***REMOVED***
    options['serializeFunctions'] = options['serializeFunctions'];
  ***REMOVED*** else ***REMOVED***
    options['serializeFunctions'] = self.s.serializeFunctions;
  ***REMOVED***

  // No check on the documents
  options.checkKeys = false;

  // Get the write concern settings
  var finalOptions = applyWriteConcern(options, ***REMOVED*** db: self.s.db, collection: self ***REMOVED***, options);

  // Decorate the findAndModify command with the write Concern
  if (finalOptions.writeConcern) ***REMOVED***
    queryObject.writeConcern = finalOptions.writeConcern;
  ***REMOVED***

  // Have we specified bypassDocumentValidation
  if (typeof finalOptions.bypassDocumentValidation === 'boolean') ***REMOVED***
    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(queryObject, self, finalOptions);

  // Execute the command
  self.s.db.command(queryObject, finalOptions, function(err, result) ***REMOVED***
    if (err) return handleCallback(callback, err, null);
    return handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***;

/**
 * Find and remove a document.
 * @method
 * @param ***REMOVED***object***REMOVED*** query Query object to locate the object to modify.
 * @param ***REMOVED***array***REMOVED*** sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use findOneAndDelete instead
 */
Collection.prototype.findAndRemove = function(query, sort, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  sort = args.length ? args.shift() || [] : [];
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, findAndRemove, [this, query, sort, options, callback]);
***REMOVED***;

var findAndRemove = function(self, query, sort, options, callback) ***REMOVED***
  // Add the remove option
  options['remove'] = true;
  // Execute the callback
  self.findAndModify(query, sort, null, options, callback);
***REMOVED***;

function decorateWithCollation(command, self, options) ***REMOVED***
  // Do we support collation 3.4 and higher
  var capabilities = self.s.topology.capabilities();
  // Do we support write concerns 3.4 and higher
  if (capabilities && capabilities.commandsTakeCollation) ***REMOVED***
    if (options.collation && typeof options.collation === 'object') ***REMOVED***
      command.collation = options.collation;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function decorateWithReadConcern(command, self, options) ***REMOVED***
  let readConcern = Object.assign(***REMOVED******REMOVED***, command.readConcern || ***REMOVED******REMOVED***);
  if (self.s.readConcern) ***REMOVED***
    Object.assign(readConcern, self.s.readConcern);
  ***REMOVED***

  if (
    options.session &&
    options.session.supports.causalConsistency &&
    options.session.operationTime
  ) ***REMOVED***
    Object.assign(readConcern, ***REMOVED*** afterClusterTime: options.session.operationTime ***REMOVED***);
  ***REMOVED***

  if (Object.keys(readConcern).length > 0) ***REMOVED***
    Object.assign(command, ***REMOVED*** readConcern: readConcern ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.2
 * @method
 * @param ***REMOVED***object***REMOVED*** pipeline Array containing all the aggregation framework commands for the execution.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***object***REMOVED*** [options.cursor=null] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.
 * @param ***REMOVED***number***REMOVED*** [options.cursor.batchSize=null] The batchSize for the cursor
 * @param ***REMOVED***boolean***REMOVED*** [options.explain=false] Explain returns the aggregation execution plan (requires mongodb 2.6 >).
 * @param ***REMOVED***boolean***REMOVED*** [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***string***REMOVED*** [options.comment] Add a comment to an aggregation command
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~aggregationCallback***REMOVED*** callback The command result callback
 * @return ***REMOVED***(null|AggregationCursor)***REMOVED***
 */
Collection.prototype.aggregate = function(pipeline, options, callback) ***REMOVED***
  var self = this;

  if (Array.isArray(pipeline)) ***REMOVED***
    // Set up callback if one is provided
    if (typeof options === 'function') ***REMOVED***
      callback = options;
      options = ***REMOVED******REMOVED***;
    ***REMOVED***

    // If we have no options or callback we are doing
    // a cursor based aggregation
    if (options == null && callback == null) ***REMOVED***
      options = ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    // Aggregation pipeline passed as arguments on the method
    var args = Array.prototype.slice.call(arguments, 0);
    // Get the callback
    callback = args.pop();
    // Get the possible options object
    var opts = args[args.length - 1];
    // If it contains any of the admissible options pop it of the args
    options =
      opts &&
      (opts.readPreference ||
        opts.explain ||
        opts.cursor ||
        opts.out ||
        opts.maxTimeMS ||
        opts.hint ||
        opts.allowDiskUse)
        ? args.pop()
        : ***REMOVED******REMOVED***;
    // Left over arguments is the pipeline
    pipeline = args;
  ***REMOVED***

  // Ignore readConcern option
  var ignoreReadConcern = false;

  // Build the command
  var command = ***REMOVED*** aggregate: this.s.name, pipeline: pipeline ***REMOVED***;

  // If out was specified
  if (typeof options.out === 'string') ***REMOVED***
    pipeline.push(***REMOVED*** $out: options.out ***REMOVED***);
    // Ignore read concern
    ignoreReadConcern = true;
  ***REMOVED*** else if (pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) ***REMOVED***
    ignoreReadConcern = true;
  ***REMOVED***

  // Decorate command with writeConcern if out has been specified
  if (
    pipeline.length > 0 &&
    pipeline[pipeline.length - 1]['$out'] &&
    self.s.topology.capabilities().commandsTakeWriteConcern
  ) ***REMOVED***
    applyWriteConcern(command, ***REMOVED*** db: self.s.db, collection: self ***REMOVED***, options);
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(command, self, options);

  // If we have bypassDocumentValidation set
  if (typeof options.bypassDocumentValidation === 'boolean') ***REMOVED***
    command.bypassDocumentValidation = options.bypassDocumentValidation;
  ***REMOVED***

  // Do we have a readConcern specified
  if (!ignoreReadConcern) ***REMOVED***
    decorateWithReadConcern(command, self, options);
  ***REMOVED***

  // If we have allowDiskUse defined
  if (options.allowDiskUse) command.allowDiskUse = options.allowDiskUse;
  if (typeof options.maxTimeMS === 'number') command.maxTimeMS = options.maxTimeMS;

  // If we are giving a hint
  if (options.hint) command.hint = options.hint;

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(this, options, this.s.db, this);

  // If explain has been specified add it
  if (options.explain) ***REMOVED***
    if (command.readConcern || command.writeConcern) ***REMOVED***
      throw toError('"explain" cannot be used on an aggregate call with readConcern/writeConcern');
    ***REMOVED***
    command.explain = options.explain;
  ***REMOVED***

  if (typeof options.comment === 'string') command.comment = options.comment;

  // Validate that cursor options is valid
  if (options.cursor != null && typeof options.cursor !== 'object') ***REMOVED***
    throw toError('cursor options must be an object');
  ***REMOVED***

  options.cursor = options.cursor || ***REMOVED******REMOVED***;
  if (options.batchSize) options.cursor.batchSize = options.batchSize;
  command.cursor = options.cursor;

  // promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  // Set the AggregationCursor constructor
  options.cursorFactory = AggregationCursor;
  if (typeof callback !== 'function') ***REMOVED***
    if (!this.s.topology.capabilities()) ***REMOVED***
      throw new MongoError('cannot connect to server');
    ***REMOVED***

    // Allow disk usage command
    if (typeof options.allowDiskUse === 'boolean') command.allowDiskUse = options.allowDiskUse;
    if (typeof options.maxTimeMS === 'number') command.maxTimeMS = options.maxTimeMS;

    // Execute the cursor
    return this.s.topology.cursor(this.s.namespace, command, options);
  ***REMOVED***

  return handleCallback(callback, null, this.s.topology.cursor(this.s.namespace, command, options));
***REMOVED***;

/**
 * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.
 * @method
 * @since 3.0.0
 * @param ***REMOVED***Array***REMOVED*** [pipeline=null] An array of ***REMOVED***@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages***REMOVED*** through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings
 * @param ***REMOVED***string***REMOVED*** [options.fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.
 * @param ***REMOVED***object***REMOVED*** [options.resumeAfter=null] Specifies the logical starting point for the new change stream. This should be the _id field from a previously returned change stream document.
 * @param ***REMOVED***number***REMOVED*** [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=null] The number of documents to return per batch. See ***REMOVED***@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation***REMOVED***.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation settings for operation. See ***REMOVED***@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation***REMOVED***.
 * @param ***REMOVED***ReadPreference***REMOVED*** [options.readPreference=null] The read preference. Defaults to the read preference of the database or collection. See ***REMOVED***@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation***REMOVED***.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @return ***REMOVED***ChangeStream***REMOVED*** a ChangeStream instance.
 */
Collection.prototype.watch = function(pipeline, options) ***REMOVED***
  pipeline = pipeline || [];
  options = options || ***REMOVED******REMOVED***;

  // Allow optionally not specifying a pipeline
  if (!Array.isArray(pipeline)) ***REMOVED***
    options = pipeline;
    pipeline = [];
  ***REMOVED***

  return new ChangeStream(this, pipeline, options);
***REMOVED***;

/**
 * The callback format for results
 * @callback Collection~parallelCollectionScanCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Cursor[]***REMOVED*** cursors A list of cursors returned allowing for parallel reading of collection.
 */

/**
 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. There are
 * no ordering guarantees for returned results.
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=null] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param ***REMOVED***number***REMOVED*** [options.numCursors=1] The maximum number of parallel command cursors to return (the number of returned cursors will be in the range 1:numCursors)
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return all BSON documents as Raw Buffer documents.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~parallelCollectionScanCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.parallelCollectionScan = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED*** numCursors: 1 ***REMOVED***);
  // Set number of cursors to 1
  options.numCursors = options.numCursors || 1;
  options.batchSize = options.batchSize || 1000;

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(this, options, this.s.db, this);

  // Add a promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  return executeOperation(this.s.topology, parallelCollectionScan, [this, options, callback], ***REMOVED***
    skipSessions: true
  ***REMOVED***);
***REMOVED***;

var parallelCollectionScan = function(self, options, callback) ***REMOVED***
  // Create command object
  var commandObject = ***REMOVED***
    parallelCollectionScan: self.s.name,
    numCursors: options.numCursors
  ***REMOVED***;

  // Do we have a readConcern specified
  decorateWithReadConcern(commandObject, self, options);

  // Store the raw value
  var raw = options.raw;
  delete options['raw'];

  // Execute the command
  self.s.db.command(commandObject, options, function(err, result) ***REMOVED***
    if (err) return handleCallback(callback, err, null);
    if (result == null)
      return handleCallback(
        callback,
        new Error('no result returned for parallelCollectionScan'),
        null
      );

    var cursors = [];
    // Add the raw back to the option
    if (raw) options.raw = raw;
    // Create command cursors for each item
    for (var i = 0; i < result.cursors.length; i++) ***REMOVED***
      var rawId = result.cursors[i].cursor.id;
      // Convert cursorId to Long if needed
      var cursorId = typeof rawId === 'number' ? Long.fromNumber(rawId) : rawId;
      // Add a command cursor
      cursors.push(self.s.topology.cursor(self.s.namespace, cursorId, options));
    ***REMOVED***

    handleCallback(callback, null, cursors);
  ***REMOVED***);
***REMOVED***;

/**
 * Execute a geo search using a geo haystack index on a collection.
 *
 * @method
 * @param ***REMOVED***number***REMOVED*** x Point to search on the x axis, ensure the indexes are ordered in the same order.
 * @param ***REMOVED***number***REMOVED*** y Point to search on the y axis, ensure the indexes are ordered in the same order.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***number***REMOVED*** [options.maxDistance=null] Include results up to maxDistance from the point.
 * @param ***REMOVED***object***REMOVED*** [options.search=null] Filter the results by a query.
 * @param ***REMOVED***number***REMOVED*** [options.limit=false] Max number of results to return.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.geoHaystackSearch = function(x, y, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 2);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, geoHaystackSearch, [this, x, y, options, callback]);
***REMOVED***;

var geoHaystackSearch = function(self, x, y, options, callback) ***REMOVED***
  // Build command object
  var commandObject = ***REMOVED***
    geoSearch: self.s.name,
    near: [x, y]
  ***REMOVED***;

  // Remove read preference from hash if it exists
  commandObject = decorateCommand(commandObject, options, ***REMOVED*** readPreference: true, session: true ***REMOVED***);

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db, self);

  // Do we have a readConcern specified
  decorateWithReadConcern(commandObject, self, options);

  // Execute the command
  self.s.db.command(commandObject, options, function(err, res) ***REMOVED***
    if (err) return handleCallback(callback, err);
    if (res.err || res.errmsg) handleCallback(callback, toError(res));
    // should we only be returning res.results here? Not sure if the user
    // should see the other return information
    handleCallback(callback, null, res);
  ***REMOVED***);
***REMOVED***;

/**
 * Group function helper
 * @ignore
 */
// var groupFunction = function () ***REMOVED***
//   var c = db[ns].find(condition);
//   var map = new Map();
//   var reduce_function = reduce;
//
//   while (c.hasNext()) ***REMOVED***
//     var obj = c.next();
//     var key = ***REMOVED******REMOVED***;
//
//     for (var i = 0, len = keys.length; i < len; ++i) ***REMOVED***
//       var k = keys[i];
//       key[k] = obj[k];
//     ***REMOVED***
//
//     var aggObj = map.get(key);
//
//     if (aggObj == null) ***REMOVED***
//       var newObj = Object.extend(***REMOVED******REMOVED***, key);
//       aggObj = Object.extend(newObj, initial);
//       map.put(key, aggObj);
//     ***REMOVED***
//
//     reduce_function(obj, aggObj);
//   ***REMOVED***
//
//   return ***REMOVED*** "result": map.values() ***REMOVED***;
// ***REMOVED***.toString();
var groupFunction =
  'function () ***REMOVED***\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) ***REMOVED***\nvar obj = c.next();\nvar key = ***REMOVED******REMOVED***;\n\nfor (var i = 0, len = keys.length; i < len; ++i) ***REMOVED***\nvar k = keys[i];\nkey[k] = obj[k];\n***REMOVED***\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) ***REMOVED***\nvar newObj = Object.extend(***REMOVED******REMOVED***, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n***REMOVED***\n\nreduce_function(obj, aggObj);\n***REMOVED***\n\nreturn ***REMOVED*** "result": map.values() ***REMOVED***;\n***REMOVED***';

/**
 * Run a group command across a collection
 *
 * @method
 * @param ***REMOVED***(object|array|function|code)***REMOVED*** keys An object, array or function expressing the keys to group by.
 * @param ***REMOVED***object***REMOVED*** condition An optional condition that must be true for a row to be considered.
 * @param ***REMOVED***object***REMOVED*** initial Initial value of the aggregation counter object.
 * @param ***REMOVED***(function|Code)***REMOVED*** reduce The reduce function aggregates (reduces) the objects iterated
 * @param ***REMOVED***(function|Code)***REMOVED*** finalize An optional function to be run on each item in the result set just before the item is returned.
 * @param ***REMOVED***boolean***REMOVED*** command Specify if you wish to run using the internal group command or using eval, default is true.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated MongoDB 3.6 or higher will no longer support the group command. We recommend rewriting using the aggregation framework.
 */
Collection.prototype.group = function(
  keys,
  condition,
  initial,
  reduce,
  finalize,
  command,
  options,
  callback
) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 3);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  reduce = args.length ? args.shift() : null;
  finalize = args.length ? args.shift() : null;
  command = args.length ? args.shift() : null;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Make sure we are backward compatible
  if (!(typeof finalize === 'function')) ***REMOVED***
    command = finalize;
    finalize = null;
  ***REMOVED***

  if (
    !Array.isArray(keys) &&
    keys instanceof Object &&
    typeof keys !== 'function' &&
    !(keys._bsontype === 'Code')
  ) ***REMOVED***
    keys = Object.keys(keys);
  ***REMOVED***

  if (typeof reduce === 'function') ***REMOVED***
    reduce = reduce.toString();
  ***REMOVED***

  if (typeof finalize === 'function') ***REMOVED***
    finalize = finalize.toString();
  ***REMOVED***

  // Set up the command as default
  command = command == null ? true : command;

  return executeOperation(this.s.topology, group, [
    this,
    keys,
    condition,
    initial,
    reduce,
    finalize,
    command,
    options,
    callback
  ]);
***REMOVED***;

var group = function(self, keys, condition, initial, reduce, finalize, command, options, callback) ***REMOVED***
  // Execute using the command
  if (command) ***REMOVED***
    var reduceFunction = reduce && reduce._bsontype === 'Code' ? reduce : new Code(reduce);

    var selector = ***REMOVED***
      group: ***REMOVED***
        ns: self.s.name,
        $reduce: reduceFunction,
        cond: condition,
        initial: initial,
        out: 'inline'
      ***REMOVED***
    ***REMOVED***;

    // if finalize is defined
    if (finalize != null) selector.group['finalize'] = finalize;
    // Set up group selector
    if ('function' === typeof keys || (keys && keys._bsontype === 'Code')) ***REMOVED***
      selector.group.$keyf = keys && keys._bsontype === 'Code' ? keys : new Code(keys);
    ***REMOVED*** else ***REMOVED***
      var hash = ***REMOVED******REMOVED***;
      keys.forEach(function(key) ***REMOVED***
        hash[key] = 1;
      ***REMOVED***);
      selector.group.key = hash;
    ***REMOVED***

    options = shallowClone(options);
    // Ensure we have the right read preference inheritance
    options = getReadPreference(self, options, self.s.db, self);

    // Do we have a readConcern specified
    decorateWithReadConcern(selector, self, options);

    // Have we specified collation
    decorateWithCollation(selector, self, options);

    // Execute command
    self.s.db.command(selector, options, function(err, result) ***REMOVED***
      if (err) return handleCallback(callback, err, null);
      handleCallback(callback, null, result.retval);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    // Create execution scope
    var scope = reduce != null && reduce._bsontype === 'Code' ? reduce.scope : ***REMOVED******REMOVED***;

    scope.ns = self.s.name;
    scope.keys = keys;
    scope.condition = condition;
    scope.initial = initial;

    // Pass in the function text to execute within mongodb.
    var groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');

    self.s.db.eval(new Code(groupfn, scope), null, options, function(err, results) ***REMOVED***
      if (err) return handleCallback(callback, err, null);
      handleCallback(callback, null, results.result || results);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***;

/**
 * Functions that are passed as scope args must
 * be converted to Code instances.
 * @ignore
 */
function processScope(scope) ***REMOVED***
  if (!isObject(scope) || scope._bsontype === 'ObjectID') ***REMOVED***
    return scope;
  ***REMOVED***

  var keys = Object.keys(scope);
  var i = keys.length;
  var key;
  var new_scope = ***REMOVED******REMOVED***;

  while (i--) ***REMOVED***
    key = keys[i];
    if ('function' === typeof scope[key]) ***REMOVED***
      new_scope[key] = new Code(String(scope[key]));
    ***REMOVED*** else ***REMOVED***
      new_scope[key] = processScope(scope[key]);
    ***REMOVED***
  ***REMOVED***

  return new_scope;
***REMOVED***

/**
 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
 *
 * @method
 * @param ***REMOVED***(function|string)***REMOVED*** map The mapping function.
 * @param ***REMOVED***(function|string)***REMOVED*** reduce The reduce function.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***object***REMOVED*** [options.out=null] Sets the output target for the map reduce job. ****REMOVED***inline:1***REMOVED*** | ***REMOVED***replace:'collectionName'***REMOVED*** | ***REMOVED***merge:'collectionName'***REMOVED*** | ***REMOVED***reduce:'collectionName'***REMOVED****
 * @param ***REMOVED***object***REMOVED*** [options.query=null] Query filter object.
 * @param ***REMOVED***object***REMOVED*** [options.sort=null] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.
 * @param ***REMOVED***number***REMOVED*** [options.limit=null] Number of objects to return from collection.
 * @param ***REMOVED***boolean***REMOVED*** [options.keeptemp=false] Keep temporary data.
 * @param ***REMOVED***(function|string)***REMOVED*** [options.finalize=null] Finalize function.
 * @param ***REMOVED***object***REMOVED*** [options.scope=null] Can pass in variables that can be access from map/reduce/finalize.
 * @param ***REMOVED***boolean***REMOVED*** [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.
 * @param ***REMOVED***boolean***REMOVED*** [options.verbose=false] Provide statistics on job execution time.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.mapReduce = function(map, reduce, options, callback) ***REMOVED***
  if ('function' === typeof options) (callback = options), (options = ***REMOVED******REMOVED***);
  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)
  if (null == options.out) ***REMOVED***
    throw new Error(
      'the out option parameter must be defined, see mongodb docs for possible values'
    );
  ***REMOVED***

  if ('function' === typeof map) ***REMOVED***
    map = map.toString();
  ***REMOVED***

  if ('function' === typeof reduce) ***REMOVED***
    reduce = reduce.toString();
  ***REMOVED***

  if ('function' === typeof options.finalize) ***REMOVED***
    options.finalize = options.finalize.toString();
  ***REMOVED***

  return executeOperation(this.s.topology, mapReduce, [this, map, reduce, options, callback]);
***REMOVED***;

var mapReduce = function(self, map, reduce, options, callback) ***REMOVED***
  var mapCommandHash = ***REMOVED***
    mapreduce: self.s.name,
    map: map,
    reduce: reduce
  ***REMOVED***;

  // Exclusion list
  var exclusionList = ['readPreference', 'session'];

  // Add any other options passed in
  for (var n in options) ***REMOVED***
    if ('scope' === n) ***REMOVED***
      mapCommandHash[n] = processScope(options[n]);
    ***REMOVED*** else ***REMOVED***
      // Only include if not in exclusion list
      if (exclusionList.indexOf(n) === -1) ***REMOVED***
        mapCommandHash[n] = options[n];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  options = shallowClone(options);

  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db, self);

  // If we have a read preference and inline is not set as output fail hard
  if (
    options.readPreference !== false &&
    options.readPreference !== 'primary' &&
    options['out'] &&
    (options['out'].inline !== 1 && options['out'] !== 'inline')
  ) ***REMOVED***
    // Force readPreference to primary
    options.readPreference = 'primary';
    // Decorate command with writeConcern if supported
    applyWriteConcern(mapCommandHash, ***REMOVED*** db: self.s.db, collection: self ***REMOVED***, options);
  ***REMOVED*** else ***REMOVED***
    decorateWithReadConcern(mapCommandHash, self, options);
  ***REMOVED***

  // Is bypassDocumentValidation specified
  if (typeof options.bypassDocumentValidation === 'boolean') ***REMOVED***
    mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(mapCommandHash, self, options);

  // Execute command
  self.s.db.command(mapCommandHash, options, function(err, result) ***REMOVED***
    if (err) return handleCallback(callback, err);
    // Check if we have an error
    if (1 !== result.ok || result.err || result.errmsg) ***REMOVED***
      return handleCallback(callback, toError(result));
    ***REMOVED***

    // Create statistics value
    var stats = ***REMOVED******REMOVED***;
    if (result.timeMillis) stats['processtime'] = result.timeMillis;
    if (result.counts) stats['counts'] = result.counts;
    if (result.timing) stats['timing'] = result.timing;

    // invoked with inline?
    if (result.results) ***REMOVED***
      // If we wish for no verbosity
      if (options['verbose'] == null || !options['verbose']) ***REMOVED***
        return handleCallback(callback, null, result.results);
      ***REMOVED***

      return handleCallback(callback, null, ***REMOVED*** results: result.results, stats: stats ***REMOVED***);
    ***REMOVED***

    // The returned collection
    var collection = null;

    // If we have an object it's a different db
    if (result.result != null && typeof result.result === 'object') ***REMOVED***
      var doc = result.result;
      // Return a collection from another db
      var Db = require('./db');
      collection = new Db(doc.db, self.s.db.s.topology, self.s.db.s.options).collection(
        doc.collection
      );
    ***REMOVED*** else ***REMOVED***
      // Create a collection object that wraps the result collection
      collection = self.s.db.collection(result.result);
    ***REMOVED***

    // If we wish for no verbosity
    if (options['verbose'] == null || !options['verbose']) ***REMOVED***
      return handleCallback(callback, err, collection);
    ***REMOVED***

    // Return stats as third set of values
    handleCallback(callback, err, ***REMOVED*** collection: collection, stats: stats ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @return ***REMOVED***UnorderedBulkOperation***REMOVED***
 */
Collection.prototype.initializeUnorderedBulkOp = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  options.promiseLibrary = this.s.promiseLibrary;
  return unordered(this.s.topology, this, options);
***REMOVED***;

/**
 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***OrderedBulkOperation***REMOVED*** callback The command result callback
 * @return ***REMOVED***null***REMOVED***
 */
Collection.prototype.initializeOrderedBulkOp = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  options.promiseLibrary = this.s.promiseLibrary;
  return ordered(this.s.topology, this, options);
***REMOVED***;

// Figure out the read preference
var getReadPreference = function(self, options, db) ***REMOVED***
  let r = null;
  if (options.readPreference) ***REMOVED***
    r = options.readPreference;
  ***REMOVED*** else if (self.s.readPreference) ***REMOVED***
    r = self.s.readPreference;
  ***REMOVED*** else if (db.s.readPreference) ***REMOVED***
    r = db.s.readPreference;
  ***REMOVED*** else ***REMOVED***
    return options;
  ***REMOVED***

  if (typeof r === 'string') ***REMOVED***
    options.readPreference = new ReadPreference(r);
  ***REMOVED*** else if (r && !(r instanceof ReadPreference) && typeof r === 'object') ***REMOVED***
    const mode = r.mode || r.preference;
    if (mode && typeof mode === 'string') ***REMOVED***
      options.readPreference = new ReadPreference(mode, r.tags, ***REMOVED***
        maxStalenessSeconds: r.maxStalenessSeconds
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED*** else if (!(r instanceof ReadPreference)) ***REMOVED***
    throw new TypeError('Invalid read preference: ' + r);
  ***REMOVED***

  return options;
***REMOVED***;

module.exports = Collection;
