'use strict';

const MongoError = require('mongodb-core').MongoError;
const ReadPreference = require('mongodb-core').ReadPreference;

var shallowClone = function(obj) ***REMOVED***
  var copy = ***REMOVED******REMOVED***;
  for (var name in obj) copy[name] = obj[name];
  return copy;
***REMOVED***;

// Figure out the read preference
var translateReadPreference = function(options) ***REMOVED***
  var r = null;
  if (options.readPreference) ***REMOVED***
    r = options.readPreference;
  ***REMOVED*** else ***REMOVED***
    return options;
  ***REMOVED***

  if (typeof r === 'string') ***REMOVED***
    options.readPreference = new ReadPreference(r);
  ***REMOVED*** else if (r && !(r instanceof ReadPreference) && typeof r === 'object') ***REMOVED***
    const mode = r.mode || r.preference;
    if (mode && typeof mode === 'string') ***REMOVED***
      options.readPreference = new ReadPreference(mode, r.tags, ***REMOVED***
        maxStalenessSeconds: r.maxStalenessSeconds
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED*** else if (!(r instanceof ReadPreference)) ***REMOVED***
    throw new TypeError('Invalid read preference: ' + r);
  ***REMOVED***

  return options;
***REMOVED***;

// Set simple property
var getSingleProperty = function(obj, name, value) ***REMOVED***
  Object.defineProperty(obj, name, ***REMOVED***
    enumerable: true,
    get: function() ***REMOVED***
      return value;
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

var formatSortValue = (exports.formatSortValue = function(sortDirection) ***REMOVED***
  var value = ('' + sortDirection).toLowerCase();

  switch (value) ***REMOVED***
    case 'ascending':
    case 'asc':
    case '1':
      return 1;
    case 'descending':
    case 'desc':
    case '-1':
      return -1;
    default:
      throw new Error(
        'Illegal sort clause, must be of the form ' +
          "[['field1', '(ascending|descending)'], " +
          "['field2', '(ascending|descending)']]"
      );
  ***REMOVED***
***REMOVED***);

var formattedOrderClause = (exports.formattedOrderClause = function(sortValue) ***REMOVED***
  var orderBy = ***REMOVED******REMOVED***;
  if (sortValue == null) return null;
  if (Array.isArray(sortValue)) ***REMOVED***
    if (sortValue.length === 0) ***REMOVED***
      return null;
    ***REMOVED***

    for (var i = 0; i < sortValue.length; i++) ***REMOVED***
      if (sortValue[i].constructor === String) ***REMOVED***
        orderBy[sortValue[i]] = 1;
      ***REMOVED*** else ***REMOVED***
        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if (sortValue != null && typeof sortValue === 'object') ***REMOVED***
    orderBy = sortValue;
  ***REMOVED*** else if (typeof sortValue === 'string') ***REMOVED***
    orderBy[sortValue] = 1;
  ***REMOVED*** else ***REMOVED***
    throw new Error(
      'Illegal sort clause, must be of the form ' +
        "[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]"
    );
  ***REMOVED***

  return orderBy;
***REMOVED***);

var checkCollectionName = function checkCollectionName(collectionName) ***REMOVED***
  if ('string' !== typeof collectionName) ***REMOVED***
    throw new MongoError('collection name must be a String');
  ***REMOVED***

  if (!collectionName || collectionName.indexOf('..') !== -1) ***REMOVED***
    throw new MongoError('collection names cannot be empty');
  ***REMOVED***

  if (
    collectionName.indexOf('$') !== -1 &&
    collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null
  ) ***REMOVED***
    throw new MongoError("collection names must not contain '$'");
  ***REMOVED***

  if (collectionName.match(/^\.|\.$/) != null) ***REMOVED***
    throw new MongoError("collection names must not start or end with '.'");
  ***REMOVED***

  // Validate that we are not passing 0x00 in the colletion name
  if (collectionName.indexOf('\x00') !== -1) ***REMOVED***
    throw new MongoError('collection names cannot contain a null character');
  ***REMOVED***
***REMOVED***;

var handleCallback = function(callback, err, value1, value2) ***REMOVED***
  try ***REMOVED***
    if (callback == null) return;

    if (callback) ***REMOVED***
      return value2 ? callback(err, value1, value2) : callback(err, value1);
    ***REMOVED***
  ***REMOVED*** catch (err) ***REMOVED***
    process.nextTick(function() ***REMOVED***
      throw err;
    ***REMOVED***);
    return false;
  ***REMOVED***

  return true;
***REMOVED***;

/**
 * Wrap a Mongo error document in an Error instance
 * @ignore
 * @api private
 */
var toError = function(error) ***REMOVED***
  if (error instanceof Error) return error;

  var msg = error.err || error.errmsg || error.errMessage || error;
  var e = MongoError.create(***REMOVED*** message: msg, driver: true ***REMOVED***);

  // Get all object keys
  var keys = typeof error === 'object' ? Object.keys(error) : [];

  for (var i = 0; i < keys.length; i++) ***REMOVED***
    try ***REMOVED***
      e[keys[i]] = error[keys[i]];
    ***REMOVED*** catch (err) ***REMOVED***
      // continue
    ***REMOVED***
  ***REMOVED***

  return e;
***REMOVED***;

/**
 * @ignore
 */
var normalizeHintField = function normalizeHintField(hint) ***REMOVED***
  var finalHint = null;

  if (typeof hint === 'string') ***REMOVED***
    finalHint = hint;
  ***REMOVED*** else if (Array.isArray(hint)) ***REMOVED***
    finalHint = ***REMOVED******REMOVED***;

    hint.forEach(function(param) ***REMOVED***
      finalHint[param] = 1;
    ***REMOVED***);
  ***REMOVED*** else if (hint != null && typeof hint === 'object') ***REMOVED***
    finalHint = ***REMOVED******REMOVED***;
    for (var name in hint) ***REMOVED***
      finalHint[name] = hint[name];
    ***REMOVED***
  ***REMOVED***

  return finalHint;
***REMOVED***;

/**
 * Create index name based on field spec
 *
 * @ignore
 * @api private
 */
var parseIndexOptions = function(fieldOrSpec) ***REMOVED***
  var fieldHash = ***REMOVED******REMOVED***;
  var indexes = [];
  var keys;

  // Get all the fields accordingly
  if ('string' === typeof fieldOrSpec) ***REMOVED***
    // 'type'
    indexes.push(fieldOrSpec + '_' + 1);
    fieldHash[fieldOrSpec] = 1;
  ***REMOVED*** else if (Array.isArray(fieldOrSpec)) ***REMOVED***
    fieldOrSpec.forEach(function(f) ***REMOVED***
      if ('string' === typeof f) ***REMOVED***
        // [***REMOVED***location:'2d'***REMOVED***, 'type']
        indexes.push(f + '_' + 1);
        fieldHash[f] = 1;
      ***REMOVED*** else if (Array.isArray(f)) ***REMOVED***
        // [['location', '2d'],['type', 1]]
        indexes.push(f[0] + '_' + (f[1] || 1));
        fieldHash[f[0]] = f[1] || 1;
      ***REMOVED*** else if (isObject(f)) ***REMOVED***
        // [***REMOVED***location:'2d'***REMOVED***, ***REMOVED***type:1***REMOVED***]
        keys = Object.keys(f);
        keys.forEach(function(k) ***REMOVED***
          indexes.push(k + '_' + f[k]);
          fieldHash[k] = f[k];
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        // undefined (ignore)
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED*** else if (isObject(fieldOrSpec)) ***REMOVED***
    // ***REMOVED***location:'2d', type:1***REMOVED***
    keys = Object.keys(fieldOrSpec);
    keys.forEach(function(key) ***REMOVED***
      indexes.push(key + '_' + fieldOrSpec[key]);
      fieldHash[key] = fieldOrSpec[key];
    ***REMOVED***);
  ***REMOVED***

  return ***REMOVED***
    name: indexes.join('_'),
    keys: keys,
    fieldHash: fieldHash
  ***REMOVED***;
***REMOVED***;

var isObject = (exports.isObject = function(arg) ***REMOVED***
  return '[object Object]' === Object.prototype.toString.call(arg);
***REMOVED***);

var debugOptions = function(debugFields, options) ***REMOVED***
  var finaloptions = ***REMOVED******REMOVED***;
  debugFields.forEach(function(n) ***REMOVED***
    finaloptions[n] = options[n];
  ***REMOVED***);

  return finaloptions;
***REMOVED***;

var decorateCommand = function(command, options, exclude) ***REMOVED***
  for (var name in options) ***REMOVED***
    if (exclude[name] == null) command[name] = options[name];
  ***REMOVED***

  return command;
***REMOVED***;

var mergeOptions = function(target, source) ***REMOVED***
  for (var name in source) ***REMOVED***
    target[name] = source[name];
  ***REMOVED***

  return target;
***REMOVED***;

// Merge options with translation
var translateOptions = function(target, source) ***REMOVED***
  var translations = ***REMOVED***
    // SSL translation options
    sslCA: 'ca',
    sslCRL: 'crl',
    sslValidate: 'rejectUnauthorized',
    sslKey: 'key',
    sslCert: 'cert',
    sslPass: 'passphrase',
    // SocketTimeout translation options
    socketTimeoutMS: 'socketTimeout',
    connectTimeoutMS: 'connectionTimeout',
    // Replicaset options
    replicaSet: 'setName',
    rs_name: 'setName',
    secondaryAcceptableLatencyMS: 'acceptableLatency',
    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',
    // Mongos options
    acceptableLatencyMS: 'localThresholdMS'
  ***REMOVED***;

  for (var name in source) ***REMOVED***
    if (translations[name]) ***REMOVED***
      target[translations[name]] = source[name];
    ***REMOVED*** else ***REMOVED***
      target[name] = source[name];
    ***REMOVED***
  ***REMOVED***

  return target;
***REMOVED***;

var filterOptions = function(options, names) ***REMOVED***
  var filterOptions = ***REMOVED******REMOVED***;

  for (var name in options) ***REMOVED***
    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];
  ***REMOVED***

  // Filtered options
  return filterOptions;
***REMOVED***;

// Write concern keys
var writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync'];

// Merge the write concern options
var mergeOptionsAndWriteConcern = function(targetOptions, sourceOptions, keys, mergeWriteConcern) ***REMOVED***
  // Mix in any allowed options
  for (var i = 0; i < keys.length; i++) ***REMOVED***
    if (!targetOptions[keys[i]] && sourceOptions[keys[i]] !== undefined) ***REMOVED***
      targetOptions[keys[i]] = sourceOptions[keys[i]];
    ***REMOVED***
  ***REMOVED***

  // No merging of write concern
  if (!mergeWriteConcern) return targetOptions;

  // Found no write Concern options
  var found = false;
  for (i = 0; i < writeConcernKeys.length; i++) ***REMOVED***
    if (targetOptions[writeConcernKeys[i]]) ***REMOVED***
      found = true;
      break;
    ***REMOVED***
  ***REMOVED***

  if (!found) ***REMOVED***
    for (i = 0; i < writeConcernKeys.length; i++) ***REMOVED***
      if (sourceOptions[writeConcernKeys[i]]) ***REMOVED***
        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return targetOptions;
***REMOVED***;

/**
 * Executes the given operation with provided arguments.
 *
 * This method reduces large amounts of duplication in the entire codebase by providing
 * a single point for determining whether callbacks or promises should be used. Additionally
 * it allows for a single point of entry to provide features such as implicit sessions, which
 * are required by the Driver Sessions specification in the event that a ClientSession is
 * not provided
 *
 * @param ***REMOVED***object***REMOVED*** topology The topology to execute this operation on
 * @param ***REMOVED***function***REMOVED*** operation The operation to execute
 * @param ***REMOVED***array***REMOVED*** args Arguments to apply the provided operation
 * @param ***REMOVED***object***REMOVED*** [options] Options that modify the behavior of the method
 * @param ***REMOVED***function]***REMOVED*** [options.resultMutator] Allows for the result of the operation to be changed for custom return types
 */
const executeOperation = (topology, operation, args, options) => ***REMOVED***
  if (topology == null) ***REMOVED***
    throw new TypeError('This method requires a valid topology instance');
  ***REMOVED***

  if (!Array.isArray(args)) ***REMOVED***
    throw new TypeError('This method requires an array of arguments to apply');
  ***REMOVED***

  options = options || ***REMOVED******REMOVED***;
  const Promise = topology.s.promiseLibrary;
  let resultMutator = options.resultMutator;
  let callback = args[args.length - 1];

  // The driver sessions spec mandates that we implicitly create sessions for operations
  // that are not explicitly provided with a session.
  let session, opOptions, owner;
  if (!options.skipSessions && topology.hasSessionSupport()) ***REMOVED***
    opOptions = args[args.length - 2];
    if (opOptions == null || opOptions.session == null) ***REMOVED***
      owner = Symbol();
      session = topology.startSession(***REMOVED*** owner ***REMOVED***);
      const optionsIndex = args.length - 2;
      args[optionsIndex] = Object.assign(***REMOVED******REMOVED***, args[optionsIndex], ***REMOVED*** session: session ***REMOVED***);
    ***REMOVED*** else if (opOptions.session && opOptions.session.hasEnded) ***REMOVED***
      throw new MongoError('Use of expired sessions is not permitted');
    ***REMOVED***
  ***REMOVED***

  const makeExecuteCallback = (resolve, reject) =>
    function executeCallback(err, result) ***REMOVED***
      if (session && session.owner === owner && !options.returnsCursor) ***REMOVED***
        session.endSession(() => ***REMOVED***
          delete opOptions.session;
          if (err) return reject(err);
          if (resultMutator) return resolve(resultMutator(result));
          resolve(result);
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        if (err) return reject(err);
        if (resultMutator) return resolve(resultMutator(result));
        resolve(result);
      ***REMOVED***
    ***REMOVED***;

  // Execute using callback
  if (typeof callback === 'function') ***REMOVED***
    callback = args.pop();
    const handler = makeExecuteCallback(
      result => callback(null, result),
      err => callback(err, null)
    );
    args.push(handler);

    try ***REMOVED***
      return operation.apply(null, args);
    ***REMOVED*** catch (e) ***REMOVED***
      handler(e);
      throw e;
    ***REMOVED***
  ***REMOVED***

  // Return a Promise
  if (args[args.length - 1] != null) ***REMOVED***
    throw new TypeError('final argument to `executeOperation` must be a callback');
  ***REMOVED***

  return new Promise(function(resolve, reject) ***REMOVED***
    const handler = makeExecuteCallback(resolve, reject);
    args[args.length - 1] = handler;

    try ***REMOVED***
      return operation.apply(null, args);
    ***REMOVED*** catch (e) ***REMOVED***
      handler(e);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Applies a write concern to a command based on well defined inheritance rules, optionally
 * detecting support for the write concern in the first place.
 *
 * @param ***REMOVED***Object***REMOVED*** target the target command we will be applying the write concern to
 * @param ***REMOVED***Object***REMOVED*** sources sources where we can inherit default write concerns from
 * @param ***REMOVED***Object***REMOVED*** [options] optional settings passed into a command for write concern overrides
 * @returns ***REMOVED***Object***REMOVED*** the (now) decorated target
 */
function applyWriteConcern(target, sources, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  const db = sources.db;
  const coll = sources.collection;

  // NOTE: there is probably a much better place for this
  if (db && db.s.options.retryWrites) ***REMOVED***
    target.retryWrites = true;
  ***REMOVED***

  if (options.w != null || options.j != null || options.fsync != null) ***REMOVED***
    const writeConcern = ***REMOVED******REMOVED***;
    if (options.w != null) writeConcern.w = options.w;
    if (options.wtimeout != null) writeConcern.wtimeout = options.wtimeout;
    if (options.j != null) writeConcern.j = options.j;
    if (options.fsync != null) writeConcern.fsync = options.fsync;
    return Object.assign(target, ***REMOVED*** writeConcern ***REMOVED***);
  ***REMOVED***

  if (
    coll &&
    (coll.writeConcern.w != null || coll.writeConcern.j != null || coll.writeConcern.fsync != null)
  ) ***REMOVED***
    return Object.assign(target, ***REMOVED*** writeConcern: Object.assign(***REMOVED******REMOVED***, coll.writeConcern) ***REMOVED***);
  ***REMOVED***

  if (
    db &&
    (db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null)
  ) ***REMOVED***
    return Object.assign(target, ***REMOVED*** writeConcern: Object.assign(***REMOVED******REMOVED***, db.writeConcern) ***REMOVED***);
  ***REMOVED***

  return target;
***REMOVED***

exports.filterOptions = filterOptions;
exports.mergeOptions = mergeOptions;
exports.translateOptions = translateOptions;
exports.shallowClone = shallowClone;
exports.getSingleProperty = getSingleProperty;
exports.checkCollectionName = checkCollectionName;
exports.toError = toError;
exports.formattedOrderClause = formattedOrderClause;
exports.parseIndexOptions = parseIndexOptions;
exports.normalizeHintField = normalizeHintField;
exports.handleCallback = handleCallback;
exports.decorateCommand = decorateCommand;
exports.isObject = isObject;
exports.debugOptions = debugOptions;
exports.MAX_JS_INT = 0x20000000000000;
exports.mergeOptionsAndWriteConcern = mergeOptionsAndWriteConcern;
exports.translateReadPreference = translateReadPreference;
exports.executeOperation = executeOperation;
exports.applyWriteConcern = applyWriteConcern;
