'use strict';

const inherits = require('util').inherits;
const MongoError = require('mongodb-core').MongoError;
const Readable = require('stream').Readable;
const CoreCursor = require('./cursor');

/**
 * @fileOverview The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB
 * allowing for iteration over the results returned from the underlying query. It supports
 * one by one document iteration, conversion to an array or can be iterated as a Node 4.X
 * or higher stream
 *
 * **AGGREGATIONCURSOR Cannot directly be instantiated**
 * @example
 * const MongoClient = require('mongodb').MongoClient;
 * const test = require('assert');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) ***REMOVED***
 *   // Create a collection we want to drop later
 *   const col = client.db(dbName).collection('createIndexExample1');
 *   // Insert a bunch of documents
 *   col.insert([***REMOVED***a:1, b:1***REMOVED***
 *     , ***REMOVED***a:2, b:2***REMOVED***, ***REMOVED***a:3, b:3***REMOVED***
 *     , ***REMOVED***a:4, b:4***REMOVED***], ***REMOVED***w:1***REMOVED***, function(err, result) ***REMOVED***
 *     test.equal(null, err);
 *     // Show that duplicate records got dropped
 *     col.aggregation(***REMOVED******REMOVED***, ***REMOVED***cursor: ***REMOVED******REMOVED******REMOVED***).toArray(function(err, items) ***REMOVED***
 *       test.equal(null, err);
 *       test.equal(4, items.length);
 *       client.close();
 *     ***REMOVED***);
 *   ***REMOVED***);
 * ***REMOVED***);
 */

/**
 * Namespace provided by the browser.
 * @external Readable
 */

/**
 * Creates a new Aggregation Cursor instance (INTERNAL TYPE, do not instantiate directly)
 * @class AggregationCursor
 * @extends external:Readable
 * @fires AggregationCursor#data
 * @fires AggregationCursor#end
 * @fires AggregationCursor#close
 * @fires AggregationCursor#readable
 * @return ***REMOVED***AggregationCursor***REMOVED*** an AggregationCursor instance.
 */
var AggregationCursor = function(bson, ns, cmd, options, topology, topologyOptions) ***REMOVED***
  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
  var state = AggregationCursor.INIT;
  var streamOptions = ***REMOVED******REMOVED***;

  // MaxTimeMS
  var maxTimeMS = null;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary || Promise;

  // Set up
  Readable.call(this, ***REMOVED*** objectMode: true ***REMOVED***);

  // Internal state
  this.s = ***REMOVED***
    // MaxTimeMS
    maxTimeMS: maxTimeMS,
    // State
    state: state,
    // Stream options
    streamOptions: streamOptions,
    // BSON
    bson: bson,
    // Namespace
    ns: ns,
    // Command
    cmd: cmd,
    // Options
    options: options,
    // Topology
    topology: topology,
    // Topology Options
    topologyOptions: topologyOptions,
    // Promise library
    promiseLibrary: promiseLibrary,
    // Optional ClientSession
    session: options.session
  ***REMOVED***;
***REMOVED***;

/**
 * AggregationCursor stream data event, fired for each document in the cursor.
 *
 * @event AggregationCursor#data
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * AggregationCursor stream end event
 *
 * @event AggregationCursor#end
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * AggregationCursor stream close event
 *
 * @event AggregationCursor#close
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * AggregationCursor stream readable event
 *
 * @event AggregationCursor#readable
 * @type ***REMOVED***null***REMOVED***
 */

// Inherit from Readable
inherits(AggregationCursor, Readable);

// Extend the Cursor
for (var name in CoreCursor.prototype) ***REMOVED***
  AggregationCursor.prototype[name] = CoreCursor.prototype[name];
***REMOVED***

/**
 * Set the batch size for the cursor.
 * @method
 * @param ***REMOVED***number***REMOVED*** value The batchSize for the cursor.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.batchSize = function(value) ***REMOVED***
  if (this.s.state === AggregationCursor.CLOSED || this.isDead())
    throw MongoError.create(***REMOVED*** message: 'Cursor is closed', driver: true ***REMOVED***);
  if (typeof value !== 'number')
    throw MongoError.create(***REMOVED*** message: 'batchSize requires an integer', drvier: true ***REMOVED***);
  if (this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
  this.setCursorBatchSize(value);
  return this;
***REMOVED***;

/**
 * Add a geoNear stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The geoNear stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.geoNear = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $geoNear: document ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Add a group stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The group stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.group = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $group: document ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Add a limit stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** value The state limit value.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.limit = function(value) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $limit: value ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Add a match stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The match stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.match = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $match: document ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Add a maxTimeMS stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** value The state maxTimeMS value.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.maxTimeMS = function(value) ***REMOVED***
  if (this.s.topology.lastIsMaster().minWireVersion > 2) ***REMOVED***
    this.s.cmd.maxTimeMS = value;
  ***REMOVED***
  return this;
***REMOVED***;

/**
 * Add a out stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** destination The destination name.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.out = function(destination) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $out: destination ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Add a project stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The project stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.project = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $project: document ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Add a lookup stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The lookup stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.lookup = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $lookup: document ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Add a redact stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The redact stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.redact = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $redact: document ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Add a skip stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** value The state skip value.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.skip = function(value) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $skip: value ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Add a sort stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The sort stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.sort = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $sort: document ***REMOVED***);
  return this;
***REMOVED***;

/**
 * Add a unwind stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** field The unwind field name.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.unwind = function(field) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED*** $unwind: field ***REMOVED***);
  return this;
***REMOVED***;

AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;

/**
 * Get the next available document from the cursor, returns null if no more documents are available.
 * @function AggregationCursor.prototype.next
 * @param ***REMOVED***AggregationCursor~resultCallback***REMOVED*** [callback] The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * Check if there is any document still available in the cursor
 * @function AggregationCursor.prototype.hasNext
 * @param ***REMOVED***AggregationCursor~resultCallback***REMOVED*** [callback] The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * The callback format for results
 * @callback AggregationCursor~toArrayResultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***object[]***REMOVED*** documents All the documents the satisfy the cursor.
 */

/**
 * Returns an array of documents. The caller is responsible for making sure that there
 * is enough memory to store the results. Note that the array only contain partial
 * results when this cursor had been previouly accessed. In that case,
 * cursor.rewind() can be used to reset the cursor.
 * @method AggregationCursor.prototype.toArray
 * @param ***REMOVED***AggregationCursor~toArrayResultCallback***REMOVED*** [callback] The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * The callback format for results
 * @callback AggregationCursor~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***(object|null)***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Iterates over all the documents for this cursor. As with *****REMOVED***cursor.toArray***REMOVED*****,
 * not all of the elements will be iterated if this cursor had been previouly accessed.
 * In that case, *****REMOVED***cursor.rewind***REMOVED***** can be used to reset the cursor. However, unlike
 * *****REMOVED***cursor.toArray***REMOVED*****, the cursor will only hold a maximum of batch size elements
 * at any given time if batch size is specified. Otherwise, the caller is responsible
 * for making sure that the entire result can fit the memory.
 * @method AggregationCursor.prototype.each
 * @param ***REMOVED***AggregationCursor~resultCallback***REMOVED*** callback The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * Close the cursor, sending a AggregationCursor command and emitting close.
 * @method AggregationCursor.prototype.close
 * @param ***REMOVED***AggregationCursor~resultCallback***REMOVED*** [callback] The result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * Is the cursor closed
 * @method AggregationCursor.prototype.isClosed
 * @return ***REMOVED***boolean***REMOVED***
 */

/**
 * Execute the explain for the cursor
 * @method AggregationCursor.prototype.explain
 * @param ***REMOVED***AggregationCursor~resultCallback***REMOVED*** [callback] The result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * Clone the cursor
 * @function AggregationCursor.prototype.clone
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */

/**
 * Resets the cursor
 * @function AggregationCursor.prototype.rewind
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */

/**
 * The callback format for the forEach iterator method
 * @callback AggregationCursor~iteratorCallback
 * @param ***REMOVED***Object***REMOVED*** doc An emitted document for the iterator
 */

/**
 * The callback error format for the forEach iterator method
 * @callback AggregationCursor~endCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 */

/*
 * Iterates over all the documents for this cursor using the iterator, callback pattern.
 * @method AggregationCursor.prototype.forEach
 * @param ***REMOVED***AggregationCursor~iteratorCallback***REMOVED*** iterator The iteration callback.
 * @param ***REMOVED***AggregationCursor~endCallback***REMOVED*** callback The end callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***null***REMOVED***
 */

AggregationCursor.INIT = 0;
AggregationCursor.OPEN = 1;
AggregationCursor.CLOSED = 2;

module.exports = AggregationCursor;
