'use strict';

const common = require('./common');
const utils = require('../utils');
const toError = require('../utils').toError;
const handleCallback = require('../utils').handleCallback;
const shallowClone = utils.shallowClone;
const BulkWriteResult = common.BulkWriteResult;
const ObjectID = require('mongodb-core').BSON.ObjectID;
const BSON = require('mongodb-core').BSON;
const Batch = common.Batch;
const mergeBatchResults = common.mergeBatchResults;
const executeOperation = utils.executeOperation;
const BulkWriteError = require('./common').BulkWriteError;
const applyWriteConcern = utils.applyWriteConcern;

var bson = new BSON([
  BSON.Binary,
  BSON.Code,
  BSON.DBRef,
  BSON.Decimal128,
  BSON.Double,
  BSON.Int32,
  BSON.Long,
  BSON.Map,
  BSON.MaxKey,
  BSON.MinKey,
  BSON.ObjectId,
  BSON.BSONRegExp,
  BSON.Symbol,
  BSON.Timestamp
]);

/**
 * Create a FindOperatorsOrdered instance (INTERNAL TYPE, do not instantiate directly)
 * @class
 * @return ***REMOVED***FindOperatorsOrdered***REMOVED*** a FindOperatorsOrdered instance.
 */
var FindOperatorsOrdered = function(self) ***REMOVED***
  this.s = self.s;
***REMOVED***;

/**
 * Add a single update document to the bulk operation
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** doc update operations
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***OrderedBulkOperation***REMOVED***
 */
FindOperatorsOrdered.prototype.update = function(updateDocument) ***REMOVED***
  // Perform upsert
  var upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false;

  // Establish the update command
  var document = ***REMOVED***
    q: this.s.currentOp.selector,
    u: updateDocument,
    multi: true,
    upsert: upsert
  ***REMOVED***;

  // Clear out current Op
  this.s.currentOp = null;
  // Add the update document to the list
  return addToOperationsList(this, common.UPDATE, document);
***REMOVED***;

/**
 * Add a single update one document to the bulk operation
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** doc update operations
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***OrderedBulkOperation***REMOVED***
 */
FindOperatorsOrdered.prototype.updateOne = function(updateDocument) ***REMOVED***
  // Perform upsert
  var upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false;

  // Establish the update command
  var document = ***REMOVED***
    q: this.s.currentOp.selector,
    u: updateDocument,
    multi: false,
    upsert: upsert
  ***REMOVED***;

  // Clear out current Op
  this.s.currentOp = null;
  // Add the update document to the list
  return addToOperationsList(this, common.UPDATE, document);
***REMOVED***;

/**
 * Add a replace one operation to the bulk operation
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** doc the new document to replace the existing one with
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***OrderedBulkOperation***REMOVED***
 */
FindOperatorsOrdered.prototype.replaceOne = function(updateDocument) ***REMOVED***
  this.updateOne(updateDocument);
***REMOVED***;

/**
 * Upsert modifier for update bulk operation
 *
 * @method
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***FindOperatorsOrdered***REMOVED***
 */
FindOperatorsOrdered.prototype.upsert = function() ***REMOVED***
  this.s.currentOp.upsert = true;
  return this;
***REMOVED***;

/**
 * Add a remove one operation to the bulk operation
 *
 * @method
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***OrderedBulkOperation***REMOVED***
 */
FindOperatorsOrdered.prototype.deleteOne = function() ***REMOVED***
  // Establish the update command
  var document = ***REMOVED***
    q: this.s.currentOp.selector,
    limit: 1
  ***REMOVED***;

  // Clear out current Op
  this.s.currentOp = null;
  // Add the remove document to the list
  return addToOperationsList(this, common.REMOVE, document);
***REMOVED***;

// Backward compatibility
FindOperatorsOrdered.prototype.removeOne = FindOperatorsOrdered.prototype.deleteOne;

/**
 * Add a remove operation to the bulk operation
 *
 * @method
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***OrderedBulkOperation***REMOVED***
 */
FindOperatorsOrdered.prototype.delete = function() ***REMOVED***
  // Establish the update command
  var document = ***REMOVED***
    q: this.s.currentOp.selector,
    limit: 0
  ***REMOVED***;

  // Clear out current Op
  this.s.currentOp = null;
  // Add the remove document to the list
  return addToOperationsList(this, common.REMOVE, document);
***REMOVED***;

// Backward compatibility
FindOperatorsOrdered.prototype.remove = FindOperatorsOrdered.prototype.delete;

// Add to internal list of documents
var addToOperationsList = function(_self, docType, document) ***REMOVED***
  // Get the bsonSize
  var bsonSize = bson.calculateObjectSize(document, ***REMOVED***
    checkKeys: false
  ***REMOVED***);

  // Throw error if the doc is bigger than the max BSON size
  if (bsonSize >= _self.s.maxBatchSizeBytes) ***REMOVED***
    throw toError('document is larger than the maximum size ' + _self.s.maxBatchSizeBytes);
  ***REMOVED***

  // Create a new batch object if we don't have a current one
  if (_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);

  // Check if we need to create a new batch
  if (
    _self.s.currentBatchSize + 1 >= _self.s.maxWriteBatchSize ||
    _self.s.currentBatchSizeBytes + _self.s.currentBatchSizeBytes >= _self.s.maxBatchSizeBytes ||
    _self.s.currentBatch.batchType !== docType
  ) ***REMOVED***
    // Save the batch to the execution stack
    _self.s.batches.push(_self.s.currentBatch);

    // Create a new batch
    _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);

    // Reset the current size trackers
    _self.s.currentBatchSize = 0;
    _self.s.currentBatchSizeBytes = 0;
  ***REMOVED*** else ***REMOVED***
    // Update current batch size
    _self.s.currentBatchSize = _self.s.currentBatchSize + 1;
    _self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;
  ***REMOVED***

  if (docType === common.INSERT) ***REMOVED***
    _self.s.bulkResult.insertedIds.push(***REMOVED*** index: _self.s.currentIndex, _id: document._id ***REMOVED***);
  ***REMOVED***

  // We have an array of documents
  if (Array.isArray(document)) ***REMOVED***
    throw toError('operation passed in cannot be an Array');
  ***REMOVED*** else ***REMOVED***
    _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);
    _self.s.currentBatch.operations.push(document);
    _self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;
    _self.s.currentIndex = _self.s.currentIndex + 1;
  ***REMOVED***

  // Return self
  return _self;
***REMOVED***;

/**
 * Create a new OrderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)
 * @class
 * @property ***REMOVED***number***REMOVED*** length Get the number of operations in the bulk.
 * @return ***REMOVED***OrderedBulkOperation***REMOVED*** a OrderedBulkOperation instance.
 */
function OrderedBulkOperation(topology, collection, options) ***REMOVED***
  options = options == null ? ***REMOVED******REMOVED*** : options;
  // TODO Bring from driver information in isMaster
  var executed = false;

  // Current item
  var currentOp = null;

  // Handle to the bson serializer, used to calculate running sizes
  var bson = topology.bson;

  // Namespace for the operation
  var namespace = collection.collectionName;

  // Set max byte size
  var maxBatchSizeBytes =
    topology.isMasterDoc && topology.isMasterDoc.maxBsonObjectSize
      ? topology.isMasterDoc.maxBsonObjectSize
      : 1024 * 1025 * 16;
  var maxWriteBatchSize =
    topology.isMasterDoc && topology.isMasterDoc.maxWriteBatchSize
      ? topology.isMasterDoc.maxWriteBatchSize
      : 1000;

  // Get the write concern
  var writeConcern = applyWriteConcern(shallowClone(options), ***REMOVED*** collection: collection ***REMOVED***, options);
  writeConcern = writeConcern.writeConcern;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary || Promise;

  // Final results
  var bulkResult = ***REMOVED***
    ok: 1,
    writeErrors: [],
    writeConcernErrors: [],
    insertedIds: [],
    nInserted: 0,
    nUpserted: 0,
    nMatched: 0,
    nModified: 0,
    nRemoved: 0,
    upserted: []
  ***REMOVED***;

  // Internal state
  this.s = ***REMOVED***
    // Final result
    bulkResult: bulkResult,
    // Current batch state
    currentBatch: null,
    currentIndex: 0,
    currentBatchSize: 0,
    currentBatchSizeBytes: 0,
    batches: [],
    // Write concern
    writeConcern: writeConcern,
    // Max batch size options
    maxBatchSizeBytes: maxBatchSizeBytes,
    maxWriteBatchSize: maxWriteBatchSize,
    // Namespace
    namespace: namespace,
    // BSON
    bson: bson,
    // Topology
    topology: topology,
    // Options
    options: options,
    // Current operation
    currentOp: currentOp,
    // Executed
    executed: executed,
    // Collection
    collection: collection,
    // Promise Library
    promiseLibrary: promiseLibrary,
    // Fundamental error
    err: null,
    // Bypass validation
    bypassDocumentValidation:
      typeof options.bypassDocumentValidation === 'boolean'
        ? options.bypassDocumentValidation
        : false,
    // check keys
    checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : true
  ***REMOVED***;
***REMOVED***

OrderedBulkOperation.prototype.raw = function(op) ***REMOVED***
  var key = Object.keys(op)[0];

  // Set up the force server object id
  var forceServerObjectId =
    typeof this.s.options.forceServerObjectId === 'boolean'
      ? this.s.options.forceServerObjectId
      : this.s.collection.s.db.options.forceServerObjectId;

  // Update operations
  if (
    (op.updateOne && op.updateOne.q) ||
    (op.updateMany && op.updateMany.q) ||
    (op.replaceOne && op.replaceOne.q)
  ) ***REMOVED***
    op[key].multi = op.updateOne || op.replaceOne ? false : true;
    return addToOperationsList(this, common.UPDATE, op[key]);
  ***REMOVED***

  // Crud spec update format
  if (op.updateOne || op.updateMany || op.replaceOne) ***REMOVED***
    var multi = op.updateOne || op.replaceOne ? false : true;
    var operation = ***REMOVED*** q: op[key].filter, u: op[key].update || op[key].replacement, multi: multi ***REMOVED***;
    operation.upsert = op[key].upsert ? true : false;
    if (op.collation) operation.collation = op.collation;
    if (op[key].arrayFilters) operation.arrayFilters = op[key].arrayFilters;
    return addToOperationsList(this, common.UPDATE, operation);
  ***REMOVED***

  // Remove operations
  if (
    op.removeOne ||
    op.removeMany ||
    (op.deleteOne && op.deleteOne.q) ||
    (op.deleteMany && op.deleteMany.q)
  ) ***REMOVED***
    op[key].limit = op.removeOne ? 1 : 0;
    return addToOperationsList(this, common.REMOVE, op[key]);
  ***REMOVED***

  // Crud spec delete operations, less efficient
  if (op.deleteOne || op.deleteMany) ***REMOVED***
    var limit = op.deleteOne ? 1 : 0;
    operation = ***REMOVED*** q: op[key].filter, limit: limit ***REMOVED***;
    if (op.collation) operation.collation = op.collation;
    return addToOperationsList(this, common.REMOVE, operation);
  ***REMOVED***

  // Insert operations
  if (op.insertOne && op.insertOne.document == null) ***REMOVED***
    if (forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();
    return addToOperationsList(this, common.INSERT, op.insertOne);
  ***REMOVED*** else if (op.insertOne && op.insertOne.document) ***REMOVED***
    if (forceServerObjectId !== true && op.insertOne.document._id == null)
      op.insertOne.document._id = new ObjectID();
    return addToOperationsList(this, common.INSERT, op.insertOne.document);
  ***REMOVED***

  if (op.insertMany) ***REMOVED***
    for (var i = 0; i < op.insertMany.length; i++) ***REMOVED***
      if (forceServerObjectId !== true && op.insertMany[i]._id == null)
        op.insertMany[i]._id = new ObjectID();
      addToOperationsList(this, common.INSERT, op.insertMany[i]);
    ***REMOVED***

    return;
  ***REMOVED***

  // No valid type of operation
  throw toError(
    'bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany'
  );
***REMOVED***;

/**
 * Add a single insert document to the bulk operation
 *
 * @param ***REMOVED***object***REMOVED*** doc the document to insert
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***OrderedBulkOperation***REMOVED***
 */
OrderedBulkOperation.prototype.insert = function(document) ***REMOVED***
  if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null)
    document._id = new ObjectID();
  return addToOperationsList(this, common.INSERT, document);
***REMOVED***;

/**
 * Initiate a find operation for an update/updateOne/remove/removeOne/replaceOne
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** selector The selector for the bulk operation.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***FindOperatorsOrdered***REMOVED***
 */
OrderedBulkOperation.prototype.find = function(selector) ***REMOVED***
  if (!selector) ***REMOVED***
    throw toError('Bulk find operation must specify a selector');
  ***REMOVED***

  // Save a current selector
  this.s.currentOp = ***REMOVED***
    selector: selector
  ***REMOVED***;

  return new FindOperatorsOrdered(this);
***REMOVED***;

Object.defineProperty(OrderedBulkOperation.prototype, 'length', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.currentIndex;
  ***REMOVED***
***REMOVED***);

//
// Execute next write command in a chain
var executeCommands = function(self, options, callback) ***REMOVED***
  if (self.s.batches.length === 0) ***REMOVED***
    return handleCallback(callback, null, new BulkWriteResult(self.s.bulkResult));
  ***REMOVED***

  // Ordered execution of the command
  var batch = self.s.batches.shift();

  var resultHandler = function(err, result) ***REMOVED***
    // Error is a driver related error not a bulk op error, terminate
    if ((err && err.driver) || (err && err.message)) ***REMOVED***
      return handleCallback(callback, err);
    ***REMOVED***

    // If we have and error
    if (err) err.ok = 0;
    // Merge the results together
    var mergeResult = mergeBatchResults(true, batch, self.s.bulkResult, err, result);
    const writeResult = new BulkWriteResult(self.s.bulkResult);
    if (mergeResult != null) ***REMOVED***
      return handleCallback(callback, null, writeResult);
    ***REMOVED***

    // If we are ordered and have errors and they are
    // not all replication errors terminate the operation
    if (self.s.bulkResult.writeErrors.length > 0) ***REMOVED***
      if (self.s.bulkResult.writeErrors.length === 1) ***REMOVED***
        return handleCallback(
          callback,
          new BulkWriteError(toError(self.s.bulkResult.writeErrors[0]), writeResult),
          null
        );
      ***REMOVED***

      return handleCallback(
        callback,
        new BulkWriteError(
          toError(***REMOVED***
            message: 'write operation failed',
            code: self.s.bulkResult.writeErrors[0].code,
            writeErrors: self.s.bulkResult.writeErrors
          ***REMOVED***),
          writeResult
        ),
        null
      );
    ***REMOVED*** else if (writeResult.getWriteConcernError()) ***REMOVED***
      return handleCallback(
        callback,
        new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult),
        null
      );
    ***REMOVED***

    // Execute the next command in line
    executeCommands(self, options, callback);
  ***REMOVED***;

  var finalOptions = Object.assign(***REMOVED*** ordered: true ***REMOVED***, options);
  if (self.s.writeConcern != null) ***REMOVED***
    finalOptions.writeConcern = self.s.writeConcern;
  ***REMOVED***

  // Set an operationIf if provided
  if (self.operationId) ***REMOVED***
    resultHandler.operationId = self.operationId;
  ***REMOVED***

  // Serialize functions
  if (self.s.options.serializeFunctions) ***REMOVED***
    finalOptions.serializeFunctions = true;
  ***REMOVED***

  // Ignore undefined
  if (self.s.options.ignoreUndefined) ***REMOVED***
    finalOptions.ignoreUndefined = true;
  ***REMOVED***

  // Is the bypassDocumentValidation options specific
  if (self.s.bypassDocumentValidation === true) ***REMOVED***
    finalOptions.bypassDocumentValidation = true;
  ***REMOVED***

  // Is the checkKeys option disabled
  if (self.s.checkKeys === false) ***REMOVED***
    finalOptions.checkKeys = false;
  ***REMOVED***

  try ***REMOVED***
    if (batch.batchType === common.INSERT) ***REMOVED***
      self.s.topology.insert(
        self.s.collection.namespace,
        batch.operations,
        finalOptions,
        resultHandler
      );
    ***REMOVED*** else if (batch.batchType === common.UPDATE) ***REMOVED***
      self.s.topology.update(
        self.s.collection.namespace,
        batch.operations,
        finalOptions,
        resultHandler
      );
    ***REMOVED*** else if (batch.batchType === common.REMOVE) ***REMOVED***
      self.s.topology.remove(
        self.s.collection.namespace,
        batch.operations,
        finalOptions,
        resultHandler
      );
    ***REMOVED***
  ***REMOVED*** catch (err) ***REMOVED***
    // Force top level error
    err.ok = 0;
    // Merge top level error and return
    handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));
  ***REMOVED***
***REMOVED***;

/**
 * The callback format for results
 * @callback OrderedBulkOperation~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***BulkWriteResult***REMOVED*** result The bulk write result.
 */

/**
 * Execute the ordered bulk operation
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.fsync=false] Specify a file sync write concern.
 * @param ***REMOVED***OrderedBulkOperation~resultCallback***REMOVED*** [callback] The result callback
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
OrderedBulkOperation.prototype.execute = function(_writeConcern, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  if (this.s.executed) ***REMOVED***
    var executedError = toError('batch cannot be re-executed');
    return typeof callback === 'function'
      ? callback(executedError, null)
      : this.s.promiseLibrary.reject(executedError);
  ***REMOVED***

  if (typeof _writeConcern === 'function') ***REMOVED***
    callback = _writeConcern;
  ***REMOVED*** else if (_writeConcern && typeof _writeConcern === 'object') ***REMOVED***
    this.s.writeConcern = _writeConcern;
  ***REMOVED***

  // If we have current batch
  if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);

  // If we have no operations in the bulk raise an error
  if (this.s.batches.length === 0) ***REMOVED***
    var emptyBatchError = toError('Invalid Operation, no operations specified');
    return typeof callback === 'function'
      ? callback(emptyBatchError, null)
      : this.s.promiseLibrary.reject(emptyBatchError);
  ***REMOVED***

  return executeOperation(this.s.topology, executeCommands, [this, options, callback]);
***REMOVED***;

/**
 * Returns an unordered batch object
 * @ignore
 */
var initializeOrderedBulkOp = function(topology, collection, options) ***REMOVED***
  return new OrderedBulkOperation(topology, collection, options);
***REMOVED***;

initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
module.exports = initializeOrderedBulkOp;
module.exports.Bulk = OrderedBulkOperation;
