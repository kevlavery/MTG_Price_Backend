'use strict';

const TopologyBase = require('./topology_base').TopologyBase;
const MongoError = require('mongodb-core').MongoError;
const CMongos = require('mongodb-core').Mongos;
const Cursor = require('../cursor');
const Server = require('./server');
const Store = require('./topology_base').Store;
const MAX_JS_INT = require('../utils').MAX_JS_INT;
const translateOptions = require('../utils').translateOptions;
const filterOptions = require('../utils').filterOptions;
const mergeOptions = require('../utils').mergeOptions;

/**
 * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is
 * used to construct connections.
 *
 * **Mongos Should not be used, use MongoClient.connect**
 */

// Allowed parameters
var legalOptionNames = [
  'ha',
  'haInterval',
  'acceptableLatencyMS',
  'poolSize',
  'ssl',
  'checkServerIdentity',
  'sslValidate',
  'sslCA',
  'sslCRL',
  'sslCert',
  'ciphers',
  'ecdhCurve',
  'sslKey',
  'sslPass',
  'socketOptions',
  'bufferMaxEntries',
  'store',
  'auto_reconnect',
  'autoReconnect',
  'emitError',
  'keepAlive',
  'keepAliveInitialDelay',
  'noDelay',
  'connectTimeoutMS',
  'socketTimeoutMS',
  'loggerLevel',
  'logger',
  'reconnectTries',
  'appname',
  'domainsEnabled',
  'servername',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'promiseLibrary',
  'monitorCommands'
];

/**
 * Creates a new Mongos instance
 * @class
 * @deprecated
 * @param ***REMOVED***Server[]***REMOVED*** servers A seedlist of servers participating in the replicaset.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings.
 * @param ***REMOVED***booelan***REMOVED*** [options.ha=true] Turn on high availability monitoring.
 * @param ***REMOVED***number***REMOVED*** [options.haInterval=5000] Time between each replicaset status check.
 * @param ***REMOVED***number***REMOVED*** [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
 * @param ***REMOVED***number***REMOVED*** [options.acceptableLatencyMS=15] Cutoff latency point in MS for MongoS proxy selection
 * @param ***REMOVED***boolean***REMOVED*** [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
 * @param ***REMOVED***boolean|function***REMOVED*** [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
 * @param ***REMOVED***boolean***REMOVED*** [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***array***REMOVED*** [options.sslCA] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***array***REMOVED*** [options.sslCRL] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***string***REMOVED*** [options.ciphers] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.
 * @param ***REMOVED***string***REMOVED*** [options.ecdhCurve] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslCert] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslKey] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslPass] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***string***REMOVED*** [options.servername] String containing the server name requested via TLS SNI.
 * @param ***REMOVED***object***REMOVED*** [options.socketOptions] Socket options
 * @param ***REMOVED***boolean***REMOVED*** [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
 * @param ***REMOVED***boolean***REMOVED*** [options.socketOptions.keepAlive=true] TCP Connection keep alive enabled
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.keepAliveInitialDelay=30000] The number of milliseconds to wait before initiating keepAlive on the TCP socket
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
 * @param ***REMOVED***boolean***REMOVED*** [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
 * @param ***REMOVED***boolean***REMOVED*** [options.monitorCommands=false] Enable command monitoring for this topology
 * @fires Mongos#connect
 * @fires Mongos#ha
 * @fires Mongos#joined
 * @fires Mongos#left
 * @fires Mongos#fullsetup
 * @fires Mongos#open
 * @fires Mongos#close
 * @fires Mongos#error
 * @fires Mongos#timeout
 * @fires Mongos#parseError
 * @fires Mongos#commandStarted
 * @fires Mongos#commandSucceeded
 * @fires Mongos#commandFailed
 * @property ***REMOVED***string***REMOVED*** parserType the parser type used (c++ or js).
 * @return ***REMOVED***Mongos***REMOVED*** a Mongos instance.
 */
class Mongos extends TopologyBase ***REMOVED***
  constructor(servers, options) ***REMOVED***
    super();

    options = options || ***REMOVED******REMOVED***;
    var self = this;

    // Filter the options
    options = filterOptions(options, legalOptionNames);

    // Ensure all the instances are Server
    for (var i = 0; i < servers.length; i++) ***REMOVED***
      if (!(servers[i] instanceof Server)) ***REMOVED***
        throw MongoError.create(***REMOVED***
          message: 'all seed list instances must be of the Server type',
          driver: true
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    // Stored options
    var storeOptions = ***REMOVED***
      force: false,
      bufferMaxEntries:
        typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : MAX_JS_INT
    ***REMOVED***;

    // Shared global store
    var store = options.store || new Store(self, storeOptions);

    // Build seed list
    var seedlist = servers.map(function(x) ***REMOVED***
      return ***REMOVED*** host: x.host, port: x.port ***REMOVED***;
    ***REMOVED***);

    // Get the reconnect option
    var reconnect = typeof options.auto_reconnect === 'boolean' ? options.auto_reconnect : true;
    reconnect = typeof options.autoReconnect === 'boolean' ? options.autoReconnect : reconnect;

    // Clone options
    var clonedOptions = mergeOptions(
      ***REMOVED******REMOVED***,
      ***REMOVED***
        disconnectHandler: store,
        cursorFactory: Cursor,
        reconnect: reconnect,
        emitError: typeof options.emitError === 'boolean' ? options.emitError : true,
        size: typeof options.poolSize === 'number' ? options.poolSize : 5,
        monitorCommands:
          typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false
      ***REMOVED***
    );

    // Translate any SSL options and other connectivity options
    clonedOptions = translateOptions(clonedOptions, options);

    // Socket options
    var socketOptions =
      options.socketOptions && Object.keys(options.socketOptions).length > 0
        ? options.socketOptions
        : options;

    // Translate all the options to the mongodb-core ones
    clonedOptions = translateOptions(clonedOptions, socketOptions);

    // Build default client information
    clonedOptions.clientInfo = this.clientInfo;
    // Do we have an application specific string
    if (options.appname) ***REMOVED***
      clonedOptions.clientInfo.application = ***REMOVED*** name: options.appname ***REMOVED***;
    ***REMOVED***

    // Internal state
    this.s = ***REMOVED***
      // Create the Mongos
      coreTopology: new CMongos(seedlist, clonedOptions),
      // Server capabilities
      sCapabilities: null,
      // Debug turned on
      debug: clonedOptions.debug,
      // Store option defaults
      storeOptions: storeOptions,
      // Cloned options
      clonedOptions: clonedOptions,
      // Actual store of callbacks
      store: store,
      // Options
      options: options,
      // Server Session Pool
      sessionPool: null,
      // Active client sessions
      sessions: [],
      // Promise library
      promiseLibrary: options.promiseLibrary || Promise
    ***REMOVED***;
  ***REMOVED***

  // Connect
  connect(_options, callback) ***REMOVED***
    var self = this;
    if ('function' === typeof _options) (callback = _options), (_options = ***REMOVED******REMOVED***);
    if (_options == null) _options = ***REMOVED******REMOVED***;
    if (!('function' === typeof callback)) callback = null;
    _options = Object.assign(***REMOVED******REMOVED***, this.s.clonedOptions, _options);
    self.s.options = _options;

    // Update bufferMaxEntries
    self.s.storeOptions.bufferMaxEntries =
      typeof _options.bufferMaxEntries === 'number' ? _options.bufferMaxEntries : -1;

    // Error handler
    var connectErrorHandler = function() ***REMOVED***
      return function(err) ***REMOVED***
        // Remove all event handlers
        var events = ['timeout', 'error', 'close'];
        events.forEach(function(e) ***REMOVED***
          self.removeListener(e, connectErrorHandler);
        ***REMOVED***);

        self.s.coreTopology.removeListener('connect', connectErrorHandler);
        // Force close the topology
        self.close(true);

        // Try to callback
        try ***REMOVED***
          callback(err);
        ***REMOVED*** catch (err) ***REMOVED***
          process.nextTick(function() ***REMOVED***
            throw err;
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***;

    // Actual handler
    var errorHandler = function(event) ***REMOVED***
      return function(err) ***REMOVED***
        if (event !== 'error') ***REMOVED***
          self.emit(event, err);
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***;

    // Error handler
    var reconnectHandler = function() ***REMOVED***
      self.emit('reconnect');
      self.s.store.execute();
    ***REMOVED***;

    // relay the event
    var relay = function(event) ***REMOVED***
      return function(t, server) ***REMOVED***
        self.emit(event, t, server);
      ***REMOVED***;
    ***REMOVED***;

    // Connect handler
    var connectHandler = function() ***REMOVED***
      // Clear out all the current handlers left over
      var events = ['timeout', 'error', 'close', 'fullsetup'];
      events.forEach(function(e) ***REMOVED***
        self.s.coreTopology.removeAllListeners(e);
      ***REMOVED***);

      // Set up listeners
      self.s.coreTopology.on('timeout', errorHandler('timeout'));
      self.s.coreTopology.on('error', errorHandler('error'));
      self.s.coreTopology.on('close', errorHandler('close'));

      // Set up serverConfig listeners
      self.s.coreTopology.on('fullsetup', function() ***REMOVED***
        self.emit('fullsetup', self);
      ***REMOVED***);

      // Emit open event
      self.emit('open', null, self);

      // Return correctly
      try ***REMOVED***
        callback(null, self);
      ***REMOVED*** catch (err) ***REMOVED***
        process.nextTick(function() ***REMOVED***
          throw err;
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;

    // Clear out all the current handlers left over
    var events = [
      'timeout',
      'error',
      'close',
      'serverOpening',
      'serverDescriptionChanged',
      'serverHeartbeatStarted',
      'serverHeartbeatSucceeded',
      'serverHeartbeatFailed',
      'serverClosed',
      'topologyOpening',
      'topologyClosed',
      'topologyDescriptionChanged',
      'commandStarted',
      'commandSucceeded',
      'commandFailed'
    ];
    events.forEach(function(e) ***REMOVED***
      self.s.coreTopology.removeAllListeners(e);
    ***REMOVED***);

    // Set up SDAM listeners
    self.s.coreTopology.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
    self.s.coreTopology.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
    self.s.coreTopology.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
    self.s.coreTopology.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));
    self.s.coreTopology.on('serverOpening', relay('serverOpening'));
    self.s.coreTopology.on('serverClosed', relay('serverClosed'));
    self.s.coreTopology.on('topologyOpening', relay('topologyOpening'));
    self.s.coreTopology.on('topologyClosed', relay('topologyClosed'));
    self.s.coreTopology.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
    self.s.coreTopology.on('commandStarted', relay('commandStarted'));
    self.s.coreTopology.on('commandSucceeded', relay('commandSucceeded'));
    self.s.coreTopology.on('commandFailed', relay('commandFailed'));

    // Set up listeners
    self.s.coreTopology.once('timeout', connectErrorHandler('timeout'));
    self.s.coreTopology.once('error', connectErrorHandler('error'));
    self.s.coreTopology.once('close', connectErrorHandler('close'));
    self.s.coreTopology.once('connect', connectHandler);
    // Join and leave events
    self.s.coreTopology.on('joined', relay('joined'));
    self.s.coreTopology.on('left', relay('left'));

    // Reconnect server
    self.s.coreTopology.on('reconnect', reconnectHandler);

    // Start connection
    self.s.coreTopology.connect(_options);
  ***REMOVED***
***REMOVED***

Object.defineProperty(Mongos.prototype, 'haInterval', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.coreTopology.s.haInterval;
  ***REMOVED***
***REMOVED***);

/**
 * A mongos connect event, used to verify that the connection is up and running
 *
 * @event Mongos#connect
 * @type ***REMOVED***Mongos***REMOVED***
 */

/**
 * The mongos high availability event
 *
 * @event Mongos#ha
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The stage in the high availability event (start|end)
 * @param ***REMOVED***boolean***REMOVED*** data.norepeat This is a repeating high availability process or a single execution only
 * @param ***REMOVED***number***REMOVED*** data.id The id for this high availability request
 * @param ***REMOVED***object***REMOVED*** data.state An object containing the information about the current replicaset
 */

/**
 * A server member left the mongos set
 *
 * @event Mongos#left
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The type of member that left (primary|secondary|arbiter)
 * @param ***REMOVED***Server***REMOVED*** server The server object that left
 */

/**
 * A server member joined the mongos set
 *
 * @event Mongos#joined
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The type of member that joined (primary|secondary|arbiter)
 * @param ***REMOVED***Server***REMOVED*** server The server object that joined
 */

/**
 * Mongos fullsetup event, emitted when all proxies in the topology have been connected to.
 *
 * @event Mongos#fullsetup
 * @type ***REMOVED***Mongos***REMOVED***
 */

/**
 * Mongos open event, emitted when mongos can start processing commands.
 *
 * @event Mongos#open
 * @type ***REMOVED***Mongos***REMOVED***
 */

/**
 * Mongos close event
 *
 * @event Mongos#close
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Mongos error event, emitted if there is an error listener.
 *
 * @event Mongos#error
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Mongos timeout event
 *
 * @event Mongos#timeout
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Mongos parseError event
 *
 * @event Mongos#parseError
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * An event emitted indicating a command was started, if command monitoring is enabled
 *
 * @event Mongos#commandStarted
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * An event emitted indicating a command succeeded, if command monitoring is enabled
 *
 * @event Mongos#commandSucceeded
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * An event emitted indicating a command failed, if command monitoring is enabled
 *
 * @event Mongos#commandFailed
 * @type ***REMOVED***object***REMOVED***
 */

module.exports = Mongos;
