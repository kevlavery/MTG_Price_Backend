'use strict';

const EventEmitter = require('events'),
  MongoError = require('mongodb-core').MongoError,
  f = require('util').format,
  os = require('os'),
  translateReadPreference = require('../utils').translateReadPreference,
  ClientSession = require('mongodb-core').Sessions.ClientSession;

// The store of ops
var Store = function(topology, storeOptions) ***REMOVED***
  var self = this;
  var storedOps = [];
  storeOptions = storeOptions || ***REMOVED*** force: false, bufferMaxEntries: -1 ***REMOVED***;

  // Internal state
  this.s = ***REMOVED***
    storedOps: storedOps,
    storeOptions: storeOptions,
    topology: topology
  ***REMOVED***;

  Object.defineProperty(this, 'length', ***REMOVED***
    enumerable: true,
    get: function() ***REMOVED***
      return self.s.storedOps.length;
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

Store.prototype.add = function(opType, ns, ops, options, callback) ***REMOVED***
  if (this.s.storeOptions.force) ***REMOVED***
    return callback(MongoError.create(***REMOVED*** message: 'db closed by application', driver: true ***REMOVED***));
  ***REMOVED***

  if (this.s.storeOptions.bufferMaxEntries === 0) ***REMOVED***
    return callback(
      MongoError.create(***REMOVED***
        message: f(
          'no connection available for operation and number of stored operation > %s',
          this.s.storeOptions.bufferMaxEntries
        ),
        driver: true
      ***REMOVED***)
    );
  ***REMOVED***

  if (
    this.s.storeOptions.bufferMaxEntries > 0 &&
    this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries
  ) ***REMOVED***
    while (this.s.storedOps.length > 0) ***REMOVED***
      var op = this.s.storedOps.shift();
      op.c(
        MongoError.create(***REMOVED***
          message: f(
            'no connection available for operation and number of stored operation > %s',
            this.s.storeOptions.bufferMaxEntries
          ),
          driver: true
        ***REMOVED***)
      );
    ***REMOVED***

    return;
  ***REMOVED***

  this.s.storedOps.push(***REMOVED*** t: opType, n: ns, o: ops, op: options, c: callback ***REMOVED***);
***REMOVED***;

Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) ***REMOVED***
  if (this.s.storeOptions.force) ***REMOVED***
    return callback(MongoError.create(***REMOVED*** message: 'db closed by application', driver: true ***REMOVED***));
  ***REMOVED***

  if (this.s.storeOptions.bufferMaxEntries === 0) ***REMOVED***
    return callback(
      MongoError.create(***REMOVED***
        message: f(
          'no connection available for operation and number of stored operation > %s',
          this.s.storeOptions.bufferMaxEntries
        ),
        driver: true
      ***REMOVED***)
    );
  ***REMOVED***

  if (
    this.s.storeOptions.bufferMaxEntries > 0 &&
    this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries
  ) ***REMOVED***
    while (this.s.storedOps.length > 0) ***REMOVED***
      var op = this.s.storedOps.shift();
      op.c(
        MongoError.create(***REMOVED***
          message: f(
            'no connection available for operation and number of stored operation > %s',
            this.s.storeOptions.bufferMaxEntries
          ),
          driver: true
        ***REMOVED***)
      );
    ***REMOVED***

    return;
  ***REMOVED***

  this.s.storedOps.push(***REMOVED*** t: opType, m: method, o: object, p: params, c: callback ***REMOVED***);
***REMOVED***;

Store.prototype.flush = function(err) ***REMOVED***
  while (this.s.storedOps.length > 0) ***REMOVED***
    this.s.storedOps
      .shift()
      .c(
        err ||
          MongoError.create(***REMOVED*** message: f('no connection available for operation'), driver: true ***REMOVED***)
      );
  ***REMOVED***
***REMOVED***;

var primaryOptions = ['primary', 'primaryPreferred', 'nearest', 'secondaryPreferred'];
var secondaryOptions = ['secondary', 'secondaryPreferred'];

Store.prototype.execute = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Get current ops
  var ops = this.s.storedOps;
  // Reset the ops
  this.s.storedOps = [];

  // Unpack options
  var executePrimary = typeof options.executePrimary === 'boolean' ? options.executePrimary : true;
  var executeSecondary =
    typeof options.executeSecondary === 'boolean' ? options.executeSecondary : true;

  // Execute all the stored ops
  while (ops.length > 0) ***REMOVED***
    var op = ops.shift();

    if (op.t === 'cursor') ***REMOVED***
      if (executePrimary && executeSecondary) ***REMOVED***
        op.o[op.m].apply(op.o, op.p);
      ***REMOVED*** else if (
        executePrimary &&
        op.o.options &&
        op.o.options.readPreference &&
        primaryOptions.indexOf(op.o.options.readPreference.mode) !== -1
      ) ***REMOVED***
        op.o[op.m].apply(op.o, op.p);
      ***REMOVED*** else if (
        !executePrimary &&
        executeSecondary &&
        op.o.options &&
        op.o.options.readPreference &&
        secondaryOptions.indexOf(op.o.options.readPreference.mode) !== -1
      ) ***REMOVED***
        op.o[op.m].apply(op.o, op.p);
      ***REMOVED***
    ***REMOVED*** else if (op.t === 'auth') ***REMOVED***
      this.s.topology[op.t].apply(this.s.topology, op.o);
    ***REMOVED*** else ***REMOVED***
      if (executePrimary && executeSecondary) ***REMOVED***
        this.s.topology[op.t](op.n, op.o, op.op, op.c);
      ***REMOVED*** else if (
        executePrimary &&
        op.op &&
        op.op.readPreference &&
        primaryOptions.indexOf(op.op.readPreference.mode) !== -1
      ) ***REMOVED***
        this.s.topology[op.t](op.n, op.o, op.op, op.c);
      ***REMOVED*** else if (
        !executePrimary &&
        executeSecondary &&
        op.op &&
        op.op.readPreference &&
        secondaryOptions.indexOf(op.op.readPreference.mode) !== -1
      ) ***REMOVED***
        this.s.topology[op.t](op.n, op.o, op.op, op.c);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

Store.prototype.all = function() ***REMOVED***
  return this.s.storedOps;
***REMOVED***;

// Server capabilities
var ServerCapabilities = function(ismaster) ***REMOVED***
  var setup_get_property = function(object, name, value) ***REMOVED***
    Object.defineProperty(object, name, ***REMOVED***
      enumerable: true,
      get: function() ***REMOVED***
        return value;
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***;

  // Capabilities
  var aggregationCursor = false;
  var writeCommands = false;
  var textSearch = false;
  var authCommands = false;
  var listCollections = false;
  var listIndexes = false;
  var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1000;
  var commandsTakeWriteConcern = false;
  var commandsTakeCollation = false;

  if (ismaster.minWireVersion >= 0) ***REMOVED***
    textSearch = true;
  ***REMOVED***

  if (ismaster.maxWireVersion >= 1) ***REMOVED***
    aggregationCursor = true;
    authCommands = true;
  ***REMOVED***

  if (ismaster.maxWireVersion >= 2) ***REMOVED***
    writeCommands = true;
  ***REMOVED***

  if (ismaster.maxWireVersion >= 3) ***REMOVED***
    listCollections = true;
    listIndexes = true;
  ***REMOVED***

  if (ismaster.maxWireVersion >= 5) ***REMOVED***
    commandsTakeWriteConcern = true;
    commandsTakeCollation = true;
  ***REMOVED***

  // If no min or max wire version set to 0
  if (ismaster.minWireVersion == null) ***REMOVED***
    ismaster.minWireVersion = 0;
  ***REMOVED***

  if (ismaster.maxWireVersion == null) ***REMOVED***
    ismaster.maxWireVersion = 0;
  ***REMOVED***

  // Map up read only parameters
  setup_get_property(this, 'hasAggregationCursor', aggregationCursor);
  setup_get_property(this, 'hasWriteCommands', writeCommands);
  setup_get_property(this, 'hasTextSearch', textSearch);
  setup_get_property(this, 'hasAuthCommands', authCommands);
  setup_get_property(this, 'hasListCollectionsCommand', listCollections);
  setup_get_property(this, 'hasListIndexesCommand', listIndexes);
  setup_get_property(this, 'minWireVersion', ismaster.minWireVersion);
  setup_get_property(this, 'maxWireVersion', ismaster.maxWireVersion);
  setup_get_property(this, 'maxNumberOfDocsInBatch', maxNumberOfDocsInBatch);
  setup_get_property(this, 'commandsTakeWriteConcern', commandsTakeWriteConcern);
  setup_get_property(this, 'commandsTakeCollation', commandsTakeCollation);
***REMOVED***;

// Get package.json variable
const driverVersion = require('../../package.json').version,
  nodejsversion = f('Node.js %s, %s', process.version, os.endianness()),
  type = os.type(),
  name = process.platform,
  architecture = process.arch,
  release = os.release();

class TopologyBase extends EventEmitter ***REMOVED***
  constructor() ***REMOVED***
    super();

    // Build default client information
    this.clientInfo = ***REMOVED***
      driver: ***REMOVED***
        name: 'nodejs',
        version: driverVersion
      ***REMOVED***,
      os: ***REMOVED***
        type: type,
        name: name,
        architecture: architecture,
        version: release
      ***REMOVED***,
      platform: nodejsversion
    ***REMOVED***;

    this.setMaxListeners(Infinity);
  ***REMOVED***

  // Sessions related methods
  hasSessionSupport() ***REMOVED***
    return this.logicalSessionTimeoutMinutes != null;
  ***REMOVED***

  startSession(options) ***REMOVED***
    const session = new ClientSession(this, this.s.sessionPool, options);
    session.once('ended', () => ***REMOVED***
      this.s.sessions = this.s.sessions.filter(s => !s.equals(session));
    ***REMOVED***);

    this.s.sessions.push(session);
    return session;
  ***REMOVED***

  endSessions(sessions, callback) ***REMOVED***
    return this.s.coreTopology.endSessions(sessions, callback);
  ***REMOVED***

  // Server capabilities
  capabilities() ***REMOVED***
    if (this.s.sCapabilities) return this.s.sCapabilities;
    if (this.s.coreTopology.lastIsMaster() == null) return null;
    this.s.sCapabilities = new ServerCapabilities(this.s.coreTopology.lastIsMaster());
    return this.s.sCapabilities;
  ***REMOVED***

  // Command
  command(ns, cmd, options, callback) ***REMOVED***
    this.s.coreTopology.command(ns, cmd, translateReadPreference(options), callback);
  ***REMOVED***

  // Insert
  insert(ns, ops, options, callback) ***REMOVED***
    this.s.coreTopology.insert(ns, ops, options, callback);
  ***REMOVED***

  // Update
  update(ns, ops, options, callback) ***REMOVED***
    this.s.coreTopology.update(ns, ops, options, callback);
  ***REMOVED***

  // Remove
  remove(ns, ops, options, callback) ***REMOVED***
    this.s.coreTopology.remove(ns, ops, options, callback);
  ***REMOVED***

  // IsConnected
  isConnected(options) ***REMOVED***
    options = options || ***REMOVED******REMOVED***;
    options = translateReadPreference(options);

    return this.s.coreTopology.isConnected(options);
  ***REMOVED***

  // IsDestroyed
  isDestroyed() ***REMOVED***
    return this.s.coreTopology.isDestroyed();
  ***REMOVED***

  // Cursor
  cursor(ns, cmd, options) ***REMOVED***
    options = options || ***REMOVED******REMOVED***;
    options = translateReadPreference(options);
    options.disconnectHandler = this.s.store;
    options.topology = this;

    return this.s.coreTopology.cursor(ns, cmd, options);
  ***REMOVED***

  lastIsMaster() ***REMOVED***
    return this.s.coreTopology.lastIsMaster();
  ***REMOVED***

  getServer(options) ***REMOVED***
    return this.s.coreTopology.getServer(options);
  ***REMOVED***

  getConnection(options) ***REMOVED***
    return this.s.coreTopology.getConnection(options);
  ***REMOVED***

  /**
   * Unref all sockets
   * @method
   */
  unref() ***REMOVED***
    return this.s.coreTopology.unref();
  ***REMOVED***

  auth() ***REMOVED***
    var args = Array.prototype.slice.call(arguments, 0);
    this.s.coreTopology.auth.apply(this.s.coreTopology, args);
  ***REMOVED***

  logout() ***REMOVED***
    var args = Array.prototype.slice.call(arguments, 0);
    this.s.coreTopology.logout.apply(this.s.coreTopology, args);
  ***REMOVED***

  /**
   * All raw connections
   * @method
   * @return ***REMOVED***array***REMOVED***
   */
  connections() ***REMOVED***
    return this.s.coreTopology.connections();
  ***REMOVED***

  close(forceClosed) ***REMOVED***
    // If we have sessions, we want to individually move them to the session pool,
    // and then send a single endSessions call.
    if (this.s.sessions.length) ***REMOVED***
      this.s.sessions.forEach(session => session.endSession(***REMOVED*** skipCommand: true ***REMOVED***));
    ***REMOVED***

    if (this.s.sessionPool) ***REMOVED***
      this.s.sessionPool.endAllPooledSessions();
    ***REMOVED***

    this.s.coreTopology.destroy(***REMOVED***
      force: typeof forceClosed === 'boolean' ? forceClosed : false
    ***REMOVED***);

    // We need to wash out all stored processes
    if (forceClosed === true) ***REMOVED***
      this.s.storeOptions.force = forceClosed;
      this.s.store.flush();
    ***REMOVED***
  ***REMOVED***
***REMOVED***

// Properties
Object.defineProperty(TopologyBase.prototype, 'isMasterDoc', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.coreTopology.lastIsMaster();
  ***REMOVED***
***REMOVED***);

Object.defineProperty(TopologyBase.prototype, 'bson', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.coreTopology.s.bson;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(TopologyBase.prototype, 'parserType', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.coreTopology.parserType;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(TopologyBase.prototype, 'logicalSessionTimeoutMinutes', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.coreTopology.logicalSessionTimeoutMinutes;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(TopologyBase.prototype, 'type', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.coreTopology.type;
  ***REMOVED***
***REMOVED***);

exports.Store = Store;
exports.ServerCapabilities = ServerCapabilities;
exports.TopologyBase = TopologyBase;
