'use strict';

const EventEmitter = require('events').EventEmitter;
const inherits = require('util').inherits;
const getSingleProperty = require('./utils').getSingleProperty;
const shallowClone = require('./utils').shallowClone;
const parseIndexOptions = require('./utils').parseIndexOptions;
const debugOptions = require('./utils').debugOptions;
const CommandCursor = require('./command_cursor');
const handleCallback = require('./utils').handleCallback;
const filterOptions = require('./utils').filterOptions;
const toError = require('./utils').toError;
const ReadPreference = require('mongodb-core').ReadPreference;
const f = require('util').format;
const Admin = require('./admin');
const Code = require('mongodb-core').BSON.Code;
const MongoError = require('mongodb-core').MongoError;
const ObjectID = require('mongodb-core').ObjectID;
const Logger = require('mongodb-core').Logger;
const Collection = require('./collection');
const crypto = require('crypto');
const mergeOptionsAndWriteConcern = require('./utils').mergeOptionsAndWriteConcern;
const executeOperation = require('./utils').executeOperation;
const applyWriteConcern = require('./utils').applyWriteConcern;

var debugFields = [
  'authSource',
  'w',
  'wtimeout',
  'j',
  'native_parser',
  'forceServerObjectId',
  'serializeFunctions',
  'raw',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'bufferMaxEntries',
  'numberOfRetries',
  'retryMiliSeconds',
  'readPreference',
  'pkFactory',
  'parentDb',
  'promiseLibrary',
  'noListener'
];

// Filter out any write concern options
var illegalCommandFields = [
  'w',
  'wtimeout',
  'j',
  'fsync',
  'autoIndexId',
  'strict',
  'serializeFunctions',
  'pkFactory',
  'raw',
  'readPreference',
  'session'
];

/**
 * @fileOverview The **Db** class is a class that represents a MongoDB Database.
 *
 * @example
 * const MongoClient = require('mongodb').MongoClient;
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) ***REMOVED***
 *   // Select the database by name
 *   const testDb = client.db(dbName);
 *   client.close();
 * ***REMOVED***);
 */

// Allowed parameters
var legalOptionNames = [
  'w',
  'wtimeout',
  'fsync',
  'j',
  'readPreference',
  'readPreferenceTags',
  'native_parser',
  'forceServerObjectId',
  'pkFactory',
  'serializeFunctions',
  'raw',
  'bufferMaxEntries',
  'authSource',
  'ignoreUndefined',
  'promoteLongs',
  'promiseLibrary',
  'readConcern',
  'retryMiliSeconds',
  'numberOfRetries',
  'parentDb',
  'noListener',
  'loggerLevel',
  'logger',
  'promoteBuffers',
  'promoteLongs',
  'promoteValues',
  'compression',
  'retryWrites'
];

/**
 * Creates a new Db instance
 * @class
 * @param ***REMOVED***string***REMOVED*** databaseName The name of the database this instance represents.
 * @param ***REMOVED***(Server|ReplSet|Mongos)***REMOVED*** topology The server topology for the database.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***string***REMOVED*** [options.authSource=null] If the database authentication is dependent on another databaseName.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***Boolean***REMOVED*** [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***number***REMOVED*** [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***object***REMOVED*** [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
 * @param ***REMOVED***object***REMOVED*** [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
 * @param ***REMOVED***object***REMOVED*** [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
 * @param ***REMOVED***object***REMOVED*** [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)
 * @property ***REMOVED***(Server|ReplSet|Mongos)***REMOVED*** serverConfig Get the current db topology.
 * @property ***REMOVED***number***REMOVED*** bufferMaxEntries Current bufferMaxEntries value for the database
 * @property ***REMOVED***string***REMOVED*** databaseName The name of the database this instance represents.
 * @property ***REMOVED***object***REMOVED*** options The options associated with the db instance.
 * @property ***REMOVED***boolean***REMOVED*** native_parser The current value of the parameter native_parser.
 * @property ***REMOVED***boolean***REMOVED*** slaveOk The current slaveOk value for the db instance.
 * @property ***REMOVED***object***REMOVED*** writeConcern The current write concern values.
 * @property ***REMOVED***object***REMOVED*** topology Access the topology object (single server, replicaset or mongos).
 * @fires Db#close
 * @fires Db#reconnect
 * @fires Db#error
 * @fires Db#timeout
 * @fires Db#parseError
 * @fires Db#fullsetup
 * @return ***REMOVED***Db***REMOVED*** a Db instance.
 */
var Db = function(databaseName, topology, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  if (!(this instanceof Db)) return new Db(databaseName, topology, options);
  EventEmitter.call(this);
  var self = this;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary || Promise;

  // Filter the options
  options = filterOptions(options, legalOptionNames);

  // Ensure we put the promiseLib in the options
  options.promiseLibrary = promiseLibrary;

  // var self = this;  // Internal state of the db object
  this.s = ***REMOVED***
    // Database name
    databaseName: databaseName,
    // DbCache
    dbCache: ***REMOVED******REMOVED***,
    // Children db's
    children: [],
    // Topology
    topology: topology,
    // Options
    options: options,
    // Logger instance
    logger: Logger('Db', options),
    // Get the bson parser
    bson: topology ? topology.bson : null,
    // Unpack read preference
    readPreference: options.readPreference,
    // Set buffermaxEntries
    bufferMaxEntries: typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : -1,
    // Parent db (if chained)
    parentDb: options.parentDb || null,
    // Set up the primary key factory or fallback to ObjectID
    pkFactory: options.pkFactory || ObjectID,
    // Get native parser
    nativeParser: options.nativeParser || options.native_parser,
    // Promise library
    promiseLibrary: promiseLibrary,
    // No listener
    noListener: typeof options.noListener === 'boolean' ? options.noListener : false,
    // ReadConcern
    readConcern: options.readConcern
  ***REMOVED***;

  // Ensure we have a valid db name
  validateDatabaseName(self.s.databaseName);

  // Add a read Only property
  getSingleProperty(this, 'serverConfig', self.s.topology);
  getSingleProperty(this, 'bufferMaxEntries', self.s.bufferMaxEntries);
  getSingleProperty(this, 'databaseName', self.s.databaseName);

  // This is a child db, do not register any listeners
  if (options.parentDb) return;
  if (this.s.noListener) return;

  // Add listeners
  topology.on('error', createListener(self, 'error', self));
  topology.on('timeout', createListener(self, 'timeout', self));
  topology.on('close', createListener(self, 'close', self));
  topology.on('parseError', createListener(self, 'parseError', self));
  topology.once('open', createListener(self, 'open', self));
  topology.once('fullsetup', createListener(self, 'fullsetup', self));
  topology.once('all', createListener(self, 'all', self));
  topology.on('reconnect', createListener(self, 'reconnect', self));
***REMOVED***;

inherits(Db, EventEmitter);

// Topology
Object.defineProperty(Db.prototype, 'topology', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.topology;
  ***REMOVED***
***REMOVED***);

// Options
Object.defineProperty(Db.prototype, 'options', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    return this.s.options;
  ***REMOVED***
***REMOVED***);

// slaveOk specified
Object.defineProperty(Db.prototype, 'slaveOk', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    if (
      this.s.options.readPreference != null &&
      (this.s.options.readPreference !== 'primary' ||
        this.s.options.readPreference.mode !== 'primary')
    ) ***REMOVED***
      return true;
    ***REMOVED***
    return false;
  ***REMOVED***
***REMOVED***);

// get the write Concern
Object.defineProperty(Db.prototype, 'writeConcern', ***REMOVED***
  enumerable: true,
  get: function() ***REMOVED***
    var ops = ***REMOVED******REMOVED***;
    if (this.s.options.w != null) ops.w = this.s.options.w;
    if (this.s.options.j != null) ops.j = this.s.options.j;
    if (this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
    if (this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
    return ops;
  ***REMOVED***
***REMOVED***);

/**
 * Ensures provided read preference is properly converted into an object
 * @param ***REMOVED***(ReadPreference|string|object)***REMOVED*** readPreference the user provided read preference
 * @return ***REMOVED***ReadPreference***REMOVED***
 */
const convertReadPreference = function(readPreference) ***REMOVED***
  if (readPreference) ***REMOVED***
    if (typeof readPreference === 'string') ***REMOVED***
      return new ReadPreference(readPreference);
    ***REMOVED*** else if (
      readPreference &&
      !(readPreference instanceof ReadPreference) &&
      typeof readPreference === 'object'
    ) ***REMOVED***
      const mode = readPreference.mode || readPreference.preference;
      if (mode && typeof mode === 'string') ***REMOVED***
        return new ReadPreference(mode, readPreference.tags, ***REMOVED***
          maxStalenessSeconds: readPreference.maxStalenessSeconds
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED*** else if (!(readPreference instanceof ReadPreference)) ***REMOVED***
      throw new TypeError('Invalid read preference: ' + readPreference);
    ***REMOVED***
  ***REMOVED***

  return readPreference;
***REMOVED***;

/**
 * The callback format for results
 * @callback Db~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***object***REMOVED*** result The result object if the command was executed successfully.
 */
var executeCommand = function(self, command, options, callback) ***REMOVED***
  // Did the user destroy the topology
  if (self.serverConfig && self.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Get the db name we are executing against
  var dbName = options.dbName || options.authdb || self.s.databaseName;

  // If we have a readPreference set
  if (options.readPreference == null && self.s.readPreference) ***REMOVED***
    options.readPreference = self.s.readPreference;
  ***REMOVED***

  // Convert the readPreference if its not a write
  if (options.readPreference) ***REMOVED***
    options.readPreference = convertReadPreference(options.readPreference);
  ***REMOVED*** else ***REMOVED***
    options.readPreference = ReadPreference.primary;
  ***REMOVED***

  // Debug information
  if (self.s.logger.isDebug())
    self.s.logger.debug(
      f(
        'executing command %s against %s with options [%s]',
        JSON.stringify(command),
        f('%s.$cmd', dbName),
        JSON.stringify(debugOptions(debugFields, options))
      )
    );

  // Execute command
  self.s.topology.command(f('%s.$cmd', dbName), command, options, function(err, result) ***REMOVED***
    if (err) return handleCallback(callback, err);
    if (options.full) return handleCallback(callback, null, result);
    handleCallback(callback, null, result.result);
  ***REMOVED***);
***REMOVED***;

/**
 * Execute a command
 * @method
 * @param ***REMOVED***object***REMOVED*** command The command hash
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.command = function(command, options, callback) ***REMOVED***
  // Change the callback
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  // Clone the options
  options = shallowClone(options);

  return executeOperation(this.s.topology, executeCommand, [this, command, options, callback]);
***REMOVED***;

/**
 * Return the Admin db instance
 * @method
 * @return ***REMOVED***Admin***REMOVED*** return the new Admin db instance
 */
Db.prototype.admin = function() ***REMOVED***
  return new Admin(this, this.s.topology, this.s.promiseLibrary);
***REMOVED***;

/**
 * The callback format for the collection method, must be used if strict is specified
 * @callback Db~collectionResultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection***REMOVED*** collection The collection instance.
 */

var collectionKeys = [
  'pkFactory',
  'readPreference',
  'serializeFunctions',
  'strict',
  'readConcern',
  'ignoreUndefined',
  'promoteValues',
  'promoteBuffers',
  'promoteLongs'
];

/**
 * Fetch a specific collection (containing the actual collection information). If the application does not use strict mode you
 * can use it without a callback in the following way: `var collection = db.collection('mycollection');`
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** name the collection name we wish to access.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***object***REMOVED*** [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.strict=false] Returns an error if the collection does not exist
 * @param ***REMOVED***object***REMOVED*** [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
 * @param ***REMOVED***object***REMOVED*** [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)
 * @param ***REMOVED***Db~collectionResultCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Collection***REMOVED*** return the new Collection instance if not in strict mode
 */
Db.prototype.collection = function(name, options, callback) ***REMOVED***
  var self = this;
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;
  options = shallowClone(options);
  // Set the promise library
  options.promiseLibrary = this.s.promiseLibrary;

  // If we have not set a collection level readConcern set the db level one
  options.readConcern = options.readConcern || this.s.readConcern;

  // Do we have ignoreUndefined set
  if (this.s.options.ignoreUndefined) ***REMOVED***
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Merge in all needed options and ensure correct writeConcern merging from db level
  options = mergeOptionsAndWriteConcern(options, this.s.options, collectionKeys, true);

  // Execute
  if (options == null || !options.strict) ***REMOVED***
    try ***REMOVED***
      var collection = new Collection(
        this,
        this.s.topology,
        this.s.databaseName,
        name,
        this.s.pkFactory,
        options
      );
      if (callback) callback(null, collection);
      return collection;
    ***REMOVED*** catch (err) ***REMOVED***
      if (err instanceof MongoError && callback) return callback(err);
      throw err;
    ***REMOVED***
  ***REMOVED***

  // Strict mode
  if (typeof callback !== 'function') ***REMOVED***
    throw toError(f('A callback is required in strict mode. While getting collection %s.', name));
  ***REMOVED***

  // Did the user destroy the topology
  if (self.serverConfig && self.serverConfig.isDestroyed()) ***REMOVED***
    return callback(new MongoError('topology was destroyed'));
  ***REMOVED***

  // Strict mode
  this.listCollections(***REMOVED*** name: name ***REMOVED***, options).toArray(function(err, collections) ***REMOVED***
    if (err != null) return handleCallback(callback, err, null);
    if (collections.length === 0)
      return handleCallback(
        callback,
        toError(f('Collection %s does not exist. Currently in strict mode.', name)),
        null
      );

    try ***REMOVED***
      return handleCallback(
        callback,
        null,
        new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options)
      );
    ***REMOVED*** catch (err) ***REMOVED***
      return handleCallback(callback, err, null);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

var createCollection = function(self, name, options, callback) ***REMOVED***
  // Get the write concern options
  const finalOptions = applyWriteConcern(shallowClone(options), ***REMOVED*** db: self ***REMOVED***, options);

  // Did the user destroy the topology
  if (self.serverConfig && self.serverConfig.isDestroyed()) ***REMOVED***
    return callback(new MongoError('topology was destroyed'));
  ***REMOVED***

  // Check if we have the name
  self
    .listCollections(***REMOVED*** name: name ***REMOVED***, finalOptions)
    .setReadPreference(ReadPreference.PRIMARY)
    .toArray(function(err, collections) ***REMOVED***
      if (err != null) return handleCallback(callback, err, null);
      if (collections.length > 0 && finalOptions.strict) ***REMOVED***
        return handleCallback(
          callback,
          MongoError.create(***REMOVED***
            message: f('Collection %s already exists. Currently in strict mode.', name),
            driver: true
          ***REMOVED***),
          null
        );
      ***REMOVED*** else if (collections.length > 0) ***REMOVED***
        try ***REMOVED***
          return handleCallback(
            callback,
            null,
            new Collection(
              self,
              self.s.topology,
              self.s.databaseName,
              name,
              self.s.pkFactory,
              options
            )
          );
        ***REMOVED*** catch (err) ***REMOVED***
          return handleCallback(callback, err);
        ***REMOVED***
      ***REMOVED***

      // Create collection command
      var cmd = ***REMOVED*** create: name ***REMOVED***;

      // Decorate command with writeConcern if supported
      applyWriteConcern(cmd, ***REMOVED*** db: self ***REMOVED***, options);

      // Add all optional parameters
      for (var n in options) ***REMOVED***
        if (
          options[n] != null &&
          typeof options[n] !== 'function' &&
          illegalCommandFields.indexOf(n) === -1
        ) ***REMOVED***
          cmd[n] = options[n];
        ***REMOVED***
      ***REMOVED***

      // Force a primary read Preference
      finalOptions.readPreference = ReadPreference.PRIMARY;

      // Execute command
      self.command(cmd, finalOptions, function(err) ***REMOVED***
        if (err) return handleCallback(callback, err);
        handleCallback(
          callback,
          null,
          new Collection(
            self,
            self.s.topology,
            self.s.databaseName,
            name,
            self.s.pkFactory,
            options
          )
        );
      ***REMOVED***);
    ***REMOVED***);
***REMOVED***;

/**
 * Create a new collection on a server with the specified options. Use this to create capped collections.
 * More information about command options available at https://docs.mongodb.com/manual/reference/command/create/
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** name the collection name we wish to access.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***object***REMOVED*** [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.strict=false] Returns an error if the collection does not exist
 * @param ***REMOVED***boolean***REMOVED*** [options.capped=false] Create a capped collection.
 * @param ***REMOVED***boolean***REMOVED*** [options.autoIndexId=true] DEPRECATED: Create an index on the _id field of the document, True by default on MongoDB 2.6 - 3.0
 * @param ***REMOVED***number***REMOVED*** [options.size=null] The size of the capped collection in bytes.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] The maximum number of documents in the capped collection.
 * @param ***REMOVED***number***REMOVED*** [options.flags=null] Optional. Available for the MMAPv1 storage engine only to set the usePowerOf2Sizes and the noPadding flag.
 * @param ***REMOVED***object***REMOVED*** [options.storageEngine=null] Allows users to specify configuration to the storage engine on a per-collection basis when creating a collection on MongoDB 3.0 or higher.
 * @param ***REMOVED***object***REMOVED*** [options.validator=null] Allows users to specify validation rules or expressions for the collection. For more information, see Document Validation on MongoDB 3.2 or higher.
 * @param ***REMOVED***string***REMOVED*** [options.validationLevel=null] Determines how strictly MongoDB applies the validation rules to existing documents during an update on MongoDB 3.2 or higher.
 * @param ***REMOVED***string***REMOVED*** [options.validationAction=null] Determines whether to error on invalid documents or just warn about the violations but allow invalid documents to be inserted on MongoDB 3.2 or higher.
 * @param ***REMOVED***object***REMOVED*** [options.indexOptionDefaults=null] Allows users to specify a default configuration for indexes when creating a collection on MongoDB 3.2 or higher.
 * @param ***REMOVED***string***REMOVED*** [options.viewOn=null] The name of the source collection or view from which to create the view. The name is not the full namespace of the collection or view; i.e. does not include the database name and implies the same database as the view to create on MongoDB 3.4 or higher.
 * @param ***REMOVED***array***REMOVED*** [options.pipeline=null] An array that consists of the aggregation pipeline stage. create creates the view by applying the specified pipeline to the viewOn collection or view on MongoDB 3.4 or higher.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~collectionResultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.createCollection = function(name, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;
  options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;

  if (options.autoIndexId !== undefined) ***REMOVED***
    console.warn('the autoIndexId option is deprecated and will be removed in a future release');
  ***REMOVED***

  return executeOperation(this.s.topology, createCollection, [this, name, options, callback]);
***REMOVED***;

/**
 * Get all the db statistics.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.scale=null] Divide the returned sizes by scale value.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.stats = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;
  // Build command object
  var commandObject = ***REMOVED*** dbStats: true ***REMOVED***;
  // Check if we have the scale value
  if (options['scale'] != null) commandObject['scale'] = options['scale'];

  // If we have a readPreference set
  if (options.readPreference == null && this.s.readPreference) ***REMOVED***
    options.readPreference = this.s.readPreference;
  ***REMOVED***

  // Execute the command
  return this.command(commandObject, options, callback);
***REMOVED***;

// Transformation methods for cursor results
var listCollectionsTranforms = function(databaseName) ***REMOVED***
  var matching = f('%s.', databaseName);

  return ***REMOVED***
    doc: function(doc) ***REMOVED***
      var index = doc.name.indexOf(matching);
      // Remove database name if available
      if (doc.name && index === 0) ***REMOVED***
        doc.name = doc.name.substr(index + matching.length);
      ***REMOVED***

      return doc;
    ***REMOVED***
  ***REMOVED***;
***REMOVED***;

/**
 * Get the list of all collection information for the specified db.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [filter=***REMOVED******REMOVED***] Query to filter collections by
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @return ***REMOVED***CommandCursor***REMOVED***
 */
Db.prototype.listCollections = function(filter, options) ***REMOVED***
  filter = filter || ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Shallow clone the object
  options = shallowClone(options);
  // Set the promise library
  options.promiseLibrary = this.s.promiseLibrary;

  // Ensure valid readPreference
  if (options.readPreference) ***REMOVED***
    options.readPreference = convertReadPreference(options.readPreference);
  ***REMOVED*** else ***REMOVED***
    options.readPreference = this.s.readPreference || ReadPreference.primary;
  ***REMOVED***

  // We have a list collections command
  if (this.serverConfig.capabilities().hasListCollectionsCommand) ***REMOVED***
    // Cursor options
    var cursor = options.batchSize ? ***REMOVED*** batchSize: options.batchSize ***REMOVED*** : ***REMOVED******REMOVED***;
    // Build the command
    var command = ***REMOVED*** listCollections: true, filter: filter, cursor: cursor ***REMOVED***;
    // Set the AggregationCursor constructor
    options.cursorFactory = CommandCursor;
    // Create the cursor
    cursor = this.s.topology.cursor(f('%s.$cmd', this.s.databaseName), command, options);
    // Do we have a readPreference, apply it
    if (options.readPreference) ***REMOVED***
      cursor.setReadPreference(options.readPreference);
    ***REMOVED***
    // Return the cursor
    return cursor;
  ***REMOVED***

  // We cannot use the listCollectionsCommand
  if (!this.serverConfig.capabilities().hasListCollectionsCommand) ***REMOVED***
    // If we have legacy mode and have not provided a full db name filter it
    if (
      typeof filter.name === 'string' &&
      !new RegExp('^' + this.databaseName + '\\.').test(filter.name)
    ) ***REMOVED***
      filter = shallowClone(filter);
      filter.name = f('%s.%s', this.s.databaseName, filter.name);
    ***REMOVED***
  ***REMOVED***

  // No filter, filter by current database
  if (filter == null) ***REMOVED***
    filter.name = f('/%s/', this.s.databaseName);
  ***REMOVED***

  // Rewrite the filter to use $and to filter out indexes
  if (filter.name) ***REMOVED***
    filter = ***REMOVED*** $and: [***REMOVED*** name: filter.name ***REMOVED***, ***REMOVED*** name: /^((?!\$).)*$/ ***REMOVED***] ***REMOVED***;
  ***REMOVED*** else ***REMOVED***
    filter = ***REMOVED*** name: /^((?!\$).)*$/ ***REMOVED***;
  ***REMOVED***

  // Return options
  var _options = ***REMOVED*** transforms: listCollectionsTranforms(this.s.databaseName) ***REMOVED***;
  // Get the cursor
  cursor = this.collection(Db.SYSTEM_NAMESPACE_COLLECTION).find(filter, _options);
  // Do we have a readPreference, apply it
  if (options.readPreference) cursor.setReadPreference(options.readPreference);
  // Set the passed in batch size if one was provided
  if (options.batchSize) cursor = cursor.batchSize(options.batchSize);
  // We have a fallback mode using legacy systems collections
  return cursor;
***REMOVED***;

var evaluate = function(self, code, parameters, options, callback) ***REMOVED***
  var finalCode = code;
  var finalParameters = [];

  // Did the user destroy the topology
  if (self.serverConfig && self.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));

  // If not a code object translate to one
  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode);
  // Ensure the parameters are correct
  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') ***REMOVED***
    finalParameters = [parameters];
  ***REMOVED*** else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') ***REMOVED***
    finalParameters = parameters;
  ***REMOVED***

  // Create execution selector
  var cmd = ***REMOVED*** $eval: finalCode, args: finalParameters ***REMOVED***;
  // Check if the nolock parameter is passed in
  if (options['nolock']) ***REMOVED***
    cmd['nolock'] = options['nolock'];
  ***REMOVED***

  // Set primary read preference
  options.readPreference = new ReadPreference(ReadPreference.PRIMARY);

  // Execute the command
  self.command(cmd, options, function(err, result) ***REMOVED***
    if (err) return handleCallback(callback, err, null);
    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);
    if (result)
      return handleCallback(
        callback,
        MongoError.create(***REMOVED*** message: f('eval failed: %s', result.errmsg), driver: true ***REMOVED***),
        null
      );
    handleCallback(callback, err, result);
  ***REMOVED***);
***REMOVED***;

/**
 * Evaluate JavaScript on the server
 *
 * @method
 * @param ***REMOVED***Code***REMOVED*** code JavaScript to execute on server.
 * @param ***REMOVED***(object|array)***REMOVED*** parameters The parameters for the call.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.nolock=false] Tell MongoDB not to block on the evaulation of the javascript.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The results callback
 * @deprecated Eval is deprecated on MongoDB 3.2 and forward
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.eval = function(code, parameters, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  parameters = args.length ? args.shift() : parameters;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, evaluate, [this, code, parameters, options, callback]);
***REMOVED***;

/**
 * Rename a collection.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** fromCollection Name of current collection to rename.
 * @param ***REMOVED***string***REMOVED*** toCollection New name of of the collection.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropTarget=false] Drop the target name collection if it previously exists.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~collectionResultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.renameCollection = function(fromCollection, toCollection, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;
  // Add return new collection
  options.new_collection = true;

  const collection = this.collection(fromCollection);
  return executeOperation(this.s.topology, collection.rename.bind(collection), [
    toCollection,
    options,
    callback
  ]);
***REMOVED***;

/**
 * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** name Name of collection to drop
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.dropCollection = function(name, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Command to execute
  var cmd = ***REMOVED*** drop: name ***REMOVED***;

  // Decorate with write concern
  applyWriteConcern(cmd, ***REMOVED*** db: this ***REMOVED***, options);

  // options
  const opts = Object.assign(***REMOVED******REMOVED***, this.s.options, ***REMOVED*** readPreference: ReadPreference.PRIMARY ***REMOVED***);
  if (options.session) opts.session = options.session;

  return executeOperation(this.s.topology, dropCollection, [this, cmd, opts, callback]);
***REMOVED***;

const dropCollection = (self, cmd, options, callback) => ***REMOVED***
  return self.command(cmd, options, function(err, result) ***REMOVED***
    // Did the user destroy the topology
    if (self.serverConfig && self.serverConfig.isDestroyed()) ***REMOVED***
      return callback(new MongoError('topology was destroyed'));
    ***REMOVED***

    if (err) return handleCallback(callback, err);
    if (result.ok) return handleCallback(callback, null, true);
    handleCallback(callback, null, false);
  ***REMOVED***);
***REMOVED***;

/**
 * Drop a database, removing it permanently from the server.
 *
 * @method
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.dropDatabase = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;
  // Drop database command
  var cmd = ***REMOVED*** dropDatabase: 1 ***REMOVED***;

  // Decorate with write concern
  applyWriteConcern(cmd, ***REMOVED*** db: this ***REMOVED***, options);

  // Ensure primary only
  const finalOptions = Object.assign(***REMOVED******REMOVED***, this.s.options, ***REMOVED***
    readPreference: ReadPreference.PRIMARY
  ***REMOVED***);

  if (options.session) ***REMOVED***
    finalOptions.session = options.session;
  ***REMOVED***

  return executeOperation(this.s.topology, dropDatabase, [this, cmd, finalOptions, callback]);
***REMOVED***;

const dropDatabase = (self, cmd, options, callback) => ***REMOVED***
  self.command(cmd, options, function(err, result) ***REMOVED***
    // Did the user destroy the topology
    if (self.serverConfig && self.serverConfig.isDestroyed()) ***REMOVED***
      return callback(new MongoError('topology was destroyed'));
    ***REMOVED***

    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  ***REMOVED***);
***REMOVED***;

/**
 * Fetch all collections for the current db.
 *
 * @method
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~collectionsResultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.collections = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, collections, [this, options, callback]);
***REMOVED***;

var collections = function(self, options, callback) ***REMOVED***
  // Let's get the collection names
  self.listCollections(***REMOVED******REMOVED***, options).toArray(function(err, documents) ***REMOVED***
    if (err != null) return handleCallback(callback, err, null);
    // Filter collections removing any illegal ones
    documents = documents.filter(function(doc) ***REMOVED***
      return doc.name.indexOf('$') === -1;
    ***REMOVED***);

    // Return the collection objects
    handleCallback(
      callback,
      null,
      documents.map(function(d) ***REMOVED***
        return new Collection(
          self,
          self.s.topology,
          self.s.databaseName,
          d.name,
          self.s.pkFactory,
          self.s.options
        );
      ***REMOVED***)
    );
  ***REMOVED***);
***REMOVED***;

/**
 * Runs a command on the database as admin.
 * @method
 * @param ***REMOVED***object***REMOVED*** command The command hash
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.executeDbAdminCommand = function(selector, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Convert read preference
  if (options.readPreference) ***REMOVED***
    options.readPreference = convertReadPreference(options.readPreference);
  ***REMOVED***

  return executeOperation(this.s.topology, executeDbAdminCommand, [
    this,
    selector,
    options,
    callback
  ]);
***REMOVED***;

const executeDbAdminCommand = (self, selector, options, callback) => ***REMOVED***
  self.s.topology.command('admin.$cmd', selector, options, function(err, result) ***REMOVED***
    // Did the user destroy the topology
    if (self.serverConfig && self.serverConfig.isDestroyed()) ***REMOVED***
      return callback(new MongoError('topology was destroyed'));
    ***REMOVED***

    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.result);
  ***REMOVED***);
***REMOVED***;

/**
 * Creates an index on the db and collection collection.
 * @method
 * @param ***REMOVED***string***REMOVED*** name Name of the collection to create the index on.
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.unique=false] Creates an unique index.
 * @param ***REMOVED***boolean***REMOVED*** [options.sparse=false] Creates a sparse index.
 * @param ***REMOVED***boolean***REMOVED*** [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param ***REMOVED***number***REMOVED*** [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.v=null] Specify the format version of the indexes.
 * @param ***REMOVED***number***REMOVED*** [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param ***REMOVED***number***REMOVED*** [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param ***REMOVED***object***REMOVED*** [options.partialFilterExpression=null] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.createIndex = function(name, fieldOrSpec, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options ? shallowClone(options) : ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, createIndex, [
    this,
    name,
    fieldOrSpec,
    options,
    callback
  ]);
***REMOVED***;

var createIndex = function(self, name, fieldOrSpec, options, callback) ***REMOVED***
  // Get the write concern options
  var finalOptions = Object.assign(***REMOVED******REMOVED***, ***REMOVED*** readPreference: ReadPreference.PRIMARY ***REMOVED***, options);
  finalOptions = applyWriteConcern(finalOptions, ***REMOVED*** db: self ***REMOVED***, options);

  // Ensure we have a callback
  if (finalOptions.writeConcern && typeof callback !== 'function') ***REMOVED***
    throw MongoError.create(***REMOVED***
      message: 'Cannot use a writeConcern without a provided callback',
      driver: true
    ***REMOVED***);
  ***REMOVED***

  // Did the user destroy the topology
  if (self.serverConfig && self.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));

  // Attempt to run using createIndexes command
  createIndexUsingCreateIndexes(self, name, fieldOrSpec, options, function(err, result) ***REMOVED***
    if (err == null) return handleCallback(callback, err, result);

    // 67 = 'CannotCreateIndex' (malformed index options)
    // 85 = 'IndexOptionsConflict' (index already exists with different options)
    // 86 = 'IndexKeySpecsConflict' (index already exists with the same name)
    // 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)
    // 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)
    // These errors mean that the server recognized `createIndex` as a command
    // and so we don't need to fallback to an insert.
    if (
      err.code === 67 ||
      err.code === 11000 ||
      err.code === 85 ||
      err.code === 86 ||
      err.code === 11600
    ) ***REMOVED***
      return handleCallback(callback, err, result);
    ***REMOVED***

    // Create command
    var doc = createCreateIndexCommand(self, name, fieldOrSpec, options);
    // Set no key checking
    finalOptions.checkKeys = false;
    // Insert document
    self.s.topology.insert(
      f('%s.%s', self.s.databaseName, Db.SYSTEM_INDEX_COLLECTION),
      doc,
      finalOptions,
      function(err, result) ***REMOVED***
        if (callback == null) return;
        if (err) return handleCallback(callback, err);
        if (result == null) return handleCallback(callback, null, null);
        if (result.result.writeErrors)
          return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);
        handleCallback(callback, null, doc.name);
      ***REMOVED***
    );
  ***REMOVED***);
***REMOVED***;

/**
 * Ensures that an index exists, if it does not it creates it
 * @method
 * @deprecated since version 2.0
 * @param ***REMOVED***string***REMOVED*** name The index name
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.unique=false] Creates an unique index.
 * @param ***REMOVED***boolean***REMOVED*** [options.sparse=false] Creates a sparse index.
 * @param ***REMOVED***boolean***REMOVED*** [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param ***REMOVED***number***REMOVED*** [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.v=null] Specify the format version of the indexes.
 * @param ***REMOVED***number***REMOVED*** [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param ***REMOVED***number***REMOVED*** [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.ensureIndex = function(name, fieldOrSpec, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, ensureIndex, [
    this,
    name,
    fieldOrSpec,
    options,
    callback
  ]);
***REMOVED***;

var ensureIndex = function(self, name, fieldOrSpec, options, callback) ***REMOVED***
  // Get the write concern options
  var finalOptions = applyWriteConcern(***REMOVED******REMOVED***, ***REMOVED*** db: self ***REMOVED***, options);
  // Create command
  var selector = createCreateIndexCommand(self, name, fieldOrSpec, options);
  var index_name = selector.name;

  // Did the user destroy the topology
  if (self.serverConfig && self.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));

  // Merge primary readPreference
  finalOptions.readPreference = ReadPreference.PRIMARY;

  // Check if the index allready exists
  self.indexInformation(name, finalOptions, function(err, indexInformation) ***REMOVED***
    if (err != null && err.code !== 26) return handleCallback(callback, err, null);
    // If the index does not exist, create it
    if (indexInformation == null || !indexInformation[index_name]) ***REMOVED***
      self.createIndex(name, fieldOrSpec, options, callback);
    ***REMOVED*** else ***REMOVED***
      if (typeof callback === 'function') return handleCallback(callback, null, index_name);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

Db.prototype.addChild = function(db) ***REMOVED***
  if (this.s.parentDb) return this.s.parentDb.addChild(db);
  this.s.children.push(db);
***REMOVED***;

var _executeAuthCreateUserCommand = function(self, username, password, options, callback) ***REMOVED***
  // Special case where there is no password ($external users)
  if (typeof username === 'string' && password != null && typeof password === 'object') ***REMOVED***
    options = password;
    password = null;
  ***REMOVED***

  // Unpack all options
  if (typeof options === 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  // Error out if we digestPassword set
  if (options.digestPassword != null) ***REMOVED***
    throw toError(
      "The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."
    );
  ***REMOVED***

  // Get additional values
  var customData = options.customData != null ? options.customData : ***REMOVED******REMOVED***;
  var roles = Array.isArray(options.roles) ? options.roles : [];
  var maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null;

  // If not roles defined print deprecated message
  if (roles.length === 0) ***REMOVED***
    console.log('Creating a user without roles is deprecated in MongoDB >= 2.6');
  ***REMOVED***

  // Get the error options
  var commandOptions = ***REMOVED*** writeCommand: true ***REMOVED***;
  if (options['dbName']) commandOptions.dbName = options['dbName'];

  // Add maxTimeMS to options if set
  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;

  // Check the db name and add roles if needed
  if (
    (self.databaseName.toLowerCase() === 'admin' || options.dbName === 'admin') &&
    !Array.isArray(options.roles)
  ) ***REMOVED***
    roles = ['root'];
  ***REMOVED*** else if (!Array.isArray(options.roles)) ***REMOVED***
    roles = ['dbOwner'];
  ***REMOVED***

  // Build the command to execute
  var command = ***REMOVED***
    createUser: username,
    customData: customData,
    roles: roles,
    digestPassword: false
  ***REMOVED***;

  // Apply write concern to command
  command = applyWriteConcern(command, ***REMOVED*** db: self ***REMOVED***, options);

  // Use node md5 generator
  var md5 = crypto.createHash('md5');
  // Generate keys used for authentication
  md5.update(username + ':mongo:' + password);
  var userPassword = md5.digest('hex');

  // No password
  if (typeof password === 'string') ***REMOVED***
    command.pwd = userPassword;
  ***REMOVED***

  // Force write using primary
  commandOptions.readPreference = ReadPreference.primary;

  // Execute the command
  self.command(command, commandOptions, function(err, result) ***REMOVED***
    if (err && err.ok === 0 && err.code === undefined)
      return handleCallback(callback, ***REMOVED*** code: -5000 ***REMOVED***, null);
    if (err) return handleCallback(callback, err, null);
    handleCallback(
      callback,
      !result.ok ? toError(result) : null,
      result.ok ? [***REMOVED*** user: username, pwd: '' ***REMOVED***] : null
    );
  ***REMOVED***);
***REMOVED***;

var addUser = function(self, username, password, options, callback) ***REMOVED***
  // Did the user destroy the topology
  if (self.serverConfig && self.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Attempt to execute auth command
  _executeAuthCreateUserCommand(self, username, password, options, function(err, r) ***REMOVED***
    // We need to perform the backward compatible insert operation
    if (err && err.code === -5000) ***REMOVED***
      var finalOptions = applyWriteConcern(shallowClone(options), ***REMOVED*** db: self ***REMOVED***, options);

      // Use node md5 generator
      var md5 = crypto.createHash('md5');
      // Generate keys used for authentication
      md5.update(username + ':mongo:' + password);
      var userPassword = md5.digest('hex');

      // If we have another db set
      var db = options.dbName ? new Db(options.dbName, self.s.topology, self.s.options) : self;

      // Fetch a user collection
      var collection = db.collection(Db.SYSTEM_USER_COLLECTION);

      // Check if we are inserting the first user
      collection.count(***REMOVED******REMOVED***, finalOptions, function(err, count) ***REMOVED***
        // We got an error (f.ex not authorized)
        if (err != null) return handleCallback(callback, err, null);
        // Check if the user exists and update i
        collection
          .find(***REMOVED*** user: username ***REMOVED***, ***REMOVED*** dbName: options['dbName'] ***REMOVED***, finalOptions)
          .toArray(function(err) ***REMOVED***
            // We got an error (f.ex not authorized)
            if (err != null) return handleCallback(callback, err, null);
            // Add command keys
            finalOptions.upsert = true;

            // We have a user, let's update the password or upsert if not
            collection.update(
              ***REMOVED*** user: username ***REMOVED***,
              ***REMOVED*** $set: ***REMOVED*** user: username, pwd: userPassword ***REMOVED*** ***REMOVED***,
              finalOptions,
              function(err) ***REMOVED***
                if (count === 0 && err)
                  return handleCallback(callback, null, [***REMOVED*** user: username, pwd: userPassword ***REMOVED***]);
                if (err) return handleCallback(callback, err, null);
                handleCallback(callback, null, [***REMOVED*** user: username, pwd: userPassword ***REMOVED***]);
              ***REMOVED***
            );
          ***REMOVED***);
      ***REMOVED***);

      return;
    ***REMOVED***

    if (err) return handleCallback(callback, err);
    handleCallback(callback, err, r);
  ***REMOVED***);
***REMOVED***;

/**
 * Add a user to the database.
 * @method
 * @param ***REMOVED***string***REMOVED*** username The username.
 * @param ***REMOVED***string***REMOVED*** password The password.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***object***REMOVED*** [options.customData=null] Custom data associated with the user (only Mongodb 2.6 or higher)
 * @param ***REMOVED***object[]***REMOVED*** [options.roles=null] Roles associated with the created user (only Mongodb 2.6 or higher)
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.addUser = function(username, password, options, callback) ***REMOVED***
  // Unpack the parameters
  var args = Array.prototype.slice.call(arguments, 2);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, addUser, [this, username, password, options, callback]);
***REMOVED***;

var _executeAuthRemoveUserCommand = function(self, username, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Did the user destroy the topology
  if (self.serverConfig && self.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Get the error options
  var commandOptions = ***REMOVED*** writeCommand: true ***REMOVED***;
  if (options['dbName']) commandOptions.dbName = options['dbName'];

  // Get additional values
  var maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null;

  // Add maxTimeMS to options if set
  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;

  // Build the command to execute
  var command = ***REMOVED***
    dropUser: username
  ***REMOVED***;

  // Apply write concern to command
  command = applyWriteConcern(command, ***REMOVED*** db: self ***REMOVED***, options);

  // Force write using primary
  commandOptions.readPreference = ReadPreference.primary;

  // Execute the command
  self.command(command, commandOptions, function(err, result) ***REMOVED***
    if (err && !err.ok && err.code === undefined) return handleCallback(callback, ***REMOVED*** code: -5000 ***REMOVED***);
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  ***REMOVED***);
***REMOVED***;

var removeUser = function(self, username, options, callback) ***REMOVED***
  // Attempt to execute command
  _executeAuthRemoveUserCommand(self, username, options, function(err, result) ***REMOVED***
    if (err && err.code === -5000) ***REMOVED***
      var finalOptions = applyWriteConcern(shallowClone(options), ***REMOVED*** db: self ***REMOVED***, options);
      // If we have another db set
      var db = options.dbName ? new Db(options.dbName, self.s.topology, self.s.options) : self;

      // Fetch a user collection
      var collection = db.collection(Db.SYSTEM_USER_COLLECTION);

      // Locate the user
      collection.findOne(***REMOVED*** user: username ***REMOVED***, finalOptions, function(err, user) ***REMOVED***
        if (user == null) return handleCallback(callback, err, false);
        collection.remove(***REMOVED*** user: username ***REMOVED***, finalOptions, function(err) ***REMOVED***
          handleCallback(callback, err, true);
        ***REMOVED***);
      ***REMOVED***);

      return;
    ***REMOVED***

    if (err) return handleCallback(callback, err);
    handleCallback(callback, err, result);
  ***REMOVED***);
***REMOVED***;

/**
 * Remove a user from a database
 * @method
 * @param ***REMOVED***string***REMOVED*** username The username.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.removeUser = function(username, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, removeUser, [this, username, options, callback]);
***REMOVED***;

/**
 * Set the current profiling level of MongoDB
 *
 * @param ***REMOVED***string***REMOVED*** level The new profiling level (off, slow_only, all).
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.setProfilingLevel = function(level, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, setProfilingLevel, [this, level, options, callback]);
***REMOVED***;

var setProfilingLevel = function(self, level, options, callback) ***REMOVED***
  var command = ***REMOVED******REMOVED***;
  var profile = 0;

  if (level === 'off') ***REMOVED***
    profile = 0;
  ***REMOVED*** else if (level === 'slow_only') ***REMOVED***
    profile = 1;
  ***REMOVED*** else if (level === 'all') ***REMOVED***
    profile = 2;
  ***REMOVED*** else ***REMOVED***
    return callback(new Error('Error: illegal profiling level value ' + level));
  ***REMOVED***

  // Set up the profile number
  command['profile'] = profile;

  self.command(command, options, function(err, doc) ***REMOVED***
    if (err == null && doc.ok === 1) return callback(null, level);
    return err != null
      ? callback(err, null)
      : callback(new Error('Error with profile command'), null);
  ***REMOVED***);
***REMOVED***;

/**
 * Retrive the current profiling information for MongoDB
 *
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Query the system.profile collection directly.
 */
Db.prototype.profilingInfo = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, profilingInfo, [this, options, callback]);
***REMOVED***;

var profilingInfo = function(self, options, callback) ***REMOVED***
  try ***REMOVED***
    self
      .collection('system.profile')
      .find(***REMOVED******REMOVED***, null, options)
      .toArray(callback);
  ***REMOVED*** catch (err) ***REMOVED***
    return callback(err, null);
  ***REMOVED***
***REMOVED***;

/**
 * Retrieve the current profiling Level for MongoDB
 *
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.profilingLevel = function(options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, profilingLevel, [this, options, callback]);
***REMOVED***;

var profilingLevel = function(self, options, callback) ***REMOVED***
  self.command(***REMOVED*** profile: -1 ***REMOVED***, options, function(err, doc) ***REMOVED***
    if (err == null && doc.ok === 1) ***REMOVED***
      var was = doc.was;
      if (was === 0) return callback(null, 'off');
      if (was === 1) return callback(null, 'slow_only');
      if (was === 2) return callback(null, 'all');
      return callback(new Error('Error: illegal profiling level value ' + was), null);
    ***REMOVED*** else ***REMOVED***
      err != null ? callback(err, null) : callback(new Error('Error with profile command'), null);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Retrieves this collections index info.
 * @method
 * @param ***REMOVED***string***REMOVED*** name The name of the collection.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.full=false] Returns the full raw index information.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Db.prototype.indexInformation = function(name, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  return executeOperation(this.s.topology, indexInformation, [this, name, options, callback]);
***REMOVED***;

var indexInformation = function(self, name, options, callback) ***REMOVED***
  // If we specified full information
  var full = options['full'] == null ? false : options['full'];

  // Did the user destroy the topology
  if (self.serverConfig && self.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Process all the results from the index command and collection
  var processResults = function(indexes) ***REMOVED***
    // Contains all the information
    var info = ***REMOVED******REMOVED***;
    // Process all the indexes
    for (var i = 0; i < indexes.length; i++) ***REMOVED***
      var index = indexes[i];
      // Let's unpack the object
      info[index.name] = [];
      for (var name in index.key) ***REMOVED***
        info[index.name].push([name, index.key[name]]);
      ***REMOVED***
    ***REMOVED***

    return info;
  ***REMOVED***;

  // Get the list of indexes of the specified collection
  self
    .collection(name)
    .listIndexes(options)
    .toArray(function(err, indexes) ***REMOVED***
      if (err) return callback(toError(err));
      if (!Array.isArray(indexes)) return handleCallback(callback, null, []);
      if (full) return handleCallback(callback, null, indexes);
      handleCallback(callback, null, processResults(indexes));
    ***REMOVED***);
***REMOVED***;

var createCreateIndexCommand = function(db, name, fieldOrSpec, options) ***REMOVED***
  var indexParameters = parseIndexOptions(fieldOrSpec);
  var fieldHash = indexParameters.fieldHash;

  // Generate the index name
  var indexName = typeof options.name === 'string' ? options.name : indexParameters.name;
  var selector = ***REMOVED***
    ns: db.databaseName + '.' + name,
    key: fieldHash,
    name: indexName
  ***REMOVED***;

  // Ensure we have a correct finalUnique
  var finalUnique = options == null || 'object' === typeof options ? false : options;
  // Set up options
  options = options == null || typeof options === 'boolean' ? ***REMOVED******REMOVED*** : options;

  // Add all the options
  var keysToOmit = Object.keys(selector);
  for (var optionName in options) ***REMOVED***
    if (keysToOmit.indexOf(optionName) === -1) ***REMOVED***
      selector[optionName] = options[optionName];
    ***REMOVED***
  ***REMOVED***

  if (selector['unique'] == null) selector['unique'] = finalUnique;

  // Remove any write concern operations
  var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
  for (var i = 0; i < removeKeys.length; i++) ***REMOVED***
    delete selector[removeKeys[i]];
  ***REMOVED***

  // Return the command creation selector
  return selector;
***REMOVED***;

var createIndexUsingCreateIndexes = function(self, name, fieldOrSpec, options, callback) ***REMOVED***
  // Build the index
  var indexParameters = parseIndexOptions(fieldOrSpec);
  // Generate the index name
  var indexName = typeof options.name === 'string' ? options.name : indexParameters.name;
  // Set up the index
  var indexes = [***REMOVED*** name: indexName, key: indexParameters.fieldHash ***REMOVED***];
  // merge all the options
  var keysToOmit = Object.keys(indexes[0]).concat([
    'w',
    'wtimeout',
    'j',
    'fsync',
    'readPreference',
    'session'
  ]);

  for (var optionName in options) ***REMOVED***
    if (keysToOmit.indexOf(optionName) === -1) ***REMOVED***
      indexes[0][optionName] = options[optionName];
    ***REMOVED***
  ***REMOVED***

  // Get capabilities
  var capabilities = self.s.topology.capabilities();

  // Did the user pass in a collation, check if our write server supports it
  if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) ***REMOVED***
    // Create a new error
    var error = new MongoError(f('server/primary/mongos does not support collation'));
    error.code = 67;
    // Return the error
    return callback(error);
  ***REMOVED***

  // Create command, apply write concern to command
  var cmd = applyWriteConcern(***REMOVED*** createIndexes: name, indexes: indexes ***REMOVED***, ***REMOVED*** db: self ***REMOVED***, options);

  // ReadPreference primary
  options.readPreference = ReadPreference.PRIMARY;

  // Build the command
  self.command(cmd, options, function(err, result) ***REMOVED***
    if (err) return handleCallback(callback, err, null);
    if (result.ok === 0) return handleCallback(callback, toError(result), null);
    // Return the indexName for backward compatibility
    handleCallback(callback, null, indexName);
  ***REMOVED***);
***REMOVED***;

// Validate the database name
var validateDatabaseName = function(databaseName) ***REMOVED***
  if (typeof databaseName !== 'string')
    throw MongoError.create(***REMOVED*** message: 'database name must be a string', driver: true ***REMOVED***);
  if (databaseName.length === 0)
    throw MongoError.create(***REMOVED*** message: 'database name cannot be the empty string', driver: true ***REMOVED***);
  if (databaseName === '$external') return;

  var invalidChars = [' ', '.', '$', '/', '\\'];
  for (var i = 0; i < invalidChars.length; i++) ***REMOVED***
    if (databaseName.indexOf(invalidChars[i]) !== -1)
      throw MongoError.create(***REMOVED***
        message: "database names cannot contain the character '" + invalidChars[i] + "'",
        driver: true
      ***REMOVED***);
  ***REMOVED***
***REMOVED***;

// Add listeners to topology
var createListener = function(self, e, object) ***REMOVED***
  var listener = function(err) ***REMOVED***
    if (object.listeners(e).length > 0) ***REMOVED***
      object.emit(e, err, self);

      // Emit on all associated db's if available
      for (var i = 0; i < self.s.children.length; i++) ***REMOVED***
        self.s.children[i].emit(e, err, self.s.children[i]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
  return listener;
***REMOVED***;

/**
 * Unref all sockets
 * @method
 */
Db.prototype.unref = function() ***REMOVED***
  this.s.topology.unref();
***REMOVED***;

/**
 * Db close event
 *
 * Emitted after a socket closed against a single server or mongos proxy.
 *
 * @event Db#close
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Db reconnect event
 *
 *  * Server: Emitted when the driver has reconnected and re-authenticated.
 *  * ReplicaSet: N/A
 *  * Mongos: Emitted when the driver reconnects and re-authenticates successfully against a Mongos.
 *
 * @event Db#reconnect
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Db error event
 *
 * Emitted after an error occurred against a single server or mongos proxy.
 *
 * @event Db#error
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Db timeout event
 *
 * Emitted after a socket timeout occurred against a single server or mongos proxy.
 *
 * @event Db#timeout
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Db parseError event
 *
 * The parseError event is emitted if the driver detects illegal or corrupt BSON being received from the server.
 *
 * @event Db#parseError
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Db fullsetup event, emitted when all servers in the topology have been connected to at start up time.
 *
 * * Server: Emitted when the driver has connected to the single server and has authenticated.
 * * ReplSet: Emitted after the driver has attempted to connect to all replicaset members.
 * * Mongos: Emitted after the driver has attempted to connect to all mongos proxies.
 *
 * @event Db#fullsetup
 * @type ***REMOVED***Db***REMOVED***
 */

// Constants
Db.SYSTEM_NAMESPACE_COLLECTION = 'system.namespaces';
Db.SYSTEM_INDEX_COLLECTION = 'system.indexes';
Db.SYSTEM_PROFILE_COLLECTION = 'system.profile';
Db.SYSTEM_USER_COLLECTION = 'system.users';
Db.SYSTEM_COMMAND_COLLECTION = '$cmd';
Db.SYSTEM_JS_COLLECTION = 'system.js';

module.exports = Db;
