'use strict';

const decorateWithCollation = require('../utils').decorateWithCollation;
const formattedOrderClause = require('../utils').formattedOrderClause;
const handleCallback = require('../utils').handleCallback;
const MongoError = require('mongodb-core').MongoError;
const push = Array.prototype.push;

/**
 * Get the count of documents for this cursor.
 *
 * @method
 * @param ***REMOVED***Cursor***REMOVED*** cursor The Cursor instance on which to count.
 * @param ***REMOVED***boolean***REMOVED*** [applySkipLimit=true] Specifies whether the count command apply limit and skip settings should be applied on the cursor or in the provided options.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Cursor.prototype.count for a list of options.
 * @param ***REMOVED***Cursor~countResultCallback***REMOVED*** [callback] The result callback.
 */
function count(cursor, applySkipLimit, opts, callback) ***REMOVED***
  if (applySkipLimit) ***REMOVED***
    if (typeof cursor.cursorSkip() === 'number') opts.skip = cursor.cursorSkip();
    if (typeof cursor.cursorLimit() === 'number') opts.limit = cursor.cursorLimit();
  ***REMOVED***

  // Command
  const delimiter = cursor.s.ns.indexOf('.');

  let command = ***REMOVED***
    count: cursor.s.ns.substr(delimiter + 1),
    query: cursor.s.cmd.query
  ***REMOVED***;

  // Apply a readConcern if set
  if (cursor.s.cmd.readConcern) ***REMOVED***
    command.readConcern = cursor.s.cmd.readConcern;
  ***REMOVED***

  // Apply a hint if set
  if (cursor.s.cmd.hint) ***REMOVED***
    command.hint = cursor.s.cmd.hint;
  ***REMOVED***

  // Apply a collation if set
  decorateWithCollation(command, cursor, cursor.s.cmd);

  if (typeof opts.maxTimeMS === 'number') ***REMOVED***
    command.maxTimeMS = opts.maxTimeMS;
  ***REMOVED*** else if (cursor.s.cmd && typeof cursor.s.cmd.maxTimeMS === 'number') ***REMOVED***
    command.maxTimeMS = cursor.s.cmd.maxTimeMS;
  ***REMOVED***

  // Merge in any options
  if (opts.skip) command.skip = opts.skip;
  if (opts.limit) command.limit = opts.limit;
  if (cursor.s.options.hint) command.hint = cursor.s.options.hint;

  // Set cursor server to the same as the topology
  cursor.server = cursor.topology.s.coreTopology;

  // Execute the command
  cursor.s.topology.command(
    `$***REMOVED***cursor.s.ns.substr(0, delimiter)***REMOVED***.$cmd`,
    command,
    cursor.s.options,
    (err, result) => ***REMOVED***
      callback(err, result ? result.result.n : null);
    ***REMOVED***
  );
***REMOVED***

/**
 * Iterates over all the documents for this cursor. See Cursor.prototype.each for more information.
 *
 * @method
 * @deprecated
 * @param ***REMOVED***Cursor***REMOVED*** cursor The Cursor instance on which to run.
 * @param ***REMOVED***Cursor~resultCallback***REMOVED*** callback The result callback.
 */
function each(cursor, callback) ***REMOVED***
  const Cursor = require('../cursor');

  if (!callback) throw MongoError.create(***REMOVED*** message: 'callback is mandatory', driver: true ***REMOVED***);
  if (cursor.isNotified()) return;
  if (cursor.s.state === Cursor.CLOSED || cursor.isDead()) ***REMOVED***
    return handleCallback(
      callback,
      MongoError.create(***REMOVED*** message: 'Cursor is closed', driver: true ***REMOVED***)
    );
  ***REMOVED***

  if (cursor.s.state === Cursor.INIT) cursor.s.state = Cursor.OPEN;

  // Define function to avoid global scope escape
  let fn = null;
  // Trampoline all the entries
  if (cursor.bufferedCount() > 0) ***REMOVED***
    while ((fn = loop(cursor, callback))) fn(cursor, callback);
    each(cursor, callback);
  ***REMOVED*** else ***REMOVED***
    cursor.next((err, item) => ***REMOVED***
      if (err) return handleCallback(callback, err);
      if (item == null) ***REMOVED***
        return cursor.close(***REMOVED*** skipKillCursors: true ***REMOVED***, () => handleCallback(callback, null, null));
      ***REMOVED***

      if (handleCallback(callback, null, item) === false) return;
      each(cursor, callback);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Check if there is any document still available in the cursor.
 *
 * @method
 * @param ***REMOVED***Cursor***REMOVED*** cursor The Cursor instance on which to run.
 * @param ***REMOVED***Cursor~resultCallback***REMOVED*** [callback] The result callback.
 */
function hasNext(cursor, callback) ***REMOVED***
  const Cursor = require('../cursor');

  if (cursor.s.currentDoc) ***REMOVED***
    return callback(null, true);
  ***REMOVED***

  if (cursor.isNotified()) ***REMOVED***
    return callback(null, false);
  ***REMOVED***

  nextObject(cursor, (err, doc) => ***REMOVED***
    if (err) return callback(err, null);
    if (cursor.s.state === Cursor.CLOSED || cursor.isDead()) return callback(null, false);
    if (!doc) return callback(null, false);
    cursor.s.currentDoc = doc;
    callback(null, true);
  ***REMOVED***);
***REMOVED***

// Trampoline emptying the number of retrieved items
// without incurring a nextTick operation
function loop(cursor, callback) ***REMOVED***
  // No more items we are done
  if (cursor.bufferedCount() === 0) return;
  // Get the next document
  cursor._next(callback);
  // Loop
  return loop;
***REMOVED***

/**
 * Get the next available document from the cursor. Returns null if no more documents are available.
 *
 * @method
 * @param ***REMOVED***Cursor***REMOVED*** cursor The Cursor instance from which to get the next document.
 * @param ***REMOVED***Cursor~resultCallback***REMOVED*** [callback] The result callback.
 */
function next(cursor, callback) ***REMOVED***
  // Return the currentDoc if someone called hasNext first
  if (cursor.s.currentDoc) ***REMOVED***
    const doc = cursor.s.currentDoc;
    cursor.s.currentDoc = null;
    return callback(null, doc);
  ***REMOVED***

  // Return the next object
  nextObject(cursor, callback);
***REMOVED***

// Get the next available document from the cursor, returns null if no more documents are available.
function nextObject(cursor, callback) ***REMOVED***
  const Cursor = require('../cursor');

  if (cursor.s.state === Cursor.CLOSED || (cursor.isDead && cursor.isDead()))
    return handleCallback(
      callback,
      MongoError.create(***REMOVED*** message: 'Cursor is closed', driver: true ***REMOVED***)
    );
  if (cursor.s.state === Cursor.INIT && cursor.s.cmd.sort) ***REMOVED***
    try ***REMOVED***
      cursor.s.cmd.sort = formattedOrderClause(cursor.s.cmd.sort);
    ***REMOVED*** catch (err) ***REMOVED***
      return handleCallback(callback, err);
    ***REMOVED***
  ***REMOVED***

  // Get the next object
  cursor._next((err, doc) => ***REMOVED***
    cursor.s.state = Cursor.OPEN;
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, doc);
  ***REMOVED***);
***REMOVED***

/**
 * Returns an array of documents. See Cursor.prototype.toArray for more information.
 *
 * @method
 * @param ***REMOVED***Cursor***REMOVED*** cursor The Cursor instance from which to get the next document.
 * @param ***REMOVED***Cursor~toArrayResultCallback***REMOVED*** [callback] The result callback.
 */
function toArray(cursor, callback) ***REMOVED***
  const Cursor = require('../cursor');

  const items = [];

  // Reset cursor
  cursor.rewind();
  cursor.s.state = Cursor.INIT;

  // Fetch all the documents
  const fetchDocs = () => ***REMOVED***
    cursor._next((err, doc) => ***REMOVED***
      if (err) ***REMOVED***
        return cursor._endSession
          ? cursor._endSession(() => handleCallback(callback, err))
          : handleCallback(callback, err);
      ***REMOVED***
      if (doc == null) ***REMOVED***
        return cursor.close(***REMOVED*** skipKillCursors: true ***REMOVED***, () => handleCallback(callback, null, items));
      ***REMOVED***

      // Add doc to items
      items.push(doc);

      // Get all buffered objects
      if (cursor.bufferedCount() > 0) ***REMOVED***
        let docs = cursor.readBufferedDocuments(cursor.bufferedCount());

        // Transform the doc if transform method added
        if (cursor.s.transforms && typeof cursor.s.transforms.doc === 'function') ***REMOVED***
          docs = docs.map(cursor.s.transforms.doc);
        ***REMOVED***

        push.apply(items, docs);
      ***REMOVED***

      // Attempt a fetch
      fetchDocs();
    ***REMOVED***);
  ***REMOVED***;

  fetchDocs();
***REMOVED***

module.exports = ***REMOVED*** count, each, hasNext, next, toArray ***REMOVED***;
