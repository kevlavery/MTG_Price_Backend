'use strict';

const authenticate = require('../authenticate');
const deprecate = require('util').deprecate;
const Logger = require('mongodb-core').Logger;
const MongoError = require('mongodb-core').MongoError;
const Mongos = require('../topologies/mongos');
const parse = require('mongodb-core').parseConnectionString;
const ReadPreference = require('mongodb-core').ReadPreference;
const ReplSet = require('../topologies/replset');
const Server = require('../topologies/server');
const ServerSessionPool = require('mongodb-core').Sessions.ServerSessionPool;

const monitoringEvents = [
  'timeout',
  'close',
  'serverOpening',
  'serverDescriptionChanged',
  'serverHeartbeatStarted',
  'serverHeartbeatSucceeded',
  'serverHeartbeatFailed',
  'serverClosed',
  'topologyOpening',
  'topologyClosed',
  'topologyDescriptionChanged',
  'commandStarted',
  'commandSucceeded',
  'commandFailed',
  'joined',
  'left',
  'ping',
  'ha',
  'all',
  'fullsetup'
];
const ignoreOptionNames = ['native_parser'];
const legacyOptionNames = ['server', 'replset', 'replSet', 'mongos', 'db'];
const legacyParse = deprecate(
  require('../url_parser'),
  'current URL string parser is deprecated, and will be removed in a future version. ' +
    'To use the new parser, pass option ***REMOVED*** useNewUrlParser: true ***REMOVED*** to MongoClient.connect.'
);
const validOptionNames = [
  'poolSize',
  'ssl',
  'sslValidate',
  'sslCA',
  'sslCert',
  'sslKey',
  'sslPass',
  'sslCRL',
  'autoReconnect',
  'noDelay',
  'keepAlive',
  'keepAliveInitialDelay',
  'connectTimeoutMS',
  'family',
  'socketTimeoutMS',
  'reconnectTries',
  'reconnectInterval',
  'ha',
  'haInterval',
  'replicaSet',
  'secondaryAcceptableLatencyMS',
  'acceptableLatencyMS',
  'connectWithNoPrimary',
  'authSource',
  'w',
  'wtimeout',
  'j',
  'forceServerObjectId',
  'serializeFunctions',
  'ignoreUndefined',
  'raw',
  'bufferMaxEntries',
  'readPreference',
  'pkFactory',
  'promiseLibrary',
  'readConcern',
  'maxStalenessSeconds',
  'loggerLevel',
  'logger',
  'promoteValues',
  'promoteBuffers',
  'promoteLongs',
  'domainsEnabled',
  'checkServerIdentity',
  'validateOptions',
  'appname',
  'auth',
  'user',
  'password',
  'authMechanism',
  'compression',
  'fsync',
  'readPreferenceTags',
  'numberOfRetries',
  'auto_reconnect',
  'minSize',
  'monitorCommands',
  'retryWrites',
  'useNewUrlParser'
];

function addListeners(mongoClient, topology) ***REMOVED***
  topology.on('authenticated', createListener(mongoClient, 'authenticated'));
  topology.on('error', createListener(mongoClient, 'error'));
  topology.on('timeout', createListener(mongoClient, 'timeout'));
  topology.on('close', createListener(mongoClient, 'close'));
  topology.on('parseError', createListener(mongoClient, 'parseError'));
  topology.once('open', createListener(mongoClient, 'open'));
  topology.once('fullsetup', createListener(mongoClient, 'fullsetup'));
  topology.once('all', createListener(mongoClient, 'all'));
  topology.on('reconnect', createListener(mongoClient, 'reconnect'));
***REMOVED***

function assignTopology(client, topology) ***REMOVED***
  client.topology = topology;
  topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);
***REMOVED***

// Clear out all events
function clearAllEvents(topology) ***REMOVED***
  monitoringEvents.forEach(event => topology.removeAllListeners(event));
***REMOVED***

// Collect all events in order from SDAM
function collectEvents(mongoClient, topology) ***REMOVED***
  const MongoClient = require('../mongo_client');
  const collectedEvents = [];

  if (mongoClient instanceof MongoClient) ***REMOVED***
    monitoringEvents.forEach(event => ***REMOVED***
      topology.on(event, (object1, object2) => ***REMOVED***
        collectedEvents.push(***REMOVED***
          event: event,
          object1: object1,
          object2: object2
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  return collectedEvents;
***REMOVED***

/**
 * Connect to MongoDB using a url as documented at
 *
 *  docs.mongodb.org/manual/reference/connection-string/
 *
 * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
 *
 * @method
 * @param ***REMOVED***MongoClient***REMOVED*** mongoClient The MongoClient instance with which to connect.
 * @param ***REMOVED***string***REMOVED*** url The connection URI string
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See MongoClient.prototype.connect for a list of options.
 * @param ***REMOVED***MongoClient~connectCallback***REMOVED*** [callback] The command result callback
 */
function connect(mongoClient, url, options, callback) ***REMOVED***
  options = Object.assign(***REMOVED******REMOVED***, options);

  // If callback is null throw an exception
  if (callback == null) ***REMOVED***
    throw new Error('no callback function provided');
  ***REMOVED***

  // Get a logger for MongoClient
  const logger = Logger('MongoClient', options);

  // Did we pass in a Server/ReplSet/Mongos
  if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) ***REMOVED***
    return connectWithUrl(mongoClient, url, options, connectCallback);
  ***REMOVED***

  const parseFn = options.useNewUrlParser ? parse : legacyParse;
  const transform = options.useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;

  parseFn(url, options, (err, _object) => ***REMOVED***
    // Do not attempt to connect if parsing error
    if (err) return callback(err);

    // Flatten
    const object = transform(_object);

    // Parse the string
    const _finalOptions = createUnifiedOptions(object, options);

    // Check if we have connection and socket timeout set
    if (_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 360000;
    if (_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 30000;

    if (_finalOptions.db_options && _finalOptions.db_options.auth) ***REMOVED***
      delete _finalOptions.db_options.auth;
    ***REMOVED***

    // Store the merged options object
    mongoClient.s.options = _finalOptions;

    // Failure modes
    if (object.servers.length === 0) ***REMOVED***
      return callback(new Error('connection string must contain at least one seed host'));
    ***REMOVED***

    // Do we have a replicaset then skip discovery and go straight to connectivity
    if (_finalOptions.replicaSet || _finalOptions.rs_name) ***REMOVED***
      return createTopology(
        mongoClient,
        'replicaset',
        _finalOptions,
        connectHandler(mongoClient, _finalOptions, connectCallback)
      );
    ***REMOVED*** else if (object.servers.length > 1) ***REMOVED***
      return createTopology(
        mongoClient,
        'mongos',
        _finalOptions,
        connectHandler(mongoClient, _finalOptions, connectCallback)
      );
    ***REMOVED*** else ***REMOVED***
      return createServer(
        mongoClient,
        _finalOptions,
        connectHandler(mongoClient, _finalOptions, connectCallback)
      );
    ***REMOVED***
  ***REMOVED***);
  function connectCallback(err, topology) ***REMOVED***
    const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;
    if (err && err.message === 'no mongos proxies found in seed list') ***REMOVED***
      if (logger.isWarn()) ***REMOVED***
        logger.warn(warningMessage);
      ***REMOVED***

      // Return a more specific error message for MongoClient.connect
      return callback(new MongoError(warningMessage));
    ***REMOVED***

    // Return the error and db instance
    callback(err, topology);
  ***REMOVED***
***REMOVED***

function connectHandler(client, options, callback) ***REMOVED***
  return (err, topology) => ***REMOVED***
    if (err) ***REMOVED***
      return handleConnectCallback(err, topology, callback);
    ***REMOVED***

    // No authentication just reconnect
    if (!options.auth) ***REMOVED***
      return handleConnectCallback(err, topology, callback);
    ***REMOVED***

    // Authenticate
    authenticate(client, options.user, options.password, options, (err, success) => ***REMOVED***
      if (success) ***REMOVED***
        handleConnectCallback(null, topology, callback);
      ***REMOVED*** else ***REMOVED***
        if (topology) topology.close();
        const authError = err ? err : new Error('Could not authenticate user ' + options.auth[0]);
        handleConnectCallback(authError, topology, callback);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***;
***REMOVED***

/**
 * Connect to MongoDB using a url as documented at
 *
 *  docs.mongodb.org/manual/reference/connection-string/
 *
 * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
 *
 * @method
 * @param ***REMOVED***MongoClient***REMOVED*** mongoClient The MongoClient instance with which to connect.
 * @param ***REMOVED***MongoClient~connectCallback***REMOVED*** [callback] The command result callback
 */
function connectOp(mongoClient, err, callback) ***REMOVED***
  // Did we have a validation error
  if (err) return callback(err);
  // Fallback to callback based connect
  connect(mongoClient, mongoClient.s.url, mongoClient.s.options, err => ***REMOVED***
    if (err) return callback(err);
    callback(null, mongoClient);
  ***REMOVED***);
***REMOVED***

function connectWithUrl(mongoClient, url, options, connectCallback) ***REMOVED***
  // Set the topology
  assignTopology(mongoClient, url);

  // Add listeners
  addListeners(mongoClient, url);

  // Propagate the events to the client
  relayEvents(mongoClient, url);

  // Connect
  return url.connect(
    options,
    connectHandler(mongoClient, options, (err, topology) => ***REMOVED***
      if (err) return connectCallback(err, topology);
      if (options.user || options.password || options.authMechanism) ***REMOVED***
        return authenticate(mongoClient, options.user, options.password, options, err => ***REMOVED***
          if (err) return connectCallback(err, topology);
          connectCallback(err, topology);
        ***REMOVED***);
      ***REMOVED***

      connectCallback(err, topology);
    ***REMOVED***)
  );
***REMOVED***

function createListener(mongoClient, event) ***REMOVED***
  const eventSet = new Set(['all', 'fullsetup', 'open', 'reconnect']);
  return (v1, v2) => ***REMOVED***
    if (eventSet.has(event)) ***REMOVED***
      return mongoClient.emit(event, mongoClient);
    ***REMOVED***

    mongoClient.emit(event, v1, v2);
  ***REMOVED***;
***REMOVED***

function createServer(mongoClient, options, callback) ***REMOVED***
  // Pass in the promise library
  options.promiseLibrary = mongoClient.s.promiseLibrary;

  // Set default options
  const servers = translateOptions(options);

  // Propagate the events to the client
  const collectedEvents = collectEvents(mongoClient, servers[0]);

  // Connect to topology
  servers[0].connect(options, (err, topology) => ***REMOVED***
    if (err) return callback(err);
    // Clear out all the collected event listeners
    clearAllEvents(servers[0]);

    // Relay all the events
    relayEvents(mongoClient, servers[0]);
    // Add listeners
    addListeners(mongoClient, servers[0]);
    // Check if we are really speaking to a mongos
    const ismaster = topology.lastIsMaster();

    // Set the topology
    assignTopology(mongoClient, topology);

    // Do we actually have a mongos
    if (ismaster && ismaster.msg === 'isdbgrid') ***REMOVED***
      // Destroy the current connection
      topology.close();
      // Create mongos connection instead
      return createTopology(mongoClient, 'mongos', options, callback);
    ***REMOVED***

    // Fire all the events
    replayEvents(mongoClient, collectedEvents);
    // Otherwise callback
    callback(err, topology);
  ***REMOVED***);
***REMOVED***

function createTopology(mongoClient, topologyType, options, callback) ***REMOVED***
  // Pass in the promise library
  options.promiseLibrary = mongoClient.s.promiseLibrary;

  // Set default options
  const servers = translateOptions(options);

  // Create the topology
  let topology;
  if (topologyType === 'mongos') ***REMOVED***
    topology = new Mongos(servers, options);
  ***REMOVED*** else if (topologyType === 'replicaset') ***REMOVED***
    topology = new ReplSet(servers, options);
  ***REMOVED***

  // Add listeners
  addListeners(mongoClient, topology);

  // Propagate the events to the client
  relayEvents(mongoClient, topology);

  // Open the connection
  topology.connect(options, (err, topology) => ***REMOVED***
    if (err) return callback(err);

    assignTopology(mongoClient, topology);
    callback(null, topology);
  ***REMOVED***);
***REMOVED***

function createUnifiedOptions(finalOptions, options) ***REMOVED***
  const childOptions = [
    'mongos',
    'server',
    'db',
    'replset',
    'db_options',
    'server_options',
    'rs_options',
    'mongos_options'
  ];
  const noMerge = ['readconcern', 'compression'];

  for (const name in options) ***REMOVED***
    if (noMerge.indexOf(name.toLowerCase()) !== -1) ***REMOVED***
      finalOptions[name] = options[name];
    ***REMOVED*** else if (childOptions.indexOf(name.toLowerCase()) !== -1) ***REMOVED***
      finalOptions = mergeOptions(finalOptions, options[name], false);
    ***REMOVED*** else ***REMOVED***
      if (
        options[name] &&
        typeof options[name] === 'object' &&
        !Buffer.isBuffer(options[name]) &&
        !Array.isArray(options[name])
      ) ***REMOVED***
        finalOptions = mergeOptions(finalOptions, options[name], true);
      ***REMOVED*** else ***REMOVED***
        finalOptions[name] = options[name];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return finalOptions;
***REMOVED***

function handleConnectCallback(err, topology, callback) ***REMOVED***
  return process.nextTick(() => ***REMOVED***
    try ***REMOVED***
      callback(err, topology);
    ***REMOVED*** catch (err) ***REMOVED***
      if (topology) topology.close();
      throw err;
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

function legacyTransformUrlOptions(object) ***REMOVED***
  return mergeOptions(createUnifiedOptions(***REMOVED******REMOVED***, object), object, false);
***REMOVED***

/**
 * Logout user from server, fire off on all connections and remove all auth info.
 *
 * @method
 * @param ***REMOVED***MongoClient***REMOVED*** mongoClient The MongoClient instance on which to logout.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See MongoClient.prototype.logout for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function logout(mongoClient, dbName, callback) ***REMOVED***
  mongoClient.topology.logout(dbName, err => ***REMOVED***
    if (err) return callback(err);
    callback(null, true);
  ***REMOVED***);
***REMOVED***

function mergeOptions(target, source, flatten) ***REMOVED***
  for (const name in source) ***REMOVED***
    if (source[name] && typeof source[name] === 'object' && flatten) ***REMOVED***
      target = mergeOptions(target, source[name], flatten);
    ***REMOVED*** else ***REMOVED***
      target[name] = source[name];
    ***REMOVED***
  ***REMOVED***

  return target;
***REMOVED***

function relayEvents(mongoClient, topology) ***REMOVED***
  const serverOrCommandEvents = [
    'serverOpening',
    'serverDescriptionChanged',
    'serverHeartbeatStarted',
    'serverHeartbeatSucceeded',
    'serverHeartbeatFailed',
    'serverClosed',
    'topologyOpening',
    'topologyClosed',
    'topologyDescriptionChanged',
    'commandStarted',
    'commandSucceeded',
    'commandFailed',
    'joined',
    'left',
    'ping',
    'ha'
  ];

  serverOrCommandEvents.forEach(event => ***REMOVED***
    topology.on(event, (object1, object2) => ***REMOVED***
      mongoClient.emit(event, object1, object2);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

//
// Replay any events due to single server connection switching to Mongos
//
function replayEvents(mongoClient, events) ***REMOVED***
  for (let i = 0; i < events.length; i++) ***REMOVED***
    mongoClient.emit(events[i].event, events[i].object1, events[i].object2);
  ***REMOVED***
***REMOVED***

const LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => ***REMOVED***
  obj[name.toLowerCase()] = name;
  return obj;
***REMOVED***, ***REMOVED******REMOVED***);

function transformUrlOptions(_object) ***REMOVED***
  let object = Object.assign(***REMOVED*** servers: _object.hosts ***REMOVED***, _object.options);
  for (let name in object) ***REMOVED***
    const camelCaseName = LEGACY_OPTIONS_MAP[name];
    if (camelCaseName) ***REMOVED***
      object[camelCaseName] = object[name];
    ***REMOVED***
  ***REMOVED***
  if (_object.auth) ***REMOVED***
    const auth = _object.auth;
    for (let i in auth) ***REMOVED***
      if (auth[i]) ***REMOVED***
        object[i] = auth[i];
      ***REMOVED***
    ***REMOVED***
    if (auth.username) ***REMOVED***
      object.auth = auth;
      object.user = auth.username;
    ***REMOVED***
    if (auth.db) ***REMOVED***
      object.dbName = auth.db;
    ***REMOVED***
  ***REMOVED***
  if (object.maxpoolsize) ***REMOVED***
    object.poolSize = object.maxpoolsize;
  ***REMOVED***
  if (object.readconcernlevel) ***REMOVED***
    object.readConcern = ***REMOVED*** level: object.readconcernlevel ***REMOVED***;
  ***REMOVED***
  if (object.wtimeoutms) ***REMOVED***
    object.wtimeout = object.wtimeoutms;
  ***REMOVED***
  return object;
***REMOVED***

function translateOptions(options) ***REMOVED***
  // If we have a readPreference passed in by the db options
  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') ***REMOVED***
    options.readPreference = new ReadPreference(options.readPreference || options.read_preference);
  ***REMOVED***

  // Do we have readPreference tags, add them
  if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) ***REMOVED***
    options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;
  ***REMOVED***

  // Do we have maxStalenessSeconds
  if (options.maxStalenessSeconds) ***REMOVED***
    options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;
  ***REMOVED***

  // Set the socket and connection timeouts
  if (options.socketTimeoutMS == null) options.socketTimeoutMS = 360000;
  if (options.connectTimeoutMS == null) options.connectTimeoutMS = 30000;

  // Create server instances
  return options.servers.map(serverObj => ***REMOVED***
    return serverObj.domain_socket
      ? new Server(serverObj.domain_socket, 27017, options)
      : new Server(serverObj.host, serverObj.port, options);
  ***REMOVED***);
***REMOVED***

// Validate options object
function validOptions(options) ***REMOVED***
  const _validOptions = validOptionNames.concat(legacyOptionNames);

  for (const name in options) ***REMOVED***
    if (ignoreOptionNames.indexOf(name) !== -1) ***REMOVED***
      continue;
    ***REMOVED***

    if (_validOptions.indexOf(name) === -1 && options.validateOptions) ***REMOVED***
      return new MongoError(`option $***REMOVED***name***REMOVED*** is not supported`);
    ***REMOVED*** else if (_validOptions.indexOf(name) === -1) ***REMOVED***
      console.warn(`the options [$***REMOVED***name***REMOVED***] is not supported`);
    ***REMOVED***

    if (legacyOptionNames.indexOf(name) !== -1) ***REMOVED***
      console.warn(
        `the server/replset/mongos options are deprecated, ` +
          `all their options are supported at the top level of the options object [$***REMOVED***validOptionNames***REMOVED***]`
      );
    ***REMOVED***
  ***REMOVED***
***REMOVED***

module.exports = ***REMOVED*** connectOp, logout, validOptions ***REMOVED***;
