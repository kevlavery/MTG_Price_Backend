'use strict';

const applyWriteConcern = require('../utils').applyWriteConcern;
const Code = require('mongodb-core').BSON.Code;
const resolveReadPreference = require('../utils').resolveReadPreference;
const crypto = require('crypto');
const Db = require('../db');
const debugOptions = require('../utils').debugOptions;
const handleCallback = require('../utils').handleCallback;
const MongoError = require('mongodb-core').MongoError;
const parseIndexOptions = require('../utils').parseIndexOptions;
const ReadPreference = require('mongodb-core').ReadPreference;
const toError = require('../utils').toError;

const count = require('./collection_ops').count;
const findOne = require('./collection_ops').findOne;
const remove = require('./collection_ops').remove;
const update = require('./collection_ops').update;

const debugFields = [
  'authSource',
  'w',
  'wtimeout',
  'j',
  'native_parser',
  'forceServerObjectId',
  'serializeFunctions',
  'raw',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'bufferMaxEntries',
  'numberOfRetries',
  'retryMiliSeconds',
  'readPreference',
  'pkFactory',
  'parentDb',
  'promiseLibrary',
  'noListener'
];

// Filter out any write concern options
const illegalCommandFields = [
  'w',
  'wtimeout',
  'j',
  'fsync',
  'autoIndexId',
  'strict',
  'serializeFunctions',
  'pkFactory',
  'raw',
  'readPreference',
  'session'
];

/**
 * Add a user to the database.
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to add a user.
 * @param ***REMOVED***string***REMOVED*** username The username.
 * @param ***REMOVED***string***REMOVED*** password The password.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.addUser for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function addUser(db, username, password, options, callback) ***REMOVED***
  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Attempt to execute auth command
  executeAuthCreateUserCommand(db, username, password, options, (err, r) => ***REMOVED***
    // We need to perform the backward compatible insert operation
    if (err && err.code === -5000) ***REMOVED***
      const finalOptions = applyWriteConcern(Object.assign(***REMOVED******REMOVED***, options), ***REMOVED*** db ***REMOVED***, options);

      // Use node md5 generator
      const md5 = crypto.createHash('md5');
      // Generate keys used for authentication
      md5.update(username + ':mongo:' + password);
      const userPassword = md5.digest('hex');

      // If we have another db set
      const db = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db;

      // Fetch a user collection
      const collection = db.collection(Db.SYSTEM_USER_COLLECTION);

      // Check if we are inserting the first user
      count(collection, ***REMOVED******REMOVED***, finalOptions, (err, count) => ***REMOVED***
        // We got an error (f.ex not authorized)
        if (err != null) return handleCallback(callback, err, null);
        // Check if the user exists and update i
        collection
          .find(***REMOVED*** user: username ***REMOVED***, ***REMOVED*** dbName: options['dbName'] ***REMOVED***, finalOptions)
          .toArray(err => ***REMOVED***
            // We got an error (f.ex not authorized)
            if (err != null) return handleCallback(callback, err, null);
            // Add command keys
            finalOptions.upsert = true;

            // We have a user, let's update the password or upsert if not
            update(
              collection,
              ***REMOVED*** user: username ***REMOVED***,
              ***REMOVED*** $set: ***REMOVED*** user: username, pwd: userPassword ***REMOVED*** ***REMOVED***,
              finalOptions,
              err => ***REMOVED***
                if (count === 0 && err)
                  return handleCallback(callback, null, [***REMOVED*** user: username, pwd: userPassword ***REMOVED***]);
                if (err) return handleCallback(callback, err, null);
                handleCallback(callback, null, [***REMOVED*** user: username, pwd: userPassword ***REMOVED***]);
              ***REMOVED***
            );
          ***REMOVED***);
      ***REMOVED***);

      return;
    ***REMOVED***

    if (err) return handleCallback(callback, err);
    handleCallback(callback, err, r);
  ***REMOVED***);
***REMOVED***

/**
 * Fetch all collections for the current db.
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to fetch collections.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.collections for a list of options.
 * @param ***REMOVED***Db~collectionsResultCallback***REMOVED*** [callback] The results callback
 */
function collections(db, options, callback) ***REMOVED***
  const Collection = require('../collection');

  options = Object.assign(***REMOVED******REMOVED***, options, ***REMOVED*** nameOnly: true ***REMOVED***);
  // Let's get the collection names
  db.listCollections(***REMOVED******REMOVED***, options).toArray((err, documents) => ***REMOVED***
    if (err != null) return handleCallback(callback, err, null);
    // Filter collections removing any illegal ones
    documents = documents.filter(doc => ***REMOVED***
      return doc.name.indexOf('$') === -1;
    ***REMOVED***);

    // Return the collection objects
    handleCallback(
      callback,
      null,
      documents.map(d => ***REMOVED***
        return new Collection(
          db,
          db.s.topology,
          db.s.databaseName,
          d.name,
          db.s.pkFactory,
          db.s.options
        );
      ***REMOVED***)
    );
  ***REMOVED***);
***REMOVED***

/**
 * Create a new collection on a server with the specified options. Use this to create capped collections.
 * More information about command options available at https://docs.mongodb.com/manual/reference/command/create/
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to create the collection.
 * @param ***REMOVED***string***REMOVED*** name The collection name to create.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.createCollection for a list of options.
 * @param ***REMOVED***Db~collectionResultCallback***REMOVED*** [callback] The results callback
 */
function createCollection(db, name, options, callback) ***REMOVED***
  const Collection = require('../collection');

  // Get the write concern options
  const finalOptions = applyWriteConcern(Object.assign(***REMOVED******REMOVED***, options), ***REMOVED*** db ***REMOVED***, options);

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed()) ***REMOVED***
    return callback(new MongoError('topology was destroyed'));
  ***REMOVED***

  const listCollectionOptions = Object.assign(***REMOVED******REMOVED***, finalOptions, ***REMOVED*** nameOnly: true ***REMOVED***);

  // Check if we have the name
  db
    .listCollections(***REMOVED*** name ***REMOVED***, listCollectionOptions)
    .setReadPreference(ReadPreference.PRIMARY)
    .toArray((err, collections) => ***REMOVED***
      if (err != null) return handleCallback(callback, err, null);
      if (collections.length > 0 && finalOptions.strict) ***REMOVED***
        return handleCallback(
          callback,
          MongoError.create(***REMOVED***
            message: `Collection $***REMOVED***name***REMOVED*** already exists. Currently in strict mode.`,
            driver: true
          ***REMOVED***),
          null
        );
      ***REMOVED*** else if (collections.length > 0) ***REMOVED***
        try ***REMOVED***
          return handleCallback(
            callback,
            null,
            new Collection(db, db.s.topology, db.s.databaseName, name, db.s.pkFactory, options)
          );
        ***REMOVED*** catch (err) ***REMOVED***
          return handleCallback(callback, err);
        ***REMOVED***
      ***REMOVED***

      // Create collection command
      const cmd = ***REMOVED*** create: name ***REMOVED***;

      // Decorate command with writeConcern if supported
      applyWriteConcern(cmd, ***REMOVED*** db ***REMOVED***, options);

      // Add all optional parameters
      for (let n in options) ***REMOVED***
        if (
          options[n] != null &&
          typeof options[n] !== 'function' &&
          illegalCommandFields.indexOf(n) === -1
        ) ***REMOVED***
          cmd[n] = options[n];
        ***REMOVED***
      ***REMOVED***

      // Force a primary read Preference
      finalOptions.readPreference = ReadPreference.PRIMARY;
      // Execute command
      executeCommand(db, cmd, finalOptions, err => ***REMOVED***
        if (err) return handleCallback(callback, err);
        handleCallback(
          callback,
          null,
          new Collection(db, db.s.topology, db.s.databaseName, name, db.s.pkFactory, options)
        );
      ***REMOVED***);
    ***REMOVED***);
***REMOVED***

/**
 * Creates an index on the db and collection.
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to create an index.
 * @param ***REMOVED***string***REMOVED*** name Name of the collection to create the index on.
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.createIndex for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function createIndex(db, name, fieldOrSpec, options, callback) ***REMOVED***
  // Get the write concern options
  let finalOptions = Object.assign(***REMOVED******REMOVED***, ***REMOVED*** readPreference: ReadPreference.PRIMARY ***REMOVED***, options);
  finalOptions = applyWriteConcern(finalOptions, ***REMOVED*** db ***REMOVED***, options);

  // Ensure we have a callback
  if (finalOptions.writeConcern && typeof callback !== 'function') ***REMOVED***
    throw MongoError.create(***REMOVED***
      message: 'Cannot use a writeConcern without a provided callback',
      driver: true
    ***REMOVED***);
  ***REMOVED***

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));

  // Attempt to run using createIndexes command
  createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => ***REMOVED***
    if (err == null) return handleCallback(callback, err, result);

    /**
     * The following errors mean that the server recognized `createIndex` as a command so we don't need to fallback to an insert:
     * 67 = 'CannotCreateIndex' (malformed index options)
     * 85 = 'IndexOptionsConflict' (index already exists with different options)
     * 86 = 'IndexKeySpecsConflict' (index already exists with the same name)
     * 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)
     * 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)
     * 197 = 'InvalidIndexSpecificationOption' (`_id` with `background: true`)
     */
    if (
      err.code === 67 ||
      err.code === 11000 ||
      err.code === 85 ||
      err.code === 86 ||
      err.code === 11600 ||
      err.code === 197
    ) ***REMOVED***
      return handleCallback(callback, err, result);
    ***REMOVED***

    // Create command
    const doc = createCreateIndexCommand(db, name, fieldOrSpec, options);
    // Set no key checking
    finalOptions.checkKeys = false;
    // Insert document
    db.s.topology.insert(
      `$***REMOVED***db.s.databaseName***REMOVED***.$***REMOVED***Db.SYSTEM_INDEX_COLLECTION***REMOVED***`,
      doc,
      finalOptions,
      (err, result) => ***REMOVED***
        if (callback == null) return;
        if (err) return handleCallback(callback, err);
        if (result == null) return handleCallback(callback, null, null);
        if (result.result.writeErrors)
          return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);
        handleCallback(callback, null, doc.name);
      ***REMOVED***
    );
  ***REMOVED***);
***REMOVED***

// Add listeners to topology
function createListener(db, e, object) ***REMOVED***
  function listener(err) ***REMOVED***
    if (object.listeners(e).length > 0) ***REMOVED***
      object.emit(e, err, db);

      // Emit on all associated db's if available
      for (let i = 0; i < db.s.children.length; i++) ***REMOVED***
        db.s.children[i].emit(e, err, db.s.children[i]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return listener;
***REMOVED***

/**
 * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to drop the collection.
 * @param ***REMOVED***string***REMOVED*** name Name of collection to drop
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Db.prototype.dropCollection for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The results callback
 */
function dropCollection(db, cmd, options, callback) ***REMOVED***
  executeCommand(db, cmd, options, (err, result) => ***REMOVED***
    // Did the user destroy the topology
    if (db.serverConfig && db.serverConfig.isDestroyed()) ***REMOVED***
      return callback(new MongoError('topology was destroyed'));
    ***REMOVED***

    if (err) return handleCallback(callback, err);
    if (result.ok) return handleCallback(callback, null, true);
    handleCallback(callback, null, false);
  ***REMOVED***);
***REMOVED***

/**
 * Drop a database, removing it permanently from the server.
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance to drop.
 * @param ***REMOVED***Object***REMOVED*** cmd The command document.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Db.prototype.dropDatabase for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The results callback
 */
function dropDatabase(db, cmd, options, callback) ***REMOVED***
  executeCommand(db, cmd, options, (err, result) => ***REMOVED***
    // Did the user destroy the topology
    if (db.serverConfig && db.serverConfig.isDestroyed()) ***REMOVED***
      return callback(new MongoError('topology was destroyed'));
    ***REMOVED***

    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  ***REMOVED***);
***REMOVED***

/**
 * Ensures that an index exists. If it does not, creates it.
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to ensure the index.
 * @param ***REMOVED***string***REMOVED*** name The index name
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.ensureIndex for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function ensureIndex(db, name, fieldOrSpec, options, callback) ***REMOVED***
  // Get the write concern options
  const finalOptions = applyWriteConcern(***REMOVED******REMOVED***, ***REMOVED*** db ***REMOVED***, options);
  // Create command
  const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);
  const index_name = selector.name;

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));

  // Merge primary readPreference
  finalOptions.readPreference = ReadPreference.PRIMARY;

  // Check if the index already exists
  indexInformation(db, name, finalOptions, (err, indexInformation) => ***REMOVED***
    if (err != null && err.code !== 26) return handleCallback(callback, err, null);
    // If the index does not exist, create it
    if (indexInformation == null || !indexInformation[index_name]) ***REMOVED***
      createIndex(db, name, fieldOrSpec, options, callback);
    ***REMOVED*** else ***REMOVED***
      if (typeof callback === 'function') return handleCallback(callback, null, index_name);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

/**
 * Evaluate JavaScript on the server
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance.
 * @param ***REMOVED***Code***REMOVED*** code JavaScript to execute on server.
 * @param ***REMOVED***(object|array)***REMOVED*** parameters The parameters for the call.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.eval for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The results callback
 * @deprecated Eval is deprecated on MongoDB 3.2 and forward
 */
function evaluate(db, code, parameters, options, callback) ***REMOVED***
  let finalCode = code;
  let finalParameters = [];

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));

  // If not a code object translate to one
  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode);
  // Ensure the parameters are correct
  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') ***REMOVED***
    finalParameters = [parameters];
  ***REMOVED*** else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') ***REMOVED***
    finalParameters = parameters;
  ***REMOVED***

  // Create execution selector
  let cmd = ***REMOVED*** $eval: finalCode, args: finalParameters ***REMOVED***;
  // Check if the nolock parameter is passed in
  if (options['nolock']) ***REMOVED***
    cmd['nolock'] = options['nolock'];
  ***REMOVED***

  // Set primary read preference
  options.readPreference = new ReadPreference(ReadPreference.PRIMARY);

  // Execute the command
  executeCommand(db, cmd, options, (err, result) => ***REMOVED***
    if (err) return handleCallback(callback, err, null);
    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);
    if (result)
      return handleCallback(
        callback,
        MongoError.create(***REMOVED*** message: `eval failed: $***REMOVED***result.errmsg***REMOVED***`, driver: true ***REMOVED***),
        null
      );
    handleCallback(callback, err, result);
  ***REMOVED***);
***REMOVED***

/**
 * Execute a command
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to execute the command.
 * @param ***REMOVED***object***REMOVED*** command The command hash
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.command for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function executeCommand(db, command, options, callback) ***REMOVED***
  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Get the db name we are executing against
  const dbName = options.dbName || options.authdb || db.s.databaseName;

  // Convert the readPreference if its not a write
  options.readPreference = resolveReadPreference(options, ***REMOVED*** db, default: ReadPreference.primary ***REMOVED***);

  // Debug information
  if (db.s.logger.isDebug())
    db.s.logger.debug(
      `executing command $***REMOVED***JSON.stringify(
        command
      )***REMOVED*** against $***REMOVED***dbName***REMOVED***.$cmd with options [$***REMOVED***JSON.stringify(
        debugOptions(debugFields, options)
      )***REMOVED***]`
    );

  // Execute command
  db.s.topology.command(`$***REMOVED***dbName***REMOVED***.$cmd`, command, options, (err, result) => ***REMOVED***
    if (err) return handleCallback(callback, err);
    if (options.full) return handleCallback(callback, null, result);
    handleCallback(callback, null, result.result);
  ***REMOVED***);
***REMOVED***

/**
 * Runs a command on the database as admin.
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to execute the command.
 * @param ***REMOVED***object***REMOVED*** command The command hash
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.executeDbAdminCommand for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function executeDbAdminCommand(db, selector, options, callback) ***REMOVED***
  db.s.topology.command('admin.$cmd', selector, options, (err, result) => ***REMOVED***
    // Did the user destroy the topology
    if (db.serverConfig && db.serverConfig.isDestroyed()) ***REMOVED***
      return callback(new MongoError('topology was destroyed'));
    ***REMOVED***

    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.result);
  ***REMOVED***);
***REMOVED***

/**
 * Retrieves this collections index info.
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to retrieve the index info.
 * @param ***REMOVED***string***REMOVED*** name The name of the collection.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.indexInformation for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function indexInformation(db, name, options, callback) ***REMOVED***
  // If we specified full information
  const full = options['full'] == null ? false : options['full'];

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Process all the results from the index command and collection
  function processResults(indexes) ***REMOVED***
    // Contains all the information
    let info = ***REMOVED******REMOVED***;
    // Process all the indexes
    for (let i = 0; i < indexes.length; i++) ***REMOVED***
      const index = indexes[i];
      // Let's unpack the object
      info[index.name] = [];
      for (let name in index.key) ***REMOVED***
        info[index.name].push([name, index.key[name]]);
      ***REMOVED***
    ***REMOVED***

    return info;
  ***REMOVED***

  // Get the list of indexes of the specified collection
  db
    .collection(name)
    .listIndexes(options)
    .toArray((err, indexes) => ***REMOVED***
      if (err) return callback(toError(err));
      if (!Array.isArray(indexes)) return handleCallback(callback, null, []);
      if (full) return handleCallback(callback, null, indexes);
      handleCallback(callback, null, processResults(indexes));
    ***REMOVED***);
***REMOVED***

// Transformation methods for cursor results
function listCollectionsTransforms(databaseName) ***REMOVED***
  const matching = `$***REMOVED***databaseName***REMOVED***.`;

  return ***REMOVED***
    doc: doc => ***REMOVED***
      const index = doc.name.indexOf(matching);
      // Remove database name if available
      if (doc.name && index === 0) ***REMOVED***
        doc.name = doc.name.substr(index + matching.length);
      ***REMOVED***

      return doc;
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

/**
 * Retrive the current profiling information for MongoDB
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to retrieve the profiling info.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Db.protoype.profilingInfo for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback.
 * @deprecated Query the system.profile collection directly.
 */
function profilingInfo(db, options, callback) ***REMOVED***
  try ***REMOVED***
    db
      .collection('system.profile')
      .find(***REMOVED******REMOVED***, null, options)
      .toArray(callback);
  ***REMOVED*** catch (err) ***REMOVED***
    return callback(err, null);
  ***REMOVED***
***REMOVED***

/**
 * Retrieve the current profiling level for MongoDB
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to retrieve the profiling level.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Db.prototype.profilingLevel for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function profilingLevel(db, options, callback) ***REMOVED***
  executeCommand(db, ***REMOVED*** profile: -1 ***REMOVED***, options, (err, doc) => ***REMOVED***
    if (err == null && doc.ok === 1) ***REMOVED***
      const was = doc.was;
      if (was === 0) return callback(null, 'off');
      if (was === 1) return callback(null, 'slow_only');
      if (was === 2) return callback(null, 'all');
      return callback(new Error('Error: illegal profiling level value ' + was), null);
    ***REMOVED*** else ***REMOVED***
      err != null ? callback(err, null) : callback(new Error('Error with profile command'), null);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

/**
 * Remove a user from a database
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to remove the user.
 * @param ***REMOVED***string***REMOVED*** username The username.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.removeUser for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function removeUser(db, username, options, callback) ***REMOVED***
  // Attempt to execute command
  executeAuthRemoveUserCommand(db, username, options, (err, result) => ***REMOVED***
    if (err && err.code === -5000) ***REMOVED***
      const finalOptions = applyWriteConcern(Object.assign(***REMOVED******REMOVED***, options), ***REMOVED*** db ***REMOVED***, options);
      // If we have another db set
      const db = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db;

      // Fetch a user collection
      const collection = db.collection(Db.SYSTEM_USER_COLLECTION);

      // Locate the user
      findOne(collection, ***REMOVED*** user: username ***REMOVED***, finalOptions, (err, user) => ***REMOVED***
        if (user == null) return handleCallback(callback, err, false);
        remove(collection, ***REMOVED*** user: username ***REMOVED***, finalOptions, err => ***REMOVED***
          handleCallback(callback, err, true);
        ***REMOVED***);
      ***REMOVED***);

      return;
    ***REMOVED***

    if (err) return handleCallback(callback, err);
    handleCallback(callback, err, result);
  ***REMOVED***);
***REMOVED***

/**
 * Set the current profiling level of MongoDB
 *
 * @method
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to execute the command.
 * @param ***REMOVED***string***REMOVED*** level The new profiling level (off, slow_only, all).
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Db.prototype.setProfilingLevel for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback.
 */
function setProfilingLevel(db, level, options, callback) ***REMOVED***
  const command = ***REMOVED******REMOVED***;
  let profile = 0;

  if (level === 'off') ***REMOVED***
    profile = 0;
  ***REMOVED*** else if (level === 'slow_only') ***REMOVED***
    profile = 1;
  ***REMOVED*** else if (level === 'all') ***REMOVED***
    profile = 2;
  ***REMOVED*** else ***REMOVED***
    return callback(new Error('Error: illegal profiling level value ' + level));
  ***REMOVED***

  // Set up the profile number
  command['profile'] = profile;

  executeCommand(db, command, options, (err, doc) => ***REMOVED***
    if (err == null && doc.ok === 1) return callback(null, level);
    return err != null
      ? callback(err, null)
      : callback(new Error('Error with profile command'), null);
  ***REMOVED***);
***REMOVED***

// Validate the database name
function validateDatabaseName(databaseName) ***REMOVED***
  if (typeof databaseName !== 'string')
    throw MongoError.create(***REMOVED*** message: 'database name must be a string', driver: true ***REMOVED***);
  if (databaseName.length === 0)
    throw MongoError.create(***REMOVED*** message: 'database name cannot be the empty string', driver: true ***REMOVED***);
  if (databaseName === '$external') return;

  const invalidChars = [' ', '.', '$', '/', '\\'];
  for (let i = 0; i < invalidChars.length; i++) ***REMOVED***
    if (databaseName.indexOf(invalidChars[i]) !== -1)
      throw MongoError.create(***REMOVED***
        message: "database names cannot contain the character '" + invalidChars[i] + "'",
        driver: true
      ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Create the command object for Db.prototype.createIndex.
 *
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to create the command.
 * @param ***REMOVED***string***REMOVED*** name Name of the collection to create the index on.
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Db.prototype.createIndex for a list of options.
 * @return ***REMOVED***Object***REMOVED*** The insert command object.
 */
function createCreateIndexCommand(db, name, fieldOrSpec, options) ***REMOVED***
  const indexParameters = parseIndexOptions(fieldOrSpec);
  const fieldHash = indexParameters.fieldHash;

  // Generate the index name
  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;
  const selector = ***REMOVED***
    ns: db.databaseName + '.' + name,
    key: fieldHash,
    name: indexName
  ***REMOVED***;

  // Ensure we have a correct finalUnique
  const finalUnique = options == null || 'object' === typeof options ? false : options;
  // Set up options
  options = options == null || typeof options === 'boolean' ? ***REMOVED******REMOVED*** : options;

  // Add all the options
  const keysToOmit = Object.keys(selector);
  for (let optionName in options) ***REMOVED***
    if (keysToOmit.indexOf(optionName) === -1) ***REMOVED***
      selector[optionName] = options[optionName];
    ***REMOVED***
  ***REMOVED***

  if (selector['unique'] == null) selector['unique'] = finalUnique;

  // Remove any write concern operations
  const removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session'];
  for (let i = 0; i < removeKeys.length; i++) ***REMOVED***
    delete selector[removeKeys[i]];
  ***REMOVED***

  // Return the command creation selector
  return selector;
***REMOVED***

/**
 * Create index using the createIndexes command.
 *
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to execute the command.
 * @param ***REMOVED***string***REMOVED*** name Name of the collection to create the index on.
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Db.prototype.createIndex for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback.
 */
function createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) ***REMOVED***
  // Build the index
  const indexParameters = parseIndexOptions(fieldOrSpec);
  // Generate the index name
  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;
  // Set up the index
  const indexes = [***REMOVED*** name: indexName, key: indexParameters.fieldHash ***REMOVED***];
  // merge all the options
  const keysToOmit = Object.keys(indexes[0]).concat([
    'writeConcern',
    'w',
    'wtimeout',
    'j',
    'fsync',
    'readPreference',
    'session'
  ]);

  for (let optionName in options) ***REMOVED***
    if (keysToOmit.indexOf(optionName) === -1) ***REMOVED***
      indexes[0][optionName] = options[optionName];
    ***REMOVED***
  ***REMOVED***

  // Get capabilities
  const capabilities = db.s.topology.capabilities();

  // Did the user pass in a collation, check if our write server supports it
  if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) ***REMOVED***
    // Create a new error
    const error = new MongoError('server/primary/mongos does not support collation');
    error.code = 67;
    // Return the error
    return callback(error);
  ***REMOVED***

  // Create command, apply write concern to command
  const cmd = applyWriteConcern(***REMOVED*** createIndexes: name, indexes ***REMOVED***, ***REMOVED*** db ***REMOVED***, options);

  // ReadPreference primary
  options.readPreference = ReadPreference.PRIMARY;

  // Build the command
  executeCommand(db, cmd, options, (err, result) => ***REMOVED***
    if (err) return handleCallback(callback, err, null);
    if (result.ok === 0) return handleCallback(callback, toError(result), null);
    // Return the indexName for backward compatibility
    handleCallback(callback, null, indexName);
  ***REMOVED***);
***REMOVED***

/**
 * Run the createUser command.
 *
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to execute the command.
 * @param ***REMOVED***string***REMOVED*** username The username of the user to add.
 * @param ***REMOVED***string***REMOVED*** password The password of the user to add.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.addUser for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function executeAuthCreateUserCommand(db, username, password, options, callback) ***REMOVED***
  // Special case where there is no password ($external users)
  if (typeof username === 'string' && password != null && typeof password === 'object') ***REMOVED***
    options = password;
    password = null;
  ***REMOVED***

  // Unpack all options
  if (typeof options === 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  // Error out if we digestPassword set
  if (options.digestPassword != null) ***REMOVED***
    return callback(
      toError(
        "The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."
      )
    );
  ***REMOVED***

  // Get additional values
  const customData = options.customData != null ? options.customData : ***REMOVED******REMOVED***;
  let roles = Array.isArray(options.roles) ? options.roles : [];
  const maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null;

  // If not roles defined print deprecated message
  if (roles.length === 0) ***REMOVED***
    console.log('Creating a user without roles is deprecated in MongoDB >= 2.6');
  ***REMOVED***

  // Get the error options
  const commandOptions = ***REMOVED*** writeCommand: true ***REMOVED***;
  if (options['dbName']) commandOptions.dbName = options['dbName'];

  // Add maxTimeMS to options if set
  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;

  // Check the db name and add roles if needed
  if (
    (db.databaseName.toLowerCase() === 'admin' || options.dbName === 'admin') &&
    !Array.isArray(options.roles)
  ) ***REMOVED***
    roles = ['root'];
  ***REMOVED*** else if (!Array.isArray(options.roles)) ***REMOVED***
    roles = ['dbOwner'];
  ***REMOVED***

  const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;

  // Build the command to execute
  let command = ***REMOVED***
    createUser: username,
    customData: customData,
    roles: roles,
    digestPassword
  ***REMOVED***;

  // Apply write concern to command
  command = applyWriteConcern(command, ***REMOVED*** db ***REMOVED***, options);

  let userPassword = password;

  if (!digestPassword) ***REMOVED***
    // Use node md5 generator
    const md5 = crypto.createHash('md5');
    // Generate keys used for authentication
    md5.update(username + ':mongo:' + password);
    userPassword = md5.digest('hex');
  ***REMOVED***

  // No password
  if (typeof password === 'string') ***REMOVED***
    command.pwd = userPassword;
  ***REMOVED***

  // Force write using primary
  commandOptions.readPreference = ReadPreference.primary;

  // Execute the command
  executeCommand(db, command, commandOptions, (err, result) => ***REMOVED***
    if (err && err.ok === 0 && err.code === undefined)
      return handleCallback(callback, ***REMOVED*** code: -5000 ***REMOVED***, null);
    if (err) return handleCallback(callback, err, null);
    handleCallback(
      callback,
      !result.ok ? toError(result) : null,
      result.ok ? [***REMOVED*** user: username, pwd: '' ***REMOVED***] : null
    );
  ***REMOVED***);
***REMOVED***

/**
 * Run the dropUser command.
 *
 * @param ***REMOVED***Db***REMOVED*** db The Db instance on which to execute the command.
 * @param ***REMOVED***string***REMOVED*** username The username of the user to remove.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Db.prototype.removeUser for a list of options.
 * @param ***REMOVED***Db~resultCallback***REMOVED*** [callback] The command result callback
 */
function executeAuthRemoveUserCommand(db, username, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Get the error options
  const commandOptions = ***REMOVED*** writeCommand: true ***REMOVED***;
  if (options['dbName']) commandOptions.dbName = options['dbName'];

  // Get additional values
  const maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null;

  // Add maxTimeMS to options if set
  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;

  // Build the command to execute
  let command = ***REMOVED***
    dropUser: username
  ***REMOVED***;

  // Apply write concern to command
  command = applyWriteConcern(command, ***REMOVED*** db ***REMOVED***, options);

  // Force write using primary
  commandOptions.readPreference = ReadPreference.primary;

  // Execute the command
  executeCommand(db, command, commandOptions, (err, result) => ***REMOVED***
    if (err && !err.ok && err.code === undefined) return handleCallback(callback, ***REMOVED*** code: -5000 ***REMOVED***);
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  ***REMOVED***);
***REMOVED***

module.exports = ***REMOVED***
  addUser,
  collections,
  createCollection,
  createListener,
  createIndex,
  dropCollection,
  dropDatabase,
  ensureIndex,
  evaluate,
  executeCommand,
  executeDbAdminCommand,
  listCollectionsTransforms,
  indexInformation,
  profilingInfo,
  profilingLevel,
  removeUser,
  setProfilingLevel,
  validateDatabaseName
***REMOVED***;
