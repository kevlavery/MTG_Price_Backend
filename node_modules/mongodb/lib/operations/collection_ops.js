'use strict';

const applyWriteConcern = require('../utils').applyWriteConcern;
const checkCollectionName = require('../utils').checkCollectionName;
const Code = require('mongodb-core').BSON.Code;
const createIndexDb = require('./db_ops').createIndex;
const decorateCommand = require('../utils').decorateCommand;
const decorateWithCollation = require('../utils').decorateWithCollation;
const decorateWithReadConcern = require('../utils').decorateWithReadConcern;
const ensureIndexDb = require('./db_ops').ensureIndex;
const evaluate = require('./db_ops').evaluate;
const executeCommand = require('./db_ops').executeCommand;
const executeDbAdminCommand = require('./db_ops').executeDbAdminCommand;
const formattedOrderClause = require('../utils').formattedOrderClause;
const resolveReadPreference = require('../utils').resolveReadPreference;
const handleCallback = require('../utils').handleCallback;
const indexInformationDb = require('./db_ops').indexInformation;
const isObject = require('../utils').isObject;
const Long = require('mongodb-core').BSON.Long;
const MongoError = require('mongodb-core').MongoError;
const ReadPreference = require('mongodb-core').ReadPreference;
const toError = require('../utils').toError;

/**
 * Group function helper
 * @ignore
 */
// var groupFunction = function () ***REMOVED***
//   var c = db[ns].find(condition);
//   var map = new Map();
//   var reduce_function = reduce;
//
//   while (c.hasNext()) ***REMOVED***
//     var obj = c.next();
//     var key = ***REMOVED******REMOVED***;
//
//     for (var i = 0, len = keys.length; i < len; ++i) ***REMOVED***
//       var k = keys[i];
//       key[k] = obj[k];
//     ***REMOVED***
//
//     var aggObj = map.get(key);
//
//     if (aggObj == null) ***REMOVED***
//       var newObj = Object.extend(***REMOVED******REMOVED***, key);
//       aggObj = Object.extend(newObj, initial);
//       map.put(key, aggObj);
//     ***REMOVED***
//
//     reduce_function(obj, aggObj);
//   ***REMOVED***
//
//   return ***REMOVED*** "result": map.values() ***REMOVED***;
// ***REMOVED***.toString();
const groupFunction =
  'function () ***REMOVED***\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) ***REMOVED***\nvar obj = c.next();\nvar key = ***REMOVED******REMOVED***;\n\nfor (var i = 0, len = keys.length; i < len; ++i) ***REMOVED***\nvar k = keys[i];\nkey[k] = obj[k];\n***REMOVED***\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) ***REMOVED***\nvar newObj = Object.extend(***REMOVED******REMOVED***, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n***REMOVED***\n\nreduce_function(obj, aggObj);\n***REMOVED***\n\nreturn ***REMOVED*** "result": map.values() ***REMOVED***;\n***REMOVED***';

/**
 * Perform a bulkWrite operation. See Collection.prototype.bulkWrite for more information.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object[]***REMOVED*** operations Bulk operations to perform.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.bulkWrite for a list of options.
 * @param ***REMOVED***Collection~bulkWriteOpCallback***REMOVED*** [callback] The command result callback
 */
function bulkWrite(coll, operations, options, callback) ***REMOVED***
  // Add ignoreUndfined
  if (coll.s.options.ignoreUndefined) ***REMOVED***
    options = Object.assign(***REMOVED******REMOVED***, options);
    options.ignoreUndefined = coll.s.options.ignoreUndefined;
  ***REMOVED***

  // Create the bulk operation
  const bulk =
    options.ordered === true || options.ordered == null
      ? coll.initializeOrderedBulkOp(options)
      : coll.initializeUnorderedBulkOp(options);

  // Do we have a collation
  let collation = false;

  // for each op go through and add to the bulk
  try ***REMOVED***
    for (let i = 0; i < operations.length; i++) ***REMOVED***
      // Get the operation type
      const key = Object.keys(operations[i])[0];
      // Check if we have a collation
      if (operations[i][key].collation) ***REMOVED***
        collation = true;
      ***REMOVED***

      // Pass to the raw bulk
      bulk.raw(operations[i]);
    ***REMOVED***
  ***REMOVED*** catch (err) ***REMOVED***
    return callback(err, null);
  ***REMOVED***

  // Final options for write concern
  const finalOptions = applyWriteConcern(
    Object.assign(***REMOVED******REMOVED***, options),
    ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***,
    options
  );

  const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : ***REMOVED******REMOVED***;
  const capabilities = coll.s.topology.capabilities();

  // Did the user pass in a collation, check if our write server supports it
  if (collation && capabilities && !capabilities.commandsTakeCollation) ***REMOVED***
    return callback(new MongoError('server/primary/mongos does not support collation'));
  ***REMOVED***

  // Execute the bulk
  bulk.execute(writeCon, finalOptions, (err, r) => ***REMOVED***
    // We have connection level error
    if (!r && err) ***REMOVED***
      return callback(err, null);
    ***REMOVED***

    r.insertedCount = r.nInserted;
    r.matchedCount = r.nMatched;
    r.modifiedCount = r.nModified || 0;
    r.deletedCount = r.nRemoved;
    r.upsertedCount = r.getUpsertedIds().length;
    r.upsertedIds = ***REMOVED******REMOVED***;
    r.insertedIds = ***REMOVED******REMOVED***;

    // Update the n
    r.n = r.insertedCount;

    // Inserted documents
    const inserted = r.getInsertedIds();
    // Map inserted ids
    for (let i = 0; i < inserted.length; i++) ***REMOVED***
      r.insertedIds[inserted[i].index] = inserted[i]._id;
    ***REMOVED***

    // Upserted documents
    const upserted = r.getUpsertedIds();
    // Map upserted ids
    for (let i = 0; i < upserted.length; i++) ***REMOVED***
      r.upsertedIds[upserted[i].index] = upserted[i]._id;
    ***REMOVED***

    // Return the results
    callback(null, r);
  ***REMOVED***);
***REMOVED***

// Check the update operation to ensure it has atomic operators.
function checkForAtomicOperators(update) ***REMOVED***
  const keys = Object.keys(update);

  // same errors as the server would give for update doc lacking atomic operators
  if (keys.length === 0) ***REMOVED***
    return toError('The update operation document must contain at least one atomic operator.');
  ***REMOVED***

  if (keys[0][0] !== '$') ***REMOVED***
    return toError('the update operation document must contain atomic operators.');
  ***REMOVED***
***REMOVED***

/**
 * Count the number of documents in the collection that match the query.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** query The query for the count.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.count for a list of options.
 * @param ***REMOVED***Collection~countCallback***REMOVED*** [callback] The command result callback
 */
function count(coll, query, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = Object.assign(***REMOVED******REMOVED***, options);

  const skip = options.skip;
  const limit = options.limit;
  const hint = options.hint;
  const maxTimeMS = options.maxTimeMS;
  query = query || ***REMOVED******REMOVED***;

  // Final query
  const cmd = ***REMOVED***
    count: coll.s.name,
    query: query
  ***REMOVED***;

  // Add limit, skip and maxTimeMS if defined
  if (typeof skip === 'number') cmd.skip = skip;
  if (typeof limit === 'number') cmd.limit = limit;
  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;
  if (hint) cmd.hint = hint;

  // Ensure we have the right read preference inheritance
  options.readPreference = resolveReadPreference(options, ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***);

  // Do we have a readConcern specified
  decorateWithReadConcern(cmd, coll, options);

  // Have we specified collation
  decorateWithCollation(cmd, coll, options);

  executeCommand(coll.s.db, cmd, options, (err, result) => ***REMOVED***
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.n);
  ***REMOVED***);
***REMOVED***

function countDocuments(coll, query, options, callback) ***REMOVED***
  const skip = options.skip;
  const limit = options.limit;
  options = Object.assign(***REMOVED******REMOVED***, options);

  const pipeline = [***REMOVED*** $match: query ***REMOVED***];

  // Add skip and limit if defined
  if (typeof skip === 'number') ***REMOVED***
    pipeline.push(***REMOVED*** $skip: skip ***REMOVED***);
  ***REMOVED***

  if (typeof limit === 'number') ***REMOVED***
    pipeline.push(***REMOVED*** $limit: limit ***REMOVED***);
  ***REMOVED***

  pipeline.push(***REMOVED*** $group: ***REMOVED*** _id: null, n: ***REMOVED*** $sum: 1 ***REMOVED*** ***REMOVED*** ***REMOVED***);

  delete options.limit;
  delete options.skip;

  coll.aggregate(pipeline, options, (err, result) => ***REMOVED***
    if (err) return handleCallback(callback, err);
    result.toArray((err, docs) => ***REMOVED***
      if (err) handleCallback(err);
      handleCallback(callback, null, docs.length ? docs[0].n : 0);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * Create an index on the db and collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.createIndex for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function createIndex(coll, fieldOrSpec, options, callback) ***REMOVED***
  createIndexDb(coll.s.db, coll.s.name, fieldOrSpec, options, callback);
***REMOVED***

/**
 * Create multiple indexes in the collection. This method is only supported for
 * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
 * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***array***REMOVED*** indexSpecs An array of index specifications to be created
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Collection.prototype.createIndexes for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function createIndexes(coll, indexSpecs, options, callback) ***REMOVED***
  const capabilities = coll.s.topology.capabilities();

  // Ensure we generate the correct name if the parameter is not set
  for (let i = 0; i < indexSpecs.length; i++) ***REMOVED***
    if (indexSpecs[i].name == null) ***REMOVED***
      const keys = [];

      // Did the user pass in a collation, check if our write server supports it
      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) ***REMOVED***
        return callback(new MongoError('server/primary/mongos does not support collation'));
      ***REMOVED***

      for (let name in indexSpecs[i].key) ***REMOVED***
        keys.push(`$***REMOVED***name***REMOVED***_$***REMOVED***indexSpecs[i].key[name]***REMOVED***`);
      ***REMOVED***

      // Set the name
      indexSpecs[i].name = keys.join('_');
    ***REMOVED***
  ***REMOVED***

  options = Object.assign(***REMOVED******REMOVED***, options, ***REMOVED*** readPreference: ReadPreference.PRIMARY ***REMOVED***);

  // Execute the index
  executeCommand(
    coll.s.db,
    ***REMOVED***
      createIndexes: coll.s.name,
      indexes: indexSpecs
    ***REMOVED***,
    options,
    callback
  );
***REMOVED***

function deleteCallback(err, r, callback) ***REMOVED***
  if (callback == null) return;
  if (err && callback) return callback(err);
  if (r == null) return callback(null, ***REMOVED*** result: ***REMOVED*** ok: 1 ***REMOVED*** ***REMOVED***);
  r.deletedCount = r.result.n;
  if (callback) callback(null, r);
***REMOVED***

/**
 * Delete multiple documents from the collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the documents to remove
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.deleteMany for a list of options.
 * @param ***REMOVED***Collection~deleteWriteOpCallback***REMOVED*** [callback] The command result callback
 */
function deleteMany(coll, filter, options, callback) ***REMOVED***
  options.single = false;

  removeDocuments(coll, filter, options, (err, r) => deleteCallback(err, r, callback));
***REMOVED***

/**
 * Delete a single document from the collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the document to remove
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.deleteOne for a list of options.
 * @param ***REMOVED***Collection~deleteWriteOpCallback***REMOVED*** [callback] The command result callback
 */
function deleteOne(coll, filter, options, callback) ***REMOVED***
  options.single = true;
  removeDocuments(coll, filter, options, (err, r) => deleteCallback(err, r, callback));
***REMOVED***

/**
 * Return a list of distinct values for the given key across a collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***string***REMOVED*** key Field of the document to find distinct values for.
 * @param ***REMOVED***object***REMOVED*** query The query for filtering the set of documents to which we apply the distinct filter.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.distinct for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function distinct(coll, key, query, options, callback) ***REMOVED***
  // maxTimeMS option
  const maxTimeMS = options.maxTimeMS;

  // Distinct command
  const cmd = ***REMOVED***
    distinct: coll.s.name,
    key: key,
    query: query
  ***REMOVED***;

  options = Object.assign(***REMOVED******REMOVED***, options);
  // Ensure we have the right read preference inheritance
  options.readPreference = resolveReadPreference(options, ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***);

  // Add maxTimeMS if defined
  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;

  // Do we have a readConcern specified
  decorateWithReadConcern(cmd, coll, options);

  // Have we specified collation
  decorateWithCollation(cmd, coll, options);

  // Execute the command
  executeCommand(coll.s.db, cmd, options, (err, result) => ***REMOVED***
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.values);
  ***REMOVED***);
***REMOVED***

/**
 * Drop an index from this collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***string***REMOVED*** indexName Name of the index to drop.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.dropIndex for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function dropIndex(coll, indexName, options, callback) ***REMOVED***
  // Delete index command
  const cmd = ***REMOVED*** dropIndexes: coll.s.name, index: indexName ***REMOVED***;

  // Decorate command with writeConcern if supported
  applyWriteConcern(cmd, ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***, options);

  // Execute command
  executeCommand(coll.s.db, cmd, options, (err, result) => ***REMOVED***
    if (typeof callback !== 'function') return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

/**
 * Drop all indexes from this collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Collection.prototype.dropIndexes for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function dropIndexes(coll, options, callback) ***REMOVED***
  dropIndex(coll, '*', options, err => ***REMOVED***
    if (err) return handleCallback(callback, err, false);
    handleCallback(callback, null, true);
  ***REMOVED***);
***REMOVED***

/**
 * Ensure that an index exists. If the index does not exist, this function creates it.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.ensureIndex for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function ensureIndex(coll, fieldOrSpec, options, callback) ***REMOVED***
  ensureIndexDb(coll.s.db, coll.s.name, fieldOrSpec, options, callback);
***REMOVED***

/**
 * Find and update a document.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** query Query object to locate the object to modify.
 * @param ***REMOVED***array***REMOVED*** sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param ***REMOVED***object***REMOVED*** doc The fields/vals to be updated.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.findAndModify for a list of options.
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The command result callback
 * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead
 */
function findAndModify(coll, query, sort, doc, options, callback) ***REMOVED***
  // Create findAndModify command object
  const queryObject = ***REMOVED***
    findAndModify: coll.s.name,
    query: query
  ***REMOVED***;

  sort = formattedOrderClause(sort);
  if (sort) ***REMOVED***
    queryObject.sort = sort;
  ***REMOVED***

  queryObject.new = options.new ? true : false;
  queryObject.remove = options.remove ? true : false;
  queryObject.upsert = options.upsert ? true : false;

  const projection = options.projection || options.fields;

  if (projection) ***REMOVED***
    queryObject.fields = projection;
  ***REMOVED***

  if (options.arrayFilters) ***REMOVED***
    queryObject.arrayFilters = options.arrayFilters;
    delete options.arrayFilters;
  ***REMOVED***

  if (doc && !options.remove) ***REMOVED***
    queryObject.update = doc;
  ***REMOVED***

  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS;

  // Either use override on the function, or go back to default on either the collection
  // level or db
  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;

  // No check on the documents
  options.checkKeys = false;

  // Get the write concern settings
  const finalOptions = applyWriteConcern(options, ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***, options);

  // Decorate the findAndModify command with the write Concern
  if (finalOptions.writeConcern) ***REMOVED***
    queryObject.writeConcern = finalOptions.writeConcern;
  ***REMOVED***

  // Have we specified bypassDocumentValidation
  if (finalOptions.bypassDocumentValidation === true) ***REMOVED***
    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(queryObject, coll, finalOptions);

  // Execute the command
  executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => ***REMOVED***
    if (err) return handleCallback(callback, err, null);

    return handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

/**
 * Find and remove a document.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** query Query object to locate the object to modify.
 * @param ***REMOVED***array***REMOVED*** sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.findAndRemove for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @deprecated use findOneAndDelete instead
 */
function findAndRemove(coll, query, sort, options, callback) ***REMOVED***
  // Add the remove option
  options.remove = true;
  // Execute the callback
  findAndModify(coll, query, sort, null, options, callback);
***REMOVED***

/**
 * Fetch the first document that matches the query.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** query Query for find Operation
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.findOne for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function findOne(coll, query, options, callback) ***REMOVED***
  const cursor = coll
    .find(query, options)
    .limit(-1)
    .batchSize(1);

  // Return the item
  cursor.next((err, item) => ***REMOVED***
    if (err != null) return handleCallback(callback, toError(err), null);
    handleCallback(callback, null, item);
  ***REMOVED***);
***REMOVED***

/**
 * Find a document and delete it in one atomic operation. This requires a write lock for the duration of the operation.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** filter Document selection filter.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.findOneAndDelete for a list of options.
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 */
function findOneAndDelete(coll, filter, options, callback) ***REMOVED***
  // Final options
  const finalOptions = Object.assign(***REMOVED******REMOVED***, options);
  finalOptions.fields = options.projection;
  finalOptions.remove = true;
  // Execute find and Modify
  findAndModify(coll, filter, options.sort, null, finalOptions, callback);
***REMOVED***

/**
 * Find a document and replace it in one atomic operation. This requires a write lock for the duration of the operation.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** filter Document selection filter.
 * @param ***REMOVED***object***REMOVED*** replacement Document replacing the matching document.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.findOneAndReplace for a list of options.
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 */
function findOneAndReplace(coll, filter, replacement, options, callback) ***REMOVED***
  // Final options
  const finalOptions = Object.assign(***REMOVED******REMOVED***, options);
  finalOptions.fields = options.projection;
  finalOptions.update = true;
  finalOptions.new = options.returnOriginal !== void 0 ? !options.returnOriginal : false;
  finalOptions.upsert = options.upsert !== void 0 ? !!options.upsert : false;

  // Execute findAndModify
  findAndModify(coll, filter, options.sort, replacement, finalOptions, callback);
***REMOVED***

/**
 * Find a document and update it in one atomic operation. This requires a write lock for the duration of the operation.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** filter Document selection filter.
 * @param ***REMOVED***object***REMOVED*** update Update operations to be performed on the document
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.findOneAndUpdate for a list of options.
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 */
function findOneAndUpdate(coll, filter, update, options, callback) ***REMOVED***
  // Final options
  const finalOptions = Object.assign(***REMOVED******REMOVED***, options);
  finalOptions.fields = options.projection;
  finalOptions.update = true;
  finalOptions.new = typeof options.returnOriginal === 'boolean' ? !options.returnOriginal : false;
  finalOptions.upsert = typeof options.upsert === 'boolean' ? options.upsert : false;

  // Execute findAndModify
  findAndModify(coll, filter, options.sort, update, finalOptions, callback);
***REMOVED***

/**
 * Execute a geo search using a geo haystack index on a collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***number***REMOVED*** x Point to search on the x axis, ensure the indexes are ordered in the same order.
 * @param ***REMOVED***number***REMOVED*** y Point to search on the y axis, ensure the indexes are ordered in the same order.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.geoHaystackSearch for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function geoHaystackSearch(coll, x, y, options, callback) ***REMOVED***
  // Build command object
  let commandObject = ***REMOVED***
    geoSearch: coll.s.name,
    near: [x, y]
  ***REMOVED***;

  // Remove read preference from hash if it exists
  commandObject = decorateCommand(commandObject, options, ***REMOVED*** readPreference: true, session: true ***REMOVED***);

  options = Object.assign(***REMOVED******REMOVED***, options);
  // Ensure we have the right read preference inheritance
  options.readPreference = resolveReadPreference(options, ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***);

  // Do we have a readConcern specified
  decorateWithReadConcern(commandObject, coll, options);

  // Execute the command
  executeCommand(coll.s.db, commandObject, options, (err, res) => ***REMOVED***
    if (err) return handleCallback(callback, err);
    if (res.err || res.errmsg) handleCallback(callback, toError(res));
    // should we only be returning res.results here? Not sure if the user
    // should see the other return information
    handleCallback(callback, null, res);
  ***REMOVED***);
***REMOVED***

/**
 * Run a group command across a collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***(object|array|function|code)***REMOVED*** keys An object, array or function expressing the keys to group by.
 * @param ***REMOVED***object***REMOVED*** condition An optional condition that must be true for a row to be considered.
 * @param ***REMOVED***object***REMOVED*** initial Initial value of the aggregation counter object.
 * @param ***REMOVED***(function|Code)***REMOVED*** reduce The reduce function aggregates (reduces) the objects iterated
 * @param ***REMOVED***(function|Code)***REMOVED*** finalize An optional function to be run on each item in the result set just before the item is returned.
 * @param ***REMOVED***boolean***REMOVED*** command Specify if you wish to run using the internal group command or using eval, default is true.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.group for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @deprecated MongoDB 3.6 or higher will no longer support the group command. We recommend rewriting using the aggregation framework.
 */
function group(coll, keys, condition, initial, reduce, finalize, command, options, callback) ***REMOVED***
  // Execute using the command
  if (command) ***REMOVED***
    const reduceFunction = reduce && reduce._bsontype === 'Code' ? reduce : new Code(reduce);

    const selector = ***REMOVED***
      group: ***REMOVED***
        ns: coll.s.name,
        $reduce: reduceFunction,
        cond: condition,
        initial: initial,
        out: 'inline'
      ***REMOVED***
    ***REMOVED***;

    // if finalize is defined
    if (finalize != null) selector.group['finalize'] = finalize;
    // Set up group selector
    if ('function' === typeof keys || (keys && keys._bsontype === 'Code')) ***REMOVED***
      selector.group.$keyf = keys && keys._bsontype === 'Code' ? keys : new Code(keys);
    ***REMOVED*** else ***REMOVED***
      const hash = ***REMOVED******REMOVED***;
      keys.forEach(key => ***REMOVED***
        hash[key] = 1;
      ***REMOVED***);
      selector.group.key = hash;
    ***REMOVED***

    options = Object.assign(***REMOVED******REMOVED***, options);
    // Ensure we have the right read preference inheritance
    options.readPreference = resolveReadPreference(options, ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***);

    // Do we have a readConcern specified
    decorateWithReadConcern(selector, coll, options);

    // Have we specified collation
    decorateWithCollation(selector, coll, options);

    // Execute command
    executeCommand(coll.s.db, selector, options, (err, result) => ***REMOVED***
      if (err) return handleCallback(callback, err, null);
      handleCallback(callback, null, result.retval);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    // Create execution scope
    const scope = reduce != null && reduce._bsontype === 'Code' ? reduce.scope : ***REMOVED******REMOVED***;

    scope.ns = coll.s.name;
    scope.keys = keys;
    scope.condition = condition;
    scope.initial = initial;

    // Pass in the function text to execute within mongodb.
    const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');

    evaluate(coll.s.db, new Code(groupfn, scope), null, options, (err, results) => ***REMOVED***
      if (err) return handleCallback(callback, err, null);
      handleCallback(callback, null, results.result || results);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Retrieve all the indexes on the collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Collection.prototype.indexes for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function indexes(coll, options, callback) ***REMOVED***
  options = Object.assign(***REMOVED******REMOVED***, ***REMOVED*** full: true ***REMOVED***, options);
  indexInformationDb(coll.s.db, coll.s.name, options, callback);
***REMOVED***

/**
 * Check if one or more indexes exist on the collection. This fails on the first index that doesn't exist.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***(string|array)***REMOVED*** indexes One or more index names to check.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Collection.prototype.indexExists for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function indexExists(coll, indexes, options, callback) ***REMOVED***
  indexInformation(coll, options, (err, indexInformation) => ***REMOVED***
    // If we have an error return
    if (err != null) return handleCallback(callback, err, null);
    // Let's check for the index names
    if (!Array.isArray(indexes))
      return handleCallback(callback, null, indexInformation[indexes] != null);
    // Check in list of indexes
    for (let i = 0; i < indexes.length; i++) ***REMOVED***
      if (indexInformation[indexes[i]] == null) ***REMOVED***
        return handleCallback(callback, null, false);
      ***REMOVED***
    ***REMOVED***

    // All keys found return true
    return handleCallback(callback, null, true);
  ***REMOVED***);
***REMOVED***

/**
 * Retrieve this collection's index info.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.indexInformation for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function indexInformation(coll, options, callback) ***REMOVED***
  indexInformationDb(coll.s.db, coll.s.name, options, callback);
***REMOVED***

function insertDocuments(coll, docs, options, callback) ***REMOVED***
  if (typeof options === 'function') (callback = options), (options = ***REMOVED******REMOVED***);
  options = options || ***REMOVED******REMOVED***;
  // Ensure we are operating on an array op docs
  docs = Array.isArray(docs) ? docs : [docs];

  // Get the write concern options
  const finalOptions = applyWriteConcern(
    Object.assign(***REMOVED******REMOVED***, options),
    ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***,
    options
  );

  // If keep going set unordered
  if (finalOptions.keepGoing === true) finalOptions.ordered = false;
  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;

  docs = prepareDocs(coll, docs, options);

  // File inserts
  coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => ***REMOVED***
    if (callback == null) return;
    if (err) return handleCallback(callback, err);
    if (result == null) return handleCallback(callback, null, null);
    if (result.result.code) return handleCallback(callback, toError(result.result));
    if (result.result.writeErrors)
      return handleCallback(callback, toError(result.result.writeErrors[0]));
    // Add docs to the list
    result.ops = docs;
    // Return the results
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

/**
 * Insert a single document into the collection. See Collection.prototype.insertOne for more information.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** doc Document to insert.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.insertOne for a list of options.
 * @param ***REMOVED***Collection~insertOneWriteOpCallback***REMOVED*** [callback] The command result callback
 */
function insertOne(coll, doc, options, callback) ***REMOVED***
  if (Array.isArray(doc)) ***REMOVED***
    return callback(
      MongoError.create(***REMOVED*** message: 'doc parameter must be an object', driver: true ***REMOVED***)
    );
  ***REMOVED***

  insertDocuments(coll, [doc], options, (err, r) => ***REMOVED***
    if (callback == null) return;
    if (err && callback) return callback(err);
    // Workaround for pre 2.6 servers
    if (r == null) return callback(null, ***REMOVED*** result: ***REMOVED*** ok: 1 ***REMOVED*** ***REMOVED***);
    // Add values to top level to ensure crud spec compatibility
    r.insertedCount = r.result.n;
    r.insertedId = doc._id;
    if (callback) callback(null, r);
  ***REMOVED***);
***REMOVED***

/**
 * Determine whether the collection is a capped collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Collection.prototype.isCapped for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The results callback
 */
function isCapped(coll, options, callback) ***REMOVED***
  optionsOp(coll, options, (err, document) => ***REMOVED***
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, document && document.capped);
  ***REMOVED***);
***REMOVED***

/**
 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***(function|string)***REMOVED*** map The mapping function.
 * @param ***REMOVED***(function|string)***REMOVED*** reduce The reduce function.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.mapReduce for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function mapReduce(coll, map, reduce, options, callback) ***REMOVED***
  const mapCommandHash = ***REMOVED***
    mapreduce: coll.s.name,
    map: map,
    reduce: reduce
  ***REMOVED***;

  // Exclusion list
  const exclusionList = ['readPreference', 'session', 'bypassDocumentValidation'];

  // Add any other options passed in
  for (let n in options) ***REMOVED***
    if ('scope' === n) ***REMOVED***
      mapCommandHash[n] = processScope(options[n]);
    ***REMOVED*** else ***REMOVED***
      // Only include if not in exclusion list
      if (exclusionList.indexOf(n) === -1) ***REMOVED***
        mapCommandHash[n] = options[n];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  options = Object.assign(***REMOVED******REMOVED***, options);

  // Ensure we have the right read preference inheritance
  options.readPreference = resolveReadPreference(options, ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***);

  // If we have a read preference and inline is not set as output fail hard
  if (
    options.readPreference !== false &&
    options.readPreference !== 'primary' &&
    options['out'] &&
    (options['out'].inline !== 1 && options['out'] !== 'inline')
  ) ***REMOVED***
    // Force readPreference to primary
    options.readPreference = 'primary';
    // Decorate command with writeConcern if supported
    applyWriteConcern(mapCommandHash, ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***, options);
  ***REMOVED*** else ***REMOVED***
    decorateWithReadConcern(mapCommandHash, coll, options);
  ***REMOVED***

  // Is bypassDocumentValidation specified
  if (options.bypassDocumentValidation === true) ***REMOVED***
    mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(mapCommandHash, coll, options);

  // Execute command
  executeCommand(coll.s.db, mapCommandHash, options, (err, result) => ***REMOVED***
    if (err) return handleCallback(callback, err);
    // Check if we have an error
    if (1 !== result.ok || result.err || result.errmsg) ***REMOVED***
      return handleCallback(callback, toError(result));
    ***REMOVED***

    // Create statistics value
    const stats = ***REMOVED******REMOVED***;
    if (result.timeMillis) stats['processtime'] = result.timeMillis;
    if (result.counts) stats['counts'] = result.counts;
    if (result.timing) stats['timing'] = result.timing;

    // invoked with inline?
    if (result.results) ***REMOVED***
      // If we wish for no verbosity
      if (options['verbose'] == null || !options['verbose']) ***REMOVED***
        return handleCallback(callback, null, result.results);
      ***REMOVED***

      return handleCallback(callback, null, ***REMOVED*** results: result.results, stats: stats ***REMOVED***);
    ***REMOVED***

    // The returned collection
    let collection = null;

    // If we have an object it's a different db
    if (result.result != null && typeof result.result === 'object') ***REMOVED***
      const doc = result.result;
      // Return a collection from another db
      const Db = require('../db');
      collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(
        doc.collection
      );
    ***REMOVED*** else ***REMOVED***
      // Create a collection object that wraps the result collection
      collection = coll.s.db.collection(result.result);
    ***REMOVED***

    // If we wish for no verbosity
    if (options['verbose'] == null || !options['verbose']) ***REMOVED***
      return handleCallback(callback, err, collection);
    ***REMOVED***

    // Return stats as third set of values
    handleCallback(callback, err, ***REMOVED*** collection: collection, stats: stats ***REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * Return the options of the collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Collection.prototype.options for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The results callback
 */
function optionsOp(coll, opts, callback) ***REMOVED***
  coll.s.db.listCollections(***REMOVED*** name: coll.s.name ***REMOVED***, opts).toArray((err, collections) => ***REMOVED***
    if (err) return handleCallback(callback, err);
    if (collections.length === 0) ***REMOVED***
      return handleCallback(
        callback,
        MongoError.create(***REMOVED*** message: `collection $***REMOVED***coll.s.namespace***REMOVED*** not found`, driver: true ***REMOVED***)
      );
    ***REMOVED***

    handleCallback(callback, err, collections[0].options || null);
  ***REMOVED***);
***REMOVED***

/**
 * Return N parallel cursors for a collection to allow parallel reading of the entire collection. There are
 * no ordering guarantees for returned results.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.parallelCollectionScan for a list of options.
 * @param ***REMOVED***Collection~parallelCollectionScanCallback***REMOVED*** [callback] The command result callback
 */
function parallelCollectionScan(coll, options, callback) ***REMOVED***
  // Create command object
  const commandObject = ***REMOVED***
    parallelCollectionScan: coll.s.name,
    numCursors: options.numCursors
  ***REMOVED***;

  // Do we have a readConcern specified
  decorateWithReadConcern(commandObject, coll, options);

  // Store the raw value
  const raw = options.raw;
  delete options['raw'];

  // Execute the command
  executeCommand(coll.s.db, commandObject, options, (err, result) => ***REMOVED***
    if (err) return handleCallback(callback, err, null);
    if (result == null)
      return handleCallback(
        callback,
        new Error('no result returned for parallelCollectionScan'),
        null
      );

    options = Object.assign(***REMOVED*** explicitlyIgnoreSession: true ***REMOVED***, options);

    const cursors = [];
    // Add the raw back to the option
    if (raw) options.raw = raw;
    // Create command cursors for each item
    for (let i = 0; i < result.cursors.length; i++) ***REMOVED***
      const rawId = result.cursors[i].cursor.id;
      // Convert cursorId to Long if needed
      const cursorId = typeof rawId === 'number' ? Long.fromNumber(rawId) : rawId;
      // Add a command cursor
      cursors.push(coll.s.topology.cursor(coll.s.namespace, cursorId, options));
    ***REMOVED***

    handleCallback(callback, null, cursors);
  ***REMOVED***);
***REMOVED***

// modifies documents before being inserted or updated
function prepareDocs(coll, docs, options) ***REMOVED***
  const forceServerObjectId =
    typeof options.forceServerObjectId === 'boolean'
      ? options.forceServerObjectId
      : coll.s.db.options.forceServerObjectId;

  // no need to modify the docs if server sets the ObjectId
  if (forceServerObjectId === true) ***REMOVED***
    return docs;
  ***REMOVED***

  return docs.map(doc => ***REMOVED***
    if (forceServerObjectId !== true && doc._id == null) ***REMOVED***
      doc._id = coll.s.pkFactory.createPk();
    ***REMOVED***

    return doc;
  ***REMOVED***);
***REMOVED***

/**
 * Functions that are passed as scope args must
 * be converted to Code instances.
 * @ignore
 */
function processScope(scope) ***REMOVED***
  if (!isObject(scope) || scope._bsontype === 'ObjectID') ***REMOVED***
    return scope;
  ***REMOVED***

  const keys = Object.keys(scope);
  let key;
  const new_scope = ***REMOVED******REMOVED***;

  for (let i = keys.length - 1; i >= 0; i--) ***REMOVED***
    key = keys[i];
    if ('function' === typeof scope[key]) ***REMOVED***
      new_scope[key] = new Code(String(scope[key]));
    ***REMOVED*** else ***REMOVED***
      new_scope[key] = processScope(scope[key]);
    ***REMOVED***
  ***REMOVED***

  return new_scope;
***REMOVED***

/**
 * Reindex all indexes on the collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***Object***REMOVED*** [options] Optional settings. See Collection.prototype.reIndex for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 */
function reIndex(coll, options, callback) ***REMOVED***
  // Reindex
  const cmd = ***REMOVED*** reIndex: coll.s.name ***REMOVED***;

  // Execute the command
  executeCommand(coll.s.db, cmd, options, (err, result) => ***REMOVED***
    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  ***REMOVED***);
***REMOVED***

function removeDocuments(coll, selector, options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    (callback = options), (options = ***REMOVED******REMOVED***);
  ***REMOVED*** else if (typeof selector === 'function') ***REMOVED***
    callback = selector;
    options = ***REMOVED******REMOVED***;
    selector = ***REMOVED******REMOVED***;
  ***REMOVED***

  // Create an empty options object if the provided one is null
  options = options || ***REMOVED******REMOVED***;

  // Get the write concern options
  const finalOptions = applyWriteConcern(
    Object.assign(***REMOVED******REMOVED***, options),
    ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***,
    options
  );

  // If selector is null set empty
  if (selector == null) selector = ***REMOVED******REMOVED***;

  // Build the op
  const op = ***REMOVED*** q: selector, limit: 0 ***REMOVED***;
  if (options.single) ***REMOVED***
    op.limit = 1;
  ***REMOVED*** else if (finalOptions.retryWrites) ***REMOVED***
    finalOptions.retryWrites = false;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(finalOptions, coll, options);

  // Execute the remove
  coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => ***REMOVED***
    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    if (result == null) return handleCallback(callback, null, null);
    if (result.result.code) return handleCallback(callback, toError(result.result));
    if (result.result.writeErrors)
      return handleCallback(callback, toError(result.result.writeErrors[0]));
    // Return the results
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

/**
 * Rename the collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***string***REMOVED*** newName New name of of the collection.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.rename for a list of options.
 * @param ***REMOVED***Collection~collectionResultCallback***REMOVED*** [callback] The results callback
 */
function rename(coll, newName, options, callback) ***REMOVED***
  const Collection = require('../collection');
  // Check the collection name
  checkCollectionName(newName);
  // Build the command
  const renameCollection = `$***REMOVED***coll.s.dbName***REMOVED***.$***REMOVED***coll.s.name***REMOVED***`;
  const toCollection = `$***REMOVED***coll.s.dbName***REMOVED***.$***REMOVED***newName***REMOVED***`;
  const dropTarget = typeof options.dropTarget === 'boolean' ? options.dropTarget : false;
  const cmd = ***REMOVED*** renameCollection: renameCollection, to: toCollection, dropTarget: dropTarget ***REMOVED***;

  // Decorate command with writeConcern if supported
  applyWriteConcern(cmd, ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***, options);

  // Execute against admin
  executeDbAdminCommand(coll.s.db.admin().s.db, cmd, options, (err, doc) => ***REMOVED***
    if (err) return handleCallback(callback, err, null);
    // We have an error
    if (doc.errmsg) return handleCallback(callback, toError(doc), null);
    try ***REMOVED***
      return handleCallback(
        callback,
        null,
        new Collection(
          coll.s.db,
          coll.s.topology,
          coll.s.dbName,
          newName,
          coll.s.pkFactory,
          coll.s.options
        )
      );
    ***REMOVED*** catch (err) ***REMOVED***
      return handleCallback(callback, toError(err), null);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

/**
 * Replace a document in the collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the document to update
 * @param ***REMOVED***object***REMOVED*** doc The Document that replaces the matching document
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.replaceOne for a list of options.
 * @param ***REMOVED***Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 */
function replaceOne(coll, filter, doc, options, callback) ***REMOVED***
  // Set single document update
  options.multi = false;

  // Execute update
  updateDocuments(coll, filter, doc, options, (err, r) => ***REMOVED***
    if (callback == null) return;
    if (err && callback) return callback(err);
    if (r == null) return callback(null, ***REMOVED*** result: ***REMOVED*** ok: 1 ***REMOVED*** ***REMOVED***);

    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId =
      Array.isArray(r.result.upserted) && r.result.upserted.length > 0
        ? r.result.upserted[0] // FIXME(major): should be `r.result.upserted[0]._id`
        : null;
    r.upsertedCount =
      Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount =
      Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    r.ops = [doc];
    if (callback) callback(null, r);
  ***REMOVED***);
***REMOVED***

/**
 * Save a document.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** doc Document to save
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.save for a list of options.
 * @param ***REMOVED***Collection~writeOpCallback***REMOVED*** [callback] The command result callback
 * @deprecated use insertOne, insertMany, updateOne or updateMany
 */
function save(coll, doc, options, callback) ***REMOVED***
  // Get the write concern options
  const finalOptions = applyWriteConcern(
    Object.assign(***REMOVED******REMOVED***, options),
    ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***,
    options
  );
  // Establish if we need to perform an insert or update
  if (doc._id != null) ***REMOVED***
    finalOptions.upsert = true;
    return updateDocuments(coll, ***REMOVED*** _id: doc._id ***REMOVED***, doc, finalOptions, callback);
  ***REMOVED***

  // Insert the document
  insertDocuments(coll, [doc], finalOptions, (err, result) => ***REMOVED***
    if (callback == null) return;
    if (doc == null) return handleCallback(callback, null, null);
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

/**
 * Get all the collection statistics.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.stats for a list of options.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The collection result callback
 */
function stats(coll, options, callback) ***REMOVED***
  // Build command object
  const commandObject = ***REMOVED***
    collStats: coll.s.name
  ***REMOVED***;

  // Check if we have the scale value
  if (options['scale'] != null) commandObject['scale'] = options['scale'];

  options = Object.assign(***REMOVED******REMOVED***, options);
  // Ensure we have the right read preference inheritance
  options.readPreference = resolveReadPreference(options, ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***);

  // Execute the command
  executeCommand(coll.s.db, commandObject, options, callback);
***REMOVED***

function updateCallback(err, r, callback) ***REMOVED***
  if (callback == null) return;
  if (err) return callback(err);
  if (r == null) return callback(null, ***REMOVED*** result: ***REMOVED*** ok: 1 ***REMOVED*** ***REMOVED***);
  r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
  r.upsertedId =
    Array.isArray(r.result.upserted) && r.result.upserted.length > 0
      ? r.result.upserted[0] // FIXME(major): should be `r.result.upserted[0]._id`
      : null;
  r.upsertedCount =
    Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
  r.matchedCount =
    Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
  callback(null, r);
***REMOVED***

function updateDocuments(coll, selector, document, options, callback) ***REMOVED***
  if ('function' === typeof options) (callback = options), (options = null);
  if (options == null) options = ***REMOVED******REMOVED***;
  if (!('function' === typeof callback)) callback = null;

  // If we are not providing a selector or document throw
  if (selector == null || typeof selector !== 'object')
    return callback(toError('selector must be a valid JavaScript object'));
  if (document == null || typeof document !== 'object')
    return callback(toError('document must be a valid JavaScript object'));

  // Get the write concern options
  const finalOptions = applyWriteConcern(
    Object.assign(***REMOVED******REMOVED***, options),
    ***REMOVED*** db: coll.s.db, collection: coll ***REMOVED***,
    options
  );

  // Do we return the actual result document
  // Either use override on the function, or go back to default on either the collection
  // level or db
  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;

  // Execute the operation
  const op = ***REMOVED*** q: selector, u: document ***REMOVED***;
  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;
  op.multi = options.multi !== void 0 ? !!options.multi : false;

  if (finalOptions.arrayFilters) ***REMOVED***
    op.arrayFilters = finalOptions.arrayFilters;
    delete finalOptions.arrayFilters;
  ***REMOVED***

  if (finalOptions.retryWrites && op.multi) ***REMOVED***
    finalOptions.retryWrites = false;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(finalOptions, coll, options);

  // Update options
  coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => ***REMOVED***
    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    if (result == null) return handleCallback(callback, null, null);
    if (result.result.code) return handleCallback(callback, toError(result.result));
    if (result.result.writeErrors)
      return handleCallback(callback, toError(result.result.writeErrors[0]));
    // Return the results
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

/**
 * Update multiple documents in the collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the documents to update
 * @param ***REMOVED***object***REMOVED*** update The update operations to be applied to the document
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.updateMany for a list of options.
 * @param ***REMOVED***Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 */
function updateMany(coll, filter, update, options, callback) ***REMOVED***
  // Set single document update
  options.multi = true;
  // Execute update
  updateDocuments(coll, filter, update, options, (err, r) => updateCallback(err, r, callback));
***REMOVED***

/**
 * Update a single document in the collection.
 *
 * @method
 * @param ***REMOVED***Collection***REMOVED*** a Collection instance.
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the document to update
 * @param ***REMOVED***object***REMOVED*** update The update operations to be applied to the document
 * @param ***REMOVED***object***REMOVED*** [options] Optional settings. See Collection.prototype.updateOne for a list of options.
 * @param ***REMOVED***Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 */
function updateOne(coll, filter, update, options, callback) ***REMOVED***
  // Set single document update
  options.multi = false;
  // Execute update
  updateDocuments(coll, filter, update, options, (err, r) => updateCallback(err, r, callback));
***REMOVED***

module.exports = ***REMOVED***
  bulkWrite,
  checkForAtomicOperators,
  count,
  countDocuments,
  createIndex,
  createIndexes,
  deleteMany,
  deleteOne,
  distinct,
  dropIndex,
  dropIndexes,
  ensureIndex,
  findAndModify,
  findAndRemove,
  findOne,
  findOneAndDelete,
  findOneAndReplace,
  findOneAndUpdate,
  geoHaystackSearch,
  group,
  indexes,
  indexExists,
  indexInformation,
  insertOne,
  isCapped,
  mapReduce,
  optionsOp,
  parallelCollectionScan,
  prepareDocs,
  reIndex,
  removeDocuments,
  rename,
  replaceOne,
  save,
  stats,
  updateDocuments,
  updateMany,
  updateOne
***REMOVED***;
