/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * Module dependencies.
 * @api private
 */

var Buffer = require('safe-buffer').Buffer
var contentDisposition = require('content-disposition');
var contentType = require('content-type');
var deprecate = require('depd')('express');
var flatten = require('array-flatten');
var mime = require('send').mime;
var etag = require('etag');
var proxyaddr = require('proxy-addr');
var qs = require('qs');
var querystring = require('querystring');

/**
 * Return strong ETag for `body`.
 *
 * @param ***REMOVED***String|Buffer***REMOVED*** body
 * @param ***REMOVED***String***REMOVED*** [encoding]
 * @return ***REMOVED***String***REMOVED***
 * @api private
 */

exports.etag = createETagGenerator(***REMOVED*** weak: false ***REMOVED***)

/**
 * Return weak ETag for `body`.
 *
 * @param ***REMOVED***String|Buffer***REMOVED*** body
 * @param ***REMOVED***String***REMOVED*** [encoding]
 * @return ***REMOVED***String***REMOVED***
 * @api private
 */

exports.wetag = createETagGenerator(***REMOVED*** weak: true ***REMOVED***)

/**
 * Check if `path` looks absolute.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 */

exports.isAbsolute = function(path)***REMOVED***
  if ('/' === path[0]) return true;
  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true; // Windows device path
  if ('\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path
***REMOVED***;

/**
 * Flatten the given `arr`.
 *
 * @param ***REMOVED***Array***REMOVED*** arr
 * @return ***REMOVED***Array***REMOVED***
 * @api private
 */

exports.flatten = deprecate.function(flatten,
  'utils.flatten: use array-flatten npm module instead');

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param ***REMOVED***String***REMOVED*** type
 * @return ***REMOVED***Object***REMOVED***
 * @api private
 */

exports.normalizeType = function(type)***REMOVED***
  return ~type.indexOf('/')
    ? acceptParams(type)
    : ***REMOVED*** value: mime.lookup(type), params: ***REMOVED******REMOVED*** ***REMOVED***;
***REMOVED***;

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param ***REMOVED***Array***REMOVED*** types
 * @return ***REMOVED***Array***REMOVED***
 * @api private
 */

exports.normalizeTypes = function(types)***REMOVED***
  var ret = [];

  for (var i = 0; i < types.length; ++i) ***REMOVED***
    ret.push(exports.normalizeType(types[i]));
  ***REMOVED***

  return ret;
***REMOVED***;

/**
 * Generate Content-Disposition header appropriate for the filename.
 * non-ascii filenames are urlencoded and a filename* parameter is added
 *
 * @param ***REMOVED***String***REMOVED*** filename
 * @return ***REMOVED***String***REMOVED***
 * @api private
 */

exports.contentDisposition = deprecate.function(contentDisposition,
  'utils.contentDisposition: use content-disposition npm module instead');

/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 * also includes `.originalIndex` for stable sorting
 *
 * @param ***REMOVED***String***REMOVED*** str
 * @return ***REMOVED***Object***REMOVED***
 * @api private
 */

function acceptParams(str, index) ***REMOVED***
  var parts = str.split(/ *; */);
  var ret = ***REMOVED*** value: parts[0], quality: 1, params: ***REMOVED******REMOVED***, originalIndex: index ***REMOVED***;

  for (var i = 1; i < parts.length; ++i) ***REMOVED***
    var pms = parts[i].split(/ *= */);
    if ('q' === pms[0]) ***REMOVED***
      ret.quality = parseFloat(pms[1]);
    ***REMOVED*** else ***REMOVED***
      ret.params[pms[0]] = pms[1];
    ***REMOVED***
  ***REMOVED***

  return ret;
***REMOVED***

/**
 * Compile "etag" value to function.
 *
 * @param  ***REMOVED***Boolean|String|Function***REMOVED*** val
 * @return ***REMOVED***Function***REMOVED***
 * @api private
 */

exports.compileETag = function(val) ***REMOVED***
  var fn;

  if (typeof val === 'function') ***REMOVED***
    return val;
  ***REMOVED***

  switch (val) ***REMOVED***
    case true:
      fn = exports.wetag;
      break;
    case false:
      break;
    case 'strong':
      fn = exports.etag;
      break;
    case 'weak':
      fn = exports.wetag;
      break;
    default:
      throw new TypeError('unknown value for etag function: ' + val);
  ***REMOVED***

  return fn;
***REMOVED***

/**
 * Compile "query parser" value to function.
 *
 * @param  ***REMOVED***String|Function***REMOVED*** val
 * @return ***REMOVED***Function***REMOVED***
 * @api private
 */

exports.compileQueryParser = function compileQueryParser(val) ***REMOVED***
  var fn;

  if (typeof val === 'function') ***REMOVED***
    return val;
  ***REMOVED***

  switch (val) ***REMOVED***
    case true:
      fn = querystring.parse;
      break;
    case false:
      fn = newObject;
      break;
    case 'extended':
      fn = parseExtendedQueryString;
      break;
    case 'simple':
      fn = querystring.parse;
      break;
    default:
      throw new TypeError('unknown value for query parser function: ' + val);
  ***REMOVED***

  return fn;
***REMOVED***

/**
 * Compile "proxy trust" value to function.
 *
 * @param  ***REMOVED***Boolean|String|Number|Array|Function***REMOVED*** val
 * @return ***REMOVED***Function***REMOVED***
 * @api private
 */

exports.compileTrust = function(val) ***REMOVED***
  if (typeof val === 'function') return val;

  if (val === true) ***REMOVED***
    // Support plain true/false
    return function()***REMOVED*** return true ***REMOVED***;
  ***REMOVED***

  if (typeof val === 'number') ***REMOVED***
    // Support trusting hop count
    return function(a, i)***REMOVED*** return i < val ***REMOVED***;
  ***REMOVED***

  if (typeof val === 'string') ***REMOVED***
    // Support comma-separated values
    val = val.split(/ *, */);
  ***REMOVED***

  return proxyaddr.compile(val || []);
***REMOVED***

/**
 * Set the charset in a given Content-Type string.
 *
 * @param ***REMOVED***String***REMOVED*** type
 * @param ***REMOVED***String***REMOVED*** charset
 * @return ***REMOVED***String***REMOVED***
 * @api private
 */

exports.setCharset = function setCharset(type, charset) ***REMOVED***
  if (!type || !charset) ***REMOVED***
    return type;
  ***REMOVED***

  // parse type
  var parsed = contentType.parse(type);

  // set charset
  parsed.parameters.charset = charset;

  // format type
  return contentType.format(parsed);
***REMOVED***;

/**
 * Create an ETag generator function, generating ETags with
 * the given options.
 *
 * @param ***REMOVED***object***REMOVED*** options
 * @return ***REMOVED***function***REMOVED***
 * @private
 */

function createETagGenerator (options) ***REMOVED***
  return function generateETag (body, encoding) ***REMOVED***
    var buf = !Buffer.isBuffer(body)
      ? Buffer.from(body, encoding)
      : body

    return etag(buf, options)
  ***REMOVED***
***REMOVED***

/**
 * Parse an extended query string with qs.
 *
 * @return ***REMOVED***Object***REMOVED***
 * @private
 */

function parseExtendedQueryString(str) ***REMOVED***
  return qs.parse(str, ***REMOVED***
    allowPrototypes: true
  ***REMOVED***);
***REMOVED***

/**
 * Return new empty object.
 *
 * @return ***REMOVED***Object***REMOVED***
 * @api private
 */

function newObject() ***REMOVED***
  return ***REMOVED******REMOVED***;
***REMOVED***
