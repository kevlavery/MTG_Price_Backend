// Copyright 2017 Joyent, Inc.

module.exports = ***REMOVED***
	read: read,
	write: write
***REMOVED***;

var assert = require('assert-plus');
var Key = require('../key');
var PrivateKey = require('../private-key');
var utils = require('../utils');
var SSHBuffer = require('../ssh-buffer');
var Dhe = require('../dhe');

var supportedAlgos = ***REMOVED***
	'rsa-sha1' : 5,
	'rsa-sha256' : 8,
	'rsa-sha512' : 10,
	'ecdsa-p256-sha256' : 13,
	'ecdsa-p384-sha384' : 14
	/*
	 * ed25519 is hypothetically supported with id 15
	 * but the common tools available don't appear to be
	 * capable of generating/using ed25519 keys
	 */
***REMOVED***;

var supportedAlgosById = ***REMOVED******REMOVED***;
Object.keys(supportedAlgos).forEach(function (k) ***REMOVED***
	supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
***REMOVED***);

function read(buf, options) ***REMOVED***
	if (typeof (buf) !== 'string') ***REMOVED***
		assert.buffer(buf, 'buf');
		buf = buf.toString('ascii');
	***REMOVED***
	var lines = buf.split('\n');
	if (lines[0].match(/^Private-key-format\: v1/)) ***REMOVED***
		var algElems = lines[1].split(' ');
		var algoNum = parseInt(algElems[1], 10);
		var algoName = algElems[2];
		if (!supportedAlgosById[algoNum])
			throw (new Error('Unsupported algorithm: ' + algoName));
		return (readDNSSECPrivateKey(algoNum, lines.slice(2)));
	***REMOVED***

	// skip any comment-lines
	var line = 0;
	/* JSSTYLED */
	while (lines[line].match(/^\;/))
		line++;
	// we should now have *one single* line left with our KEY on it.
	if ((lines[line].match(/\. IN KEY /) ||
	    lines[line].match(/\. IN DNSKEY /)) && lines[line+1].length === 0) ***REMOVED***
		return (readRFC3110(lines[line]));
	***REMOVED***
	throw (new Error('Cannot parse dnssec key'));
***REMOVED***

function readRFC3110(keyString) ***REMOVED***
	var elems = keyString.split(' ');
	//unused var flags = parseInt(elems[3], 10);
	//unused var protocol = parseInt(elems[4], 10);
	var algorithm = parseInt(elems[5], 10);
	if (!supportedAlgosById[algorithm])
		throw (new Error('Unsupported algorithm: ' + algorithm));
	var base64key = elems.slice(6, elems.length).join();
	var keyBuffer = new Buffer(base64key, 'base64');
	if (supportedAlgosById[algorithm].match(/^RSA-/)) ***REMOVED***
		// join the rest of the body into a single base64-blob
		var publicExponentLen = keyBuffer.readUInt8(0);
		if (publicExponentLen != 3 && publicExponentLen != 1)
			throw (new Error('Cannot parse dnssec key: ' +
			    'unsupported exponent length'));

		var publicExponent = keyBuffer.slice(1, publicExponentLen+1);
		publicExponent = utils.mpNormalize(publicExponent);
		var modulus = keyBuffer.slice(1+publicExponentLen);
		modulus = utils.mpNormalize(modulus);
		// now, make the key
		var rsaKey = ***REMOVED***
			type: 'rsa',
			parts: []
		***REMOVED***;
		rsaKey.parts.push(***REMOVED*** name: 'e', data: publicExponent***REMOVED***);
		rsaKey.parts.push(***REMOVED*** name: 'n', data: modulus***REMOVED***);
		return (new Key(rsaKey));
	***REMOVED***
	if (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' ||
	    supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') ***REMOVED***
		var curve = 'nistp384';
		var size = 384;
		if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) ***REMOVED***
			curve = 'nistp256';
			size = 256;
		***REMOVED***

		var ecdsaKey = ***REMOVED***
			type: 'ecdsa',
			curve: curve,
			size: size,
			parts: [
				***REMOVED***name: 'curve', data: new Buffer(curve) ***REMOVED***,
				***REMOVED***name: 'Q', data: utils.ecNormalize(keyBuffer) ***REMOVED***
			]
		***REMOVED***;
		return (new Key(ecdsaKey));
	***REMOVED***
	throw (new Error('Unsupported algorithm: ' +
	    supportedAlgosById[algorithm]));
***REMOVED***

function elementToBuf(e) ***REMOVED***
	return (new Buffer(e.split(' ')[1], 'base64'));
***REMOVED***

function readDNSSECRSAPrivateKey(elements) ***REMOVED***
	var rsaParams = ***REMOVED******REMOVED***;
	elements.forEach(function (element) ***REMOVED***
		if (element.split(' ')[0] === 'Modulus:')
			rsaParams['n'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'PublicExponent:')
			rsaParams['e'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'PrivateExponent:')
			rsaParams['d'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Prime1:')
			rsaParams['p'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Prime2:')
			rsaParams['q'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Exponent1:')
			rsaParams['dmodp'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Exponent2:')
			rsaParams['dmodq'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Coefficient:')
			rsaParams['iqmp'] = elementToBuf(element);
	***REMOVED***);
	// now, make the key
	var key = ***REMOVED***
		type: 'rsa',
		parts: [
			***REMOVED*** name: 'e', data: utils.mpNormalize(rsaParams['e'])***REMOVED***,
			***REMOVED*** name: 'n', data: utils.mpNormalize(rsaParams['n'])***REMOVED***,
			***REMOVED*** name: 'd', data: utils.mpNormalize(rsaParams['d'])***REMOVED***,
			***REMOVED*** name: 'p', data: utils.mpNormalize(rsaParams['p'])***REMOVED***,
			***REMOVED*** name: 'q', data: utils.mpNormalize(rsaParams['q'])***REMOVED***,
			***REMOVED*** name: 'dmodp',
			    data: utils.mpNormalize(rsaParams['dmodp'])***REMOVED***,
			***REMOVED*** name: 'dmodq',
			    data: utils.mpNormalize(rsaParams['dmodq'])***REMOVED***,
			***REMOVED*** name: 'iqmp',
			    data: utils.mpNormalize(rsaParams['iqmp'])***REMOVED***
		]
	***REMOVED***;
	return (new PrivateKey(key));
***REMOVED***

function readDNSSECPrivateKey(alg, elements) ***REMOVED***
	if (supportedAlgosById[alg].match(/^RSA-/)) ***REMOVED***
		return (readDNSSECRSAPrivateKey(elements));
	***REMOVED***
	if (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' ||
	    supportedAlgosById[alg] === 'ECDSA-P256-SHA256') ***REMOVED***
		var d = new Buffer(elements[0].split(' ')[1], 'base64');
		var curve = 'nistp384';
		var size = 384;
		if (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') ***REMOVED***
			curve = 'nistp256';
			size = 256;
		***REMOVED***
		// DNSSEC generates the public-key on the fly (go calculate it)
		var publicKey = utils.publicFromPrivateECDSA(curve, d);
		var Q = publicKey.part['Q'].data;
		var ecdsaKey = ***REMOVED***
			type: 'ecdsa',
			curve: curve,
			size: size,
			parts: [
				***REMOVED***name: 'curve', data: new Buffer(curve) ***REMOVED***,
				***REMOVED***name: 'd', data: d ***REMOVED***,
				***REMOVED***name: 'Q', data: Q ***REMOVED***
			]
		***REMOVED***;
		return (new PrivateKey(ecdsaKey));
	***REMOVED***
	throw (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));
***REMOVED***

function dnssecTimestamp(date) ***REMOVED***
	var year = date.getFullYear() + ''; //stringify
	var month = (date.getMonth() + 1);
	var timestampStr = year + month + date.getUTCDate();
	timestampStr += '' + date.getUTCHours() + date.getUTCMinutes();
	timestampStr += date.getUTCSeconds();
	return (timestampStr);
***REMOVED***

function rsaAlgFromOptions(opts) ***REMOVED***
	if (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1')
		return ('5 (RSASHA1)');
	else if (opts.hashAlgo === 'sha256')
		return ('8 (RSASHA256)');
	else if (opts.hashAlgo === 'sha512')
		return ('10 (RSASHA512)');
	else
		throw (new Error('Unknown or unsupported hash: ' +
		    opts.hashAlgo));
***REMOVED***

function writeRSA(key, options) ***REMOVED***
	// if we're missing parts, add them.
	if (!key.part.dmodp || !key.part.dmodq) ***REMOVED***
		utils.addRSAMissing(key);
	***REMOVED***

	var out = '';
	out += 'Private-key-format: v1.3\n';
	out += 'Algorithm: ' + rsaAlgFromOptions(options) + '\n';
	var n = utils.mpDenormalize(key.part['n'].data);
	out += 'Modulus: ' + n.toString('base64') + '\n';
	var e = utils.mpDenormalize(key.part['e'].data);
	out += 'PublicExponent: ' + e.toString('base64') + '\n';
	var d = utils.mpDenormalize(key.part['d'].data);
	out += 'PrivateExponent: ' + d.toString('base64') + '\n';
	var p = utils.mpDenormalize(key.part['p'].data);
	out += 'Prime1: ' + p.toString('base64') + '\n';
	var q = utils.mpDenormalize(key.part['q'].data);
	out += 'Prime2: ' + q.toString('base64') + '\n';
	var dmodp = utils.mpDenormalize(key.part['dmodp'].data);
	out += 'Exponent1: ' + dmodp.toString('base64') + '\n';
	var dmodq = utils.mpDenormalize(key.part['dmodq'].data);
	out += 'Exponent2: ' + dmodq.toString('base64') + '\n';
	var iqmp = utils.mpDenormalize(key.part['iqmp'].data);
	out += 'Coefficient: ' + iqmp.toString('base64') + '\n';
	// Assume that we're valid as-of now
	var timestamp = new Date();
	out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';
	return (new Buffer(out, 'ascii'));
***REMOVED***

function writeECDSA(key, options) ***REMOVED***
	var out = '';
	out += 'Private-key-format: v1.3\n';

	if (key.curve === 'nistp256') ***REMOVED***
		out += 'Algorithm: 13 (ECDSAP256SHA256)\n';
	***REMOVED*** else if (key.curve === 'nistp384') ***REMOVED***
		out += 'Algorithm: 14 (ECDSAP384SHA384)\n';
	***REMOVED*** else ***REMOVED***
		throw (new Error('Unsupported curve'));
	***REMOVED***
	var base64Key = key.part['d'].data.toString('base64');
	out += 'PrivateKey: ' + base64Key + '\n';

	// Assume that we're valid as-of now
	var timestamp = new Date();
	out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';

	return (new Buffer(out, 'ascii'));
***REMOVED***

function write(key, options) ***REMOVED***
	if (PrivateKey.isPrivateKey(key)) ***REMOVED***
		if (key.type === 'rsa') ***REMOVED***
			return (writeRSA(key, options));
		***REMOVED*** else if (key.type === 'ecdsa') ***REMOVED***
			return (writeECDSA(key, options));
		***REMOVED*** else ***REMOVED***
			throw (new Error('Unsupported algorithm: ' + key.type));
		***REMOVED***
	***REMOVED*** else if (Key.isKey(key)) ***REMOVED***
		/*
		 * RFC3110 requires a keyname, and a keytype, which we
		 * don't really have a mechanism for specifying such
		 * additional metadata.
		 */
		throw (new Error('Format "dnssec" only supports ' +
		    'writing private keys'));
	***REMOVED*** else ***REMOVED***
		throw (new Error('key is not a Key or PrivateKey'));
	***REMOVED***
***REMOVED***
