// Copyright 2017 Joyent, Inc.

module.exports = Key;

var assert = require('assert-plus');
var algs = require('./algs');
var crypto = require('crypto');
var Fingerprint = require('./fingerprint');
var Signature = require('./signature');
var DiffieHellman = require('./dhe').DiffieHellman;
var errs = require('./errors');
var utils = require('./utils');
var PrivateKey = require('./private-key');
var edCompat;

try ***REMOVED***
	edCompat = require('./ed-compat');
***REMOVED*** catch (e) ***REMOVED***
	/* Just continue through, and bail out if we try to use it. */
***REMOVED***

var InvalidAlgorithmError = errs.InvalidAlgorithmError;
var KeyParseError = errs.KeyParseError;

var formats = ***REMOVED******REMOVED***;
formats['auto'] = require('./formats/auto');
formats['pem'] = require('./formats/pem');
formats['pkcs1'] = require('./formats/pkcs1');
formats['pkcs8'] = require('./formats/pkcs8');
formats['rfc4253'] = require('./formats/rfc4253');
formats['ssh'] = require('./formats/ssh');
formats['ssh-private'] = require('./formats/ssh-private');
formats['openssh'] = formats['ssh-private'];
formats['dnssec'] = require('./formats/dnssec');

function Key(opts) ***REMOVED***
	assert.object(opts, 'options');
	assert.arrayOfObject(opts.parts, 'options.parts');
	assert.string(opts.type, 'options.type');
	assert.optionalString(opts.comment, 'options.comment');

	var algInfo = algs.info[opts.type];
	if (typeof (algInfo) !== 'object')
		throw (new InvalidAlgorithmError(opts.type));

	var partLookup = ***REMOVED******REMOVED***;
	for (var i = 0; i < opts.parts.length; ++i) ***REMOVED***
		var part = opts.parts[i];
		partLookup[part.name] = part;
	***REMOVED***

	this.type = opts.type;
	this.parts = opts.parts;
	this.part = partLookup;
	this.comment = undefined;
	this.source = opts.source;

	/* for speeding up hashing/fingerprint operations */
	this._rfc4253Cache = opts._rfc4253Cache;
	this._hashCache = ***REMOVED******REMOVED***;

	var sz;
	this.curve = undefined;
	if (this.type === 'ecdsa') ***REMOVED***
		var curve = this.part.curve.data.toString();
		this.curve = curve;
		sz = algs.curves[curve].size;
	***REMOVED*** else if (this.type === 'ed25519' || this.type === 'curve25519') ***REMOVED***
		sz = 256;
		this.curve = 'curve25519';
	***REMOVED*** else ***REMOVED***
		var szPart = this.part[algInfo.sizePart];
		sz = szPart.data.length;
		sz = sz * 8 - utils.countZeros(szPart.data);
	***REMOVED***
	this.size = sz;
***REMOVED***

Key.formats = formats;

Key.prototype.toBuffer = function (format, options) ***REMOVED***
	if (format === undefined)
		format = 'ssh';
	assert.string(format, 'format');
	assert.object(formats[format], 'formats[format]');
	assert.optionalObject(options, 'options');

	if (format === 'rfc4253') ***REMOVED***
		if (this._rfc4253Cache === undefined)
			this._rfc4253Cache = formats['rfc4253'].write(this);
		return (this._rfc4253Cache);
	***REMOVED***

	return (formats[format].write(this, options));
***REMOVED***;

Key.prototype.toString = function (format, options) ***REMOVED***
	return (this.toBuffer(format, options).toString());
***REMOVED***;

Key.prototype.hash = function (algo) ***REMOVED***
	assert.string(algo, 'algorithm');
	algo = algo.toLowerCase();
	if (algs.hashAlgs[algo] === undefined)
		throw (new InvalidAlgorithmError(algo));

	if (this._hashCache[algo])
		return (this._hashCache[algo]);
	var hash = crypto.createHash(algo).
	    update(this.toBuffer('rfc4253')).digest();
	this._hashCache[algo] = hash;
	return (hash);
***REMOVED***;

Key.prototype.fingerprint = function (algo) ***REMOVED***
	if (algo === undefined)
		algo = 'sha256';
	assert.string(algo, 'algorithm');
	var opts = ***REMOVED***
		type: 'key',
		hash: this.hash(algo),
		algorithm: algo
	***REMOVED***;
	return (new Fingerprint(opts));
***REMOVED***;

Key.prototype.defaultHashAlgorithm = function () ***REMOVED***
	var hashAlgo = 'sha1';
	if (this.type === 'rsa')
		hashAlgo = 'sha256';
	if (this.type === 'dsa' && this.size > 1024)
		hashAlgo = 'sha256';
	if (this.type === 'ed25519')
		hashAlgo = 'sha512';
	if (this.type === 'ecdsa') ***REMOVED***
		if (this.size <= 256)
			hashAlgo = 'sha256';
		else if (this.size <= 384)
			hashAlgo = 'sha384';
		else
			hashAlgo = 'sha512';
	***REMOVED***
	return (hashAlgo);
***REMOVED***;

Key.prototype.createVerify = function (hashAlgo) ***REMOVED***
	if (hashAlgo === undefined)
		hashAlgo = this.defaultHashAlgorithm();
	assert.string(hashAlgo, 'hash algorithm');

	/* ED25519 is not supported by OpenSSL, use a javascript impl. */
	if (this.type === 'ed25519' && edCompat !== undefined)
		return (new edCompat.Verifier(this, hashAlgo));
	if (this.type === 'curve25519')
		throw (new Error('Curve25519 keys are not suitable for ' +
		    'signing or verification'));

	var v, nm, err;
	try ***REMOVED***
		nm = hashAlgo.toUpperCase();
		v = crypto.createVerify(nm);
	***REMOVED*** catch (e) ***REMOVED***
		err = e;
	***REMOVED***
	if (v === undefined || (err instanceof Error &&
	    err.message.match(/Unknown message digest/))) ***REMOVED***
		nm = 'RSA-';
		nm += hashAlgo.toUpperCase();
		v = crypto.createVerify(nm);
	***REMOVED***
	assert.ok(v, 'failed to create verifier');
	var oldVerify = v.verify.bind(v);
	var key = this.toBuffer('pkcs8');
	var curve = this.curve;
	var self = this;
	v.verify = function (signature, fmt) ***REMOVED***
		if (Signature.isSignature(signature, [2, 0])) ***REMOVED***
			if (signature.type !== self.type)
				return (false);
			if (signature.hashAlgorithm &&
			    signature.hashAlgorithm !== hashAlgo)
				return (false);
			if (signature.curve && self.type === 'ecdsa' &&
			    signature.curve !== curve)
				return (false);
			return (oldVerify(key, signature.toBuffer('asn1')));

		***REMOVED*** else if (typeof (signature) === 'string' ||
		    Buffer.isBuffer(signature)) ***REMOVED***
			return (oldVerify(key, signature, fmt));

		/*
		 * Avoid doing this on valid arguments, walking the prototype
		 * chain can be quite slow.
		 */
		***REMOVED*** else if (Signature.isSignature(signature, [1, 0])) ***REMOVED***
			throw (new Error('signature was created by too old ' +
			    'a version of sshpk and cannot be verified'));

		***REMOVED*** else ***REMOVED***
			throw (new TypeError('signature must be a string, ' +
			    'Buffer, or Signature object'));
		***REMOVED***
	***REMOVED***;
	return (v);
***REMOVED***;

Key.prototype.createDiffieHellman = function () ***REMOVED***
	if (this.type === 'rsa')
		throw (new Error('RSA keys do not support Diffie-Hellman'));

	return (new DiffieHellman(this));
***REMOVED***;
Key.prototype.createDH = Key.prototype.createDiffieHellman;

Key.parse = function (data, format, options) ***REMOVED***
	if (typeof (data) !== 'string')
		assert.buffer(data, 'data');
	if (format === undefined)
		format = 'auto';
	assert.string(format, 'format');
	if (typeof (options) === 'string')
		options = ***REMOVED*** filename: options ***REMOVED***;
	assert.optionalObject(options, 'options');
	if (options === undefined)
		options = ***REMOVED******REMOVED***;
	assert.optionalString(options.filename, 'options.filename');
	if (options.filename === undefined)
		options.filename = '(unnamed)';

	assert.object(formats[format], 'formats[format]');

	try ***REMOVED***
		var k = formats[format].read(data, options);
		if (k instanceof PrivateKey)
			k = k.toPublic();
		if (!k.comment)
			k.comment = options.filename;
		return (k);
	***REMOVED*** catch (e) ***REMOVED***
		if (e.name === 'KeyEncryptedError')
			throw (e);
		throw (new KeyParseError(options.filename, format, e));
	***REMOVED***
***REMOVED***;

Key.isKey = function (obj, ver) ***REMOVED***
	return (utils.isCompatible(obj, Key, ver));
***REMOVED***;

/*
 * API versions for Key:
 * [1,0] -- initial ver, may take Signature for createVerify or may not
 * [1,1] -- added pkcs1, pkcs8 formats
 * [1,2] -- added auto, ssh-private, openssh formats
 * [1,3] -- added defaultHashAlgorithm
 * [1,4] -- added ed support, createDH
 * [1,5] -- first explicitly tagged version
 * [1,6] -- changed ed25519 part names
 */
Key.prototype._sshpkApiVersion = [1, 6];

Key._oldVersionDetect = function (obj) ***REMOVED***
	assert.func(obj.toBuffer);
	assert.func(obj.fingerprint);
	if (obj.createDH)
		return ([1, 4]);
	if (obj.defaultHashAlgorithm)
		return ([1, 3]);
	if (obj.formats['auto'])
		return ([1, 2]);
	if (obj.formats['pkcs1'])
		return ([1, 1]);
	return ([1, 0]);
***REMOVED***;
