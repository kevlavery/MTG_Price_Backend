// Copyright 2017 Joyent, Inc.

module.exports = PrivateKey;

var assert = require('assert-plus');
var algs = require('./algs');
var crypto = require('crypto');
var Fingerprint = require('./fingerprint');
var Signature = require('./signature');
var errs = require('./errors');
var util = require('util');
var utils = require('./utils');
var dhe = require('./dhe');
var generateECDSA = dhe.generateECDSA;
var generateED25519 = dhe.generateED25519;
var edCompat;
var nacl;

try ***REMOVED***
	edCompat = require('./ed-compat');
***REMOVED*** catch (e) ***REMOVED***
	/* Just continue through, and bail out if we try to use it. */
***REMOVED***

var Key = require('./key');

var InvalidAlgorithmError = errs.InvalidAlgorithmError;
var KeyParseError = errs.KeyParseError;
var KeyEncryptedError = errs.KeyEncryptedError;

var formats = ***REMOVED******REMOVED***;
formats['auto'] = require('./formats/auto');
formats['pem'] = require('./formats/pem');
formats['pkcs1'] = require('./formats/pkcs1');
formats['pkcs8'] = require('./formats/pkcs8');
formats['rfc4253'] = require('./formats/rfc4253');
formats['ssh-private'] = require('./formats/ssh-private');
formats['openssh'] = formats['ssh-private'];
formats['ssh'] = formats['ssh-private'];
formats['dnssec'] = require('./formats/dnssec');

function PrivateKey(opts) ***REMOVED***
	assert.object(opts, 'options');
	Key.call(this, opts);

	this._pubCache = undefined;
***REMOVED***
util.inherits(PrivateKey, Key);

PrivateKey.formats = formats;

PrivateKey.prototype.toBuffer = function (format, options) ***REMOVED***
	if (format === undefined)
		format = 'pkcs1';
	assert.string(format, 'format');
	assert.object(formats[format], 'formats[format]');
	assert.optionalObject(options, 'options');

	return (formats[format].write(this, options));
***REMOVED***;

PrivateKey.prototype.hash = function (algo) ***REMOVED***
	return (this.toPublic().hash(algo));
***REMOVED***;

PrivateKey.prototype.toPublic = function () ***REMOVED***
	if (this._pubCache)
		return (this._pubCache);

	var algInfo = algs.info[this.type];
	var pubParts = [];
	for (var i = 0; i < algInfo.parts.length; ++i) ***REMOVED***
		var p = algInfo.parts[i];
		pubParts.push(this.part[p]);
	***REMOVED***

	this._pubCache = new Key(***REMOVED***
		type: this.type,
		source: this,
		parts: pubParts
	***REMOVED***);
	if (this.comment)
		this._pubCache.comment = this.comment;
	return (this._pubCache);
***REMOVED***;

PrivateKey.prototype.derive = function (newType) ***REMOVED***
	assert.string(newType, 'type');
	var priv, pub, pair;

	if (this.type === 'ed25519' && newType === 'curve25519') ***REMOVED***
		if (nacl === undefined)
			nacl = require('tweetnacl');

		priv = this.part.k.data;
		if (priv[0] === 0x00)
			priv = priv.slice(1);

		pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
		pub = new Buffer(pair.publicKey);

		return (new PrivateKey(***REMOVED***
			type: 'curve25519',
			parts: [
				***REMOVED*** name: 'A', data: utils.mpNormalize(pub) ***REMOVED***,
				***REMOVED*** name: 'k', data: utils.mpNormalize(priv) ***REMOVED***
			]
		***REMOVED***));
	***REMOVED*** else if (this.type === 'curve25519' && newType === 'ed25519') ***REMOVED***
		if (nacl === undefined)
			nacl = require('tweetnacl');

		priv = this.part.k.data;
		if (priv[0] === 0x00)
			priv = priv.slice(1);

		pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
		pub = new Buffer(pair.publicKey);

		return (new PrivateKey(***REMOVED***
			type: 'ed25519',
			parts: [
				***REMOVED*** name: 'A', data: utils.mpNormalize(pub) ***REMOVED***,
				***REMOVED*** name: 'k', data: utils.mpNormalize(priv) ***REMOVED***
			]
		***REMOVED***));
	***REMOVED***
	throw (new Error('Key derivation not supported from ' + this.type +
	    ' to ' + newType));
***REMOVED***;

PrivateKey.prototype.createVerify = function (hashAlgo) ***REMOVED***
	return (this.toPublic().createVerify(hashAlgo));
***REMOVED***;

PrivateKey.prototype.createSign = function (hashAlgo) ***REMOVED***
	if (hashAlgo === undefined)
		hashAlgo = this.defaultHashAlgorithm();
	assert.string(hashAlgo, 'hash algorithm');

	/* ED25519 is not supported by OpenSSL, use a javascript impl. */
	if (this.type === 'ed25519' && edCompat !== undefined)
		return (new edCompat.Signer(this, hashAlgo));
	if (this.type === 'curve25519')
		throw (new Error('Curve25519 keys are not suitable for ' +
		    'signing or verification'));

	var v, nm, err;
	try ***REMOVED***
		nm = hashAlgo.toUpperCase();
		v = crypto.createSign(nm);
	***REMOVED*** catch (e) ***REMOVED***
		err = e;
	***REMOVED***
	if (v === undefined || (err instanceof Error &&
	    err.message.match(/Unknown message digest/))) ***REMOVED***
		nm = 'RSA-';
		nm += hashAlgo.toUpperCase();
		v = crypto.createSign(nm);
	***REMOVED***
	assert.ok(v, 'failed to create verifier');
	var oldSign = v.sign.bind(v);
	var key = this.toBuffer('pkcs1');
	var type = this.type;
	var curve = this.curve;
	v.sign = function () ***REMOVED***
		var sig = oldSign(key);
		if (typeof (sig) === 'string')
			sig = new Buffer(sig, 'binary');
		sig = Signature.parse(sig, type, 'asn1');
		sig.hashAlgorithm = hashAlgo;
		sig.curve = curve;
		return (sig);
	***REMOVED***;
	return (v);
***REMOVED***;

PrivateKey.parse = function (data, format, options) ***REMOVED***
	if (typeof (data) !== 'string')
		assert.buffer(data, 'data');
	if (format === undefined)
		format = 'auto';
	assert.string(format, 'format');
	if (typeof (options) === 'string')
		options = ***REMOVED*** filename: options ***REMOVED***;
	assert.optionalObject(options, 'options');
	if (options === undefined)
		options = ***REMOVED******REMOVED***;
	assert.optionalString(options.filename, 'options.filename');
	if (options.filename === undefined)
		options.filename = '(unnamed)';

	assert.object(formats[format], 'formats[format]');

	try ***REMOVED***
		var k = formats[format].read(data, options);
		assert.ok(k instanceof PrivateKey, 'key is not a private key');
		if (!k.comment)
			k.comment = options.filename;
		return (k);
	***REMOVED*** catch (e) ***REMOVED***
		if (e.name === 'KeyEncryptedError')
			throw (e);
		throw (new KeyParseError(options.filename, format, e));
	***REMOVED***
***REMOVED***;

PrivateKey.isPrivateKey = function (obj, ver) ***REMOVED***
	return (utils.isCompatible(obj, PrivateKey, ver));
***REMOVED***;

PrivateKey.generate = function (type, options) ***REMOVED***
	if (options === undefined)
		options = ***REMOVED******REMOVED***;
	assert.object(options, 'options');

	switch (type) ***REMOVED***
	case 'ecdsa':
		if (options.curve === undefined)
			options.curve = 'nistp256';
		assert.string(options.curve, 'options.curve');
		return (generateECDSA(options.curve));
	case 'ed25519':
		return (generateED25519());
	default:
		throw (new Error('Key generation not supported with key ' +
		    'type "' + type + '"'));
	***REMOVED***
***REMOVED***;

/*
 * API versions for PrivateKey:
 * [1,0] -- initial ver
 * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats
 * [1,2] -- added defaultHashAlgorithm
 * [1,3] -- added derive, ed, createDH
 * [1,4] -- first tagged version
 * [1,5] -- changed ed25519 part names and format
 */
PrivateKey.prototype._sshpkApiVersion = [1, 5];

PrivateKey._oldVersionDetect = function (obj) ***REMOVED***
	assert.func(obj.toPublic);
	assert.func(obj.createSign);
	if (obj.derive)
		return ([1, 3]);
	if (obj.defaultHashAlgorithm)
		return ([1, 2]);
	if (obj.formats['auto'])
		return ([1, 1]);
	return ([1, 0]);
***REMOVED***;
