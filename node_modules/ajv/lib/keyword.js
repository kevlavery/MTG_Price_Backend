'use strict';

var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require('./dotjs/custom');

module.exports = ***REMOVED***
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword
***REMOVED***;

/**
 * Define custom keyword
 * @this  Ajv
 * @param ***REMOVED***String***REMOVED*** keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param ***REMOVED***Object***REMOVED*** definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return ***REMOVED***Ajv***REMOVED*** this for method chaining
 */
function addKeyword(keyword, definition) ***REMOVED***
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;

  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) ***REMOVED***
    if (definition.macro && definition.valid !== undefined)
      throw new Error('"valid" option cannot be used with macro keywords');

    var dataType = definition.type;
    if (Array.isArray(dataType)) ***REMOVED***
      var i, len = dataType.length;
      for (i=0; i<len; i++) checkDataType(dataType[i]);
      for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);
    ***REMOVED*** else ***REMOVED***
      if (dataType) checkDataType(dataType);
      _addRule(keyword, dataType, definition);
    ***REMOVED***

    var $data = definition.$data === true && this._opts.$data;
    if ($data && !definition.validate)
      throw new Error('$data support: "validate" function is not defined');

    var metaSchema = definition.metaSchema;
    if (metaSchema) ***REMOVED***
      if ($data) ***REMOVED***
        metaSchema = ***REMOVED***
          anyOf: [
            metaSchema,
            ***REMOVED*** '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#' ***REMOVED***
          ]
        ***REMOVED***;
      ***REMOVED***
      definition.validateSchema = this.compile(metaSchema, true);
    ***REMOVED***
  ***REMOVED***

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) ***REMOVED***
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) ***REMOVED***
      var rg = RULES[i];
      if (rg.type == dataType) ***REMOVED***
        ruleGroup = rg;
        break;
      ***REMOVED***
    ***REMOVED***

    if (!ruleGroup) ***REMOVED***
      ruleGroup = ***REMOVED*** type: dataType, rules: [] ***REMOVED***;
      RULES.push(ruleGroup);
    ***REMOVED***

    var rule = ***REMOVED***
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    ***REMOVED***;
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  ***REMOVED***


  function checkDataType(dataType) ***REMOVED***
    if (!RULES.types[dataType]) throw new Error('Unknown type ' + dataType);
  ***REMOVED***

  return this;
***REMOVED***


/**
 * Get keyword
 * @this  Ajv
 * @param ***REMOVED***String***REMOVED*** keyword pre-defined or custom keyword.
 * @return ***REMOVED***Object|Boolean***REMOVED*** custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) ***REMOVED***
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
***REMOVED***


/**
 * Remove keyword
 * @this  Ajv
 * @param ***REMOVED***String***REMOVED*** keyword pre-defined or custom keyword.
 * @return ***REMOVED***Ajv***REMOVED*** this for method chaining
 */
function removeKeyword(keyword) ***REMOVED***
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) ***REMOVED***
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) ***REMOVED***
      if (rules[j].keyword == keyword) ***REMOVED***
        rules.splice(j, 1);
        break;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return this;
***REMOVED***
