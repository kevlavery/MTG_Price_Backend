'use strict';

var url = require('url')
  , equal = require('fast-deep-equal')
  , util = require('./util')
  , SchemaObject = require('./schema_obj')
  , traverse = require('json-schema-traverse');

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  ***REMOVED***Function***REMOVED*** compile reference to schema compilation funciton (localCompile)
 * @param  ***REMOVED***Object***REMOVED*** root object with information about the root schema for the current schema
 * @param  ***REMOVED***String***REMOVED*** ref reference to resolve
 * @return ***REMOVED***Object|Function***REMOVED*** schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) ***REMOVED***
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') ***REMOVED***
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  ***REMOVED***

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) ***REMOVED***
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  ***REMOVED***

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) ***REMOVED***
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  ***REMOVED***

  if (schema instanceof SchemaObject) ***REMOVED***
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  ***REMOVED*** else if (schema !== undefined) ***REMOVED***
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  ***REMOVED***

  return v;
***REMOVED***


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  ***REMOVED***Object***REMOVED*** root root object with properties schema, refVal, refs
 * @param  ***REMOVED***String***REMOVED*** ref  reference to resolve
 * @return ***REMOVED***Object***REMOVED*** object with properties schema, root, baseId
 */
function resolveSchema(root, ref) ***REMOVED***
  /* jshint validthis: true */
  var p = url.parse(ref, false, true)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (refPath !== baseId) ***REMOVED***
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') ***REMOVED***
      return resolveRecursive.call(this, root, refVal, p);
    ***REMOVED*** else if (refVal instanceof SchemaObject) ***REMOVED***
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    ***REMOVED*** else ***REMOVED***
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) ***REMOVED***
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return ***REMOVED*** schema: refVal, root: root, baseId: baseId ***REMOVED***;
        root = refVal;
      ***REMOVED*** else ***REMOVED***
        return;
      ***REMOVED***
    ***REMOVED***
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  ***REMOVED***
  return getJsonPointer.call(this, p, baseId, root.schema, root);
***REMOVED***


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) ***REMOVED***
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) ***REMOVED***
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  ***REMOVED***
***REMOVED***


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) ***REMOVED***
  /* jshint validthis: true */
  parsedRef.hash = parsedRef.hash || '';
  if (parsedRef.hash.slice(0,2) != '#/') return;
  var parts = parsedRef.hash.split('/');

  for (var i = 1; i < parts.length; i++) ***REMOVED***
    var part = parts[i];
    if (part) ***REMOVED***
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) ***REMOVED***
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) ***REMOVED***
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) ***REMOVED***
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if (schema !== undefined && schema !== root.schema)
    return ***REMOVED*** schema: schema, root: root, baseId: baseId ***REMOVED***;
***REMOVED***


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) ***REMOVED***
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
***REMOVED***


function checkNoRef(schema) ***REMOVED***
  var item;
  if (Array.isArray(schema)) ***REMOVED***
    for (var i=0; i<schema.length; i++) ***REMOVED***
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    for (var key in schema) ***REMOVED***
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    ***REMOVED***
  ***REMOVED***
  return true;
***REMOVED***


function countKeys(schema) ***REMOVED***
  var count = 0, item;
  if (Array.isArray(schema)) ***REMOVED***
    for (var i=0; i<schema.length; i++) ***REMOVED***
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    for (var key in schema) ***REMOVED***
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) ***REMOVED***
        count++;
      ***REMOVED*** else ***REMOVED***
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return count;
***REMOVED***


function getFullPath(id, normalize) ***REMOVED***
  if (normalize !== false) id = normalizeId(id);
  var p = url.parse(id, false, true);
  return _getFullPath(p);
***REMOVED***


function _getFullPath(p) ***REMOVED***
  var protocolSeparator = p.protocol || p.href.slice(0,2) == '//' ? '//' : '';
  return (p.protocol||'') + protocolSeparator + (p.host||'') + (p.path||'')  + '#';
***REMOVED***


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) ***REMOVED***
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
***REMOVED***


function resolveUrl(baseId, id) ***REMOVED***
  id = normalizeId(id);
  return url.resolve(baseId, id);
***REMOVED***


/* @this Ajv */
function resolveIds(schema) ***REMOVED***
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = ***REMOVED***'': schemaId***REMOVED***;
  var fullPaths = ***REMOVED***'': getFullPath(schemaId, false)***REMOVED***;
  var localRefs = ***REMOVED******REMOVED***;
  var self = this;

  traverse(schema, ***REMOVED***allKeys: true***REMOVED***, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) ***REMOVED***
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') ***REMOVED***
      id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) ***REMOVED***
        if (!equal(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      ***REMOVED*** else if (id != normalizeId(fullPath)) ***REMOVED***
        if (id[0] == '#') ***REMOVED***
          if (localRefs[id] && !equal(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        ***REMOVED*** else ***REMOVED***
          self._refs[id] = fullPath;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  ***REMOVED***);

  return localRefs;
***REMOVED***
