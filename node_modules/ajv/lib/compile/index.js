'use strict';

var resolve = require('./resolve')
  , util = require('./util')
  , errorClasses = require('./error_classes')
  , stableStringify = require('fast-json-stable-stringify');

var validateGenerator = require('../dotjs/validate');

/**
 * Functions below are used inside compiled validations function
 */

var co = require('co');
var ucs2length = util.ucs2length;
var equal = require('fast-deep-equal');

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  ***REMOVED***Object***REMOVED*** schema schema object
 * @param  ***REMOVED***Object***REMOVED*** root object with information about the root schema for this schema
 * @param  ***REMOVED***Object***REMOVED*** localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  ***REMOVED***String***REMOVED*** baseId base ID for IDs in the schema
 * @return ***REMOVED***Function***REMOVED*** validation function
 */
function compile(schema, root, localRefs, baseId) ***REMOVED***
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = ***REMOVED******REMOVED***
    , patterns = []
    , patternsHash = ***REMOVED******REMOVED***
    , defaults = []
    , defaultsHash = ***REMOVED******REMOVED***
    , customRules = [];

  root = root || ***REMOVED*** schema: schema, refVal: refVal, refs: refs ***REMOVED***;

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try ***REMOVED***
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) ***REMOVED***
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    ***REMOVED***
    return v;
  ***REMOVED*** finally ***REMOVED***
    endCompiling.call(this, schema, root, baseId);
  ***REMOVED***

  function callValidate() ***REMOVED***
    var validate = compilation.validate;
    var result = validate.apply(null, arguments);
    callValidate.errors = validate.errors;
    return result;
  ***REMOVED***

  function localCompile(_schema, _root, localRefs, baseId) ***REMOVED***
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator(***REMOVED***
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    ***REMOVED***);

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate;
    try ***REMOVED***
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'co',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        co,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    ***REMOVED*** catch(e) ***REMOVED***
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    ***REMOVED***

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) ***REMOVED***
      validate.source = ***REMOVED***
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      ***REMOVED***;
    ***REMOVED***

    return validate;
  ***REMOVED***

  function resolveRef(baseId, ref, isRoot) ***REMOVED***
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) ***REMOVED***
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    ***REMOVED***
    if (!isRoot && root.refs) ***REMOVED***
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) ***REMOVED***
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      ***REMOVED***
    ***REMOVED***

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) ***REMOVED***
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) ***REMOVED***
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      ***REMOVED***
    ***REMOVED***

    if (v === undefined) ***REMOVED***
      removeLocalRef(ref);
    ***REMOVED*** else ***REMOVED***
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    ***REMOVED***
  ***REMOVED***

  function addLocalRef(ref, v) ***REMOVED***
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  ***REMOVED***

  function removeLocalRef(ref) ***REMOVED***
    delete refs[ref];
  ***REMOVED***

  function replaceLocalRef(ref, v) ***REMOVED***
    var refId = refs[ref];
    refVal[refId] = v;
  ***REMOVED***

  function resolvedRef(refVal, code) ***REMOVED***
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? ***REMOVED*** code: code, schema: refVal, inline: true ***REMOVED***
            : ***REMOVED*** code: code, $async: refVal && refVal.$async ***REMOVED***;
  ***REMOVED***

  function usePattern(regexStr) ***REMOVED***
    var index = patternsHash[regexStr];
    if (index === undefined) ***REMOVED***
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    ***REMOVED***
    return 'pattern' + index;
  ***REMOVED***

  function useDefault(value) ***REMOVED***
    switch (typeof value) ***REMOVED***
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) ***REMOVED***
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        ***REMOVED***
        return 'default' + index;
    ***REMOVED***
  ***REMOVED***

  function useCustomRule(rule, schema, parentSchema, it) ***REMOVED***
    var validateSchema = rule.definition.validateSchema;
    if (validateSchema && self._opts.validateSchema !== false) ***REMOVED***
      var valid = validateSchema(schema);
      if (!valid) ***REMOVED***
        var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
        if (self._opts.validateSchema == 'log') self.logger.error(message);
        else throw new Error(message);
      ***REMOVED***
    ***REMOVED***

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) ***REMOVED***
      validate = compile.call(self, schema, parentSchema, it);
    ***REMOVED*** else if (macro) ***REMOVED***
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    ***REMOVED*** else if (inline) ***REMOVED***
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    ***REMOVED*** else ***REMOVED***
      validate = rule.definition.validate;
      if (!validate) return;
    ***REMOVED***

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return ***REMOVED***
      code: 'customRule' + index,
      validate: validate
    ***REMOVED***;
  ***REMOVED***
***REMOVED***


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  ***REMOVED***Object***REMOVED*** schema schema to compile
 * @param  ***REMOVED***Object***REMOVED*** root root object
 * @param  ***REMOVED***String***REMOVED*** baseId base schema ID
 * @return ***REMOVED***Object***REMOVED*** object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) ***REMOVED***
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return ***REMOVED*** index: index, compiling: true ***REMOVED***;
  index = this._compilations.length;
  this._compilations[index] = ***REMOVED***
    schema: schema,
    root: root,
    baseId: baseId
  ***REMOVED***;
  return ***REMOVED*** index: index, compiling: false ***REMOVED***;
***REMOVED***


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  ***REMOVED***Object***REMOVED*** schema schema to compile
 * @param  ***REMOVED***Object***REMOVED*** root root object
 * @param  ***REMOVED***String***REMOVED*** baseId base schema ID
 */
function endCompiling(schema, root, baseId) ***REMOVED***
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
***REMOVED***


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  ***REMOVED***Object***REMOVED*** schema schema to compile
 * @param  ***REMOVED***Object***REMOVED*** root root object
 * @param  ***REMOVED***String***REMOVED*** baseId base schema ID
 * @return ***REMOVED***Integer***REMOVED*** compilation index
 */
function compIndex(schema, root, baseId) ***REMOVED***
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) ***REMOVED***
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  ***REMOVED***
  return -1;
***REMOVED***


function patternCode(i, patterns) ***REMOVED***
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
***REMOVED***


function defaultCode(i) ***REMOVED***
  return 'var default' + i + ' = defaults[' + i + '];';
***REMOVED***


function refValCode(i, refVal) ***REMOVED***
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
***REMOVED***


function customRuleCode(i) ***REMOVED***
  return 'var customRule' + i + ' = customRules[' + i + '];';
***REMOVED***


function vars(arr, statement) ***REMOVED***
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
***REMOVED***
