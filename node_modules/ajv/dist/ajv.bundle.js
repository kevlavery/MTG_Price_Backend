(function(f)***REMOVED***if(typeof exports==="object"&&typeof module!=="undefined")***REMOVED***module.exports=f()***REMOVED***else if(typeof define==="function"&&define.amd)***REMOVED***define([],f)***REMOVED***else***REMOVED***var g;if(typeof window!=="undefined")***REMOVED***g=window***REMOVED***else if(typeof global!=="undefined")***REMOVED***g=global***REMOVED***else if(typeof self!=="undefined")***REMOVED***g=self***REMOVED***else***REMOVED***g=this***REMOVED***g.Ajv = f()***REMOVED******REMOVED***)(function()***REMOVED***var define,module,exports;return (function e(t,n,r)***REMOVED***function s(o,u)***REMOVED***if(!n[o])***REMOVED***if(!t[o])***REMOVED***var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f***REMOVED***var l=n[o]=***REMOVED***exports:***REMOVED******REMOVED******REMOVED***;t[o][0].call(l.exports,function(e)***REMOVED***var n=t[o][1][e];return s(n?n:e)***REMOVED***,l,l.exports,e,t,n,r)***REMOVED***return n[o].exports***REMOVED***var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s***REMOVED***)(***REMOVED***1:[function(require,module,exports)***REMOVED***
'use strict';

var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

module.exports = function (metaSchema, keywordsJsonPointers) ***REMOVED***
  for (var i=0; i<keywordsJsonPointers.length; i++) ***REMOVED***
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) ***REMOVED***
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) ***REMOVED***
        keywords[key] = ***REMOVED***
          anyOf: [
            schema,
            ***REMOVED*** $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#' ***REMOVED***
          ]
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return metaSchema;
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],2:[function(require,module,exports)***REMOVED***
'use strict';


var Cache = module.exports = function Cache() ***REMOVED***
  this._cache = ***REMOVED******REMOVED***;
***REMOVED***;


Cache.prototype.put = function Cache_put(key, value) ***REMOVED***
  this._cache[key] = value;
***REMOVED***;


Cache.prototype.get = function Cache_get(key) ***REMOVED***
  return this._cache[key];
***REMOVED***;


Cache.prototype.del = function Cache_del(key) ***REMOVED***
  delete this._cache[key];
***REMOVED***;


Cache.prototype.clear = function Cache_clear() ***REMOVED***
  this._cache = ***REMOVED******REMOVED***;
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],3:[function(require,module,exports)***REMOVED***
'use strict';

//all requires must be explicit because browserify won't work with dynamic requires
module.exports = ***REMOVED***
  '$ref': require('../dotjs/ref'),
  allOf: require('../dotjs/allOf'),
  anyOf: require('../dotjs/anyOf'),
  const: require('../dotjs/const'),
  contains: require('../dotjs/contains'),
  dependencies: require('../dotjs/dependencies'),
  'enum': require('../dotjs/enum'),
  format: require('../dotjs/format'),
  items: require('../dotjs/items'),
  maximum: require('../dotjs/_limit'),
  minimum: require('../dotjs/_limit'),
  maxItems: require('../dotjs/_limitItems'),
  minItems: require('../dotjs/_limitItems'),
  maxLength: require('../dotjs/_limitLength'),
  minLength: require('../dotjs/_limitLength'),
  maxProperties: require('../dotjs/_limitProperties'),
  minProperties: require('../dotjs/_limitProperties'),
  multipleOf: require('../dotjs/multipleOf'),
  not: require('../dotjs/not'),
  oneOf: require('../dotjs/oneOf'),
  pattern: require('../dotjs/pattern'),
  properties: require('../dotjs/properties'),
  propertyNames: require('../dotjs/propertyNames'),
  required: require('../dotjs/required'),
  uniqueItems: require('../dotjs/uniqueItems'),
  validate: require('../dotjs/validate')
***REMOVED***;

***REMOVED***,***REMOVED***"../dotjs/_limit":13,"../dotjs/_limitItems":14,"../dotjs/_limitLength":15,"../dotjs/_limitProperties":16,"../dotjs/allOf":17,"../dotjs/anyOf":18,"../dotjs/const":19,"../dotjs/contains":20,"../dotjs/dependencies":22,"../dotjs/enum":23,"../dotjs/format":24,"../dotjs/items":25,"../dotjs/multipleOf":26,"../dotjs/not":27,"../dotjs/oneOf":28,"../dotjs/pattern":29,"../dotjs/properties":30,"../dotjs/propertyNames":31,"../dotjs/ref":32,"../dotjs/required":33,"../dotjs/uniqueItems":34,"../dotjs/validate":35***REMOVED***],4:[function(require,module,exports)***REMOVED***
'use strict';

var MissingRefError = require('./error_classes').MissingRef;

module.exports = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param ***REMOVED***Object***REMOVED***   schema schema object
 * @param ***REMOVED***Boolean***REMOVED***  meta optional true to compile meta-schema; this parameter can be skipped
 * @param ***REMOVED***Function***REMOVED*** callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return ***REMOVED***Promise***REMOVED*** promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) ***REMOVED***
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') ***REMOVED***
    callback = meta;
    meta = undefined;
  ***REMOVED***

  var p = loadMetaSchemaOf(schema).then(function () ***REMOVED***
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  ***REMOVED***);

  if (callback) ***REMOVED***
    p.then(
      function(v) ***REMOVED*** callback(null, v); ***REMOVED***,
      callback
    );
  ***REMOVED***

  return p;


  function loadMetaSchemaOf(sch) ***REMOVED***
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, ***REMOVED*** $ref: $schema ***REMOVED***, true)
            : Promise.resolve();
  ***REMOVED***


  function _compileAsync(schemaObj) ***REMOVED***
    try ***REMOVED*** return self._compile(schemaObj); ***REMOVED***
    catch(e) ***REMOVED***
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    ***REMOVED***


    function loadMissingSchema(e) ***REMOVED***
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) ***REMOVED***
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      ***REMOVED***

      return schemaPromise.then(function (sch) ***REMOVED***
        if (!added(ref)) ***REMOVED***
          return loadMetaSchemaOf(sch).then(function () ***REMOVED***
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***).then(function() ***REMOVED***
        return _compileAsync(schemaObj);
      ***REMOVED***);

      function removePromise() ***REMOVED***
        delete self._loadingSchemas[ref];
      ***REMOVED***

      function added(ref) ***REMOVED***
        return self._refs[ref] || self._schemas[ref];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

***REMOVED***,***REMOVED***"./error_classes":5***REMOVED***],5:[function(require,module,exports)***REMOVED***
'use strict';

var resolve = require('./resolve');

module.exports = ***REMOVED***
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
***REMOVED***;


function ValidationError(errors) ***REMOVED***
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
***REMOVED***


MissingRefError.message = function (baseId, ref) ***REMOVED***
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
***REMOVED***;


function MissingRefError(baseId, ref, message) ***REMOVED***
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
***REMOVED***


function errorSubclass(Subclass) ***REMOVED***
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
***REMOVED***

***REMOVED***,***REMOVED***"./resolve":8***REMOVED***],6:[function(require,module,exports)***REMOVED***
'use strict';

var util = require('./util');

var DATE = /^\d\d\d\d-(\d\d)-(\d\d)$/;
var DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]***REMOVED***0,61***REMOVED***[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]***REMOVED***0,61***REMOVED***[0-9a-z])?)*$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]***REMOVED***2***REMOVED***)*@)?(?:\[(?:(?:(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***6***REMOVED***|::(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***5***REMOVED***|(?:[0-9a-f]***REMOVED***1,4***REMOVED***)?::(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***4***REMOVED***|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,1***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***3***REMOVED***|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,2***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***2***REMOVED***|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,3***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::[0-9a-f]***REMOVED***1,4***REMOVED***:|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,4***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::)(?:[0-9a-f]***REMOVED***1,4***REMOVED***:[0-9a-f]***REMOVED***1,4***REMOVED***|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.)***REMOVED***3***REMOVED***(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,5***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::[0-9a-f]***REMOVED***1,4***REMOVED***|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,6***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.)***REMOVED***3***REMOVED***(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]***REMOVED***2***REMOVED***)*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]***REMOVED***2***REMOVED***)*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]***REMOVED***2***REMOVED***)+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]***REMOVED***2***REMOVED***)*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]***REMOVED***2***REMOVED***)+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]***REMOVED***2***REMOVED***)*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]***REMOVED***2***REMOVED***)*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]***REMOVED***2***REMOVED***)*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]***REMOVED***2***REMOVED***)*@)?(?:\[(?:(?:(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***6***REMOVED***|::(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***5***REMOVED***|(?:[0-9a-f]***REMOVED***1,4***REMOVED***)?::(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***4***REMOVED***|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,1***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***3***REMOVED***|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,2***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***2***REMOVED***|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,3***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::[0-9a-f]***REMOVED***1,4***REMOVED***:|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,4***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::)(?:[0-9a-f]***REMOVED***1,4***REMOVED***:[0-9a-f]***REMOVED***1,4***REMOVED***|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.)***REMOVED***3***REMOVED***(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,5***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::[0-9a-f]***REMOVED***1,4***REMOVED***|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***0,6***REMOVED***[0-9a-f]***REMOVED***1,4***REMOVED***)?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.)***REMOVED***3***REMOVED***(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]***REMOVED***2***REMOVED***)*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]***REMOVED***2***REMOVED***)*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]***REMOVED***2***REMOVED***)+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]***REMOVED***2***REMOVED***)*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]***REMOVED***2***REMOVED***)+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]***REMOVED***2***REMOVED***)*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]***REMOVED***2***REMOVED***)*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]***REMOVED***2***REMOVED***)*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`***REMOVED***|***REMOVED***]|%[0-9a-f]***REMOVED***2***REMOVED***)|\***REMOVED***[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]***REMOVED***2***REMOVED***)+(?::[1-9][0-9]***REMOVED***0,3***REMOVED***|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]***REMOVED***2***REMOVED***)+(?::[1-9][0-9]***REMOVED***0,3***REMOVED***|\*)?)*\***REMOVED***)*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d***REMOVED***1,3***REMOVED***)***REMOVED***3***REMOVED***)(?!127(?:\.\d***REMOVED***1,3***REMOVED***)***REMOVED***3***REMOVED***)(?!169\.254(?:\.\d***REMOVED***1,3***REMOVED***)***REMOVED***2***REMOVED***)(?!192\.168(?:\.\d***REMOVED***1,3***REMOVED***)***REMOVED***2***REMOVED***)(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d***REMOVED***1,3***REMOVED***)***REMOVED***2***REMOVED***)(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d***REMOVED***1,2***REMOVED***|2[0-4]\d|25[0-5]))***REMOVED***2***REMOVED***(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u***REMOVED***00a1***REMOVED***-\u***REMOVED***ffff***REMOVED***0-9]+-?)*[a-z\u***REMOVED***00a1***REMOVED***-\u***REMOVED***ffff***REMOVED***0-9]+)(?:\.(?:[a-z\u***REMOVED***00a1***REMOVED***-\u***REMOVED***ffff***REMOVED***0-9]+-?)*[a-z\u***REMOVED***00a1***REMOVED***-\u***REMOVED***ffff***REMOVED***0-9]+)*(?:\.(?:[a-z\u***REMOVED***00a1***REMOVED***-\u***REMOVED***ffff***REMOVED***]***REMOVED***2,***REMOVED***)))(?::\d***REMOVED***2,5***REMOVED***)?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]***REMOVED***1,3***REMOVED***)***REMOVED***3***REMOVED***)(?!127(?:\.[0-9]***REMOVED***1,3***REMOVED***)***REMOVED***3***REMOVED***)(?!169\.254(?:\.[0-9]***REMOVED***1,3***REMOVED***)***REMOVED***2***REMOVED***)(?!192\.168(?:\.[0-9]***REMOVED***1,3***REMOVED***)***REMOVED***2***REMOVED***)(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]***REMOVED***1,3***REMOVED***)***REMOVED***2***REMOVED***)(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]***REMOVED***1,2***REMOVED***|2[0-4][0-9]|25[0-5]))***REMOVED***2***REMOVED***(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])***REMOVED***2,***REMOVED***)))(?::[0-9]***REMOVED***2,5***REMOVED***)?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]***REMOVED***8***REMOVED***-(?:[0-9a-f]***REMOVED***4***REMOVED***-)***REMOVED***3***REMOVED***[0-9a-f]***REMOVED***12***REMOVED***$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$|^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]***REMOVED***2***REMOVED***|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) ***REMOVED***
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
***REMOVED***


formats.fast = ***REMOVED***
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*)(?::|\/)\/?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`***REMOVED***|***REMOVED***~-]+@[a-z0-9](?:[a-z0-9-]***REMOVED***0,61***REMOVED***[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]***REMOVED***0,61***REMOVED***[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.)***REMOVED***3***REMOVED***(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***7***REMOVED***(?:[0-9a-f]***REMOVED***1,4***REMOVED***|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***6***REMOVED***(?::[0-9a-f]***REMOVED***1,4***REMOVED***|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***)|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***5***REMOVED***(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,2***REMOVED***)|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***)|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***4***REMOVED***(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,3***REMOVED***)|(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***))|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***3***REMOVED***(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,4***REMOVED***)|(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***0,2***REMOVED***:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***))|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***2***REMOVED***(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,5***REMOVED***)|(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***0,3***REMOVED***:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***))|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***1***REMOVED***(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,6***REMOVED***)|(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***0,4***REMOVED***:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***))|:))|(?::(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,7***REMOVED***)|(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***0,5***REMOVED***:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
***REMOVED***;


formats.full = ***REMOVED***
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_`***REMOVED***|***REMOVED***~-]+(?:\.[a-z0-9!#$%&''*+/=?^_`***REMOVED***|***REMOVED***~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: hostname,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.)***REMOVED***3***REMOVED***(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***7***REMOVED***(?:[0-9a-f]***REMOVED***1,4***REMOVED***|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***6***REMOVED***(?::[0-9a-f]***REMOVED***1,4***REMOVED***|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***)|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***5***REMOVED***(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,2***REMOVED***)|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***)|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***4***REMOVED***(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,3***REMOVED***)|(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***))|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***3***REMOVED***(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,4***REMOVED***)|(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***0,2***REMOVED***:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***))|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***2***REMOVED***(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,5***REMOVED***)|(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***0,3***REMOVED***:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***))|:))|(?:(?:[0-9a-f]***REMOVED***1,4***REMOVED***:)***REMOVED***1***REMOVED***(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,6***REMOVED***)|(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***0,4***REMOVED***:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***))|:))|(?::(?:(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***1,7***REMOVED***)|(?:(?::[0-9a-f]***REMOVED***1,4***REMOVED***)***REMOVED***0,5***REMOVED***:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))***REMOVED***3***REMOVED***))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'relative-json-pointer': RELATIVE_JSON_POINTER
***REMOVED***;


function date(str) ***REMOVED***
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var month = +matches[1];
  var day = +matches[2];
  return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
***REMOVED***


function time(str, full) ***REMOVED***
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
***REMOVED***


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) ***REMOVED***
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
***REMOVED***


function hostname(str) ***REMOVED***
  // https://tools.ietf.org/html/rfc1034#section-3.5
  // https://tools.ietf.org/html/rfc1123#section-2
  return str.length <= 255 && HOSTNAME.test(str);
***REMOVED***


var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) ***REMOVED***
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
***REMOVED***


var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) ***REMOVED***
  if (Z_ANCHOR.test(str)) return false;
  try ***REMOVED***
    new RegExp(str);
    return true;
  ***REMOVED*** catch(e) ***REMOVED***
    return false;
  ***REMOVED***
***REMOVED***

***REMOVED***,***REMOVED***"./util":12***REMOVED***],7:[function(require,module,exports)***REMOVED***
'use strict';

var resolve = require('./resolve')
  , util = require('./util')
  , errorClasses = require('./error_classes')
  , stableStringify = require('fast-json-stable-stringify');

var validateGenerator = require('../dotjs/validate');

/**
 * Functions below are used inside compiled validations function
 */

var co = require('co');
var ucs2length = util.ucs2length;
var equal = require('fast-deep-equal');

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  ***REMOVED***Object***REMOVED*** schema schema object
 * @param  ***REMOVED***Object***REMOVED*** root object with information about the root schema for this schema
 * @param  ***REMOVED***Object***REMOVED*** localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  ***REMOVED***String***REMOVED*** baseId base ID for IDs in the schema
 * @return ***REMOVED***Function***REMOVED*** validation function
 */
function compile(schema, root, localRefs, baseId) ***REMOVED***
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = ***REMOVED******REMOVED***
    , patterns = []
    , patternsHash = ***REMOVED******REMOVED***
    , defaults = []
    , defaultsHash = ***REMOVED******REMOVED***
    , customRules = [];

  root = root || ***REMOVED*** schema: schema, refVal: refVal, refs: refs ***REMOVED***;

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try ***REMOVED***
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) ***REMOVED***
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    ***REMOVED***
    return v;
  ***REMOVED*** finally ***REMOVED***
    endCompiling.call(this, schema, root, baseId);
  ***REMOVED***

  function callValidate() ***REMOVED***
    var validate = compilation.validate;
    var result = validate.apply(null, arguments);
    callValidate.errors = validate.errors;
    return result;
  ***REMOVED***

  function localCompile(_schema, _root, localRefs, baseId) ***REMOVED***
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator(***REMOVED***
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    ***REMOVED***);

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate;
    try ***REMOVED***
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'co',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        co,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    ***REMOVED*** catch(e) ***REMOVED***
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    ***REMOVED***

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) ***REMOVED***
      validate.source = ***REMOVED***
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      ***REMOVED***;
    ***REMOVED***

    return validate;
  ***REMOVED***

  function resolveRef(baseId, ref, isRoot) ***REMOVED***
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) ***REMOVED***
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    ***REMOVED***
    if (!isRoot && root.refs) ***REMOVED***
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) ***REMOVED***
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      ***REMOVED***
    ***REMOVED***

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) ***REMOVED***
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) ***REMOVED***
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      ***REMOVED***
    ***REMOVED***

    if (v === undefined) ***REMOVED***
      removeLocalRef(ref);
    ***REMOVED*** else ***REMOVED***
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    ***REMOVED***
  ***REMOVED***

  function addLocalRef(ref, v) ***REMOVED***
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  ***REMOVED***

  function removeLocalRef(ref) ***REMOVED***
    delete refs[ref];
  ***REMOVED***

  function replaceLocalRef(ref, v) ***REMOVED***
    var refId = refs[ref];
    refVal[refId] = v;
  ***REMOVED***

  function resolvedRef(refVal, code) ***REMOVED***
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? ***REMOVED*** code: code, schema: refVal, inline: true ***REMOVED***
            : ***REMOVED*** code: code, $async: refVal && refVal.$async ***REMOVED***;
  ***REMOVED***

  function usePattern(regexStr) ***REMOVED***
    var index = patternsHash[regexStr];
    if (index === undefined) ***REMOVED***
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    ***REMOVED***
    return 'pattern' + index;
  ***REMOVED***

  function useDefault(value) ***REMOVED***
    switch (typeof value) ***REMOVED***
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) ***REMOVED***
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        ***REMOVED***
        return 'default' + index;
    ***REMOVED***
  ***REMOVED***

  function useCustomRule(rule, schema, parentSchema, it) ***REMOVED***
    var validateSchema = rule.definition.validateSchema;
    if (validateSchema && self._opts.validateSchema !== false) ***REMOVED***
      var valid = validateSchema(schema);
      if (!valid) ***REMOVED***
        var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
        if (self._opts.validateSchema == 'log') self.logger.error(message);
        else throw new Error(message);
      ***REMOVED***
    ***REMOVED***

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) ***REMOVED***
      validate = compile.call(self, schema, parentSchema, it);
    ***REMOVED*** else if (macro) ***REMOVED***
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    ***REMOVED*** else if (inline) ***REMOVED***
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    ***REMOVED*** else ***REMOVED***
      validate = rule.definition.validate;
      if (!validate) return;
    ***REMOVED***

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return ***REMOVED***
      code: 'customRule' + index,
      validate: validate
    ***REMOVED***;
  ***REMOVED***
***REMOVED***


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  ***REMOVED***Object***REMOVED*** schema schema to compile
 * @param  ***REMOVED***Object***REMOVED*** root root object
 * @param  ***REMOVED***String***REMOVED*** baseId base schema ID
 * @return ***REMOVED***Object***REMOVED*** object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) ***REMOVED***
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return ***REMOVED*** index: index, compiling: true ***REMOVED***;
  index = this._compilations.length;
  this._compilations[index] = ***REMOVED***
    schema: schema,
    root: root,
    baseId: baseId
  ***REMOVED***;
  return ***REMOVED*** index: index, compiling: false ***REMOVED***;
***REMOVED***


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  ***REMOVED***Object***REMOVED*** schema schema to compile
 * @param  ***REMOVED***Object***REMOVED*** root root object
 * @param  ***REMOVED***String***REMOVED*** baseId base schema ID
 */
function endCompiling(schema, root, baseId) ***REMOVED***
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
***REMOVED***


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  ***REMOVED***Object***REMOVED*** schema schema to compile
 * @param  ***REMOVED***Object***REMOVED*** root root object
 * @param  ***REMOVED***String***REMOVED*** baseId base schema ID
 * @return ***REMOVED***Integer***REMOVED*** compilation index
 */
function compIndex(schema, root, baseId) ***REMOVED***
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) ***REMOVED***
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  ***REMOVED***
  return -1;
***REMOVED***


function patternCode(i, patterns) ***REMOVED***
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
***REMOVED***


function defaultCode(i) ***REMOVED***
  return 'var default' + i + ' = defaults[' + i + '];';
***REMOVED***


function refValCode(i, refVal) ***REMOVED***
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
***REMOVED***


function customRuleCode(i) ***REMOVED***
  return 'var customRule' + i + ' = customRules[' + i + '];';
***REMOVED***


function vars(arr, statement) ***REMOVED***
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
***REMOVED***

***REMOVED***,***REMOVED***"../dotjs/validate":35,"./error_classes":5,"./resolve":8,"./util":12,"co":40,"fast-deep-equal":41,"fast-json-stable-stringify":42***REMOVED***],8:[function(require,module,exports)***REMOVED***
'use strict';

var url = require('url')
  , equal = require('fast-deep-equal')
  , util = require('./util')
  , SchemaObject = require('./schema_obj')
  , traverse = require('json-schema-traverse');

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  ***REMOVED***Function***REMOVED*** compile reference to schema compilation funciton (localCompile)
 * @param  ***REMOVED***Object***REMOVED*** root object with information about the root schema for the current schema
 * @param  ***REMOVED***String***REMOVED*** ref reference to resolve
 * @return ***REMOVED***Object|Function***REMOVED*** schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) ***REMOVED***
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') ***REMOVED***
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  ***REMOVED***

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) ***REMOVED***
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  ***REMOVED***

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) ***REMOVED***
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  ***REMOVED***

  if (schema instanceof SchemaObject) ***REMOVED***
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  ***REMOVED*** else if (schema !== undefined) ***REMOVED***
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  ***REMOVED***

  return v;
***REMOVED***


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  ***REMOVED***Object***REMOVED*** root root object with properties schema, refVal, refs
 * @param  ***REMOVED***String***REMOVED*** ref  reference to resolve
 * @return ***REMOVED***Object***REMOVED*** object with properties schema, root, baseId
 */
function resolveSchema(root, ref) ***REMOVED***
  /* jshint validthis: true */
  var p = url.parse(ref, false, true)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (refPath !== baseId) ***REMOVED***
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') ***REMOVED***
      return resolveRecursive.call(this, root, refVal, p);
    ***REMOVED*** else if (refVal instanceof SchemaObject) ***REMOVED***
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    ***REMOVED*** else ***REMOVED***
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) ***REMOVED***
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return ***REMOVED*** schema: refVal, root: root, baseId: baseId ***REMOVED***;
        root = refVal;
      ***REMOVED*** else ***REMOVED***
        return;
      ***REMOVED***
    ***REMOVED***
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  ***REMOVED***
  return getJsonPointer.call(this, p, baseId, root.schema, root);
***REMOVED***


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) ***REMOVED***
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) ***REMOVED***
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  ***REMOVED***
***REMOVED***


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) ***REMOVED***
  /* jshint validthis: true */
  parsedRef.hash = parsedRef.hash || '';
  if (parsedRef.hash.slice(0,2) != '#/') return;
  var parts = parsedRef.hash.split('/');

  for (var i = 1; i < parts.length; i++) ***REMOVED***
    var part = parts[i];
    if (part) ***REMOVED***
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) ***REMOVED***
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) ***REMOVED***
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) ***REMOVED***
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if (schema !== undefined && schema !== root.schema)
    return ***REMOVED*** schema: schema, root: root, baseId: baseId ***REMOVED***;
***REMOVED***


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) ***REMOVED***
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
***REMOVED***


function checkNoRef(schema) ***REMOVED***
  var item;
  if (Array.isArray(schema)) ***REMOVED***
    for (var i=0; i<schema.length; i++) ***REMOVED***
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    for (var key in schema) ***REMOVED***
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    ***REMOVED***
  ***REMOVED***
  return true;
***REMOVED***


function countKeys(schema) ***REMOVED***
  var count = 0, item;
  if (Array.isArray(schema)) ***REMOVED***
    for (var i=0; i<schema.length; i++) ***REMOVED***
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    for (var key in schema) ***REMOVED***
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) ***REMOVED***
        count++;
      ***REMOVED*** else ***REMOVED***
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return count;
***REMOVED***


function getFullPath(id, normalize) ***REMOVED***
  if (normalize !== false) id = normalizeId(id);
  var p = url.parse(id, false, true);
  return _getFullPath(p);
***REMOVED***


function _getFullPath(p) ***REMOVED***
  var protocolSeparator = p.protocol || p.href.slice(0,2) == '//' ? '//' : '';
  return (p.protocol||'') + protocolSeparator + (p.host||'') + (p.path||'')  + '#';
***REMOVED***


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) ***REMOVED***
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
***REMOVED***


function resolveUrl(baseId, id) ***REMOVED***
  id = normalizeId(id);
  return url.resolve(baseId, id);
***REMOVED***


/* @this Ajv */
function resolveIds(schema) ***REMOVED***
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = ***REMOVED***'': schemaId***REMOVED***;
  var fullPaths = ***REMOVED***'': getFullPath(schemaId, false)***REMOVED***;
  var localRefs = ***REMOVED******REMOVED***;
  var self = this;

  traverse(schema, ***REMOVED***allKeys: true***REMOVED***, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) ***REMOVED***
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') ***REMOVED***
      id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) ***REMOVED***
        if (!equal(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      ***REMOVED*** else if (id != normalizeId(fullPath)) ***REMOVED***
        if (id[0] == '#') ***REMOVED***
          if (localRefs[id] && !equal(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        ***REMOVED*** else ***REMOVED***
          self._refs[id] = fullPath;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  ***REMOVED***);

  return localRefs;
***REMOVED***

***REMOVED***,***REMOVED***"./schema_obj":10,"./util":12,"fast-deep-equal":41,"json-schema-traverse":43,"url":48***REMOVED***],9:[function(require,module,exports)***REMOVED***
'use strict';

var ruleModules = require('./_rules')
  , toHash = require('./util').toHash;

module.exports = function rules() ***REMOVED***
  var RULES = [
    ***REMOVED*** type: 'number',
      rules: [ ***REMOVED*** 'maximum': ['exclusiveMaximum'] ***REMOVED***,
               ***REMOVED*** 'minimum': ['exclusiveMinimum'] ***REMOVED***, 'multipleOf', 'format'] ***REMOVED***,
    ***REMOVED*** type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] ***REMOVED***,
    ***REMOVED*** type: 'array',
      rules: [ 'maxItems', 'minItems', 'uniqueItems', 'contains', 'items' ] ***REMOVED***,
    ***REMOVED*** type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               ***REMOVED*** 'properties': ['additionalProperties', 'patternProperties'] ***REMOVED*** ] ***REMOVED***,
    ***REMOVED*** rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf' ] ***REMOVED***
  ];

  var ALL = [ 'type' ];
  var KEYWORDS = [
    'additionalItems', '$schema', '$id', 'id', 'title',
    'description', 'default', 'definitions'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) ***REMOVED***
    group.rules = group.rules.map(function (keyword) ***REMOVED***
      var implKeywords;
      if (typeof keyword == 'object') ***REMOVED***
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) ***REMOVED***
          ALL.push(k);
          RULES.all[k] = true;
        ***REMOVED***);
      ***REMOVED***
      ALL.push(keyword);
      var rule = RULES.all[keyword] = ***REMOVED***
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      ***REMOVED***;
      return rule;
    ***REMOVED***);

    if (group.type) RULES.types[group.type] = group;
  ***REMOVED***);

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = ***REMOVED******REMOVED***;

  return RULES;
***REMOVED***;

***REMOVED***,***REMOVED***"./_rules":3,"./util":12***REMOVED***],10:[function(require,module,exports)***REMOVED***
'use strict';

var util = require('./util');

module.exports = SchemaObject;

function SchemaObject(obj) ***REMOVED***
  util.copy(obj, this);
***REMOVED***

***REMOVED***,***REMOVED***"./util":12***REMOVED***],11:[function(require,module,exports)***REMOVED***
'use strict';

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) ***REMOVED***
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) ***REMOVED***
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) ***REMOVED***
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    ***REMOVED***
  ***REMOVED***
  return length;
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],12:[function(require,module,exports)***REMOVED***
'use strict';


module.exports = ***REMOVED***
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: require('fast-deep-equal'),
  ucs2length: require('./ucs2length'),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  finalCleanUpCode: finalCleanUpCode,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
***REMOVED***;


function copy(o, to) ***REMOVED***
  to = to || ***REMOVED******REMOVED***;
  for (var key in o) to[key] = o[key];
  return to;
***REMOVED***


function checkDataType(dataType, data, negate) ***REMOVED***
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) ***REMOVED***
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  ***REMOVED***
***REMOVED***


function checkDataTypes(dataTypes, data) ***REMOVED***
  switch (dataTypes.length) ***REMOVED***
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) ***REMOVED***
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      ***REMOVED***
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

      return code;
  ***REMOVED***
***REMOVED***


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) ***REMOVED***
  if (Array.isArray(dataTypes)) ***REMOVED***
    var types = [];
    for (var i=0; i<dataTypes.length; i++) ***REMOVED***
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    ***REMOVED***
    if (types.length) return types;
  ***REMOVED*** else if (COERCE_TO_TYPES[dataTypes]) ***REMOVED***
    return [dataTypes];
  ***REMOVED*** else if (optionCoerceTypes === 'array' && dataTypes === 'array') ***REMOVED***
    return ['array'];
  ***REMOVED***
***REMOVED***


function toHash(arr) ***REMOVED***
  var hash = ***REMOVED******REMOVED***;
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
***REMOVED***


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) ***REMOVED***
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
***REMOVED***


function escapeQuotes(str) ***REMOVED***
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
***REMOVED***


function varOccurences(str, dataVar) ***REMOVED***
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
***REMOVED***


function varReplace(str, dataVar, expr) ***REMOVED***
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
***REMOVED***


var EMPTY_ELSE = /else\s****REMOVED***\s****REMOVED***/g
  , EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\***REMOVED***\s*\***REMOVED***(?!\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\***REMOVED***\s*\***REMOVED***\s*else(?!\s*if)/g;
function cleanUpCode(out) ***REMOVED***
  return out.replace(EMPTY_ELSE, '')
            .replace(EMPTY_IF_NO_ELSE, '')
            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
***REMOVED***


var ERRORS_REGEXP = /[^v.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = 'return errors === 0;'
  , RETURN_TRUE = 'validate.errors = null; return true;'
  , RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/
  , RETURN_DATA_ASYNC = 'return data;'
  , ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g
  , REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;

function finalCleanUpCode(out, async) ***REMOVED***
  var matches = out.match(ERRORS_REGEXP);
  if (matches && matches.length == 2) ***REMOVED***
    out = async
          ? out.replace(REMOVE_ERRORS_ASYNC, '')
               .replace(RETURN_ASYNC, RETURN_DATA_ASYNC)
          : out.replace(REMOVE_ERRORS, '')
               .replace(RETURN_VALID, RETURN_TRUE);
  ***REMOVED***

  matches = out.match(ROOTDATA_REGEXP);
  if (!matches || matches.length !== 3) return out;
  return out.replace(REMOVE_ROOTDATA, '');
***REMOVED***


function schemaHasRules(schema, rules) ***REMOVED***
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
***REMOVED***


function schemaHasRulesExcept(schema, rules, exceptKeyword) ***REMOVED***
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
***REMOVED***


function toQuotedString(str) ***REMOVED***
  return '\'' + escapeQuotes(str) + '\'';
***REMOVED***


function getPathExpr(currentPath, expr, jsonPointers, isNumber) ***REMOVED***
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
***REMOVED***


function getPath(currentPath, prop, jsonPointers) ***REMOVED***
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
***REMOVED***


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) ***REMOVED***
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') ***REMOVED***
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  ***REMOVED*** else ***REMOVED***
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') ***REMOVED***
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    ***REMOVED***

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  ***REMOVED***

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) ***REMOVED***
    var segment = segments[i];
    if (segment) ***REMOVED***
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    ***REMOVED***
  ***REMOVED***
  return expr;
***REMOVED***


function joinPaths (a, b) ***REMOVED***
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/' \+ '/g, '');
***REMOVED***


function unescapeFragment(str) ***REMOVED***
  return unescapeJsonPointer(decodeURIComponent(str));
***REMOVED***


function escapeFragment(str) ***REMOVED***
  return encodeURIComponent(escapeJsonPointer(str));
***REMOVED***


function escapeJsonPointer(str) ***REMOVED***
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
***REMOVED***


function unescapeJsonPointer(str) ***REMOVED***
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
***REMOVED***

***REMOVED***,***REMOVED***"./ucs2length":11,"fast-deep-equal":41***REMOVED***],13:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate__limit(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if ($isDataExcl) ***REMOVED***
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') ***REMOVED*** ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) ***REMOVED***
      out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED******REMOVED*** ';
      if (it.opts.messages !== false) ***REMOVED***
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      ***REMOVED***
      if (it.opts.verbose) ***REMOVED***
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED*** else ***REMOVED***
      out += ' ***REMOVED******REMOVED*** ';
    ***REMOVED***
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
      if (it.async) ***REMOVED***
        out += ' throw new ValidationError([' + (__err) + ']); ';
      ***REMOVED*** else ***REMOVED***
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    ***REMOVED***
    out += ' ***REMOVED*** else if ( ';
    if ($isData) ***REMOVED***
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    ***REMOVED***
    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') ***REMOVED*** var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\';';
  ***REMOVED*** else ***REMOVED***
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) ***REMOVED***
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) ***REMOVED***
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      ***REMOVED***
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') ***REMOVED*** ';
    ***REMOVED*** else ***REMOVED***
      if ($exclIsNumber && $schema === undefined) ***REMOVED***
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      ***REMOVED*** else ***REMOVED***
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) ***REMOVED***
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        ***REMOVED*** else ***REMOVED***
          $exclusive = false;
          $opStr += '=';
        ***REMOVED***
      ***REMOVED***
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) ***REMOVED***
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      ***REMOVED***
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED***
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' ***REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) ***REMOVED***
        out += '\' + ' + ($schemaValue);
      ***REMOVED*** else ***REMOVED***
        out += '' + ($schemaValue) + '\'';
      ***REMOVED***
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema:  ';
      if ($isData) ***REMOVED***
        out += 'validate.schema' + ($schemaPath);
      ***REMOVED*** else ***REMOVED***
        out += '' + ($schema);
      ***REMOVED***
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError([' + (__err) + ']); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  ***REMOVED***
  out += ' ***REMOVED*** ';
  if ($breakOnError) ***REMOVED***
    out += ' else ***REMOVED*** ';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],14:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate__limitItems(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) ***REMOVED***
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  ***REMOVED***
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') ***REMOVED*** ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** limit: ' + ($schemaValue) + ' ***REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') ***REMOVED***
        out += 'more';
      ***REMOVED*** else ***REMOVED***
        out += 'less';
      ***REMOVED***
      out += ' than ';
      if ($isData) ***REMOVED***
        out += '\' + ' + ($schemaValue) + ' + \'';
      ***REMOVED*** else ***REMOVED***
        out += '' + ($schema);
      ***REMOVED***
      out += ' items\' ';
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema:  ';
      if ($isData) ***REMOVED***
        out += 'validate.schema' + ($schemaPath);
      ***REMOVED*** else ***REMOVED***
        out += '' + ($schema);
      ***REMOVED***
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError([' + (__err) + ']); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  ***REMOVED***
  out += '***REMOVED*** ';
  if ($breakOnError) ***REMOVED***
    out += ' else ***REMOVED*** ';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],15:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate__limitLength(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) ***REMOVED***
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  ***REMOVED***
  if (it.opts.unicode === false) ***REMOVED***
    out += ' ' + ($data) + '.length ';
  ***REMOVED*** else ***REMOVED***
    out += ' ucs2length(' + ($data) + ') ';
  ***REMOVED***
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') ***REMOVED*** ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** limit: ' + ($schemaValue) + ' ***REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') ***REMOVED***
        out += 'longer';
      ***REMOVED*** else ***REMOVED***
        out += 'shorter';
      ***REMOVED***
      out += ' than ';
      if ($isData) ***REMOVED***
        out += '\' + ' + ($schemaValue) + ' + \'';
      ***REMOVED*** else ***REMOVED***
        out += '' + ($schema);
      ***REMOVED***
      out += ' characters\' ';
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema:  ';
      if ($isData) ***REMOVED***
        out += 'validate.schema' + ($schemaPath);
      ***REMOVED*** else ***REMOVED***
        out += '' + ($schema);
      ***REMOVED***
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError([' + (__err) + ']); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  ***REMOVED***
  out += '***REMOVED*** ';
  if ($breakOnError) ***REMOVED***
    out += ' else ***REMOVED*** ';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],16:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate__limitProperties(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) ***REMOVED***
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  ***REMOVED***
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') ***REMOVED*** ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** limit: ' + ($schemaValue) + ' ***REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') ***REMOVED***
        out += 'more';
      ***REMOVED*** else ***REMOVED***
        out += 'less';
      ***REMOVED***
      out += ' than ';
      if ($isData) ***REMOVED***
        out += '\' + ' + ($schemaValue) + ' + \'';
      ***REMOVED*** else ***REMOVED***
        out += '' + ($schema);
      ***REMOVED***
      out += ' properties\' ';
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema:  ';
      if ($isData) ***REMOVED***
        out += 'validate.schema' + ($schemaPath);
      ***REMOVED*** else ***REMOVED***
        out += '' + ($schema);
      ***REMOVED***
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError([' + (__err) + ']); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  ***REMOVED***
  out += '***REMOVED*** ';
  if ($breakOnError) ***REMOVED***
    out += ' else ***REMOVED*** ';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],17:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_allOf(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) ***REMOVED***
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) ***REMOVED***
      $sch = arr1[$i += 1];
      if (it.util.schemaHasRules($sch, it.RULES.all)) ***REMOVED***
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) ***REMOVED***
          out += ' if (' + ($nextValid) + ') ***REMOVED*** ';
          $closingBraces += '***REMOVED***';
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if ($breakOnError) ***REMOVED***
    if ($allSchemasEmpty) ***REMOVED***
      out += ' if (true) ***REMOVED*** ';
    ***REMOVED*** else ***REMOVED***
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    ***REMOVED***
  ***REMOVED***
  out = it.util.cleanUpCode(out);
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],18:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_anyOf(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) ***REMOVED***
    return it.util.schemaHasRules($sch, it.RULES.all);
  ***REMOVED***);
  if ($noEmptySchema) ***REMOVED***
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) ***REMOVED***
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) ***REMOVED***
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') ***REMOVED*** ';
        $closingBraces += '***REMOVED***';
      ***REMOVED***
    ***REMOVED***
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') ***REMOVED***   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) ***REMOVED***
      out += ' ***REMOVED*** keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED******REMOVED*** ';
      if (it.opts.messages !== false) ***REMOVED***
        out += ' , message: \'should match some schema in anyOf\' ';
      ***REMOVED***
      if (it.opts.verbose) ***REMOVED***
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED*** else ***REMOVED***
      out += ' ***REMOVED******REMOVED*** ';
    ***REMOVED***
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
      if (it.async) ***REMOVED***
        out += ' throw new ValidationError(vErrors); ';
      ***REMOVED*** else ***REMOVED***
        out += ' validate.errors = vErrors; return false; ';
      ***REMOVED***
    ***REMOVED***
    out += ' ***REMOVED*** else ***REMOVED***  errors = ' + ($errs) + '; if (vErrors !== null) ***REMOVED*** if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; ***REMOVED*** ';
    if (it.opts.allErrors) ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED***
    out = it.util.cleanUpCode(out);
  ***REMOVED*** else ***REMOVED***
    if ($breakOnError) ***REMOVED***
      out += ' if (true) ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],19:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_const(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  if (!$isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  ***REMOVED***
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') ***REMOVED***   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED******REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should be equal to constant\' ';
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError([' + (__err) + ']); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  ***REMOVED***
  out += ' ***REMOVED***';
  if ($breakOnError) ***REMOVED***
    out += ' else ***REMOVED*** ';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],20:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_contains(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = it.util.schemaHasRules($schema, it.RULES.all);
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) ***REMOVED***
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) ***REMOVED*** ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) ***REMOVED***
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    ***REMOVED*** else ***REMOVED***
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    ***REMOVED***
    out += ' if (' + ($nextValid) + ') break; ***REMOVED***  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') ***REMOVED***';
  ***REMOVED*** else ***REMOVED***
    out += ' if (' + ($data) + '.length == 0) ***REMOVED***';
  ***REMOVED***
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED******REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should contain a valid item\' ';
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError([' + (__err) + ']); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  ***REMOVED***
  out += ' ***REMOVED*** else ***REMOVED*** ';
  if ($nonEmptySchema) ***REMOVED***
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) ***REMOVED*** if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; ***REMOVED*** ';
  ***REMOVED***
  if (it.opts.allErrors) ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED***
  out = it.util.cleanUpCode(out);
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],21:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_custom(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) ***REMOVED***
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  ***REMOVED*** else ***REMOVED***
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  ***REMOVED***
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) ***REMOVED***
    out += '' + ($ruleErrs) + ' = null;';
  ***REMOVED***
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) ***REMOVED***
    $closingBraces += '***REMOVED***';
    out += ' if (' + ($schemaValue) + ' === undefined) ***REMOVED*** ' + ($valid) + ' = true; ***REMOVED*** else ***REMOVED*** ';
    if ($validateSchema) ***REMOVED***
      $closingBraces += '***REMOVED***';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED***
  if ($inline) ***REMOVED***
    if ($rDef.statements) ***REMOVED***
      out += ' ' + ($ruleValidate.validate) + ' ';
    ***REMOVED*** else ***REMOVED***
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    ***REMOVED***
  ***REMOVED*** else if ($macro) ***REMOVED***
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  ***REMOVED*** else ***REMOVED***
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) ***REMOVED***
      out += 'this';
    ***REMOVED*** else ***REMOVED***
      out += 'self';
    ***REMOVED***
    if ($compile || $rDef.schema === false) ***REMOVED***
      out += ' , ' + ($data) + ' ';
    ***REMOVED*** else ***REMOVED***
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    ***REMOVED***
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') ***REMOVED***
      out += ' + ' + (it.errorPath);
    ***REMOVED***
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) ***REMOVED***
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) ***REMOVED***
        out += '' + (it.yieldAwait);
      ***REMOVED***
      out += '' + (def_callRuleValidate) + '; ';
    ***REMOVED*** else ***REMOVED***
      if ($asyncKeyword) ***REMOVED***
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try ***REMOVED*** ' + ($valid) + ' = ' + (it.yieldAwait) + (def_callRuleValidate) + '; ***REMOVED*** catch (e) ***REMOVED*** ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; ***REMOVED*** ';
      ***REMOVED*** else ***REMOVED***
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if ($rDef.modifying) ***REMOVED***
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  ***REMOVED***
  out += '' + ($closingBraces);
  if ($rDef.valid) ***REMOVED***
    if ($breakOnError) ***REMOVED***
      out += ' if (true) ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' if ( ';
    if ($rDef.valid === undefined) ***REMOVED***
      out += ' !';
      if ($macro) ***REMOVED***
        out += '' + ($nextValid);
      ***REMOVED*** else ***REMOVED***
        out += '' + ($valid);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      out += ' ' + (!$rDef.valid) + ' ';
    ***REMOVED***
    out += ') ***REMOVED*** ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) ***REMOVED***
      out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** keyword: \'' + ($rule.keyword) + '\' ***REMOVED*** ';
      if (it.opts.messages !== false) ***REMOVED***
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      ***REMOVED***
      if (it.opts.verbose) ***REMOVED***
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED*** else ***REMOVED***
      out += ' ***REMOVED******REMOVED*** ';
    ***REMOVED***
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
      if (it.async) ***REMOVED***
        out += ' throw new ValidationError([' + (__err) + ']); ';
      ***REMOVED*** else ***REMOVED***
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    ***REMOVED***
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) ***REMOVED***
      if ($rDef.errors) ***REMOVED***
        if ($rDef.errors != 'full') ***REMOVED***
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) ***REMOVED*** var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) ***REMOVED*** ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; ***REMOVED*** ';
          if (it.opts.verbose) ***REMOVED***
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          ***REMOVED***
          out += ' ***REMOVED*** ';
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        if ($rDef.errors === false) ***REMOVED***
          out += ' ' + (def_customError) + ' ';
        ***REMOVED*** else ***REMOVED***
          out += ' if (' + ($errs) + ' == errors) ***REMOVED*** ' + (def_customError) + ' ***REMOVED*** else ***REMOVED***  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) ***REMOVED*** var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) ***REMOVED*** ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; ***REMOVED*** ';
          if (it.opts.verbose) ***REMOVED***
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          ***REMOVED***
          out += ' ***REMOVED*** ***REMOVED*** ';
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else if ($macro) ***REMOVED***
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) ***REMOVED***
        out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** keyword: \'' + ($rule.keyword) + '\' ***REMOVED*** ';
        if (it.opts.messages !== false) ***REMOVED***
          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
        ***REMOVED***
        if (it.opts.verbose) ***REMOVED***
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        ***REMOVED***
        out += ' ***REMOVED*** ';
      ***REMOVED*** else ***REMOVED***
        out += ' ***REMOVED******REMOVED*** ';
      ***REMOVED***
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
        if (it.async) ***REMOVED***
          out += ' throw new ValidationError(vErrors); ';
        ***REMOVED*** else ***REMOVED***
          out += ' validate.errors = vErrors; return false; ';
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if ($rDef.errors === false) ***REMOVED***
        out += ' ' + (def_customError) + ' ';
      ***REMOVED*** else ***REMOVED***
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) ***REMOVED*** if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) ***REMOVED*** var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) ***REMOVED***
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        ***REMOVED***
        out += ' ***REMOVED*** ***REMOVED*** else ***REMOVED*** ' + (def_customError) + ' ***REMOVED*** ';
      ***REMOVED***
    ***REMOVED***
    out += ' ***REMOVED*** ';
    if ($breakOnError) ***REMOVED***
      out += ' else ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],22:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_dependencies(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = ***REMOVED******REMOVED***,
    $propertyDeps = ***REMOVED******REMOVED***,
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) ***REMOVED***
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  ***REMOVED***
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) ***REMOVED***
    $deps = $propertyDeps[$property];
    if ($deps.length) ***REMOVED***
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) ***REMOVED***
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      ***REMOVED***
      if ($breakOnError) ***REMOVED***
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) ***REMOVED***
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) ***REMOVED***
            $propertyKey = arr1[$i += 1];
            if ($i) ***REMOVED***
              out += ' || ';
            ***REMOVED***
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) ***REMOVED***
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            ***REMOVED***
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          ***REMOVED***
        ***REMOVED***
        out += ')) ***REMOVED***  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) ***REMOVED***
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        ***REMOVED***
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) ***REMOVED***
          out += ' ***REMOVED*** keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' ***REMOVED*** ';
          if (it.opts.messages !== false) ***REMOVED***
            out += ' , message: \'should have ';
            if ($deps.length == 1) ***REMOVED***
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            ***REMOVED*** else ***REMOVED***
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            ***REMOVED***
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
          ***REMOVED***
          if (it.opts.verbose) ***REMOVED***
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          ***REMOVED***
          out += ' ***REMOVED*** ';
        ***REMOVED*** else ***REMOVED***
          out += ' ***REMOVED******REMOVED*** ';
        ***REMOVED***
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
          if (it.async) ***REMOVED***
            out += ' throw new ValidationError([' + (__err) + ']); ';
          ***REMOVED*** else ***REMOVED***
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        out += ' ) ***REMOVED*** ';
        var arr2 = $deps;
        if (arr2) ***REMOVED***
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) ***REMOVED***
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) ***REMOVED***
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            ***REMOVED***
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) ***REMOVED***
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            ***REMOVED***
            out += ') ***REMOVED***  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) ***REMOVED***
              out += ' ***REMOVED*** keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' ***REMOVED*** ';
              if (it.opts.messages !== false) ***REMOVED***
                out += ' , message: \'should have ';
                if ($deps.length == 1) ***REMOVED***
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                ***REMOVED*** else ***REMOVED***
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                ***REMOVED***
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              ***REMOVED***
              if (it.opts.verbose) ***REMOVED***
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              ***REMOVED***
              out += ' ***REMOVED*** ';
            ***REMOVED*** else ***REMOVED***
              out += ' ***REMOVED******REMOVED*** ';
            ***REMOVED***
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ***REMOVED*** ';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      out += ' ***REMOVED***   ';
      if ($breakOnError) ***REMOVED***
        $closingBraces += '***REMOVED***';
        out += ' else ***REMOVED*** ';
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) ***REMOVED***
    var $sch = $schemaDeps[$property];
    if (it.util.schemaHasRules($sch, it.RULES.all)) ***REMOVED***
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) ***REMOVED***
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      ***REMOVED***
      out += ') ***REMOVED*** ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ***REMOVED***  ';
      if ($breakOnError) ***REMOVED***
        out += ' if (' + ($nextValid) + ') ***REMOVED*** ';
        $closingBraces += '***REMOVED***';
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if ($breakOnError) ***REMOVED***
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) ***REMOVED***';
  ***REMOVED***
  out = it.util.cleanUpCode(out);
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],23:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_enum(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) ***REMOVED***
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  ***REMOVED***
  out += 'var ' + ($valid) + ';';
  if ($isData) ***REMOVED***
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else ***REMOVED***';
  ***REMOVED***
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) ***REMOVED*** ' + ($valid) + ' = true; break; ***REMOVED***';
  if ($isData) ***REMOVED***
    out += '  ***REMOVED***  ';
  ***REMOVED***
  out += ' if (!' + ($valid) + ') ***REMOVED***   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** allowedValues: schema' + ($lvl) + ' ***REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should be equal to one of the allowed values\' ';
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError([' + (__err) + ']); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  ***REMOVED***
  out += ' ***REMOVED***';
  if ($breakOnError) ***REMOVED***
    out += ' else ***REMOVED*** ';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],24:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_format(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) ***REMOVED***
    if ($breakOnError) ***REMOVED***
      out += ' if (true) ***REMOVED*** ';
    ***REMOVED***
    return out;
  ***REMOVED***
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) ***REMOVED***
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') ***REMOVED*** ';
    if (it.async) ***REMOVED***
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    ***REMOVED***
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; ***REMOVED*** if (  ';
    if ($isData) ***REMOVED***
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    ***REMOVED***
    out += ' (';
    if ($unknownFormats != 'ignore') ***REMOVED***
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) ***REMOVED***
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      ***REMOVED***
      out += ') || ';
    ***REMOVED***
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) ***REMOVED***
      out += ' (async' + ($lvl) + ' ? ' + (it.yieldAwait) + ' ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    ***REMOVED*** else ***REMOVED***
      out += ' ' + ($format) + '(' + ($data) + ') ';
    ***REMOVED***
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) ***REMOVED***';
  ***REMOVED*** else ***REMOVED***
    var $format = it.formats[$schema];
    if (!$format) ***REMOVED***
      if ($unknownFormats == 'ignore') ***REMOVED***
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) ***REMOVED***
          out += ' if (true) ***REMOVED*** ';
        ***REMOVED***
        return out;
      ***REMOVED*** else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) ***REMOVED***
        if ($breakOnError) ***REMOVED***
          out += ' if (true) ***REMOVED*** ';
        ***REMOVED***
        return out;
      ***REMOVED*** else ***REMOVED***
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      ***REMOVED***
    ***REMOVED***
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) ***REMOVED***
      var $async = $format.async === true;
      $format = $format.validate;
    ***REMOVED***
    if ($formatType != $ruleType) ***REMOVED***
      if ($breakOnError) ***REMOVED***
        out += ' if (true) ***REMOVED*** ';
      ***REMOVED***
      return out;
    ***REMOVED***
    if ($async) ***REMOVED***
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(' + (it.yieldAwait) + ' ' + ($formatRef) + '(' + ($data) + '))) ***REMOVED*** ';
    ***REMOVED*** else ***REMOVED***
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') ***REMOVED***
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      ***REMOVED*** else ***REMOVED***
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      ***REMOVED***
      out += ') ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED***
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** format:  ';
    if ($isData) ***REMOVED***
      out += '' + ($schemaValue);
    ***REMOVED*** else ***REMOVED***
      out += '' + (it.util.toQuotedString($schema));
    ***REMOVED***
    out += '  ***REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should match format "';
      if ($isData) ***REMOVED***
        out += '\' + ' + ($schemaValue) + ' + \'';
      ***REMOVED*** else ***REMOVED***
        out += '' + (it.util.escapeQuotes($schema));
      ***REMOVED***
      out += '"\' ';
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema:  ';
      if ($isData) ***REMOVED***
        out += 'validate.schema' + ($schemaPath);
      ***REMOVED*** else ***REMOVED***
        out += '' + (it.util.toQuotedString($schema));
      ***REMOVED***
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError([' + (__err) + ']); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  ***REMOVED***
  out += ' ***REMOVED*** ';
  if ($breakOnError) ***REMOVED***
    out += ' else ***REMOVED*** ';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],25:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_items(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) ***REMOVED***
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) ***REMOVED***
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') ***REMOVED***   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) ***REMOVED***
        out += ' ***REMOVED*** keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** limit: ' + ($schema.length) + ' ***REMOVED*** ';
        if (it.opts.messages !== false) ***REMOVED***
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        ***REMOVED***
        if (it.opts.verbose) ***REMOVED***
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        ***REMOVED***
        out += ' ***REMOVED*** ';
      ***REMOVED*** else ***REMOVED***
        out += ' ***REMOVED******REMOVED*** ';
      ***REMOVED***
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
        if (it.async) ***REMOVED***
          out += ' throw new ValidationError([' + (__err) + ']); ';
        ***REMOVED*** else ***REMOVED***
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      ***REMOVED***
      out += ' ***REMOVED*** ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) ***REMOVED***
        $closingBraces += '***REMOVED***';
        out += ' else ***REMOVED*** ';
      ***REMOVED***
    ***REMOVED***
    var arr1 = $schema;
    if (arr1) ***REMOVED***
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) ***REMOVED***
        $sch = arr1[$i += 1];
        if (it.util.schemaHasRules($sch, it.RULES.all)) ***REMOVED***
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') ***REMOVED*** ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) ***REMOVED***
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          ***REMOVED*** else ***REMOVED***
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          ***REMOVED***
          out += ' ***REMOVED***  ';
          if ($breakOnError) ***REMOVED***
            out += ' if (' + ($nextValid) + ') ***REMOVED*** ';
            $closingBraces += '***REMOVED***';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) ***REMOVED***
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') ***REMOVED***  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) ***REMOVED*** ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) ***REMOVED***
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      ***REMOVED*** else ***REMOVED***
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      ***REMOVED***
      if ($breakOnError) ***REMOVED***
        out += ' if (!' + ($nextValid) + ') break; ';
      ***REMOVED***
      out += ' ***REMOVED*** ***REMOVED***  ';
      if ($breakOnError) ***REMOVED***
        out += ' if (' + ($nextValid) + ') ***REMOVED*** ';
        $closingBraces += '***REMOVED***';
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if (it.util.schemaHasRules($schema, it.RULES.all)) ***REMOVED***
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) ***REMOVED*** ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) ***REMOVED***
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    ***REMOVED*** else ***REMOVED***
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    ***REMOVED***
    if ($breakOnError) ***REMOVED***
      out += ' if (!' + ($nextValid) + ') break; ';
    ***REMOVED***
    out += ' ***REMOVED***';
  ***REMOVED***
  if ($breakOnError) ***REMOVED***
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) ***REMOVED***';
  ***REMOVED***
  out = it.util.cleanUpCode(out);
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],26:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_multipleOf(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) ***REMOVED***
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  ***REMOVED***
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) ***REMOVED***
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  ***REMOVED*** else ***REMOVED***
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  ***REMOVED***
  out += ' ) ';
  if ($isData) ***REMOVED***
    out += '  )  ';
  ***REMOVED***
  out += ' ) ***REMOVED***   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** multipleOf: ' + ($schemaValue) + ' ***REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should be multiple of ';
      if ($isData) ***REMOVED***
        out += '\' + ' + ($schemaValue);
      ***REMOVED*** else ***REMOVED***
        out += '' + ($schemaValue) + '\'';
      ***REMOVED***
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema:  ';
      if ($isData) ***REMOVED***
        out += 'validate.schema' + ($schemaPath);
      ***REMOVED*** else ***REMOVED***
        out += '' + ($schema);
      ***REMOVED***
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError([' + (__err) + ']); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  ***REMOVED***
  out += '***REMOVED*** ';
  if ($breakOnError) ***REMOVED***
    out += ' else ***REMOVED*** ';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],27:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_not(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if (it.util.schemaHasRules($schema, it.RULES.all)) ***REMOVED***
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) ***REMOVED***
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    ***REMOVED***
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') ***REMOVED***   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) ***REMOVED***
      out += ' ***REMOVED*** keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED******REMOVED*** ';
      if (it.opts.messages !== false) ***REMOVED***
        out += ' , message: \'should NOT be valid\' ';
      ***REMOVED***
      if (it.opts.verbose) ***REMOVED***
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED*** else ***REMOVED***
      out += ' ***REMOVED******REMOVED*** ';
    ***REMOVED***
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
      if (it.async) ***REMOVED***
        out += ' throw new ValidationError([' + (__err) + ']); ';
      ***REMOVED*** else ***REMOVED***
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    ***REMOVED***
    out += ' ***REMOVED*** else ***REMOVED***  errors = ' + ($errs) + '; if (vErrors !== null) ***REMOVED*** if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; ***REMOVED*** ';
    if (it.opts.allErrors) ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) ***REMOVED***
      out += ' ***REMOVED*** keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED******REMOVED*** ';
      if (it.opts.messages !== false) ***REMOVED***
        out += ' , message: \'should NOT be valid\' ';
      ***REMOVED***
      if (it.opts.verbose) ***REMOVED***
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED*** else ***REMOVED***
      out += ' ***REMOVED******REMOVED*** ';
    ***REMOVED***
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) ***REMOVED***
      out += ' if (false) ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],28:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_oneOf(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;var prevValid' + ($lvl) + ' = false;var ' + ($valid) + ' = false;';
  var $currentBaseId = $it.baseId;
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) ***REMOVED***
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) ***REMOVED***
      $sch = arr1[$i += 1];
      if (it.util.schemaHasRules($sch, it.RULES.all)) ***REMOVED***
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      ***REMOVED*** else ***REMOVED***
        out += ' var ' + ($nextValid) + ' = true; ';
      ***REMOVED***
      if ($i) ***REMOVED***
        out += ' if (' + ($nextValid) + ' && prevValid' + ($lvl) + ') ' + ($valid) + ' = false; else ***REMOVED*** ';
        $closingBraces += '***REMOVED***';
      ***REMOVED***
      out += ' if (' + ($nextValid) + ') ' + ($valid) + ' = prevValid' + ($lvl) + ' = true;';
    ***REMOVED***
  ***REMOVED***
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') ***REMOVED***   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED******REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError(vErrors); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = vErrors; return false; ';
    ***REMOVED***
  ***REMOVED***
  out += '***REMOVED*** else ***REMOVED***  errors = ' + ($errs) + '; if (vErrors !== null) ***REMOVED*** if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; ***REMOVED***';
  if (it.opts.allErrors) ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],29:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_pattern(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) ***REMOVED***
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  ***REMOVED***
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) ***REMOVED***   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) ***REMOVED***
    out += ' ***REMOVED*** keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** pattern:  ';
    if ($isData) ***REMOVED***
      out += '' + ($schemaValue);
    ***REMOVED*** else ***REMOVED***
      out += '' + (it.util.toQuotedString($schema));
    ***REMOVED***
    out += '  ***REMOVED*** ';
    if (it.opts.messages !== false) ***REMOVED***
      out += ' , message: \'should match pattern "';
      if ($isData) ***REMOVED***
        out += '\' + ' + ($schemaValue) + ' + \'';
      ***REMOVED*** else ***REMOVED***
        out += '' + (it.util.escapeQuotes($schema));
      ***REMOVED***
      out += '"\' ';
    ***REMOVED***
    if (it.opts.verbose) ***REMOVED***
      out += ' , schema:  ';
      if ($isData) ***REMOVED***
        out += 'validate.schema' + ($schemaPath);
      ***REMOVED*** else ***REMOVED***
        out += '' + (it.util.toQuotedString($schema));
      ***REMOVED***
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
  ***REMOVED*** else ***REMOVED***
    out += ' ***REMOVED******REMOVED*** ';
  ***REMOVED***
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
    if (it.async) ***REMOVED***
      out += ' throw new ValidationError([' + (__err) + ']); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  ***REMOVED***
  out += '***REMOVED*** ';
  if ($breakOnError) ***REMOVED***
    out += ' else ***REMOVED*** ';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],30:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_properties(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || ***REMOVED******REMOVED***),
    $pProperties = it.schema.patternProperties || ***REMOVED******REMOVED***,
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  if (it.opts.patternGroups) ***REMOVED***
    var $pgProperties = it.schema.patternGroups || ***REMOVED******REMOVED***,
      $pgPropertyKeys = Object.keys($pgProperties);
  ***REMOVED***
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) ***REMOVED***
    out += ' var ' + ($dataProperties) + ' = undefined;';
  ***REMOVED***
  if ($checkAdditional) ***REMOVED***
    if ($ownProperties) ***REMOVED***
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) ***REMOVED*** var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    ***REMOVED*** else ***REMOVED***
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') ***REMOVED*** ';
    ***REMOVED***
    if ($someProperties) ***REMOVED***
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) ***REMOVED***
        if ($schemaKeys.length > 5) ***REMOVED***
          out += ' || validate.schema' + ($schemaPath) + '[' + ($key) + '] ';
        ***REMOVED*** else ***REMOVED***
          var arr1 = $schemaKeys;
          if (arr1) ***REMOVED***
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) ***REMOVED***
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      if ($pPropertyKeys.length) ***REMOVED***
        var arr2 = $pPropertyKeys;
        if (arr2) ***REMOVED***
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) ***REMOVED***
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      if (it.opts.patternGroups && $pgPropertyKeys.length) ***REMOVED***
        var arr3 = $pgPropertyKeys;
        if (arr3) ***REMOVED***
          var $pgProperty, $i = -1,
            l3 = arr3.length - 1;
          while ($i < l3) ***REMOVED***
            $pgProperty = arr3[$i += 1];
            out += ' || ' + (it.usePattern($pgProperty)) + '.test(' + ($key) + ') ';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      out += ' ); if (isAdditional' + ($lvl) + ') ***REMOVED*** ';
    ***REMOVED***
    if ($removeAdditional == 'all') ***REMOVED***
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    ***REMOVED*** else ***REMOVED***
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) ***REMOVED***
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      ***REMOVED***
      if ($noAdditional) ***REMOVED***
        if ($removeAdditional) ***REMOVED***
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        ***REMOVED*** else ***REMOVED***
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) ***REMOVED***
            out += ' ***REMOVED*** keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** additionalProperty: \'' + ($additionalProperty) + '\' ***REMOVED*** ';
            if (it.opts.messages !== false) ***REMOVED***
              out += ' , message: \'should NOT have additional properties\' ';
            ***REMOVED***
            if (it.opts.verbose) ***REMOVED***
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            ***REMOVED***
            out += ' ***REMOVED*** ';
          ***REMOVED*** else ***REMOVED***
            out += ' ***REMOVED******REMOVED*** ';
          ***REMOVED***
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
            if (it.async) ***REMOVED***
              out += ' throw new ValidationError([' + (__err) + ']); ';
            ***REMOVED*** else ***REMOVED***
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            ***REMOVED***
          ***REMOVED*** else ***REMOVED***
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          ***REMOVED***
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) ***REMOVED***
            out += ' break; ';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED*** else if ($additionalIsSchema) ***REMOVED***
        if ($removeAdditional == 'failing') ***REMOVED***
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) ***REMOVED***
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          ***REMOVED*** else ***REMOVED***
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          ***REMOVED***
          out += ' if (!' + ($nextValid) + ') ***REMOVED*** errors = ' + ($errs) + '; if (validate.errors !== null) ***REMOVED*** if (errors) validate.errors.length = errors; else validate.errors = null; ***REMOVED*** delete ' + ($data) + '[' + ($key) + ']; ***REMOVED***  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        ***REMOVED*** else ***REMOVED***
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) ***REMOVED***
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          ***REMOVED*** else ***REMOVED***
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          ***REMOVED***
          if ($breakOnError) ***REMOVED***
            out += ' if (!' + ($nextValid) + ') break; ';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      it.errorPath = $currentErrorPath;
    ***REMOVED***
    if ($someProperties) ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED***
    out += ' ***REMOVED***  ';
    if ($breakOnError) ***REMOVED***
      out += ' if (' + ($nextValid) + ') ***REMOVED*** ';
      $closingBraces += '***REMOVED***';
    ***REMOVED***
  ***REMOVED***
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) ***REMOVED***
    var arr4 = $schemaKeys;
    if (arr4) ***REMOVED***
      var $propertyKey, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) ***REMOVED***
        $propertyKey = arr4[i4 += 1];
        var $sch = $schema[$propertyKey];
        if (it.util.schemaHasRules($sch, it.RULES.all)) ***REMOVED***
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) ***REMOVED***
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          ***REMOVED*** else ***REMOVED***
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          ***REMOVED***
          if ($hasDefault) ***REMOVED***
            out += ' ' + ($code) + ' ';
          ***REMOVED*** else ***REMOVED***
            if ($requiredHash && $requiredHash[$propertyKey]) ***REMOVED***
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) ***REMOVED***
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
              ***REMOVED***
              out += ') ***REMOVED*** ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) ***REMOVED***
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              ***REMOVED***
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) ***REMOVED***
                out += ' ***REMOVED*** keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** missingProperty: \'' + ($missingProperty) + '\' ***REMOVED*** ';
                if (it.opts.messages !== false) ***REMOVED***
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) ***REMOVED***
                    out += 'is a required property';
                  ***REMOVED*** else ***REMOVED***
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  ***REMOVED***
                  out += '\' ';
                ***REMOVED***
                if (it.opts.verbose) ***REMOVED***
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                ***REMOVED***
                out += ' ***REMOVED*** ';
              ***REMOVED*** else ***REMOVED***
                out += ' ***REMOVED******REMOVED*** ';
              ***REMOVED***
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
                if (it.async) ***REMOVED***
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                ***REMOVED*** else ***REMOVED***
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              ***REMOVED***
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' ***REMOVED*** else ***REMOVED*** ';
            ***REMOVED*** else ***REMOVED***
              if ($breakOnError) ***REMOVED***
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) ***REMOVED***
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                ***REMOVED***
                out += ') ***REMOVED*** ' + ($nextValid) + ' = true; ***REMOVED*** else ***REMOVED*** ';
              ***REMOVED*** else ***REMOVED***
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) ***REMOVED***
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                ***REMOVED***
                out += ' ) ***REMOVED*** ';
              ***REMOVED***
            ***REMOVED***
            out += ' ' + ($code) + ' ***REMOVED*** ';
          ***REMOVED***
        ***REMOVED***
        if ($breakOnError) ***REMOVED***
          out += ' if (' + ($nextValid) + ') ***REMOVED*** ';
          $closingBraces += '***REMOVED***';
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if ($pPropertyKeys.length) ***REMOVED***
    var arr5 = $pPropertyKeys;
    if (arr5) ***REMOVED***
      var $pProperty, i5 = -1,
        l5 = arr5.length - 1;
      while (i5 < l5) ***REMOVED***
        $pProperty = arr5[i5 += 1];
        var $sch = $pProperties[$pProperty];
        if (it.util.schemaHasRules($sch, it.RULES.all)) ***REMOVED***
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) ***REMOVED***
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) ***REMOVED*** var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          ***REMOVED*** else ***REMOVED***
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') ***REMOVED*** ';
          ***REMOVED***
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) ***REMOVED*** ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) ***REMOVED***
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          ***REMOVED*** else ***REMOVED***
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          ***REMOVED***
          if ($breakOnError) ***REMOVED***
            out += ' if (!' + ($nextValid) + ') break; ';
          ***REMOVED***
          out += ' ***REMOVED*** ';
          if ($breakOnError) ***REMOVED***
            out += ' else ' + ($nextValid) + ' = true; ';
          ***REMOVED***
          out += ' ***REMOVED***  ';
          if ($breakOnError) ***REMOVED***
            out += ' if (' + ($nextValid) + ') ***REMOVED*** ';
            $closingBraces += '***REMOVED***';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if (it.opts.patternGroups && $pgPropertyKeys.length) ***REMOVED***
    var arr6 = $pgPropertyKeys;
    if (arr6) ***REMOVED***
      var $pgProperty, i6 = -1,
        l6 = arr6.length - 1;
      while (i6 < l6) ***REMOVED***
        $pgProperty = arr6[i6 += 1];
        var $pgSchema = $pgProperties[$pgProperty],
          $sch = $pgSchema.schema;
        if (it.util.schemaHasRules($sch, it.RULES.all)) ***REMOVED***
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternGroups' + it.util.getProperty($pgProperty) + '.schema';
          $it.errSchemaPath = it.errSchemaPath + '/patternGroups/' + it.util.escapeFragment($pgProperty) + '/schema';
          out += ' var pgPropCount' + ($lvl) + ' = 0;  ';
          if ($ownProperties) ***REMOVED***
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) ***REMOVED*** var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          ***REMOVED*** else ***REMOVED***
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') ***REMOVED*** ';
          ***REMOVED***
          out += ' if (' + (it.usePattern($pgProperty)) + '.test(' + ($key) + ')) ***REMOVED*** pgPropCount' + ($lvl) + '++; ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) ***REMOVED***
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          ***REMOVED*** else ***REMOVED***
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          ***REMOVED***
          if ($breakOnError) ***REMOVED***
            out += ' if (!' + ($nextValid) + ') break; ';
          ***REMOVED***
          out += ' ***REMOVED*** ';
          if ($breakOnError) ***REMOVED***
            out += ' else ' + ($nextValid) + ' = true; ';
          ***REMOVED***
          out += ' ***REMOVED***  ';
          if ($breakOnError) ***REMOVED***
            out += ' if (' + ($nextValid) + ') ***REMOVED*** ';
            $closingBraces += '***REMOVED***';
          ***REMOVED***
          var $pgMin = $pgSchema.minimum,
            $pgMax = $pgSchema.maximum;
          if ($pgMin !== undefined || $pgMax !== undefined) ***REMOVED***
            out += ' var ' + ($valid) + ' = true; ';
            var $currErrSchemaPath = $errSchemaPath;
            if ($pgMin !== undefined) ***REMOVED***
              var $limit = $pgMin,
                $reason = 'minimum',
                $moreOrLess = 'less';
              out += ' ' + ($valid) + ' = pgPropCount' + ($lvl) + ' >= ' + ($pgMin) + '; ';
              $errSchemaPath = it.errSchemaPath + '/patternGroups/minimum';
              out += '  if (!' + ($valid) + ') ***REMOVED***   ';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) ***REMOVED***
                out += ' ***REMOVED*** keyword: \'' + ('patternGroups') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** reason: \'' + ($reason) + '\', limit: ' + ($limit) + ', pattern: \'' + (it.util.escapeQuotes($pgProperty)) + '\' ***REMOVED*** ';
                if (it.opts.messages !== false) ***REMOVED***
                  out += ' , message: \'should NOT have ' + ($moreOrLess) + ' than ' + ($limit) + ' properties matching pattern "' + (it.util.escapeQuotes($pgProperty)) + '"\' ';
                ***REMOVED***
                if (it.opts.verbose) ***REMOVED***
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                ***REMOVED***
                out += ' ***REMOVED*** ';
              ***REMOVED*** else ***REMOVED***
                out += ' ***REMOVED******REMOVED*** ';
              ***REMOVED***
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
                if (it.async) ***REMOVED***
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                ***REMOVED*** else ***REMOVED***
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              ***REMOVED***
              out += ' ***REMOVED*** ';
              if ($pgMax !== undefined) ***REMOVED***
                out += ' else ';
              ***REMOVED***
            ***REMOVED***
            if ($pgMax !== undefined) ***REMOVED***
              var $limit = $pgMax,
                $reason = 'maximum',
                $moreOrLess = 'more';
              out += ' ' + ($valid) + ' = pgPropCount' + ($lvl) + ' <= ' + ($pgMax) + '; ';
              $errSchemaPath = it.errSchemaPath + '/patternGroups/maximum';
              out += '  if (!' + ($valid) + ') ***REMOVED***   ';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) ***REMOVED***
                out += ' ***REMOVED*** keyword: \'' + ('patternGroups') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** reason: \'' + ($reason) + '\', limit: ' + ($limit) + ', pattern: \'' + (it.util.escapeQuotes($pgProperty)) + '\' ***REMOVED*** ';
                if (it.opts.messages !== false) ***REMOVED***
                  out += ' , message: \'should NOT have ' + ($moreOrLess) + ' than ' + ($limit) + ' properties matching pattern "' + (it.util.escapeQuotes($pgProperty)) + '"\' ';
                ***REMOVED***
                if (it.opts.verbose) ***REMOVED***
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                ***REMOVED***
                out += ' ***REMOVED*** ';
              ***REMOVED*** else ***REMOVED***
                out += ' ***REMOVED******REMOVED*** ';
              ***REMOVED***
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
                if (it.async) ***REMOVED***
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                ***REMOVED*** else ***REMOVED***
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              ***REMOVED***
              out += ' ***REMOVED*** ';
            ***REMOVED***
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) ***REMOVED***
              out += ' if (' + ($valid) + ') ***REMOVED*** ';
              $closingBraces += '***REMOVED***';
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if ($breakOnError) ***REMOVED***
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) ***REMOVED***';
  ***REMOVED***
  out = it.util.cleanUpCode(out);
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],31:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_propertyNames(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if (it.util.schemaHasRules($schema, it.RULES.all)) ***REMOVED***
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\' + ' + $key + ' + \'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    out += ' var ' + ($errs) + ' = errors; ';
    if ($ownProperties) ***REMOVED***
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    ***REMOVED***
    if ($ownProperties) ***REMOVED***
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) ***REMOVED*** var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    ***REMOVED*** else ***REMOVED***
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') ***REMOVED*** ';
    ***REMOVED***
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) ***REMOVED***
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    ***REMOVED*** else ***REMOVED***
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    ***REMOVED***
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') ***REMOVED*** for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) ***REMOVED*** vErrors[' + ($i) + '].propertyName = ' + ($key) + '; ***REMOVED***   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) ***REMOVED***
      out += ' ***REMOVED*** keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** propertyName: \'' + ($invalidName) + '\' ***REMOVED*** ';
      if (it.opts.messages !== false) ***REMOVED***
        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
      ***REMOVED***
      if (it.opts.verbose) ***REMOVED***
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED*** else ***REMOVED***
      out += ' ***REMOVED******REMOVED*** ';
    ***REMOVED***
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
      if (it.async) ***REMOVED***
        out += ' throw new ValidationError(vErrors); ';
      ***REMOVED*** else ***REMOVED***
        out += ' validate.errors = vErrors; return false; ';
      ***REMOVED***
    ***REMOVED***
    if ($breakOnError) ***REMOVED***
      out += ' break; ';
    ***REMOVED***
    out += ' ***REMOVED*** ***REMOVED***';
  ***REMOVED***
  if ($breakOnError) ***REMOVED***
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) ***REMOVED***';
  ***REMOVED***
  out = it.util.cleanUpCode(out);
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],32:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_ref(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') ***REMOVED***
    if (it.isRoot) ***REMOVED***
      $async = it.async;
      $refCode = 'validate';
    ***REMOVED*** else ***REMOVED***
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) ***REMOVED***
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') ***REMOVED***
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) ***REMOVED***
          out += ' ***REMOVED*** keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** ref: \'' + (it.util.escapeQuotes($schema)) + '\' ***REMOVED*** ';
          if (it.opts.messages !== false) ***REMOVED***
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          ***REMOVED***
          if (it.opts.verbose) ***REMOVED***
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          ***REMOVED***
          out += ' ***REMOVED*** ';
        ***REMOVED*** else ***REMOVED***
          out += ' ***REMOVED******REMOVED*** ';
        ***REMOVED***
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
          if (it.async) ***REMOVED***
            out += ' throw new ValidationError([' + (__err) + ']); ';
          ***REMOVED*** else ***REMOVED***
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        ***REMOVED***
        if ($breakOnError) ***REMOVED***
          out += ' if (false) ***REMOVED*** ';
        ***REMOVED***
      ***REMOVED*** else if (it.opts.missingRefs == 'ignore') ***REMOVED***
        it.logger.warn($message);
        if ($breakOnError) ***REMOVED***
          out += ' if (true) ***REMOVED*** ';
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        throw new it.MissingRefError(it.baseId, $schema, $message);
      ***REMOVED***
    ***REMOVED*** else if ($refVal.inline) ***REMOVED***
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) ***REMOVED***
        out += ' if (' + ($nextValid) + ') ***REMOVED*** ';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      $async = $refVal.$async === true;
      $refCode = $refVal.code;
    ***REMOVED***
  ***REMOVED***
  if ($refCode) ***REMOVED***
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) ***REMOVED***
      out += ' ' + ($refCode) + '.call(this, ';
    ***REMOVED*** else ***REMOVED***
      out += ' ' + ($refCode) + '( ';
    ***REMOVED***
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') ***REMOVED***
      out += ' + ' + (it.errorPath);
    ***REMOVED***
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) ***REMOVED***
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) ***REMOVED***
        out += ' var ' + ($valid) + '; ';
      ***REMOVED***
      out += ' try ***REMOVED*** ' + (it.yieldAwait) + ' ' + (__callValidate) + '; ';
      if ($breakOnError) ***REMOVED***
        out += ' ' + ($valid) + ' = true; ';
      ***REMOVED***
      out += ' ***REMOVED*** catch (e) ***REMOVED*** if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) ***REMOVED***
        out += ' ' + ($valid) + ' = false; ';
      ***REMOVED***
      out += ' ***REMOVED*** ';
      if ($breakOnError) ***REMOVED***
        out += ' if (' + ($valid) + ') ***REMOVED*** ';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      out += ' if (!' + (__callValidate) + ') ***REMOVED*** if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; ***REMOVED*** ';
      if ($breakOnError) ***REMOVED***
        out += ' else ***REMOVED*** ';
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],33:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_required(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  var $vSchema = 'schema' + $lvl;
  if (!$isData) ***REMOVED***
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) ***REMOVED***
      var $required = [];
      var arr1 = $schema;
      if (arr1) ***REMOVED***
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) ***REMOVED***
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) ***REMOVED***
            $required[$required.length] = $property;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      var $required = $schema;
    ***REMOVED***
  ***REMOVED***
  if ($isData || $required.length) ***REMOVED***
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) ***REMOVED***
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) ***REMOVED***
        if (!$isData) ***REMOVED***
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        ***REMOVED***
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) ***REMOVED***
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        ***REMOVED***
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) ***REMOVED***
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else ***REMOVED***';
        ***REMOVED***
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) ***REMOVED*** ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) ***REMOVED***
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        ***REMOVED***
        out += '; if (!' + ($valid) + ') break; ***REMOVED*** ';
        if ($isData) ***REMOVED***
          out += '  ***REMOVED***  ';
        ***REMOVED***
        out += '  if (!' + ($valid) + ') ***REMOVED***   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) ***REMOVED***
          out += ' ***REMOVED*** keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** missingProperty: \'' + ($missingProperty) + '\' ***REMOVED*** ';
          if (it.opts.messages !== false) ***REMOVED***
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) ***REMOVED***
              out += 'is a required property';
            ***REMOVED*** else ***REMOVED***
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            ***REMOVED***
            out += '\' ';
          ***REMOVED***
          if (it.opts.verbose) ***REMOVED***
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          ***REMOVED***
          out += ' ***REMOVED*** ';
        ***REMOVED*** else ***REMOVED***
          out += ' ***REMOVED******REMOVED*** ';
        ***REMOVED***
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
          if (it.async) ***REMOVED***
            out += ' throw new ValidationError([' + (__err) + ']); ';
          ***REMOVED*** else ***REMOVED***
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        ***REMOVED***
        out += ' ***REMOVED*** else ***REMOVED*** ';
      ***REMOVED*** else ***REMOVED***
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) ***REMOVED***
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) ***REMOVED***
            $propertyKey = arr2[$i += 1];
            if ($i) ***REMOVED***
              out += ' || ';
            ***REMOVED***
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) ***REMOVED***
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            ***REMOVED***
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          ***REMOVED***
        ***REMOVED***
        out += ') ***REMOVED***  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) ***REMOVED***
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        ***REMOVED***
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) ***REMOVED***
          out += ' ***REMOVED*** keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** missingProperty: \'' + ($missingProperty) + '\' ***REMOVED*** ';
          if (it.opts.messages !== false) ***REMOVED***
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) ***REMOVED***
              out += 'is a required property';
            ***REMOVED*** else ***REMOVED***
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            ***REMOVED***
            out += '\' ';
          ***REMOVED***
          if (it.opts.verbose) ***REMOVED***
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          ***REMOVED***
          out += ' ***REMOVED*** ';
        ***REMOVED*** else ***REMOVED***
          out += ' ***REMOVED******REMOVED*** ';
        ***REMOVED***
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
          if (it.async) ***REMOVED***
            out += ' throw new ValidationError([' + (__err) + ']); ';
          ***REMOVED*** else ***REMOVED***
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        ***REMOVED***
        out += ' ***REMOVED*** else ***REMOVED*** ';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if ($loopRequired) ***REMOVED***
        if (!$isData) ***REMOVED***
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        ***REMOVED***
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) ***REMOVED***
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        ***REMOVED***
        if ($isData) ***REMOVED***
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) ***REMOVED***  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) ***REMOVED***
            out += ' ***REMOVED*** keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** missingProperty: \'' + ($missingProperty) + '\' ***REMOVED*** ';
            if (it.opts.messages !== false) ***REMOVED***
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) ***REMOVED***
                out += 'is a required property';
              ***REMOVED*** else ***REMOVED***
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              ***REMOVED***
              out += '\' ';
            ***REMOVED***
            if (it.opts.verbose) ***REMOVED***
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            ***REMOVED***
            out += ' ***REMOVED*** ';
          ***REMOVED*** else ***REMOVED***
            out += ' ***REMOVED******REMOVED*** ';
          ***REMOVED***
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ***REMOVED*** else if (' + ($vSchema) + ' !== undefined) ***REMOVED*** ';
        ***REMOVED***
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) ***REMOVED*** if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) ***REMOVED***
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        ***REMOVED***
        out += ') ***REMOVED***  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) ***REMOVED***
          out += ' ***REMOVED*** keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** missingProperty: \'' + ($missingProperty) + '\' ***REMOVED*** ';
          if (it.opts.messages !== false) ***REMOVED***
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) ***REMOVED***
              out += 'is a required property';
            ***REMOVED*** else ***REMOVED***
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            ***REMOVED***
            out += '\' ';
          ***REMOVED***
          if (it.opts.verbose) ***REMOVED***
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          ***REMOVED***
          out += ' ***REMOVED*** ';
        ***REMOVED*** else ***REMOVED***
          out += ' ***REMOVED******REMOVED*** ';
        ***REMOVED***
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ***REMOVED*** ***REMOVED*** ';
        if ($isData) ***REMOVED***
          out += '  ***REMOVED***  ';
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        var arr3 = $required;
        if (arr3) ***REMOVED***
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) ***REMOVED***
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) ***REMOVED***
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            ***REMOVED***
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) ***REMOVED***
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            ***REMOVED***
            out += ') ***REMOVED***  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) ***REMOVED***
              out += ' ***REMOVED*** keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** missingProperty: \'' + ($missingProperty) + '\' ***REMOVED*** ';
              if (it.opts.messages !== false) ***REMOVED***
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) ***REMOVED***
                  out += 'is a required property';
                ***REMOVED*** else ***REMOVED***
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                ***REMOVED***
                out += '\' ';
              ***REMOVED***
              if (it.opts.verbose) ***REMOVED***
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              ***REMOVED***
              out += ' ***REMOVED*** ';
            ***REMOVED*** else ***REMOVED***
              out += ' ***REMOVED******REMOVED*** ';
            ***REMOVED***
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ***REMOVED*** ';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    it.errorPath = $currentErrorPath;
  ***REMOVED*** else if ($breakOnError) ***REMOVED***
    out += ' if (true) ***REMOVED***';
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],34:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) ***REMOVED***
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) ***REMOVED***
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  ***REMOVED*** else ***REMOVED***
    $schemaValue = $schema;
  ***REMOVED***
  if (($schema || $isData) && it.opts.uniqueItems !== false) ***REMOVED***
    if ($isData) ***REMOVED***
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else ***REMOVED*** ';
    ***REMOVED***
    out += ' var ' + ($valid) + ' = true; if (' + ($data) + '.length > 1) ***REMOVED*** var i = ' + ($data) + '.length, j; outer: for (;i--;) ***REMOVED*** for (j = i; j--;) ***REMOVED*** if (equal(' + ($data) + '[i], ' + ($data) + '[j])) ***REMOVED*** ' + ($valid) + ' = false; break outer; ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED*** ';
    if ($isData) ***REMOVED***
      out += '  ***REMOVED***  ';
    ***REMOVED***
    out += ' if (!' + ($valid) + ') ***REMOVED***   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) ***REMOVED***
      out += ' ***REMOVED*** keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** i: i, j: j ***REMOVED*** ';
      if (it.opts.messages !== false) ***REMOVED***
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      ***REMOVED***
      if (it.opts.verbose) ***REMOVED***
        out += ' , schema:  ';
        if ($isData) ***REMOVED***
          out += 'validate.schema' + ($schemaPath);
        ***REMOVED*** else ***REMOVED***
          out += '' + ($schema);
        ***REMOVED***
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED*** else ***REMOVED***
      out += ' ***REMOVED******REMOVED*** ';
    ***REMOVED***
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
      if (it.async) ***REMOVED***
        out += ' throw new ValidationError([' + (__err) + ']); ';
      ***REMOVED*** else ***REMOVED***
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    ***REMOVED***
    out += ' ***REMOVED*** ';
    if ($breakOnError) ***REMOVED***
      out += ' else ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    if ($breakOnError) ***REMOVED***
      out += ' if (true) ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],35:[function(require,module,exports)***REMOVED***
'use strict';
module.exports = function generate_validate(it, $keyword, $ruleType) ***REMOVED***
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.isTop) ***REMOVED***
    if ($async) ***REMOVED***
      it.async = true;
      var $es7 = it.opts.async == 'es7';
      it.yieldAwait = $es7 ? 'await' : 'yield';
    ***REMOVED***
    out += ' var validate = ';
    if ($async) ***REMOVED***
      if ($es7) ***REMOVED***
        out += ' (async function ';
      ***REMOVED*** else ***REMOVED***
        if (it.opts.async != '*') ***REMOVED***
          out += 'co.wrap';
        ***REMOVED***
        out += '(function* ';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      out += ' (function ';
    ***REMOVED***
    out += ' (data, dataPath, parentData, parentDataProperty, rootData) ***REMOVED*** \'use strict\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) ***REMOVED***
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    ***REMOVED***
  ***REMOVED***
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) ***REMOVED***
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) ***REMOVED***
      if (it.isTop) ***REMOVED***
        $breakOnError = true;
      ***REMOVED*** else ***REMOVED***
        out += ' var ' + ($valid) + ' = false; ';
      ***REMOVED***
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) ***REMOVED***
        out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED******REMOVED*** ';
        if (it.opts.messages !== false) ***REMOVED***
          out += ' , message: \'boolean schema is false\' ';
        ***REMOVED***
        if (it.opts.verbose) ***REMOVED***
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        ***REMOVED***
        out += ' ***REMOVED*** ';
      ***REMOVED*** else ***REMOVED***
        out += ' ***REMOVED******REMOVED*** ';
      ***REMOVED***
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
        if (it.async) ***REMOVED***
          out += ' throw new ValidationError([' + (__err) + ']); ';
        ***REMOVED*** else ***REMOVED***
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if (it.isTop) ***REMOVED***
        if ($async) ***REMOVED***
          out += ' return data; ';
        ***REMOVED*** else ***REMOVED***
          out += ' validate.errors = null; return true; ';
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        out += ' var ' + ($valid) + ' = true; ';
      ***REMOVED***
    ***REMOVED***
    if (it.isTop) ***REMOVED***
      out += ' ***REMOVED***); return validate; ';
    ***REMOVED***
    return out;
  ***REMOVED***
  if (it.isTop) ***REMOVED***
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [undefined];
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  ***REMOVED*** else ***REMOVED***
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  ***REMOVED***
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeIsArray && $typeSchema.length == 1) ***REMOVED***
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  ***REMOVED***
  if (it.schema.$ref && $refKeywords) ***REMOVED***
    if (it.opts.extendRefs == 'fail') ***REMOVED***
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    ***REMOVED*** else if (it.opts.extendRefs !== true) ***REMOVED***
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    ***REMOVED***
  ***REMOVED***
  if ($typeSchema) ***REMOVED***
    if (it.opts.coerceTypes) ***REMOVED***
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    ***REMOVED***
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) ***REMOVED***
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') ***REMOVED*** ';
      if ($coerceToTypes) ***REMOVED***
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
        if (it.opts.coerceTypes == 'array') ***REMOVED***
          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \'array\'; ';
        ***REMOVED***
        out += ' var ' + ($coerced) + ' = undefined; ';
        var $bracesCoercion = '';
        var arr1 = $coerceToTypes;
        if (arr1) ***REMOVED***
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) ***REMOVED***
            $type = arr1[$i += 1];
            if ($i) ***REMOVED***
              out += ' if (' + ($coerced) + ' === undefined) ***REMOVED*** ';
              $bracesCoercion += '***REMOVED***';
            ***REMOVED***
            if (it.opts.coerceTypes == 'array' && $type != 'array') ***REMOVED***
              out += ' if (' + ($dataType) + ' == \'array\' && ' + ($data) + '.length == 1) ***REMOVED*** ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  ***REMOVED*** ';
            ***REMOVED***
            if ($type == 'string') ***REMOVED***
              out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
            ***REMOVED*** else if ($type == 'number' || $type == 'integer') ***REMOVED***
              out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') ***REMOVED***
                out += ' && !(' + ($data) + ' % 1)';
              ***REMOVED***
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            ***REMOVED*** else if ($type == 'boolean') ***REMOVED***
              out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            ***REMOVED*** else if ($type == 'null') ***REMOVED***
              out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            ***REMOVED*** else if (it.opts.coerceTypes == 'array' && $type == 'array') ***REMOVED***
              out += ' if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
        out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) ***REMOVED***   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) ***REMOVED***
          out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** type: \'';
          if ($typeIsArray) ***REMOVED***
            out += '' + ($typeSchema.join(","));
          ***REMOVED*** else ***REMOVED***
            out += '' + ($typeSchema);
          ***REMOVED***
          out += '\' ***REMOVED*** ';
          if (it.opts.messages !== false) ***REMOVED***
            out += ' , message: \'should be ';
            if ($typeIsArray) ***REMOVED***
              out += '' + ($typeSchema.join(","));
            ***REMOVED*** else ***REMOVED***
              out += '' + ($typeSchema);
            ***REMOVED***
            out += '\' ';
          ***REMOVED***
          if (it.opts.verbose) ***REMOVED***
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          ***REMOVED***
          out += ' ***REMOVED*** ';
        ***REMOVED*** else ***REMOVED***
          out += ' ***REMOVED******REMOVED*** ';
        ***REMOVED***
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
          if (it.async) ***REMOVED***
            out += ' throw new ValidationError([' + (__err) + ']); ';
          ***REMOVED*** else ***REMOVED***
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        ***REMOVED***
        out += ' ***REMOVED*** else ***REMOVED***  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) ***REMOVED***
          out += 'if (' + ($parentData) + ' !== undefined)';
        ***REMOVED***
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; ***REMOVED*** ';
      ***REMOVED*** else ***REMOVED***
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) ***REMOVED***
          out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** type: \'';
          if ($typeIsArray) ***REMOVED***
            out += '' + ($typeSchema.join(","));
          ***REMOVED*** else ***REMOVED***
            out += '' + ($typeSchema);
          ***REMOVED***
          out += '\' ***REMOVED*** ';
          if (it.opts.messages !== false) ***REMOVED***
            out += ' , message: \'should be ';
            if ($typeIsArray) ***REMOVED***
              out += '' + ($typeSchema.join(","));
            ***REMOVED*** else ***REMOVED***
              out += '' + ($typeSchema);
            ***REMOVED***
            out += '\' ';
          ***REMOVED***
          if (it.opts.verbose) ***REMOVED***
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          ***REMOVED***
          out += ' ***REMOVED*** ';
        ***REMOVED*** else ***REMOVED***
          out += ' ***REMOVED******REMOVED*** ';
        ***REMOVED***
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
          if (it.async) ***REMOVED***
            out += ' throw new ValidationError([' + (__err) + ']); ';
          ***REMOVED*** else ***REMOVED***
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        ***REMOVED***
      ***REMOVED***
      out += ' ***REMOVED*** ';
    ***REMOVED***
  ***REMOVED***
  if (it.schema.$ref && !$refKeywords) ***REMOVED***
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) ***REMOVED***
      out += ' ***REMOVED*** if (errors === ';
      if ($top) ***REMOVED***
        out += '0';
      ***REMOVED*** else ***REMOVED***
        out += 'errs_' + ($lvl);
      ***REMOVED***
      out += ') ***REMOVED*** ';
      $closingBraces2 += '***REMOVED***';
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    if (it.opts.v5 && it.schema.patternGroups) ***REMOVED***
      it.logger.warn('keyword "patternGroups" is deprecated and disabled. Use option patternGroups: true to enable.');
    ***REMOVED***
    var arr2 = it.RULES;
    if (arr2) ***REMOVED***
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) ***REMOVED***
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) ***REMOVED***
          if ($rulesGroup.type) ***REMOVED***
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') ***REMOVED*** ';
          ***REMOVED***
          if (it.opts.useDefaults && !it.compositeRule) ***REMOVED***
            if ($rulesGroup.type == 'object' && it.schema.properties) ***REMOVED***
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) ***REMOVED***
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) ***REMOVED***
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) ***REMOVED***
                    var $passData = $data + it.util.getProperty($propertyKey);
                    out += '  if (' + ($passData) + ' === undefined) ' + ($passData) + ' = ';
                    if (it.opts.useDefaults == 'shared') ***REMOVED***
                      out += ' ' + (it.useDefault($sch.default)) + ' ';
                    ***REMOVED*** else ***REMOVED***
                      out += ' ' + (JSON.stringify($sch.default)) + ' ';
                    ***REMOVED***
                    out += '; ';
                  ***REMOVED***
                ***REMOVED***
              ***REMOVED***
            ***REMOVED*** else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) ***REMOVED***
              var arr4 = it.schema.items;
              if (arr4) ***REMOVED***
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) ***REMOVED***
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) ***REMOVED***
                    var $passData = $data + '[' + $i + ']';
                    out += '  if (' + ($passData) + ' === undefined) ' + ($passData) + ' = ';
                    if (it.opts.useDefaults == 'shared') ***REMOVED***
                      out += ' ' + (it.useDefault($sch.default)) + ' ';
                    ***REMOVED*** else ***REMOVED***
                      out += ' ' + (JSON.stringify($sch.default)) + ' ';
                    ***REMOVED***
                    out += '; ';
                  ***REMOVED***
                ***REMOVED***
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
          var arr5 = $rulesGroup.rules;
          if (arr5) ***REMOVED***
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) ***REMOVED***
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) ***REMOVED***
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) ***REMOVED***
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) ***REMOVED***
                    $closingBraces1 += '***REMOVED***';
                  ***REMOVED***
                ***REMOVED***
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
          if ($breakOnError) ***REMOVED***
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          ***REMOVED***
          if ($rulesGroup.type) ***REMOVED***
            out += ' ***REMOVED*** ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) ***REMOVED***
              out += ' else ***REMOVED*** ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) ***REMOVED***
                out += ' ***REMOVED*** keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: ***REMOVED*** type: \'';
                if ($typeIsArray) ***REMOVED***
                  out += '' + ($typeSchema.join(","));
                ***REMOVED*** else ***REMOVED***
                  out += '' + ($typeSchema);
                ***REMOVED***
                out += '\' ***REMOVED*** ';
                if (it.opts.messages !== false) ***REMOVED***
                  out += ' , message: \'should be ';
                  if ($typeIsArray) ***REMOVED***
                    out += '' + ($typeSchema.join(","));
                  ***REMOVED*** else ***REMOVED***
                    out += '' + ($typeSchema);
                  ***REMOVED***
                  out += '\' ';
                ***REMOVED***
                if (it.opts.verbose) ***REMOVED***
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                ***REMOVED***
                out += ' ***REMOVED*** ';
              ***REMOVED*** else ***REMOVED***
                out += ' ***REMOVED******REMOVED*** ';
              ***REMOVED***
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) ***REMOVED*** /* istanbul ignore if */
                if (it.async) ***REMOVED***
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                ***REMOVED*** else ***REMOVED***
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              ***REMOVED***
              out += ' ***REMOVED*** ';
            ***REMOVED***
          ***REMOVED***
          if ($breakOnError) ***REMOVED***
            out += ' if (errors === ';
            if ($top) ***REMOVED***
              out += '0';
            ***REMOVED*** else ***REMOVED***
              out += 'errs_' + ($lvl);
            ***REMOVED***
            out += ') ***REMOVED*** ';
            $closingBraces2 += '***REMOVED***';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if ($breakOnError) ***REMOVED***
    out += ' ' + ($closingBraces2) + ' ';
  ***REMOVED***
  if ($top) ***REMOVED***
    if ($async) ***REMOVED***
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    ***REMOVED*** else ***REMOVED***
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    ***REMOVED***
    out += ' ***REMOVED***); return validate;';
  ***REMOVED*** else ***REMOVED***
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  ***REMOVED***
  out = it.util.cleanUpCode(out);
  if ($top) ***REMOVED***
    out = it.util.finalCleanUpCode(out, $async);
  ***REMOVED***

  function $shouldUseGroup($rulesGroup) ***REMOVED***
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  ***REMOVED***

  function $shouldUseRule($rule) ***REMOVED***
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  ***REMOVED***

  function $ruleImplementsSomeKeyword($rule) ***REMOVED***
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  ***REMOVED***
  return out;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],36:[function(require,module,exports)***REMOVED***
'use strict';

var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require('./dotjs/custom');

module.exports = ***REMOVED***
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword
***REMOVED***;

/**
 * Define custom keyword
 * @this  Ajv
 * @param ***REMOVED***String***REMOVED*** keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param ***REMOVED***Object***REMOVED*** definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return ***REMOVED***Ajv***REMOVED*** this for method chaining
 */
function addKeyword(keyword, definition) ***REMOVED***
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;

  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) ***REMOVED***
    if (definition.macro && definition.valid !== undefined)
      throw new Error('"valid" option cannot be used with macro keywords');

    var dataType = definition.type;
    if (Array.isArray(dataType)) ***REMOVED***
      var i, len = dataType.length;
      for (i=0; i<len; i++) checkDataType(dataType[i]);
      for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);
    ***REMOVED*** else ***REMOVED***
      if (dataType) checkDataType(dataType);
      _addRule(keyword, dataType, definition);
    ***REMOVED***

    var $data = definition.$data === true && this._opts.$data;
    if ($data && !definition.validate)
      throw new Error('$data support: "validate" function is not defined');

    var metaSchema = definition.metaSchema;
    if (metaSchema) ***REMOVED***
      if ($data) ***REMOVED***
        metaSchema = ***REMOVED***
          anyOf: [
            metaSchema,
            ***REMOVED*** '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#' ***REMOVED***
          ]
        ***REMOVED***;
      ***REMOVED***
      definition.validateSchema = this.compile(metaSchema, true);
    ***REMOVED***
  ***REMOVED***

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) ***REMOVED***
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) ***REMOVED***
      var rg = RULES[i];
      if (rg.type == dataType) ***REMOVED***
        ruleGroup = rg;
        break;
      ***REMOVED***
    ***REMOVED***

    if (!ruleGroup) ***REMOVED***
      ruleGroup = ***REMOVED*** type: dataType, rules: [] ***REMOVED***;
      RULES.push(ruleGroup);
    ***REMOVED***

    var rule = ***REMOVED***
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    ***REMOVED***;
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  ***REMOVED***


  function checkDataType(dataType) ***REMOVED***
    if (!RULES.types[dataType]) throw new Error('Unknown type ' + dataType);
  ***REMOVED***

  return this;
***REMOVED***


/**
 * Get keyword
 * @this  Ajv
 * @param ***REMOVED***String***REMOVED*** keyword pre-defined or custom keyword.
 * @return ***REMOVED***Object|Boolean***REMOVED*** custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) ***REMOVED***
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
***REMOVED***


/**
 * Remove keyword
 * @this  Ajv
 * @param ***REMOVED***String***REMOVED*** keyword pre-defined or custom keyword.
 * @return ***REMOVED***Ajv***REMOVED*** this for method chaining
 */
function removeKeyword(keyword) ***REMOVED***
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) ***REMOVED***
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) ***REMOVED***
      if (rules[j].keyword == keyword) ***REMOVED***
        rules.splice(j, 1);
        break;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return this;
***REMOVED***

***REMOVED***,***REMOVED***"./dotjs/custom":21***REMOVED***],37:[function(require,module,exports)***REMOVED***
'use strict';

var META_SCHEMA_ID = 'http://json-schema.org/draft-06/schema';

module.exports = function (ajv) ***REMOVED***
  var defaultMeta = ajv._opts.defaultMeta;
  var metaSchemaRef = typeof defaultMeta == 'string'
                      ? ***REMOVED*** $ref: defaultMeta ***REMOVED***
                      : ajv.getSchema(META_SCHEMA_ID)
                        ? ***REMOVED*** $ref: META_SCHEMA_ID ***REMOVED***
                        : ***REMOVED******REMOVED***;

  ajv.addKeyword('patternGroups', ***REMOVED***
    // implemented in properties.jst
    metaSchema: ***REMOVED***
      type: 'object',
      additionalProperties: ***REMOVED***
        type: 'object',
        required: [ 'schema' ],
        properties: ***REMOVED***
          maximum: ***REMOVED***
            type: 'integer',
            minimum: 0
          ***REMOVED***,
          minimum: ***REMOVED***
            type: 'integer',
            minimum: 0
          ***REMOVED***,
          schema: metaSchemaRef
        ***REMOVED***,
        additionalProperties: false
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
  ajv.RULES.all.properties.implements.push('patternGroups');
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],38:[function(require,module,exports)***REMOVED***
module.exports=***REMOVED***
    "$schema": "http://json-schema.org/draft-06/schema#",
    "$id": "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#",
    "description": "Meta-schema for $data reference (JSON-schema extension proposal)",
    "type": "object",
    "required": [ "$data" ],
    "properties": ***REMOVED***
        "$data": ***REMOVED***
            "type": "string",
            "anyOf": [
                ***REMOVED*** "format": "relative-json-pointer" ***REMOVED***, 
                ***REMOVED*** "format": "json-pointer" ***REMOVED***
            ]
        ***REMOVED***
    ***REMOVED***,
    "additionalProperties": false
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],39:[function(require,module,exports)***REMOVED***
module.exports=***REMOVED***
    "$schema": "http://json-schema.org/draft-06/schema#",
    "$id": "http://json-schema.org/draft-06/schema#",
    "title": "Core schema meta-schema",
    "definitions": ***REMOVED***
        "schemaArray": ***REMOVED***
            "type": "array",
            "minItems": 1,
            "items": ***REMOVED*** "$ref": "#" ***REMOVED***
        ***REMOVED***,
        "nonNegativeInteger": ***REMOVED***
            "type": "integer",
            "minimum": 0
        ***REMOVED***,
        "nonNegativeIntegerDefault0": ***REMOVED***
            "allOf": [
                ***REMOVED*** "$ref": "#/definitions/nonNegativeInteger" ***REMOVED***,
                ***REMOVED*** "default": 0 ***REMOVED***
            ]
        ***REMOVED***,
        "simpleTypes": ***REMOVED***
            "enum": [
                "array",
                "boolean",
                "integer",
                "null",
                "number",
                "object",
                "string"
            ]
        ***REMOVED***,
        "stringArray": ***REMOVED***
            "type": "array",
            "items": ***REMOVED*** "type": "string" ***REMOVED***,
            "uniqueItems": true,
            "default": []
        ***REMOVED***
    ***REMOVED***,
    "type": ["object", "boolean"],
    "properties": ***REMOVED***
        "$id": ***REMOVED***
            "type": "string",
            "format": "uri-reference"
        ***REMOVED***,
        "$schema": ***REMOVED***
            "type": "string",
            "format": "uri"
        ***REMOVED***,
        "$ref": ***REMOVED***
            "type": "string",
            "format": "uri-reference"
        ***REMOVED***,
        "title": ***REMOVED***
            "type": "string"
        ***REMOVED***,
        "description": ***REMOVED***
            "type": "string"
        ***REMOVED***,
        "default": ***REMOVED******REMOVED***,
        "examples": ***REMOVED***
            "type": "array",
            "items": ***REMOVED******REMOVED***
        ***REMOVED***,
        "multipleOf": ***REMOVED***
            "type": "number",
            "exclusiveMinimum": 0
        ***REMOVED***,
        "maximum": ***REMOVED***
            "type": "number"
        ***REMOVED***,
        "exclusiveMaximum": ***REMOVED***
            "type": "number"
        ***REMOVED***,
        "minimum": ***REMOVED***
            "type": "number"
        ***REMOVED***,
        "exclusiveMinimum": ***REMOVED***
            "type": "number"
        ***REMOVED***,
        "maxLength": ***REMOVED*** "$ref": "#/definitions/nonNegativeInteger" ***REMOVED***,
        "minLength": ***REMOVED*** "$ref": "#/definitions/nonNegativeIntegerDefault0" ***REMOVED***,
        "pattern": ***REMOVED***
            "type": "string",
            "format": "regex"
        ***REMOVED***,
        "additionalItems": ***REMOVED*** "$ref": "#" ***REMOVED***,
        "items": ***REMOVED***
            "anyOf": [
                ***REMOVED*** "$ref": "#" ***REMOVED***,
                ***REMOVED*** "$ref": "#/definitions/schemaArray" ***REMOVED***
            ],
            "default": ***REMOVED******REMOVED***
        ***REMOVED***,
        "maxItems": ***REMOVED*** "$ref": "#/definitions/nonNegativeInteger" ***REMOVED***,
        "minItems": ***REMOVED*** "$ref": "#/definitions/nonNegativeIntegerDefault0" ***REMOVED***,
        "uniqueItems": ***REMOVED***
            "type": "boolean",
            "default": false
        ***REMOVED***,
        "contains": ***REMOVED*** "$ref": "#" ***REMOVED***,
        "maxProperties": ***REMOVED*** "$ref": "#/definitions/nonNegativeInteger" ***REMOVED***,
        "minProperties": ***REMOVED*** "$ref": "#/definitions/nonNegativeIntegerDefault0" ***REMOVED***,
        "required": ***REMOVED*** "$ref": "#/definitions/stringArray" ***REMOVED***,
        "additionalProperties": ***REMOVED*** "$ref": "#" ***REMOVED***,
        "definitions": ***REMOVED***
            "type": "object",
            "additionalProperties": ***REMOVED*** "$ref": "#" ***REMOVED***,
            "default": ***REMOVED******REMOVED***
        ***REMOVED***,
        "properties": ***REMOVED***
            "type": "object",
            "additionalProperties": ***REMOVED*** "$ref": "#" ***REMOVED***,
            "default": ***REMOVED******REMOVED***
        ***REMOVED***,
        "patternProperties": ***REMOVED***
            "type": "object",
            "additionalProperties": ***REMOVED*** "$ref": "#" ***REMOVED***,
            "default": ***REMOVED******REMOVED***
        ***REMOVED***,
        "dependencies": ***REMOVED***
            "type": "object",
            "additionalProperties": ***REMOVED***
                "anyOf": [
                    ***REMOVED*** "$ref": "#" ***REMOVED***,
                    ***REMOVED*** "$ref": "#/definitions/stringArray" ***REMOVED***
                ]
            ***REMOVED***
        ***REMOVED***,
        "propertyNames": ***REMOVED*** "$ref": "#" ***REMOVED***,
        "const": ***REMOVED******REMOVED***,
        "enum": ***REMOVED***
            "type": "array",
            "minItems": 1,
            "uniqueItems": true
        ***REMOVED***,
        "type": ***REMOVED***
            "anyOf": [
                ***REMOVED*** "$ref": "#/definitions/simpleTypes" ***REMOVED***,
                ***REMOVED***
                    "type": "array",
                    "items": ***REMOVED*** "$ref": "#/definitions/simpleTypes" ***REMOVED***,
                    "minItems": 1,
                    "uniqueItems": true
                ***REMOVED***
            ]
        ***REMOVED***,
        "format": ***REMOVED*** "type": "string" ***REMOVED***,
        "allOf": ***REMOVED*** "$ref": "#/definitions/schemaArray" ***REMOVED***,
        "anyOf": ***REMOVED*** "$ref": "#/definitions/schemaArray" ***REMOVED***,
        "oneOf": ***REMOVED*** "$ref": "#/definitions/schemaArray" ***REMOVED***,
        "not": ***REMOVED*** "$ref": "#" ***REMOVED***
    ***REMOVED***,
    "default": ***REMOVED******REMOVED***
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],40:[function(require,module,exports)***REMOVED***

/**
 * slice() reference.
 */

var slice = Array.prototype.slice;

/**
 * Expose `co`.
 */

module.exports = co['default'] = co.co = co;

/**
 * Wrap the given generator `fn` into a
 * function that returns a promise.
 * This is a separate function so that
 * every `co()` call doesn't create a new,
 * unnecessary closure.
 *
 * @param ***REMOVED***GeneratorFunction***REMOVED*** fn
 * @return ***REMOVED***Function***REMOVED***
 * @api public
 */

co.wrap = function (fn) ***REMOVED***
  createPromise.__generatorFunction__ = fn;
  return createPromise;
  function createPromise() ***REMOVED***
    return co.call(this, fn.apply(this, arguments));
  ***REMOVED***
***REMOVED***;

/**
 * Execute the generator function or a generator
 * and return a promise.
 *
 * @param ***REMOVED***Function***REMOVED*** fn
 * @return ***REMOVED***Promise***REMOVED***
 * @api public
 */

function co(gen) ***REMOVED***
  var ctx = this;
  var args = slice.call(arguments, 1)

  // we wrap everything in a promise to avoid promise chaining,
  // which leads to memory leak errors.
  // see https://github.com/tj/co/issues/180
  return new Promise(function(resolve, reject) ***REMOVED***
    if (typeof gen === 'function') gen = gen.apply(ctx, args);
    if (!gen || typeof gen.next !== 'function') return resolve(gen);

    onFulfilled();

    /**
     * @param ***REMOVED***Mixed***REMOVED*** res
     * @return ***REMOVED***Promise***REMOVED***
     * @api private
     */

    function onFulfilled(res) ***REMOVED***
      var ret;
      try ***REMOVED***
        ret = gen.next(res);
      ***REMOVED*** catch (e) ***REMOVED***
        return reject(e);
      ***REMOVED***
      next(ret);
    ***REMOVED***

    /**
     * @param ***REMOVED***Error***REMOVED*** err
     * @return ***REMOVED***Promise***REMOVED***
     * @api private
     */

    function onRejected(err) ***REMOVED***
      var ret;
      try ***REMOVED***
        ret = gen.throw(err);
      ***REMOVED*** catch (e) ***REMOVED***
        return reject(e);
      ***REMOVED***
      next(ret);
    ***REMOVED***

    /**
     * Get the next value in the generator,
     * return a promise.
     *
     * @param ***REMOVED***Object***REMOVED*** ret
     * @return ***REMOVED***Promise***REMOVED***
     * @api private
     */

    function next(ret) ***REMOVED***
      if (ret.done) return resolve(ret.value);
      var value = toPromise.call(ctx, ret.value);
      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '
        + 'but the following object was passed: "' + String(ret.value) + '"'));
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

/**
 * Convert a `yield`ed value into a promise.
 *
 * @param ***REMOVED***Mixed***REMOVED*** obj
 * @return ***REMOVED***Promise***REMOVED***
 * @api private
 */

function toPromise(obj) ***REMOVED***
  if (!obj) return obj;
  if (isPromise(obj)) return obj;
  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
  if ('function' == typeof obj) return thunkToPromise.call(this, obj);
  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
  if (isObject(obj)) return objectToPromise.call(this, obj);
  return obj;
***REMOVED***

/**
 * Convert a thunk to a promise.
 *
 * @param ***REMOVED***Function***REMOVED***
 * @return ***REMOVED***Promise***REMOVED***
 * @api private
 */

function thunkToPromise(fn) ***REMOVED***
  var ctx = this;
  return new Promise(function (resolve, reject) ***REMOVED***
    fn.call(ctx, function (err, res) ***REMOVED***
      if (err) return reject(err);
      if (arguments.length > 2) res = slice.call(arguments, 1);
      resolve(res);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * Convert an array of "yieldables" to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param ***REMOVED***Array***REMOVED*** obj
 * @return ***REMOVED***Promise***REMOVED***
 * @api private
 */

function arrayToPromise(obj) ***REMOVED***
  return Promise.all(obj.map(toPromise, this));
***REMOVED***

/**
 * Convert an object of "yieldables" to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param ***REMOVED***Object***REMOVED*** obj
 * @return ***REMOVED***Promise***REMOVED***
 * @api private
 */

function objectToPromise(obj)***REMOVED***
  var results = new obj.constructor();
  var keys = Object.keys(obj);
  var promises = [];
  for (var i = 0; i < keys.length; i++) ***REMOVED***
    var key = keys[i];
    var promise = toPromise.call(this, obj[key]);
    if (promise && isPromise(promise)) defer(promise, key);
    else results[key] = obj[key];
  ***REMOVED***
  return Promise.all(promises).then(function () ***REMOVED***
    return results;
  ***REMOVED***);

  function defer(promise, key) ***REMOVED***
    // predefine the key in the result
    results[key] = undefined;
    promises.push(promise.then(function (res) ***REMOVED***
      results[key] = res;
    ***REMOVED***));
  ***REMOVED***
***REMOVED***

/**
 * Check if `obj` is a promise.
 *
 * @param ***REMOVED***Object***REMOVED*** obj
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 */

function isPromise(obj) ***REMOVED***
  return 'function' == typeof obj.then;
***REMOVED***

/**
 * Check if `obj` is a generator.
 *
 * @param ***REMOVED***Mixed***REMOVED*** obj
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 */

function isGenerator(obj) ***REMOVED***
  return 'function' == typeof obj.next && 'function' == typeof obj.throw;
***REMOVED***

/**
 * Check if `obj` is a generator function.
 *
 * @param ***REMOVED***Mixed***REMOVED*** obj
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 */
function isGeneratorFunction(obj) ***REMOVED***
  var constructor = obj.constructor;
  if (!constructor) return false;
  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
  return isGenerator(constructor.prototype);
***REMOVED***

/**
 * Check for plain object.
 *
 * @param ***REMOVED***Mixed***REMOVED*** val
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 */

function isObject(val) ***REMOVED***
  return Object == val.constructor;
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],41:[function(require,module,exports)***REMOVED***
'use strict';

module.exports = function equal(a, b) ***REMOVED***
  if (a === b) return true;

  var arrA = Array.isArray(a)
    , arrB = Array.isArray(b)
    , i;

  if (arrA && arrB) ***REMOVED***
    if (a.length != b.length) return false;
    for (i = 0; i < a.length; i++)
      if (!equal(a[i], b[i])) return false;
    return true;
  ***REMOVED***

  if (arrA != arrB) return false;

  if (a && b && typeof a === 'object' && typeof b === 'object') ***REMOVED***
    var keys = Object.keys(a);
    if (keys.length !== Object.keys(b).length) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA && dateB) return a.getTime() == b.getTime();
    if (dateA != dateB) return false;

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA && regexpB) return a.toString() == b.toString();
    if (regexpA != regexpB) return false;

    for (i = 0; i < keys.length; i++)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = 0; i < keys.length; i++)
      if(!equal(a[keys[i]], b[keys[i]])) return false;

    return true;
  ***REMOVED***

  return false;
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],42:[function(require,module,exports)***REMOVED***
'use strict';

module.exports = function (data, opts) ***REMOVED***
    if (!opts) opts = ***REMOVED******REMOVED***;
    if (typeof opts === 'function') opts = ***REMOVED*** cmp: opts ***REMOVED***;
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) ***REMOVED***
        return function (node) ***REMOVED***
            return function (a, b) ***REMOVED***
                var aobj = ***REMOVED*** key: a, value: node[a] ***REMOVED***;
                var bobj = ***REMOVED*** key: b, value: node[b] ***REMOVED***;
                return f(aobj, bobj);
            ***REMOVED***;
        ***REMOVED***;
    ***REMOVED***)(opts.cmp);

    var seen = [];
    return (function stringify (node) ***REMOVED***
        if (node && node.toJSON && typeof node.toJSON === 'function') ***REMOVED***
            node = node.toJSON();
        ***REMOVED***

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) ***REMOVED***
            out = '[';
            for (i = 0; i < node.length; i++) ***REMOVED***
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            ***REMOVED***
            return out + ']';
        ***REMOVED***

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) ***REMOVED***
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        ***REMOVED***

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) ***REMOVED***
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        ***REMOVED***
        seen.splice(seenIndex, 1);
        return '***REMOVED***' + out + '***REMOVED***';
    ***REMOVED***)(data);
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],43:[function(require,module,exports)***REMOVED***
'use strict';

var traverse = module.exports = function (schema, opts, cb) ***REMOVED***
  if (typeof opts == 'function') ***REMOVED***
    cb = opts;
    opts = ***REMOVED******REMOVED***;
  ***REMOVED***
  _traverse(opts, cb, schema, '', schema);
***REMOVED***;


traverse.keywords = ***REMOVED***
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
***REMOVED***;

traverse.arrayKeywords = ***REMOVED***
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
***REMOVED***;

traverse.propsKeywords = ***REMOVED***
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
***REMOVED***;

traverse.skipKeywords = ***REMOVED***
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
***REMOVED***;


function _traverse(opts, cb, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) ***REMOVED***
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) ***REMOVED***
    cb(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) ***REMOVED***
      var sch = schema[key];
      if (Array.isArray(sch)) ***REMOVED***
        if (key in traverse.arrayKeywords) ***REMOVED***
          for (var i=0; i<sch.length; i++)
            _traverse(opts, cb, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        ***REMOVED***
      ***REMOVED*** else if (key in traverse.propsKeywords) ***REMOVED***
        if (sch && typeof sch == 'object') ***REMOVED***
          for (var prop in sch)
            _traverse(opts, cb, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        ***REMOVED***
      ***REMOVED*** else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) ***REMOVED***
        _traverse(opts, cb, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***


function escapeJsonPtr(str) ***REMOVED***
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],44:[function(require,module,exports)***REMOVED***
(function (global)***REMOVED***
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) ***REMOVED***

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) ***REMOVED***
		root = freeGlobal;
	***REMOVED***

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = ***REMOVED***
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	***REMOVED***,

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param ***REMOVED***String***REMOVED*** type The error type.
	 * @returns ***REMOVED***Error***REMOVED*** Throws a `RangeError` with the applicable error message.
	 */
	function error(type) ***REMOVED***
		throw new RangeError(errors[type]);
	***REMOVED***

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param ***REMOVED***Array***REMOVED*** array The array to iterate over.
	 * @param ***REMOVED***Function***REMOVED*** callback The function that gets called for every array
	 * item.
	 * @returns ***REMOVED***Array***REMOVED*** A new array of values returned by the callback function.
	 */
	function map(array, fn) ***REMOVED***
		var length = array.length;
		var result = [];
		while (length--) ***REMOVED***
			result[length] = fn(array[length]);
		***REMOVED***
		return result;
	***REMOVED***

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param ***REMOVED***String***REMOVED*** domain The domain name or email address.
	 * @param ***REMOVED***Function***REMOVED*** callback The function that gets called for every
	 * character.
	 * @returns ***REMOVED***Array***REMOVED*** A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) ***REMOVED***
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) ***REMOVED***
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		***REMOVED***
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	***REMOVED***

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param ***REMOVED***String***REMOVED*** string The Unicode input string (UCS-2).
	 * @returns ***REMOVED***Array***REMOVED*** The new array of code points.
	 */
	function ucs2decode(string) ***REMOVED***
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) ***REMOVED***
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) ***REMOVED***
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) ***REMOVED*** // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				***REMOVED*** else ***REMOVED***
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				***REMOVED***
			***REMOVED*** else ***REMOVED***
				output.push(value);
			***REMOVED***
		***REMOVED***
		return output;
	***REMOVED***

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param ***REMOVED***Array***REMOVED*** codePoints The array of numeric code points.
	 * @returns ***REMOVED***String***REMOVED*** The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) ***REMOVED***
		return map(array, function(value) ***REMOVED***
			var output = '';
			if (value > 0xFFFF) ***REMOVED***
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			***REMOVED***
			output += stringFromCharCode(value);
			return output;
		***REMOVED***).join('');
	***REMOVED***

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param ***REMOVED***Number***REMOVED*** codePoint The basic numeric code point value.
	 * @returns ***REMOVED***Number***REMOVED*** The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) ***REMOVED***
		if (codePoint - 48 < 10) ***REMOVED***
			return codePoint - 22;
		***REMOVED***
		if (codePoint - 65 < 26) ***REMOVED***
			return codePoint - 65;
		***REMOVED***
		if (codePoint - 97 < 26) ***REMOVED***
			return codePoint - 97;
		***REMOVED***
		return base;
	***REMOVED***

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param ***REMOVED***Number***REMOVED*** digit The numeric value of a basic code point.
	 * @returns ***REMOVED***Number***REMOVED*** The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) ***REMOVED***
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	***REMOVED***

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) ***REMOVED***
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) ***REMOVED***
			delta = floor(delta / baseMinusTMin);
		***REMOVED***
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	***REMOVED***

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param ***REMOVED***String***REMOVED*** input The Punycode string of ASCII-only symbols.
	 * @returns ***REMOVED***String***REMOVED*** The resulting string of Unicode symbols.
	 */
	function decode(input) ***REMOVED***
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) ***REMOVED***
			basic = 0;
		***REMOVED***

		for (j = 0; j < basic; ++j) ***REMOVED***
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) ***REMOVED***
				error('not-basic');
			***REMOVED***
			output.push(input.charCodeAt(j));
		***REMOVED***

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) ***REMOVED***

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) ***REMOVED***

				if (index >= inputLength) ***REMOVED***
					error('invalid-input');
				***REMOVED***

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) ***REMOVED***
					error('overflow');
				***REMOVED***

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) ***REMOVED***
					break;
				***REMOVED***

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) ***REMOVED***
					error('overflow');
				***REMOVED***

				w *= baseMinusT;

			***REMOVED***

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) ***REMOVED***
				error('overflow');
			***REMOVED***

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		***REMOVED***

		return ucs2encode(output);
	***REMOVED***

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param ***REMOVED***String***REMOVED*** input The string of Unicode symbols.
	 * @returns ***REMOVED***String***REMOVED*** The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) ***REMOVED***
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) ***REMOVED***
			currentValue = input[j];
			if (currentValue < 0x80) ***REMOVED***
				output.push(stringFromCharCode(currentValue));
			***REMOVED***
		***REMOVED***

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) ***REMOVED***
			output.push(delimiter);
		***REMOVED***

		// Main encoding loop:
		while (handledCPCount < inputLength) ***REMOVED***

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) ***REMOVED***
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) ***REMOVED***
					m = currentValue;
				***REMOVED***
			***REMOVED***

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) ***REMOVED***
				error('overflow');
			***REMOVED***

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) ***REMOVED***
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) ***REMOVED***
					error('overflow');
				***REMOVED***

				if (currentValue == n) ***REMOVED***
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) ***REMOVED***
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) ***REMOVED***
							break;
						***REMOVED***
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					***REMOVED***

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				***REMOVED***
			***REMOVED***

			++delta;
			++n;

		***REMOVED***
		return output.join('');
	***REMOVED***

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param ***REMOVED***String***REMOVED*** input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns ***REMOVED***String***REMOVED*** The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) ***REMOVED***
		return mapDomain(input, function(string) ***REMOVED***
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		***REMOVED***);
	***REMOVED***

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param ***REMOVED***String***REMOVED*** input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns ***REMOVED***String***REMOVED*** The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) ***REMOVED***
		return mapDomain(input, function(string) ***REMOVED***
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		***REMOVED***);
	***REMOVED***

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = ***REMOVED***
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': ***REMOVED***
			'decode': ucs2decode,
			'encode': ucs2encode
		***REMOVED***,
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	***REMOVED***;

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) ***REMOVED***
		define('punycode', function() ***REMOVED***
			return punycode;
		***REMOVED***);
	***REMOVED*** else if (freeExports && freeModule) ***REMOVED***
		if (module.exports == freeExports) ***REMOVED***
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		***REMOVED*** else ***REMOVED***
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) ***REMOVED***
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			***REMOVED***
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		// in Rhino or a web browser
		root.punycode = punycode;
	***REMOVED***

***REMOVED***(this));

***REMOVED***).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : ***REMOVED******REMOVED***)
***REMOVED***,***REMOVED******REMOVED***],45:[function(require,module,exports)***REMOVED***
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) ***REMOVED***
  return Object.prototype.hasOwnProperty.call(obj, prop);
***REMOVED***

module.exports = function(qs, sep, eq, options) ***REMOVED***
  sep = sep || '&';
  eq = eq || '=';
  var obj = ***REMOVED******REMOVED***;

  if (typeof qs !== 'string' || qs.length === 0) ***REMOVED***
    return obj;
  ***REMOVED***

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') ***REMOVED***
    maxKeys = options.maxKeys;
  ***REMOVED***

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) ***REMOVED***
    len = maxKeys;
  ***REMOVED***

  for (var i = 0; i < len; ++i) ***REMOVED***
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) ***REMOVED***
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    ***REMOVED*** else ***REMOVED***
      kstr = x;
      vstr = '';
    ***REMOVED***

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) ***REMOVED***
      obj[k] = v;
    ***REMOVED*** else if (isArray(obj[k])) ***REMOVED***
      obj[k].push(v);
    ***REMOVED*** else ***REMOVED***
      obj[k] = [obj[k], v];
    ***REMOVED***
  ***REMOVED***

  return obj;
***REMOVED***;

var isArray = Array.isArray || function (xs) ***REMOVED***
  return Object.prototype.toString.call(xs) === '[object Array]';
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],46:[function(require,module,exports)***REMOVED***
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) ***REMOVED***
  switch (typeof v) ***REMOVED***
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  ***REMOVED***
***REMOVED***;

module.exports = function(obj, sep, eq, name) ***REMOVED***
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) ***REMOVED***
    obj = undefined;
  ***REMOVED***

  if (typeof obj === 'object') ***REMOVED***
    return map(objectKeys(obj), function(k) ***REMOVED***
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) ***REMOVED***
        return map(obj[k], function(v) ***REMOVED***
          return ks + encodeURIComponent(stringifyPrimitive(v));
        ***REMOVED***).join(sep);
      ***REMOVED*** else ***REMOVED***
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      ***REMOVED***
    ***REMOVED***).join(sep);

  ***REMOVED***

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
***REMOVED***;

var isArray = Array.isArray || function (xs) ***REMOVED***
  return Object.prototype.toString.call(xs) === '[object Array]';
***REMOVED***;

function map (xs, f) ***REMOVED***
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) ***REMOVED***
    res.push(f(xs[i], i));
  ***REMOVED***
  return res;
***REMOVED***

var objectKeys = Object.keys || function (obj) ***REMOVED***
  var res = [];
  for (var key in obj) ***REMOVED***
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  ***REMOVED***
  return res;
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],47:[function(require,module,exports)***REMOVED***
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

***REMOVED***,***REMOVED***"./decode":45,"./encode":46***REMOVED***],48:[function(require,module,exports)***REMOVED***
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() ***REMOVED***
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
***REMOVED***

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['***REMOVED***', '***REMOVED***', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]***REMOVED***0,63***REMOVED***$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]***REMOVED***0,63***REMOVED***)(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = ***REMOVED***
      'javascript': true,
      'javascript:': true
    ***REMOVED***,
    // protocols that never have a hostname.
    hostlessProtocol = ***REMOVED***
      'javascript': true,
      'javascript:': true
    ***REMOVED***,
    // protocols that always contain a // bit.
    slashedProtocol = ***REMOVED***
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    ***REMOVED***,
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) ***REMOVED***
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
***REMOVED***

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) ***REMOVED***
  if (!util.isString(url)) ***REMOVED***
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  ***REMOVED***

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) ***REMOVED***
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) ***REMOVED***
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) ***REMOVED***
        this.search = simplePath[2];
        if (parseQueryString) ***REMOVED***
          this.query = querystring.parse(this.search.substr(1));
        ***REMOVED*** else ***REMOVED***
          this.query = this.search.substr(1);
        ***REMOVED***
      ***REMOVED*** else if (parseQueryString) ***REMOVED***
        this.search = '';
        this.query = ***REMOVED******REMOVED***;
      ***REMOVED***
      return this;
    ***REMOVED***
  ***REMOVED***

  var proto = protocolPattern.exec(rest);
  if (proto) ***REMOVED***
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  ***REMOVED***

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) ***REMOVED***
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) ***REMOVED***
      rest = rest.substr(2);
      this.slashes = true;
    ***REMOVED***
  ***REMOVED***

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) ***REMOVED***

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) ***REMOVED***
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    ***REMOVED***

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) ***REMOVED***
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    ***REMOVED*** else ***REMOVED***
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    ***REMOVED***

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) ***REMOVED***
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    ***REMOVED***

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) ***REMOVED***
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    ***REMOVED***
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) ***REMOVED***
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) ***REMOVED***
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) ***REMOVED***
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) ***REMOVED***
            if (part.charCodeAt(j) > 127) ***REMOVED***
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            ***REMOVED*** else ***REMOVED***
              newpart += part[j];
            ***REMOVED***
          ***REMOVED***
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) ***REMOVED***
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) ***REMOVED***
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            ***REMOVED***
            if (notHost.length) ***REMOVED***
              rest = '/' + notHost.join('.') + rest;
            ***REMOVED***
            this.hostname = validParts.join('.');
            break;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    if (this.hostname.length > hostnameMaxLen) ***REMOVED***
      this.hostname = '';
    ***REMOVED*** else ***REMOVED***
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    ***REMOVED***

    if (!ipv6Hostname) ***REMOVED***
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    ***REMOVED***

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) ***REMOVED***
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') ***REMOVED***
        rest = '/' + rest;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) ***REMOVED***

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) ***REMOVED***
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) ***REMOVED***
        esc = escape(ae);
      ***REMOVED***
      rest = rest.split(ae).join(esc);
    ***REMOVED***
  ***REMOVED***


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) ***REMOVED***
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  ***REMOVED***
  var qm = rest.indexOf('?');
  if (qm !== -1) ***REMOVED***
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) ***REMOVED***
      this.query = querystring.parse(this.query);
    ***REMOVED***
    rest = rest.slice(0, qm);
  ***REMOVED*** else if (parseQueryString) ***REMOVED***
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = ***REMOVED******REMOVED***;
  ***REMOVED***
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) ***REMOVED***
    this.pathname = '/';
  ***REMOVED***

  //to support http.request
  if (this.pathname || this.search) ***REMOVED***
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  ***REMOVED***

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
***REMOVED***;

// format a parsed object into a url string
function urlFormat(obj) ***REMOVED***
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
***REMOVED***

Url.prototype.format = function() ***REMOVED***
  var auth = this.auth || '';
  if (auth) ***REMOVED***
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  ***REMOVED***

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) ***REMOVED***
    host = auth + this.host;
  ***REMOVED*** else if (this.hostname) ***REMOVED***
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) ***REMOVED***
      host += ':' + this.port;
    ***REMOVED***
  ***REMOVED***

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) ***REMOVED***
    query = querystring.stringify(this.query);
  ***REMOVED***

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) ***REMOVED***
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  ***REMOVED*** else if (!host) ***REMOVED***
    host = '';
  ***REMOVED***

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) ***REMOVED***
    return encodeURIComponent(match);
  ***REMOVED***);
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
***REMOVED***;

function urlResolve(source, relative) ***REMOVED***
  return urlParse(source, false, true).resolve(relative);
***REMOVED***

Url.prototype.resolve = function(relative) ***REMOVED***
  return this.resolveObject(urlParse(relative, false, true)).format();
***REMOVED***;

function urlResolveObject(source, relative) ***REMOVED***
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
***REMOVED***

Url.prototype.resolveObject = function(relative) ***REMOVED***
  if (util.isString(relative)) ***REMOVED***
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  ***REMOVED***

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) ***REMOVED***
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  ***REMOVED***

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') ***REMOVED***
    result.href = result.format();
    return result;
  ***REMOVED***

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) ***REMOVED***
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) ***REMOVED***
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    ***REMOVED***

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) ***REMOVED***
      result.path = result.pathname = '/';
    ***REMOVED***

    result.href = result.format();
    return result;
  ***REMOVED***

  if (relative.protocol && relative.protocol !== result.protocol) ***REMOVED***
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) ***REMOVED***
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) ***REMOVED***
        var k = keys[v];
        result[k] = relative[k];
      ***REMOVED***
      result.href = result.format();
      return result;
    ***REMOVED***

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) ***REMOVED***
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    ***REMOVED*** else ***REMOVED***
      result.pathname = relative.pathname;
    ***REMOVED***
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) ***REMOVED***
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    ***REMOVED***
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  ***REMOVED***

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) ***REMOVED***
    result.hostname = '';
    result.port = null;
    if (result.host) ***REMOVED***
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    ***REMOVED***
    result.host = '';
    if (relative.protocol) ***REMOVED***
      relative.hostname = null;
      relative.port = null;
      if (relative.host) ***REMOVED***
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      ***REMOVED***
      relative.host = null;
    ***REMOVED***
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  ***REMOVED***

  if (isRelAbs) ***REMOVED***
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  ***REMOVED*** else if (relPath.length) ***REMOVED***
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  ***REMOVED*** else if (!util.isNullOrUndefined(relative.search)) ***REMOVED***
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) ***REMOVED***
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) ***REMOVED***
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      ***REMOVED***
    ***REMOVED***
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) ***REMOVED***
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    ***REMOVED***
    result.href = result.format();
    return result;
  ***REMOVED***

  if (!srcPath.length) ***REMOVED***
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) ***REMOVED***
      result.path = '/' + result.search;
    ***REMOVED*** else ***REMOVED***
      result.path = null;
    ***REMOVED***
    result.href = result.format();
    return result;
  ***REMOVED***

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) ***REMOVED***
    last = srcPath[i];
    if (last === '.') ***REMOVED***
      srcPath.splice(i, 1);
    ***REMOVED*** else if (last === '..') ***REMOVED***
      srcPath.splice(i, 1);
      up++;
    ***REMOVED*** else if (up) ***REMOVED***
      srcPath.splice(i, 1);
      up--;
    ***REMOVED***
  ***REMOVED***

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) ***REMOVED***
    for (; up--; up) ***REMOVED***
      srcPath.unshift('..');
    ***REMOVED***
  ***REMOVED***

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) ***REMOVED***
    srcPath.unshift('');
  ***REMOVED***

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) ***REMOVED***
    srcPath.push('');
  ***REMOVED***

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) ***REMOVED***
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) ***REMOVED***
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    ***REMOVED***
  ***REMOVED***

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) ***REMOVED***
    srcPath.unshift('');
  ***REMOVED***

  if (!srcPath.length) ***REMOVED***
    result.pathname = null;
    result.path = null;
  ***REMOVED*** else ***REMOVED***
    result.pathname = srcPath.join('/');
  ***REMOVED***

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) ***REMOVED***
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  ***REMOVED***
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
***REMOVED***;

Url.prototype.parseHost = function() ***REMOVED***
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) ***REMOVED***
    port = port[0];
    if (port !== ':') ***REMOVED***
      this.port = port.substr(1);
    ***REMOVED***
    host = host.substr(0, host.length - port.length);
  ***REMOVED***
  if (host) this.hostname = host;
***REMOVED***;

***REMOVED***,***REMOVED***"./util":49,"punycode":44,"querystring":47***REMOVED***],49:[function(require,module,exports)***REMOVED***
'use strict';

module.exports = ***REMOVED***
  isString: function(arg) ***REMOVED***
    return typeof(arg) === 'string';
  ***REMOVED***,
  isObject: function(arg) ***REMOVED***
    return typeof(arg) === 'object' && arg !== null;
  ***REMOVED***,
  isNull: function(arg) ***REMOVED***
    return arg === null;
  ***REMOVED***,
  isNullOrUndefined: function(arg) ***REMOVED***
    return arg == null;
  ***REMOVED***
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],"ajv":[function(require,module,exports)***REMOVED***
'use strict';

var compileSchema = require('./compile')
  , resolve = require('./compile/resolve')
  , Cache = require('./cache')
  , SchemaObject = require('./compile/schema_obj')
  , stableStringify = require('fast-json-stable-stringify')
  , formats = require('./compile/formats')
  , rules = require('./compile/rules')
  , $dataMetaSchema = require('./$data')
  , patternGroups = require('./patternGroups')
  , util = require('./compile/util')
  , co = require('co');

module.exports = Ajv;

Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = require('./compile/async');
var customKeyword = require('./keyword');
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;

var errorClasses = require('./compile/error_classes');
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = 'http://json-schema.org/draft-06/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param ***REMOVED***Object***REMOVED*** opts optional options
 * @return ***REMOVED***Object***REMOVED*** ajv instance
 */
function Ajv(opts) ***REMOVED***
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || ***REMOVED******REMOVED***;
  setLogger(this);
  this._schemas = ***REMOVED******REMOVED***;
  this._refs = ***REMOVED******REMOVED***;
  this._fragments = ***REMOVED******REMOVED***;
  this._formats = formats(opts.format);
  var schemaUriFormat = this._schemaUriFormat = this._formats['uri-reference'];
  this._schemaUriFormatFunc = function (str) ***REMOVED*** return schemaUriFormat.test(str); ***REMOVED***;

  this._cache = opts.cache || new Cache;
  this._loadingSchemas = ***REMOVED******REMOVED***;
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  addDraft6MetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  addInitialSchemas(this);
  if (opts.patternGroups) patternGroups(this);
***REMOVED***



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  ***REMOVED***String|Object***REMOVED*** schemaKeyRef key, ref or schema object
 * @param  ***REMOVED***Any***REMOVED*** data to be validated
 * @return ***REMOVED***Boolean***REMOVED*** validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate(schemaKeyRef, data) ***REMOVED***
  var v;
  if (typeof schemaKeyRef == 'string') ***REMOVED***
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  ***REMOVED*** else ***REMOVED***
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  ***REMOVED***

  var valid = v(data);
  if (v.$async === true)
    return this._opts.async == '*' ? co(valid) : valid;
  this.errors = v.errors;
  return valid;
***REMOVED***


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  ***REMOVED***Object***REMOVED*** schema schema object
 * @param  ***REMOVED***Boolean***REMOVED*** _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return ***REMOVED***Function***REMOVED*** validating function
 */
function compile(schema, _meta) ***REMOVED***
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
***REMOVED***


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param ***REMOVED***Object|Array***REMOVED*** schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param ***REMOVED***String***REMOVED*** key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param ***REMOVED***Boolean***REMOVED*** _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param ***REMOVED***Boolean***REMOVED*** _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return ***REMOVED***Ajv***REMOVED*** this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) ***REMOVED***
  if (Array.isArray(schema))***REMOVED***
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  ***REMOVED***
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
***REMOVED***


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param ***REMOVED***Object***REMOVED*** schema schema object
 * @param ***REMOVED***String***REMOVED*** key optional schema key
 * @param ***REMOVED***Boolean***REMOVED*** skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return ***REMOVED***Ajv***REMOVED*** this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) ***REMOVED***
  this.addSchema(schema, key, skipValidation, true);
  return this;
***REMOVED***


/**
 * Validate schema
 * @this   Ajv
 * @param ***REMOVED***Object***REMOVED*** schema schema to validate
 * @param ***REMOVED***Boolean***REMOVED*** throwOrLogError pass true to throw (or log) an error if invalid
 * @return ***REMOVED***Boolean***REMOVED*** true if schema is valid
 */
function validateSchema(schema, throwOrLogError) ***REMOVED***
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) ***REMOVED***
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  ***REMOVED***
  var currentUriFormat = this._formats.uri;
  this._formats.uri = typeof currentUriFormat == 'function'
                      ? this._schemaUriFormatFunc
                      : this._schemaUriFormat;
  var valid;
  try ***REMOVED*** valid = this.validate($schema, schema); ***REMOVED***
  finally ***REMOVED*** this._formats.uri = currentUriFormat; ***REMOVED***
  if (!valid && throwOrLogError) ***REMOVED***
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  ***REMOVED***
  return valid;
***REMOVED***


function defaultMeta(self) ***REMOVED***
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
***REMOVED***


/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  ***REMOVED***String***REMOVED*** keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return ***REMOVED***Function***REMOVED*** schema validating function (with property `schema`).
 */
function getSchema(keyRef) ***REMOVED***
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) ***REMOVED***
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  ***REMOVED***
***REMOVED***


function _getSchemaFragment(self, ref) ***REMOVED***
  var res = resolve.schema.call(self, ***REMOVED*** schema: ***REMOVED******REMOVED*** ***REMOVED***, ref);
  if (res) ***REMOVED***
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject(***REMOVED***
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    ***REMOVED***);
    return v;
  ***REMOVED***
***REMOVED***


function _getSchemaObj(self, keyRef) ***REMOVED***
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
***REMOVED***


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  ***REMOVED***String|Object|RegExp***REMOVED*** schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return ***REMOVED***Ajv***REMOVED*** this for method chaining
 */
function removeSchema(schemaKeyRef) ***REMOVED***
  if (schemaKeyRef instanceof RegExp) ***REMOVED***
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  ***REMOVED***
  switch (typeof schemaKeyRef) ***REMOVED***
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) ***REMOVED***
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      ***REMOVED***
  ***REMOVED***
  return this;
***REMOVED***


function _removeAllSchemas(self, schemas, regex) ***REMOVED***
  for (var keyRef in schemas) ***REMOVED***
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) ***REMOVED***
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    ***REMOVED***
  ***REMOVED***
***REMOVED***


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) ***REMOVED***
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema);

  var schemaObj = new SchemaObject(***REMOVED***
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  ***REMOVED***);

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
***REMOVED***


/* @this   Ajv */
function _compile(schemaObj, root) ***REMOVED***
  if (schemaObj.compiling) ***REMOVED***
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  ***REMOVED***
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) ***REMOVED***
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  ***REMOVED***

  var v;
  try ***REMOVED*** v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); ***REMOVED***
  finally ***REMOVED***
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  ***REMOVED***

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  function callValidate() ***REMOVED***
    var _validate = schemaObj.validate;
    var result = _validate.apply(null, arguments);
    callValidate.errors = _validate.errors;
    return result;
  ***REMOVED***
***REMOVED***


function chooseGetId(opts) ***REMOVED***
  switch (opts.schemaId) ***REMOVED***
    case '$id': return _get$Id;
    case 'id': return _getId;
    default: return _get$IdOrId;
  ***REMOVED***
***REMOVED***

/* @this   Ajv */
function _getId(schema) ***REMOVED***
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
***REMOVED***

/* @this   Ajv */
function _get$Id(schema) ***REMOVED***
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
***REMOVED***


function _get$IdOrId(schema) ***REMOVED***
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
***REMOVED***


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  ***REMOVED***Array<Object>***REMOVED*** errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  ***REMOVED***Object***REMOVED*** options optional options with properties `separator` and `dataVar`.
 * @return ***REMOVED***String***REMOVED*** human readable string with all errors descriptions
 */
function errorsText(errors, options) ***REMOVED***
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || ***REMOVED******REMOVED***;
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) ***REMOVED***
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  ***REMOVED***
  return text.slice(0, -separator.length);
***REMOVED***


/**
 * Add custom format
 * @this   Ajv
 * @param ***REMOVED***String***REMOVED*** name format name
 * @param ***REMOVED***String|RegExp|Function***REMOVED*** format string is converted to RegExp; function should return boolean (true when valid)
 * @return ***REMOVED***Ajv***REMOVED*** this for method chaining
 */
function addFormat(name, format) ***REMOVED***
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
***REMOVED***


function addDraft6MetaSchema(self) ***REMOVED***
  var $dataSchema;
  if (self._opts.$data) ***REMOVED***
    $dataSchema = require('./refs/$data.json');
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  ***REMOVED***
  if (self._opts.meta === false) return;
  var metaSchema = require('./refs/json-schema-draft-06.json');
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
***REMOVED***


function addInitialSchemas(self) ***REMOVED***
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
***REMOVED***


function addInitialFormats(self) ***REMOVED***
  for (var name in self._opts.formats) ***REMOVED***
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  ***REMOVED***
***REMOVED***


function checkUnique(self, id) ***REMOVED***
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
***REMOVED***


function getMetaSchemaOptions(self) ***REMOVED***
  var metaOpts = util.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
***REMOVED***


function setLogger(self) ***REMOVED***
  var logger = self._opts.logger;
  if (logger === false) ***REMOVED***
    self.logger = ***REMOVED***log: noop, warn: noop, error: noop***REMOVED***;
  ***REMOVED*** else ***REMOVED***
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  ***REMOVED***
***REMOVED***


function noop() ***REMOVED******REMOVED***

***REMOVED***,***REMOVED***"./$data":1,"./cache":2,"./compile":7,"./compile/async":4,"./compile/error_classes":5,"./compile/formats":6,"./compile/resolve":8,"./compile/rules":9,"./compile/schema_obj":10,"./compile/util":12,"./keyword":36,"./patternGroups":37,"./refs/$data.json":38,"./refs/json-schema-draft-06.json":39,"co":40,"fast-json-stable-stringify":42***REMOVED***]***REMOVED***,***REMOVED******REMOVED***,[])("ajv")
***REMOVED***);