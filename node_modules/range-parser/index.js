/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 * @public
 */

module.exports = rangeParser

/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param ***REMOVED***Number***REMOVED*** size
 * @param ***REMOVED***String***REMOVED*** str
 * @param ***REMOVED***Object***REMOVED*** [options]
 * @return ***REMOVED***Array***REMOVED***
 * @public
 */

function rangeParser (size, str, options) ***REMOVED***
  var index = str.indexOf('=')

  if (index === -1) ***REMOVED***
    return -2
  ***REMOVED***

  // split the range string
  var arr = str.slice(index + 1).split(',')
  var ranges = []

  // add ranges type
  ranges.type = str.slice(0, index)

  // parse all ranges
  for (var i = 0; i < arr.length; i++) ***REMOVED***
    var range = arr[i].split('-')
    var start = parseInt(range[0], 10)
    var end = parseInt(range[1], 10)

    // -nnn
    if (isNaN(start)) ***REMOVED***
      start = size - end
      end = size - 1
    // nnn-
    ***REMOVED*** else if (isNaN(end)) ***REMOVED***
      end = size - 1
    ***REMOVED***

    // limit last-byte-pos to current length
    if (end > size - 1) ***REMOVED***
      end = size - 1
    ***REMOVED***

    // invalid or unsatisifiable
    if (isNaN(start) || isNaN(end) || start > end || start < 0) ***REMOVED***
      continue
    ***REMOVED***

    // add range
    ranges.push(***REMOVED***
      start: start,
      end: end
    ***REMOVED***)
  ***REMOVED***

  if (ranges.length < 1) ***REMOVED***
    // unsatisifiable
    return -1
  ***REMOVED***

  return options && options.combine
    ? combineRanges(ranges)
    : ranges
***REMOVED***

/**
 * Combine overlapping & adjacent ranges.
 * @private
 */

function combineRanges (ranges) ***REMOVED***
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)

  for (var j = 0, i = 1; i < ordered.length; i++) ***REMOVED***
    var range = ordered[i]
    var current = ordered[j]

    if (range.start > current.end + 1) ***REMOVED***
      // next range
      ordered[++j] = range
    ***REMOVED*** else if (range.end > current.end) ***REMOVED***
      // extend range
      current.end = range.end
      current.index = Math.min(current.index, range.index)
    ***REMOVED***
  ***REMOVED***

  // trim ordered array
  ordered.length = j + 1

  // generate combined range
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)

  // copy ranges type
  combined.type = ranges.type

  return combined
***REMOVED***

/**
 * Map function to add index value to ranges.
 * @private
 */

function mapWithIndex (range, index) ***REMOVED***
  return ***REMOVED***
    start: range.start,
    end: range.end,
    index: index
  ***REMOVED***
***REMOVED***

/**
 * Map function to remove index value from ranges.
 * @private
 */

function mapWithoutIndex (range) ***REMOVED***
  return ***REMOVED***
    start: range.start,
    end: range.end
  ***REMOVED***
***REMOVED***

/**
 * Sort function to sort ranges by index.
 * @private
 */

function sortByRangeIndex (a, b) ***REMOVED***
  return a.index - b.index
***REMOVED***

/**
 * Sort function to sort ranges by start position.
 * @private
 */

function sortByRangeStart (a, b) ***REMOVED***
  return a.start - b.start
***REMOVED***
