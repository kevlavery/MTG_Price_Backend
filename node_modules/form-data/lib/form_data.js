var CombinedStream = require('combined-stream');
var util = require('util');
var path = require('path');
var http = require('http');
var https = require('https');
var parseUrl = require('url').parse;
var fs = require('fs');
var mime = require('mime-types');
var asynckit = require('asynckit');
var populate = require('./populate.js');

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param ***REMOVED***Object***REMOVED*** options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) ***REMOVED***
  if (!(this instanceof FormData)) ***REMOVED***
    return new FormData();
  ***REMOVED***

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || ***REMOVED******REMOVED***;
  for (var option in options) ***REMOVED***
    this[option] = options[option];
  ***REMOVED***
***REMOVED***

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) ***REMOVED***

  options = options || ***REMOVED******REMOVED***;

  // allow filename as single option
  if (typeof options == 'string') ***REMOVED***
    options = ***REMOVED***filename: options***REMOVED***;
  ***REMOVED***

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') ***REMOVED***
    value = '' + value;
  ***REMOVED***

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) ***REMOVED***
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  ***REMOVED***

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
***REMOVED***;

FormData.prototype._trackLength = function(header, value, options) ***REMOVED***
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) ***REMOVED***
    valueLength += +options.knownLength;
  ***REMOVED*** else if (Buffer.isBuffer(value)) ***REMOVED***
    valueLength = value.length;
  ***REMOVED*** else if (typeof value === 'string') ***REMOVED***
    valueLength = Buffer.byteLength(value);
  ***REMOVED***

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) ***REMOVED***
    return;
  ***REMOVED***

  // no need to bother with the length
  if (!options.knownLength) ***REMOVED***
    this._valuesToMeasure.push(value);
  ***REMOVED***
***REMOVED***;

FormData.prototype._lengthRetriever = function(value, callback) ***REMOVED***

  if (value.hasOwnProperty('fd')) ***REMOVED***

    // take read range into a account
    // `end` = Infinity â€“> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) ***REMOVED***

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    ***REMOVED*** else ***REMOVED***
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) ***REMOVED***

        var fileSize;

        if (err) ***REMOVED***
          callback(err);
          return;
        ***REMOVED***

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      ***REMOVED***);
    ***REMOVED***

  // or http response
  ***REMOVED*** else if (value.hasOwnProperty('httpVersion')) ***REMOVED***
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  ***REMOVED*** else if (value.hasOwnProperty('httpModule')) ***REMOVED***
    // wait till response come back
    value.on('response', function(response) ***REMOVED***
      value.pause();
      callback(null, +response.headers['content-length']);
    ***REMOVED***);
    value.resume();

  // something else
  ***REMOVED*** else ***REMOVED***
    callback('Unknown stream');
  ***REMOVED***
***REMOVED***;

FormData.prototype._multiPartHeader = function(field, value, options) ***REMOVED***
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') ***REMOVED***
    return options.header;
  ***REMOVED***

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = ***REMOVED***
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  ***REMOVED***;

  // allow custom headers.
  if (typeof options.header == 'object') ***REMOVED***
    populate(headers, options.header);
  ***REMOVED***

  var header;
  for (var prop in headers) ***REMOVED***
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) ***REMOVED***
      continue;
    ***REMOVED***

    // convert all headers to arrays.
    if (!Array.isArray(header)) ***REMOVED***
      header = [header];
    ***REMOVED***

    // add non-empty headers.
    if (header.length) ***REMOVED***
      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    ***REMOVED***
  ***REMOVED***

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
***REMOVED***;

FormData.prototype._getContentDisposition = function(value, options) ***REMOVED***

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') ***REMOVED***
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  ***REMOVED*** else if (options.filename || value.name || value.path) ***REMOVED***
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  ***REMOVED*** else if (value.readable && value.hasOwnProperty('httpVersion')) ***REMOVED***
    // or try http response
    filename = path.basename(value.client._httpMessage.path);
  ***REMOVED***

  if (filename) ***REMOVED***
    contentDisposition = 'filename="' + filename + '"';
  ***REMOVED***

  return contentDisposition;
***REMOVED***;

FormData.prototype._getContentType = function(value, options) ***REMOVED***

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) ***REMOVED***
    contentType = mime.lookup(value.name);
  ***REMOVED***

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) ***REMOVED***
    contentType = mime.lookup(value.path);
  ***REMOVED***

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) ***REMOVED***
    contentType = value.headers['content-type'];
  ***REMOVED***

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) ***REMOVED***
    contentType = mime.lookup(options.filepath || options.filename);
  ***REMOVED***

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') ***REMOVED***
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  ***REMOVED***

  return contentType;
***REMOVED***;

FormData.prototype._multiPartFooter = function() ***REMOVED***
  return function(next) ***REMOVED***
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) ***REMOVED***
      footer += this._lastBoundary();
    ***REMOVED***

    next(footer);
  ***REMOVED***.bind(this);
***REMOVED***;

FormData.prototype._lastBoundary = function() ***REMOVED***
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
***REMOVED***;

FormData.prototype.getHeaders = function(userHeaders) ***REMOVED***
  var header;
  var formHeaders = ***REMOVED***
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  ***REMOVED***;

  for (header in userHeaders) ***REMOVED***
    if (userHeaders.hasOwnProperty(header)) ***REMOVED***
      formHeaders[header.toLowerCase()] = userHeaders[header];
    ***REMOVED***
  ***REMOVED***

  return formHeaders;
***REMOVED***;

FormData.prototype.getBoundary = function() ***REMOVED***
  if (!this._boundary) ***REMOVED***
    this._generateBoundary();
  ***REMOVED***

  return this._boundary;
***REMOVED***;

FormData.prototype._generateBoundary = function() ***REMOVED***
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) ***REMOVED***
    boundary += Math.floor(Math.random() * 10).toString(16);
  ***REMOVED***

  this._boundary = boundary;
***REMOVED***;

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() ***REMOVED***
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) ***REMOVED***
    knownLength += this._lastBoundary().length;
  ***REMOVED***

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) ***REMOVED***
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  ***REMOVED***

  return knownLength;
***REMOVED***;

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() ***REMOVED***
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) ***REMOVED***
    hasKnownLength = false;
  ***REMOVED***

  return hasKnownLength;
***REMOVED***;

FormData.prototype.getLength = function(cb) ***REMOVED***
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) ***REMOVED***
    knownLength += this._lastBoundary().length;
  ***REMOVED***

  if (!this._valuesToMeasure.length) ***REMOVED***
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  ***REMOVED***

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) ***REMOVED***
    if (err) ***REMOVED***
      cb(err);
      return;
    ***REMOVED***

    values.forEach(function(length) ***REMOVED***
      knownLength += length;
    ***REMOVED***);

    cb(null, knownLength);
  ***REMOVED***);
***REMOVED***;

FormData.prototype.submit = function(params, cb) ***REMOVED***
  var request
    , options
    , defaults = ***REMOVED***method: 'post'***REMOVED***
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') ***REMOVED***

    params = parseUrl(params);
    options = populate(***REMOVED***
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    ***REMOVED***, defaults);

  // use custom params
  ***REMOVED*** else ***REMOVED***

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) ***REMOVED***
      options.port = options.protocol == 'https:' ? 443 : 80;
    ***REMOVED***
  ***REMOVED***

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') ***REMOVED***
    request = https.request(options);
  ***REMOVED*** else ***REMOVED***
    request = http.request(options);
  ***REMOVED***

  // get content length and fire away
  this.getLength(function(err, length) ***REMOVED***
    if (err) ***REMOVED***
      this._error(err);
      return;
    ***REMOVED***

    // add content length
    request.setHeader('Content-Length', length);

    this.pipe(request);
    if (cb) ***REMOVED***
      request.on('error', cb);
      request.on('response', cb.bind(this, null));
    ***REMOVED***
  ***REMOVED***.bind(this));

  return request;
***REMOVED***;

FormData.prototype._error = function(err) ***REMOVED***
  if (!this.error) ***REMOVED***
    this.error = err;
    this.pause();
    this.emit('error', err);
  ***REMOVED***
***REMOVED***;

FormData.prototype.toString = function () ***REMOVED***
  return '[object FormData]';
***REMOVED***;
